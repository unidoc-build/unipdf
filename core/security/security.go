//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_bad "bytes";_e "crypto/aes";_ge "crypto/cipher";_gcb "crypto/md5";_ab "crypto/rand";_d "crypto/rc4";_b "crypto/sha256";_gc "crypto/sha512";_c "encoding/binary";_ba "errors";_gfc "fmt";_cf "github.com/unidoc/unipdf/v3/common";
_a "hash";_gf "io";_f "math";);func _fc (_fae []byte )(_ge .Block ,error ){_gfd ,_bec :=_e .NewCipher (_fae );if _bec !=nil {_cf .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bec );
return nil ,_bec ;};return _gfd ,nil ;};

// Authenticate implements StdHandler interface.
func (_ggf stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_cf .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_ff ,_bee :=_ggf .alg7 (d ,pass );if _bee !=nil {return nil ,0,_bee ;};if _ff !=nil {_cf .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ff ,PermOwner ,nil ;
};_cf .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_ff ,_bee =_ggf .alg6 (d ,pass );if _bee !=nil {return nil ,0,_bee ;
};if _ff !=nil {_cf .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ff ,d .P ,nil ;};return nil ,0,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;
};func (_af *ecbEncrypter )BlockSize ()int {return _af ._ef };const _cdb ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";const (PermOwner =Permissions (_f .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_cae *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cae ._ef !=0{_cf .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_cf .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cae ._cfc .Decrypt (dst ,src [:_cae ._ef ]);src =src [_cae ._ef :];dst =dst [_cae ._ef :];};};func (_bgd stdHandlerR6 )alg2b (R int ,_cca ,_ggc ,_aefe []byte )([]byte ,error ){if R ==5{return _dfb (_cca );};return _aec (_cca ,_ggc ,_aefe );
};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_bab stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_dfc :=make ([]byte ,32);if _ ,_dbc :=_gf .ReadFull (_ab .Reader ,_dfc );_dbc !=nil {return nil ,_dbc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cdbe :=_bab .alg8 (d ,_dfc ,upass );_cdbe !=nil {return nil ,_cdbe ;};if _cba :=_bab .alg9 (d ,_dfc ,opass );_cba !=nil {return nil ,_cba ;};if d .R ==5{return _dfc ,nil ;
};if _cced :=_bab .alg10 (d ,_dfc );_cced !=nil {return nil ,_cced ;};return _dfc ,nil ;};func (_gad stdHandlerR4 )alg2 (_cfa *StdEncryptDict ,_gb []byte )[]byte {_cf .Log .Trace ("\u0061\u006c\u0067\u0032");_ebb :=_gad .paddedPass (_gb );_gg :=_gcb .New ();
_gg .Write (_ebb );_gg .Write (_cfa .O );var _caf [4]byte ;_c .LittleEndian .PutUint32 (_caf [:],uint32 (_cfa .P ));_gg .Write (_caf [:]);_cf .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_caf );_gg .Write ([]byte (_gad .ID0 ));_cf .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_cfa .R ,_cfa .EncryptMetadata );
if (_cfa .R >=4)&&!_cfa .EncryptMetadata {_gg .Write ([]byte {0xff,0xff,0xff,0xff});};_afb :=_gg .Sum (nil );if _cfa .R >=3{_gg =_gcb .New ();for _bc :=0;_bc < 50;_bc ++{_gg .Reset ();_gg .Write (_afb [0:_gad .Length /8]);_afb =_gg .Sum (nil );};};if _cfa .R >=3{return _afb [0:_gad .Length /8];
};return _afb [0:5];};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_acg errInvalidField )Error ()string {return _gfc .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_acg .Func ,_acg .Field ,_acg .Exp ,_acg .Got );
};type ecbEncrypter ecb ;func (_eeg stdHandlerR4 )alg4 (_fg []byte ,_fbb []byte )([]byte ,error ){_eg ,_ddf :=_d .NewCipher (_fg );if _ddf !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bae :=[]byte (_cdb );_fbg :=make ([]byte ,len (_bae ));_eg .XORKeyStream (_fbg ,_bae );return _fbg ,nil ;};func (stdHandlerR4 )paddedPass (_ec []byte )[]byte {_dd :=make ([]byte ,32);_gd :=copy (_dd ,_ec );for ;_gd < 32;_gd ++{_dd [_gd ]=_cdb [_gd -len (_ec )];
};return _dd ;};var _ StdHandler =stdHandlerR4 {};type ecb struct{_cfc _ge .Block ;_ef int ;};func _ddad (_cce []byte ,_gda int ){_aacb :=_gda ;for _aacb < len (_cce ){copy (_cce [_aacb :],_cce [:_aacb ]);_aacb *=2;};};func (_fa *ecbDecrypter )BlockSize ()int {return _fa ._ef };


// Authenticate implements StdHandler interface.
func (_aba stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _aba .alg2a (d ,pass );};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e");
);func _dfb (_eeag []byte )([]byte ,error ){_bac :=_b .New ();_bac .Write (_eeag );return _bac .Sum (nil ),nil ;};func _abc (_ca _ge .Block )*ecb {return &ecb {_cfc :_ca ,_ef :_ca .BlockSize ()}};type stdHandlerR6 struct{};func _ac (_bg _ge .Block )_ge .BlockMode {return (*ecbEncrypter )(_abc (_bg ))};
var _ StdHandler =stdHandlerR6 {};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_edf stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_dea :=_edf .alg3 (d .R ,upass ,opass );if _dea !=nil {_cf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dea );
return nil ,_dea ;};d .O =O ;_cf .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_fad :=_edf .alg2 (d ,upass );U ,_dea :=_edf .alg5 (_fad ,upass );if _dea !=nil {_cf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dea );
return nil ,_dea ;};d .U =U ;_cf .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _fad ,nil ;};func (_afd stdHandlerR6 )alg12 (_gab *StdEncryptDict ,_ffad []byte )([]byte ,error ){if _fgc :=_bd ("\u0061\u006c\u00671\u0032","\u0055",48,_gab .U );
_fgc !=nil {return nil ,_fgc ;};if _eac :=_bd ("\u0061\u006c\u00671\u0032","\u004f",48,_gab .O );_eac !=nil {return nil ,_eac ;};_agc :=make ([]byte ,len (_ffad )+8+48);_egbe :=copy (_agc ,_ffad );_egbe +=copy (_agc [_egbe :],_gab .O [32:40]);_egbe +=copy (_agc [_egbe :],_gab .U [0:48]);
_fade ,_ade :=_afd .alg2b (_gab .R ,_agc ,_ffad ,_gab .U [0:48]);if _ade !=nil {return nil ,_ade ;};_fade =_fade [:32];if !_bad .Equal (_fade ,_gab .O [:32]){return nil ,nil ;};return _fade ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_aa *StdEncryptDict ,_ga ,_ee []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_fb *StdEncryptDict ,_be []byte )([]byte ,Permissions ,error );};func (_ae stdHandlerR4 )alg3 (R int ,_gag ,_ecd []byte )([]byte ,error ){var _abb []byte ;if len (_ecd )> 0{_abb =_ae .alg3Key (R ,_ecd );}else {_abb =_ae .alg3Key (R ,_gag );
};_aac ,_gge :=_d .NewCipher (_abb );if _gge !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dac :=_ae .paddedPass (_gag );_bgg :=make ([]byte ,len (_dac ));_aac .XORKeyStream (_bgg ,_dac );
if R >=3{_daab :=make ([]byte ,len (_abb ));for _dbb :=0;_dbb < 19;_dbb ++{for _aef :=0;_aef < len (_abb );_aef ++{_daab [_aef ]=_abb [_aef ]^byte (_dbb +1);};_bf ,_dcb :=_d .NewCipher (_daab );if _dcb !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bf .XORKeyStream (_bgg ,_bgg );};};return _bgg ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_faf stdHandlerR4 )alg5 (_fd []byte ,_de []byte )([]byte ,error ){_efc :=_gcb .New ();_efc .Write ([]byte (_cdb ));_efc .Write ([]byte (_faf .ID0 ));_dg :=_efc .Sum (nil );_cf .Log .Trace ("\u0061\u006c\u0067\u0035");_cf .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fd );
_cf .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_faf .ID0 );if len (_dg )!=16{return nil ,_ba .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_dda ,_bge :=_d .NewCipher (_fd );
if _bge !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_df :=make ([]byte ,16);_dda .XORKeyStream (_df ,_dg );_fda :=make ([]byte ,len (_fd ));for _cc :=0;_cc < 19;_cc ++{for _efd :=0;
_efd < len (_fd );_efd ++{_fda [_efd ]=_fd [_efd ]^byte (_cc +1);};_dda ,_bge =_d .NewCipher (_fda );if _bge !=nil {return nil ,_ba .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dda .XORKeyStream (_df ,_df );
_cf .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_cc ,_fda );_cf .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_cc ,_df );};_afa :=make ([]byte ,32);
for _bca :=0;_bca < 16;_bca ++{_afa [_bca ]=_df [_bca ];};_ ,_bge =_ab .Read (_afa [16:32]);if _bge !=nil {return nil ,_ba .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _afa ,nil ;};type ecbDecrypter ecb ;func (_gbe stdHandlerR4 )alg7 (_gbd *StdEncryptDict ,_fac []byte )([]byte ,error ){_ecb :=_gbe .alg3Key (_gbd .R ,_fac );_geg :=make ([]byte ,len (_gbd .O ));if _gbd .R ==2{_gcba ,_adfc :=_d .NewCipher (_ecb );
if _adfc !=nil {return nil ,_ba .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gcba .XORKeyStream (_geg ,_gbd .O );}else if _gbd .R >=3{_face :=append ([]byte {},_gbd .O ...);for _gcfe :=0;_gcfe < 20;_gcfe ++{_eea :=append ([]byte {},_ecb ...);
for _cfgf :=0;_cfgf < len (_ecb );_cfgf ++{_eea [_cfgf ]^=byte (19-_gcfe );};_dcbf ,_ece :=_d .NewCipher (_eea );if _ece !=nil {return nil ,_ba .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_dcbf .XORKeyStream (_geg ,_face );
_face =append ([]byte {},_geg ...);};}else {return nil ,_ba .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_bdc ,_cdf :=_gbe .alg6 (_gbd ,_geg );if _cdf !=nil {return nil ,nil ;};return _bdc ,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_edd stdHandlerR6 )alg9 (_fea *StdEncryptDict ,_ggb []byte ,_fba []byte )error {if _eda :=_bd ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_ggb );
_eda !=nil {return _eda ;};if _bfag :=_bd ("\u0061\u006c\u0067\u0039","\u0055",48,_fea .U );_bfag !=nil {return _bfag ;};var _efca [16]byte ;if _ ,_egb :=_gf .ReadFull (_ab .Reader ,_efca [:]);_egb !=nil {return _egb ;};_bcea :=_efca [0:8];_fee :=_efca [8:16];
_eegd :=_fea .U [:48];_adc :=make ([]byte ,len (_fba )+len (_bcea )+len (_eegd ));_bdd :=copy (_adc ,_fba );_bdd +=copy (_adc [_bdd :],_bcea );_bdd +=copy (_adc [_bdd :],_eegd );_fge ,_bba :=_edd .alg2b (_fea .R ,_adc ,_fba ,_eegd );if _bba !=nil {return _bba ;
};O :=make ([]byte ,len (_fge )+len (_bcea )+len (_fee ));_bdd =copy (O ,_fge [:32]);_bdd +=copy (O [_bdd :],_bcea );_bdd +=copy (O [_bdd :],_fee );_fea .O =O ;_bdd =len (_fba );_bdd +=copy (_adc [_bdd :],_fee );_fge ,_bba =_edd .alg2b (_fea .R ,_adc ,_fba ,_eegd );
if _bba !=nil {return _bba ;};_dca ,_bba :=_fc (_fge [:32]);if _bba !=nil {return _bba ;};_bgf :=make ([]byte ,_e .BlockSize );_ddg :=_ge .NewCBCEncrypter (_dca ,_bgf );OE :=make ([]byte ,32);_ddg .CryptBlocks (OE ,_ggb [:32]);_fea .OE =OE ;return nil ;
};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// Allowed checks if a set of permissions can be granted.
func (_cd Permissions )Allowed (p2 Permissions )bool {return _cd &p2 ==p2 };func (_ea stdHandlerR4 )alg3Key (R int ,_adf []byte )[]byte {_db :=_gcb .New ();_aff :=_ea .paddedPass (_adf );_db .Write (_aff );if R >=3{for _ecf :=0;_ecf < 50;_ecf ++{_baf :=_db .Sum (nil );
_db =_gcb .New ();_db .Write (_baf );};};_ag :=_db .Sum (nil );if R ==2{_ag =_ag [0:5];}else {_ag =_ag [0:_ea .Length /8];};return _ag ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_dgge stdHandlerR6 )alg13 (_fgg *StdEncryptDict ,_aega []byte )error {if _ced :=_bd ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_aega );
_ced !=nil {return _ced ;};if _cg :=_bd ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_fgg .Perms );_cg !=nil {return _cg ;};_aab :=make ([]byte ,16);copy (_aab ,_fgg .Perms [:16]);_acbf ,_fcagc :=_e .NewCipher (_aega [:32]);if _fcagc !=nil {return _fcagc ;
};_aaa :=_ed (_acbf );_aaa .CryptBlocks (_aab ,_aab );if !_bad .Equal (_aab [9:12],[]byte ("\u0061\u0064\u0062")){return _ba .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_daf :=Permissions (_c .LittleEndian .Uint32 (_aab [0:4]));if _daf !=_fgg .P {return _ba .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _bgfc bool ;if _aab [8]=='T'{_bgfc =true ;}else if _aab [8]=='F'{_bgfc =false ;}else {return _ba .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _bgfc !=_fgg .EncryptMetadata {return _ba .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_dff stdHandlerR4 )alg6 (_cfgc *StdEncryptDict ,_aad []byte )([]byte ,error ){var (_ce []byte ;_bb error ;);_cad :=_dff .alg2 (_cfgc ,_aad );if _cfgc .R ==2{_ce ,_bb =_dff .alg4 (_cad ,_aad );}else if _cfgc .R >=3{_ce ,_bb =_dff .alg5 (_cad ,_aad );
}else {return nil ,_ba .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _bb !=nil {return nil ,_bb ;};_cf .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_ce ),string (_cfgc .U ));
_gcf :=_ce ;_abd :=_cfgc .U ;if _cfgc .R >=3{if len (_gcf )> 16{_gcf =_gcf [0:16];};if len (_abd )> 16{_abd =_abd [0:16];};};if !_bad .Equal (_gcf ,_abd ){return nil ,nil ;};return _cad ,nil ;};func (_ddd stdHandlerR6 )alg10 (_gee *StdEncryptDict ,_acba []byte )error {if _fcag :=_bd ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_acba );
_fcag !=nil {return _fcag ;};_caa :=uint64 (uint32 (_gee .P ))|(_f .MaxUint32 <<32);Perms :=make ([]byte ,16);_c .LittleEndian .PutUint64 (Perms [:8],_caa );if _gee .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_efdd :=_gf .ReadFull (_ab .Reader ,Perms [12:16]);_efdd !=nil {return _efdd ;};_aece ,_fed :=_fc (_acba [:32]);if _fed !=nil {return _fed ;};_agf :=_ac (_aece );_agf .CryptBlocks (Perms ,Perms );_gee .Perms =Perms [:16];return nil ;};func (_bfa stdHandlerR6 )alg2a (_ggee *StdEncryptDict ,_cee []byte )([]byte ,Permissions ,error ){if _gea :=_bd ("\u0061\u006c\u00672\u0061","\u004f",48,_ggee .O );
_gea !=nil {return nil ,0,_gea ;};if _gac :=_bd ("\u0061\u006c\u00672\u0061","\u0055",48,_ggee .U );_gac !=nil {return nil ,0,_gac ;};if len (_cee )> 127{_cee =_cee [:127];};_fdf ,_gcg :=_bfa .alg12 (_ggee ,_cee );if _gcg !=nil {return nil ,0,_gcg ;};var (_cac []byte ;
_afc []byte ;_bce []byte ;);var _ege Permissions ;if len (_fdf )!=0{_ege =PermOwner ;_cec :=make ([]byte ,len (_cee )+8+48);_ffa :=copy (_cec ,_cee );_ffa +=copy (_cec [_ffa :],_ggee .O [40:48]);copy (_cec [_ffa :],_ggee .U [0:48]);_cac =_cec ;_afc =_ggee .OE ;
_bce =_ggee .U [0:48];}else {_fdf ,_gcg =_bfa .alg11 (_ggee ,_cee );if _gcg ==nil &&len (_fdf )==0{_fdf ,_gcg =_bfa .alg11 (_ggee ,[]byte (""));};if _gcg !=nil {return nil ,0,_gcg ;}else if len (_fdf )==0{return nil ,0,nil ;};_ege =_ggee .P ;_aga :=make ([]byte ,len (_cee )+8);
_bbb :=copy (_aga ,_cee );copy (_aga [_bbb :],_ggee .U [40:48]);_cac =_aga ;_afc =_ggee .UE ;_bce =nil ;};if _gdg :=_bd ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_afc );_gdg !=nil {return nil ,0,_gdg ;};_afc =_afc [:32];_ace ,_gcg :=_bfa .alg2b (_ggee .R ,_cac ,_cee ,_bce );
if _gcg !=nil {return nil ,0,_gcg ;};_ead ,_gcg :=_e .NewCipher (_ace [:32]);if _gcg !=nil {return nil ,0,_gcg ;};_fcg :=make ([]byte ,_e .BlockSize );_ggg :=_ge .NewCBCDecrypter (_ead ,_fcg );_fca :=make ([]byte ,32);_ggg .CryptBlocks (_fca ,_afc );if _ggee .R ==5{return _fca ,_ege ,nil ;
};_gcg =_bfa .alg13 (_ggee ,_fca );if _gcg !=nil {return nil ,0,_gcg ;};return _fca ,_ege ,nil ;};func (_adbc stdHandlerR6 )alg11 (_dgg *StdEncryptDict ,_aaf []byte )([]byte ,error ){if _aeg :=_bd ("\u0061\u006c\u00671\u0031","\u0055",48,_dgg .U );_aeg !=nil {return nil ,_aeg ;
};_dga :=make ([]byte ,len (_aaf )+8);_aefb :=copy (_dga ,_aaf );_aefb +=copy (_dga [_aefb :],_dgg .U [32:40]);_ccc ,_ebc :=_adbc .alg2b (_dgg .R ,_dga ,_aaf ,nil );if _ebc !=nil {return nil ,_ebc ;};_ccc =_ccc [:32];if !_bad .Equal (_ccc ,_dgg .U [:32]){return nil ,nil ;
};return _ccc ,nil ;};func (_ebbg stdHandlerR6 )alg8 (_aefc *StdEncryptDict ,_facd []byte ,_dcd []byte )error {if _ecdb :=_bd ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_facd );_ecdb !=nil {return _ecdb ;};var _acge [16]byte ;if _ ,_faa :=_gf .ReadFull (_ab .Reader ,_acge [:]);
_faa !=nil {return _faa ;};_beb :=_acge [0:8];_gegg :=_acge [8:16];_feb :=make ([]byte ,len (_dcd )+len (_beb ));_acb :=copy (_feb ,_dcd );copy (_feb [_acb :],_beb );_ega ,_fbgb :=_ebbg .alg2b (_aefc .R ,_feb ,_dcd ,nil );if _fbgb !=nil {return _fbgb ;
};U :=make ([]byte ,len (_ega )+len (_beb )+len (_gegg ));_acb =copy (U ,_ega [:32]);_acb +=copy (U [_acb :],_beb );copy (U [_acb :],_gegg );_aefc .U =U ;_acb =len (_dcd );copy (_feb [_acb :],_gegg );_ega ,_fbgb =_ebbg .alg2b (_aefc .R ,_feb ,_dcd ,nil );
if _fbgb !=nil {return _fbgb ;};_gef ,_fbgb :=_fc (_ega [:32]);if _fbgb !=nil {return _fbgb ;};_afba :=make ([]byte ,_e .BlockSize );_gdb :=_ge .NewCBCEncrypter (_gef ,_afba );UE :=make ([]byte ,32);_gdb .CryptBlocks (UE ,_facd [:32]);_aefc .UE =UE ;return nil ;
};func _aec (_deg ,_ebe ,_fe []byte )([]byte ,error ){var (_ebg ,_bea ,_cbf _a .Hash ;);_ebg =_b .New ();_bdb :=make ([]byte ,64);_gcfg :=_ebg ;_gcfg .Write (_deg );K :=_gcfg .Sum (_bdb [:0]);_fcc :=make ([]byte ,64*(127+64+48));_fbbd :=func (_afaa int )([]byte ,error ){_gcc :=len (_ebe )+len (K )+len (_fe );
_bgc :=_fcc [:_gcc ];_bcc :=copy (_bgc ,_ebe );_bcc +=copy (_bgc [_bcc :],K [:]);_bcc +=copy (_bgc [_bcc :],_fe );if _bcc !=_gcc {_cf .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_ba .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_fcc [:_gcc *64];_ddad (K1 ,_gcc );_bbf ,_fcab :=_fc (K [0:16]);if _fcab !=nil {return nil ,_fcab ;};_agg :=_ge .NewCBCEncrypter (_bbf ,K [16:32]);_agg .CryptBlocks (K1 ,K1 );
E :=K1 ;_abg :=0;for _adb :=0;_adb < 16;_adb ++{_abg +=int (E [_adb ]%3);};var _aeff _a .Hash ;switch _abg %3{case 0:_aeff =_ebg ;case 1:if _bea ==nil {_bea =_gc .New384 ();};_aeff =_bea ;case 2:if _cbf ==nil {_cbf =_gc .New ();};_aeff =_cbf ;};_aeff .Reset ();
_aeff .Write (E );K =_aeff .Sum (_bdb [:0]);return E ,nil ;};for _bgcc :=0;;{E ,_gacg :=_fbbd (_bgcc );if _gacg !=nil {return nil ,_gacg ;};_bed :=E [len (E )-1];_bgcc ++;if _bgcc >=64&&_bed <=uint8 (_bgcc -32){break ;};};return K [:32],nil ;};func _ed (_gff _ge .Block )_ge .BlockMode {return (*ecbDecrypter )(_abc (_gff ))};
func _bd (_eb ,_dc string ,_cfg int ,_ad []byte )error {if len (_ad )< _cfg {return errInvalidField {Func :_eb ,Field :_dc ,Exp :_cfg ,Got :len (_ad )};};return nil ;};func (_da *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_da ._ef !=0{_cf .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_cf .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_da ._cfc .Encrypt (dst ,src [:_da ._ef ]);src =src [_da ._ef :];dst =dst [_da ._ef :];};};