//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_cef "bytes";_cb "crypto/aes";_a "crypto/cipher";_agc "crypto/md5";_be "crypto/rand";_f "crypto/rc4";_ce "crypto/sha256";_eb "crypto/sha512";_ag "encoding/binary";_b "errors";_ca "fmt";_bf "github.com/unidoc/unipdf/v3/common";
_g "hash";_e "io";_cbb "math";);func _aag (_ggae []byte )(_a .Block ,error ){_acgb ,_cbbg :=_cb .NewCipher (_ggae );if _cbbg !=nil {_bf .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_cbbg );
return nil ,_cbbg ;};return _acgb ,nil ;};func (_gb *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gb ._ac !=0{_bf .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_bf .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gb ._d .Decrypt (dst ,src [:_gb ._ac ]);src =src [_gb ._ac :];dst =dst [_gb ._ac :];};};func (_bg stdHandlerR4 )alg7 (_gfc *StdEncryptDict ,_gff []byte )([]byte ,error ){_dga :=_bg .alg3Key (_gfc .R ,_gff );_dbcb :=make ([]byte ,len (_gfc .O ));
if _gfc .R ==2{_gcb ,_de :=_f .NewCipher (_dga );if _de !=nil {return nil ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gcb .XORKeyStream (_dbcb ,_gfc .O );}else if _gfc .R >=3{_cbed :=append ([]byte {},_gfc .O ...);
for _ged :=0;_ged < 20;_ged ++{_cgb :=append ([]byte {},_dga ...);for _bff :=0;_bff < len (_dga );_bff ++{_cgb [_bff ]^=byte (19-_ged );};_af ,_gegfg :=_f .NewCipher (_cgb );if _gegfg !=nil {return nil ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_af .XORKeyStream (_dbcb ,_cbed );_cbed =append ([]byte {},_dbcb ...);};}else {return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_gga ,_cbbc :=_bg .alg6 (_gfc ,_dbcb );if _cbbc !=nil {return nil ,nil ;};return _gga ,nil ;};func _gd (_gc _a .Block )_a .BlockMode {return (*ecbEncrypter )(_db (_gc ))};
func (_cea *ecbDecrypter )BlockSize ()int {return _cea ._ac };func (_ecb stdHandlerR4 )alg2 (_ga *StdEncryptDict ,_ea []byte )[]byte {_bf .Log .Trace ("\u0061\u006c\u0067\u0032");_eab :=_ecb .paddedPass (_ea );_cc :=_agc .New ();_cc .Write (_eab );_cc .Write (_ga .O );
var _agf [4]byte ;_ag .LittleEndian .PutUint32 (_agf [:],uint32 (_ga .P ));_cc .Write (_agf [:]);_bf .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_agf );_cc .Write ([]byte (_ecb .ID0 ));_bf .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ga .R ,_ga .EncryptMetadata );
if (_ga .R >=4)&&!_ga .EncryptMetadata {_cc .Write ([]byte {0xff,0xff,0xff,0xff});};_gf :=_cc .Sum (nil );if _ga .R >=3{_cc =_agc .New ();for _bfg :=0;_bfg < 50;_bfg ++{_cc .Reset ();_cc .Write (_gf [0:_ecb .Length /8]);_gf =_cc .Sum (nil );};};if _ga .R >=3{return _gf [0:_ecb .Length /8];
};return _gf [0:5];};const (PermOwner =Permissions (_cbb .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);
PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e");
);func (_bb stdHandlerR6 )alg2b (R int ,_ead ,_aff ,_daf []byte )([]byte ,error ){if R ==5{return _cga (_ead );};return _dfb (_ead ,_aff ,_daf );};func _dfb (_egd ,_ggc ,_acfd []byte )([]byte ,error ){var (_dfbc ,_fae ,_dgae _g .Hash ;);_dfbc =_ce .New ();
_abac :=make ([]byte ,64);_da :=_dfbc ;_da .Write (_egd );K :=_da .Sum (_abac [:0]);_aea :=make ([]byte ,64*(127+64+48));_fgg :=func (_cdg int )([]byte ,error ){_cdb :=len (_ggc )+len (K )+len (_acfd );_feg :=_aea [:_cdb ];_gdde :=copy (_feg ,_ggc );_gdde +=copy (_feg [_gdde :],K [:]);
_gdde +=copy (_feg [_gdde :],_acfd );if _gdde !=_cdb {_bf .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_b .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_aea [:_cdb *64];_cbff (K1 ,_cdb );_fbgf ,_ggaf :=_aag (K [0:16]);if _ggaf !=nil {return nil ,_ggaf ;};_dbed :=_a .NewCBCEncrypter (_fbgf ,K [16:32]);_dbed .CryptBlocks (K1 ,K1 );
E :=K1 ;_aga :=0;for _cfc :=0;_cfc < 16;_cfc ++{_aga +=int (E [_cfc ]%3);};var _gac _g .Hash ;switch _aga %3{case 0:_gac =_dfbc ;case 1:if _fae ==nil {_fae =_eb .New384 ();};_gac =_fae ;case 2:if _dgae ==nil {_dgae =_eb .New ();};_gac =_dgae ;};_gac .Reset ();
_gac .Write (E );K =_gac .Sum (_abac [:0]);return E ,nil ;};for _dc :=0;;{E ,_age :=_fgg (_dc );if _age !=nil {return nil ,_age ;};_cead :=E [len (E )-1];_dc ++;if _dc >=64&&_cead <=uint8 (_dc -32){break ;};};return K [:32],nil ;};func (_adg stdHandlerR4 )alg4 (_fgb []byte ,_ebb []byte )([]byte ,error ){_ced ,_aa :=_f .NewCipher (_fgb );
if _aa !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_df :=[]byte (_ed );_fgba :=make ([]byte ,len (_df ));_ced .XORKeyStream (_fgba ,_df );return _fgba ,nil ;};func (_dgdc stdHandlerR6 )alg2a (_fdcf *StdEncryptDict ,_abg []byte )([]byte ,Permissions ,error ){if _aca :=_ba ("\u0061\u006c\u00672\u0061","\u004f",48,_fdcf .O );
_aca !=nil {return nil ,0,_aca ;};if _afe :=_ba ("\u0061\u006c\u00672\u0061","\u0055",48,_fdcf .U );_afe !=nil {return nil ,0,_afe ;};if len (_abg )> 127{_abg =_abg [:127];};_eac ,_ede :=_dgdc .alg12 (_fdcf ,_abg );if _ede !=nil {return nil ,0,_ede ;};
var (_gcag []byte ;_eaa []byte ;_cbag []byte ;);var _cgd Permissions ;if len (_eac )!=0{_cgd =PermOwner ;_fbgc :=make ([]byte ,len (_abg )+8+48);_dfa :=copy (_fbgc ,_abg );_dfa +=copy (_fbgc [_dfa :],_fdcf .O [40:48]);copy (_fbgc [_dfa :],_fdcf .U [0:48]);
_gcag =_fbgc ;_eaa =_fdcf .OE ;_cbag =_fdcf .U [0:48];}else {_eac ,_ede =_dgdc .alg11 (_fdcf ,_abg );if _ede ==nil &&len (_eac )==0{_eac ,_ede =_dgdc .alg11 (_fdcf ,[]byte (""));};if _ede !=nil {return nil ,0,_ede ;}else if len (_eac )==0{return nil ,0,nil ;
};_cgd =_fdcf .P ;_fa :=make ([]byte ,len (_abg )+8);_adb :=copy (_fa ,_abg );copy (_fa [_adb :],_fdcf .U [40:48]);_gcag =_fa ;_eaa =_fdcf .UE ;_cbag =nil ;};if _dgg :=_ba ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_eaa );_dgg !=nil {return nil ,0,_dgg ;
};_eaa =_eaa [:32];_abf ,_ede :=_dgdc .alg2b (_fdcf .R ,_gcag ,_abg ,_cbag );if _ede !=nil {return nil ,0,_ede ;};_geff ,_ede :=_cb .NewCipher (_abf [:32]);if _ede !=nil {return nil ,0,_ede ;};_bga :=make ([]byte ,_cb .BlockSize );_fge :=_a .NewCBCDecrypter (_geff ,_bga );
_fea :=make ([]byte ,32);_fge .CryptBlocks (_fea ,_eaa );if _fdcf .R ==5{return _fea ,_cgd ,nil ;};_ede =_dgdc .alg13 (_fdcf ,_fea );if _ede !=nil {return nil ,0,_ede ;};return _fea ,_cgd ,nil ;};type ecb struct{_d _a .Block ;_ac int ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func _ba (_fc ,_fdf string ,_dgb int ,_ec []byte )error {if len (_ec )< _dgb {return errInvalidField {Func :_fc ,Field :_fdf ,Exp :_dgb ,Got :len (_ec )};};return nil ;};func (_abc errInvalidField )Error ()string {return _ca .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_abc .Func ,_abc .Field ,_abc .Exp ,_abc .Got );
};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};type stdHandlerR4 struct{Length int ;ID0 string ;};func (stdHandlerR4 )paddedPass (_bd []byte )[]byte {_baa :=make ([]byte ,32);_gef :=copy (_baa ,_bd );
for ;_gef < 32;_gef ++{_baa [_gef ]=_ed [_gef -len (_bd )];};return _baa ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};var _ StdHandler =stdHandlerR4 {};func (_bab stdHandlerR6 )alg11 (_eada *StdEncryptDict ,_aae []byte )([]byte ,error ){if _gae :=_ba ("\u0061\u006c\u00671\u0031","\u0055",48,_eada .U );_gae !=nil {return nil ,_gae ;
};_caeb :=make ([]byte ,len (_aae )+8);_aaef :=copy (_caeb ,_aae );_aaef +=copy (_caeb [_aaef :],_eada .U [32:40]);_cbac ,_ffa :=_bab .alg2b (_eada .R ,_caeb ,_aae ,nil );if _ffa !=nil {return nil ,_ffa ;};_cbac =_cbac [:32];if !_cef .Equal (_cbac ,_eada .U [:32]){return nil ,nil ;
};return _cbac ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_ge Permissions )Allowed (p2 Permissions )bool {return _ge &p2 ==p2 };func (_ebc stdHandlerR6 )alg12 (_afd *StdEncryptDict ,_abae []byte )([]byte ,error ){if _aec :=_ba ("\u0061\u006c\u00671\u0032","\u0055",48,_afd .U );_aec !=nil {return nil ,_aec ;
};if _fef :=_ba ("\u0061\u006c\u00671\u0032","\u004f",48,_afd .O );_fef !=nil {return nil ,_fef ;};_efa :=make ([]byte ,len (_abae )+8+48);_edd :=copy (_efa ,_abae );_edd +=copy (_efa [_edd :],_afd .O [32:40]);_edd +=copy (_efa [_edd :],_afd .U [0:48]);
_agfg ,_dd :=_ebc .alg2b (_afd .R ,_efa ,_abae ,_afd .U [0:48]);if _dd !=nil {return nil ,_dd ;};_agfg =_agfg [:32];if !_cef .Equal (_agfg ,_afd .O [:32]){return nil ,nil ;};return _agfg ,nil ;};

// Authenticate implements StdHandler interface.
func (_gca stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_bf .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_cgbb ,_dgd :=_gca .alg7 (d ,pass );if _dgd !=nil {return nil ,0,_dgd ;};if _cgbb !=nil {_bf .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cgbb ,PermOwner ,nil ;
};_bf .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cgbb ,_dgd =_gca .alg6 (d ,pass );if _dgd !=nil {return nil ,0,_dgd ;
};if _cgbb !=nil {_bf .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cgbb ,d .P ,nil ;};return nil ,0,nil ;};func (_gag stdHandlerR6 )alg10 (_bffe *StdEncryptDict ,_beeb []byte )error {if _gbe :=_ba ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_beeb );
_gbe !=nil {return _gbe ;};_aeb :=uint64 (uint32 (_bffe .P ))|(_cbb .MaxUint32 <<32);Perms :=make ([]byte ,16);_ag .LittleEndian .PutUint64 (Perms [:8],_aeb );if _bffe .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_aebb :=_e .ReadFull (_be .Reader ,Perms [12:16]);_aebb !=nil {return _aebb ;};_bc ,_gde :=_aag (_beeb [:32]);if _gde !=nil {return _gde ;};_bde :=_gd (_bc );_bde .CryptBlocks (Perms ,Perms );_bffe .Perms =Perms [:16];return nil ;};func (_feb stdHandlerR4 )alg5 (_gaa []byte ,_dbd []byte )([]byte ,error ){_gegf :=_agc .New ();
_gegf .Write ([]byte (_ed ));_gegf .Write ([]byte (_feb .ID0 ));_fdc :=_gegf .Sum (nil );_bf .Log .Trace ("\u0061\u006c\u0067\u0035");_bf .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gaa );_bf .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_feb .ID0 );
if len (_fdc )!=16{return nil ,_b .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_dgc ,_fca :=_f .NewCipher (_gaa );if _fca !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gdd :=make ([]byte ,16);_dgc .XORKeyStream (_gdd ,_fdc );_cbf :=make ([]byte ,len (_gaa ));for _acg :=0;_acg < 19;_acg ++{for _ae :=0;_ae < len (_gaa );_ae ++{_cbf [_ae ]=_gaa [_ae ]^byte (_acg +1);};_dgc ,_fca =_f .NewCipher (_cbf );if _fca !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dgc .XORKeyStream (_gdd ,_gdd );_bf .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_acg ,_cbf );_bf .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_acg ,_gdd );
};_gaf :=make ([]byte ,32);for _gea :=0;_gea < 16;_gea ++{_gaf [_gea ]=_gdd [_gea ];};_ ,_fca =_be .Read (_gaf [16:32]);if _fca !=nil {return nil ,_b .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _gaf ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;type ecbEncrypter ecb ;

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_gaab stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_cfe :=make ([]byte ,32);if _ ,_cbc :=_e .ReadFull (_be .Reader ,_cfe );_cbc !=nil {return nil ,_cbc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _bgf :=_gaab .alg8 (d ,_cfe ,upass );_bgf !=nil {return nil ,_bgf ;};if _bbe :=_gaab .alg9 (d ,_cfe ,opass );_bbe !=nil {return nil ,_bbe ;};if d .R ==5{return _cfe ,nil ;
};if _bda :=_gaab .alg10 (d ,_cfe );_bda !=nil {return nil ,_bda ;};return _cfe ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_eag stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_gddg :=_eag .alg3 (d .R ,upass ,opass );if _gddg !=nil {_bf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gddg );
return nil ,_gddg ;};d .O =O ;_bf .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_fgbb :=_eag .alg2 (d ,upass );U ,_gddg :=_eag .alg5 (_fgbb ,upass );if _gddg !=nil {_bf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gddg );
return nil ,_gddg ;};d .U =U ;_bf .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _fgbb ,nil ;};func (_ef stdHandlerR4 )alg3 (R int ,_cd ,_geg []byte )([]byte ,error ){var _cgc []byte ;if len (_geg )> 0{_cgc =_ef .alg3Key (R ,_geg );
}else {_cgc =_ef .alg3Key (R ,_cd );};_cgg ,_cba :=_f .NewCipher (_cgc );if _cba !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cbe :=_ef .paddedPass (_cd );_cab :=make ([]byte ,len (_cbe ));
_cgg .XORKeyStream (_cab ,_cbe );if R >=3{_cbg :=make ([]byte ,len (_cgc ));for _ad :=0;_ad < 19;_ad ++{for _fbe :=0;_fbe < len (_cgc );_fbe ++{_cbg [_fbe ]=_cgc [_fbe ]^byte (_ad +1);};_agd ,_aba :=_f .NewCipher (_cbg );if _aba !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_agd .XORKeyStream (_cab ,_cab );};};return _cab ,nil ;};var _ StdHandler =stdHandlerR6 {};func _cga (_fdd []byte )([]byte ,error ){_cee :=_ce .New ();_cee .Write (_fdd );return _cee .Sum (nil ),nil ;};func (_cced stdHandlerR6 )alg13 (_dfe *StdEncryptDict ,_ecfd []byte )error {if _fbb :=_ba ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_ecfd );
_fbb !=nil {return _fbb ;};if _cfce :=_ba ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_dfe .Perms );_cfce !=nil {return _cfce ;};_bgd :=make ([]byte ,16);copy (_bgd ,_dfe .Perms [:16]);_eba ,_dag :=_cb .NewCipher (_ecfd [:32]);if _dag !=nil {return _dag ;
};_abcf :=_agcg (_eba );_abcf .CryptBlocks (_bgd ,_bgd );if !_cef .Equal (_bgd [9:12],[]byte ("\u0061\u0064\u0062")){return _b .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_fgdf :=Permissions (_ag .LittleEndian .Uint32 (_bgd [0:4]));if _fgdf !=_dfe .P {return _b .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _ebf bool ;if _bgd [8]=='T'{_ebf =true ;}else if _bgd [8]=='F'{_ebf =false ;}else {return _b .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _ebf !=_dfe .EncryptMetadata {return _b .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func _agcg (_fgf _a .Block )_a .BlockMode {return (*ecbDecrypter )(_db (_fgf ))};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func _cbff (_eg []byte ,_ffb int ){_gddc :=_ffb ;for _gddc < len (_eg ){copy (_eg [_gddc :],_eg [:_gddc ]);_gddc *=2;};};func (_cac stdHandlerR6 )alg9 (_cce *StdEncryptDict ,_bee []byte ,_cefg []byte )error {if _eace :=_ba ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_bee );
_eace !=nil {return _eace ;};if _fcf :=_ba ("\u0061\u006c\u0067\u0039","\u0055",48,_cce .U );_fcf !=nil {return _fcf ;};var _ecf [16]byte ;if _ ,_bdc :=_e .ReadFull (_be .Reader ,_ecf [:]);_bdc !=nil {return _bdc ;};_cfcc :=_ecf [0:8];_ceadc :=_ecf [8:16];
_fgd :=_cce .U [:48];_fbc :=make ([]byte ,len (_cefg )+len (_cfcc )+len (_fgd ));_acae :=copy (_fbc ,_cefg );_acae +=copy (_fbc [_acae :],_cfcc );_acae +=copy (_fbc [_acae :],_fgd );_dge ,_agg :=_cac .alg2b (_cce .R ,_fbc ,_cefg ,_fgd );if _agg !=nil {return _agg ;
};O :=make ([]byte ,len (_dge )+len (_cfcc )+len (_ceadc ));_acae =copy (O ,_dge [:32]);_acae +=copy (O [_acae :],_cfcc );_acae +=copy (O [_acae :],_ceadc );_cce .O =O ;_acae =len (_cefg );_acae +=copy (_fbc [_acae :],_ceadc );_dge ,_agg =_cac .alg2b (_cce .R ,_fbc ,_cefg ,_fgd );
if _agg !=nil {return _agg ;};_dfda ,_agg :=_aag (_dge [:32]);if _agg !=nil {return _agg ;};_fcc :=make ([]byte ,_cb .BlockSize );_eae :=_a .NewCBCEncrypter (_dfda ,_fcc );OE :=make ([]byte ,32);_eae .CryptBlocks (OE ,_bee [:32]);_cce .OE =OE ;return nil ;
};type stdHandlerR6 struct{};func (_fg *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_fg ._ac !=0{_bf .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_bf .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_fg ._d .Encrypt (dst ,src [:_fg ._ac ]);src =src [_fg ._ac :];dst =dst [_fg ._ac :];};};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gdf *StdEncryptDict ,_dbe ,_cf []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ab *StdEncryptDict ,_fd []byte )([]byte ,Permissions ,error );};func (_dg *ecbEncrypter )BlockSize ()int {return _dg ._ac };type ecbDecrypter ecb ;func (_beg stdHandlerR6 )alg8 (_gfa *StdEncryptDict ,_gad []byte ,_bae []byte )error {if _dfd :=_ba ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gad );
_dfd !=nil {return _dfd ;};var _fgga [16]byte ;if _ ,_dafg :=_e .ReadFull (_be .Reader ,_fgga [:]);_dafg !=nil {return _dafg ;};_baec :=_fgga [0:8];_dcd :=_fgga [8:16];_ade :=make ([]byte ,len (_bae )+len (_baec ));_feab :=copy (_ade ,_bae );copy (_ade [_feab :],_baec );
_agef ,_adge :=_beg .alg2b (_gfa .R ,_ade ,_bae ,nil );if _adge !=nil {return _adge ;};U :=make ([]byte ,len (_agef )+len (_baec )+len (_dcd ));_feab =copy (U ,_agef [:32]);_feab +=copy (U [_feab :],_baec );copy (U [_feab :],_dcd );_gfa .U =U ;_feab =len (_bae );
copy (_ade [_feab :],_dcd );_agef ,_adge =_beg .alg2b (_gfa .R ,_ade ,_bae ,nil );if _adge !=nil {return _adge ;};_dfde ,_adge :=_aag (_agef [:32]);if _adge !=nil {return _adge ;};_gfd :=make ([]byte ,_cb .BlockSize );_eaf :=_a .NewCBCEncrypter (_dfde ,_gfd );
UE :=make ([]byte ,32);_eaf .CryptBlocks (UE ,_gad [:32]);_gfa .UE =UE ;return nil ;};func _db (_fb _a .Block )*ecb {return &ecb {_d :_fb ,_ac :_fb .BlockSize ()}};const _ed ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";
func (_cg stdHandlerR4 )alg3Key (R int ,_bac []byte )[]byte {_dbc :=_agc .New ();_fe :=_cg .paddedPass (_bac );_dbc .Write (_fe );if R >=3{for _fbg :=0;_fbg < 50;_fbg ++{_ee :=_dbc .Sum (nil );_dbc =_agc .New ();_dbc .Write (_ee );};};_fec :=_dbc .Sum (nil );
if R ==2{_fec =_fec [0:5];}else {_fec =_fec [0:_cg .Length /8];};return _fec ;};func (_cag stdHandlerR4 )alg6 (_ff *StdEncryptDict ,_gg []byte )([]byte ,error ){var (_dgcg []byte ;_cgce error ;);_cae :=_cag .alg2 (_ff ,_gg );if _ff .R ==2{_dgcg ,_cgce =_cag .alg4 (_cae ,_gg );
}else if _ff .R >=3{_dgcg ,_cgce =_cag .alg5 (_cae ,_gg );}else {return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _cgce !=nil {return nil ,_cgce ;};_bf .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_dgcg ),string (_ff .U ));
_acf :=_dgcg ;_baad :=_ff .U ;if _ff .R >=3{if len (_acf )> 16{_acf =_acf [0:16];};if len (_baad )> 16{_baad =_baad [0:16];};};if !_cef .Equal (_acf ,_baad ){return nil ,nil ;};return _cae ,nil ;};

// Authenticate implements StdHandler interface.
func (_cfg stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cfg .alg2a (d ,pass );};