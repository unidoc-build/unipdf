//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_aad "bytes";_ae "crypto/aes";_f "crypto/cipher";_fb "crypto/md5";_d "crypto/rand";_aag "crypto/rc4";_fc "crypto/sha256";_aa "crypto/sha512";_aae "encoding/binary";_ec "errors";_ge "fmt";_fe "github.com/unidoc/unipdf/v3/common";_c "hash";_e "io";_g "math";);func (_cfdd stdHandlerR6 )alg13 (_adf *StdEncryptDict ,_fdd []byte )error {if _cbg :=_fa ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_fdd );_cbg !=nil {return _cbg ;};if _fec :=_fa ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_adf .Perms );_fec !=nil {return _fec ;};_dba :=make ([]byte ,16);copy (_dba ,_adf .Perms [:16]);_bdd ,_bbb :=_ae .NewCipher (_fdd [:32]);if _bbb !=nil {return _bbb ;};_dgfe :=_fd (_bdd );_dgfe .CryptBlocks (_dba ,_dba );if !_aad .Equal (_dba [9:12],[]byte ("\u0061\u0064\u0062")){return _ec .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_ccbd :=Permissions (_aae .LittleEndian .Uint32 (_dba [0:4]));if _ccbd !=_adf .P {return _ec .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};var _dcd bool ;if _dba [8]=='T'{_dcd =true ;}else if _dba [8]=='F'{_dcd =false ;}else {return _ec .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _dcd !=_adf .EncryptMetadata {return _ec .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_cce stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_aeb :=_cce .alg3 (d .R ,upass ,opass );if _aeb !=nil {_fe .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aeb );return nil ,_aeb ;};d .O =O ;_fe .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_abee :=_cce .alg2 (d ,upass );U ,_aeb :=_cce .alg5 (_abee ,upass );if _aeb !=nil {_fe .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aeb );return nil ,_aeb ;};d .U =U ;_fe .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _abee ,nil ;};type ecbEncrypter ecb ;type stdHandlerR4 struct{Length int ;ID0 string ;};func (_eaab stdHandlerR4 )alg6 (_bac *StdEncryptDict ,_cef []byte )([]byte ,error ){var (_cefd []byte ;_ege error ;);_gd :=_eaab .alg2 (_bac ,_cef );if _bac .R ==2{_cefd ,_ege =_eaab .alg4 (_gd ,_cef );}else if _bac .R >=3{_cefd ,_ege =_eaab .alg5 (_gd ,_cef );}else {return nil ,_ec .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _ege !=nil {return nil ,_ege ;};_fe .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_cefd ),string (_bac .U ));_dgd :=_cefd ;_bc :=_bac .U ;if _bac .R >=3{if len (_dgd )> 16{_dgd =_dgd [0:16];};if len (_bc )> 16{_bc =_bc [0:16];};};if !_aad .Equal (_dgd ,_bc ){return nil ,nil ;};return _gd ,nil ;};func (_ee *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ee ._dg !=0{_fe .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_fe .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ee ._gf .Encrypt (dst ,src [:_ee ._dg ]);src =src [_ee ._dg :];dst =dst [_ee ._dg :];};};func _eg (_aeg _f .Block )*ecb {return &ecb {_gf :_aeg ,_dg :_aeg .BlockSize ()}};var _ StdHandler =stdHandlerR4 {};func (_acc stdHandlerR4 )alg3 (R int ,_dfc ,_de []byte )([]byte ,error ){var _gb []byte ;if len (_de )> 0{_gb =_acc .alg3Key (R ,_de );}else {_gb =_acc .alg3Key (R ,_dfc );};_faa ,_acg :=_aag .NewCipher (_gb );if _acg !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eac :=_acc .paddedPass (_dfc );_fdae :=make ([]byte ,len (_eac ));_faa .XORKeyStream (_fdae ,_eac );if R >=3{_acd :=make ([]byte ,len (_gb ));for _afd :=0;_afd < 19;_afd ++{for _faae :=0;_faae < len (_gb );_faae ++{_acd [_faae ]=_gb [_faae ]^byte (_afd +1);};_cb ,_cdb :=_aag .NewCipher (_acd );if _cdb !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cb .XORKeyStream (_fdae ,_fdae );};};return _fdae ,nil ;};func (_efc stdHandlerR6 )alg12 (_ega *StdEncryptDict ,_aee []byte )([]byte ,error ){if _cfa :=_fa ("\u0061\u006c\u00671\u0032","\u0055",48,_ega .U );_cfa !=nil {return nil ,_cfa ;};if _dgdc :=_fa ("\u0061\u006c\u00671\u0032","\u004f",48,_ega .O );_dgdc !=nil {return nil ,_dgdc ;};_ffab :=make ([]byte ,len (_aee )+8+48);_edcg :=copy (_ffab ,_aee );_edcg +=copy (_ffab [_edcg :],_ega .O [32:40]);_edcg +=copy (_ffab [_edcg :],_ega .U [0:48]);_dfce ,_ebc :=_efc .alg2b (_ega .R ,_ffab ,_aee ,_ega .U [0:48]);if _ebc !=nil {return nil ,_ebc ;};_dfce =_dfce [:32];if !_aad .Equal (_dfce ,_ega .O [:32]){return nil ,nil ;};return _dfce ,nil ;};func _fd (_cd _f .Block )_f .BlockMode {return (*ecbDecrypter )(_eg (_cd ))};func (_eeg *ecbDecrypter )BlockSize ()int {return _eeg ._dg };

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_egg *StdEncryptDict ,_cdf ,_ad []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_cf *StdEncryptDict ,_ac []byte )([]byte ,Permissions ,error );};func (_eaa stdHandlerR4 )alg4 (_dge []byte ,_ba []byte )([]byte ,error ){_bae ,_cab :=_aag .NewCipher (_dge );if _cab !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_baa :=[]byte (_faf );_gcg :=make ([]byte ,len (_baa ));_bae .XORKeyStream (_gcg ,_baa );return _gcg ,nil ;};var _ StdHandler =stdHandlerR6 {};func (_dcfe stdHandlerR6 )alg10 (_aedd *StdEncryptDict ,_aea []byte )error {if _gefg :=_fa ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_aea );_gefg !=nil {return _gefg ;};_dcc :=uint64 (uint32 (_aedd .P ))|(_g .MaxUint32 <<32);Perms :=make ([]byte ,16);_aae .LittleEndian .PutUint64 (Perms [:8],_dcc );if _aedd .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_bgc :=_e .ReadFull (_d .Reader ,Perms [12:16]);_bgc !=nil {return _bgc ;};_cgdf ,_edd :=_cgg (_aea [:32]);if _edd !=nil {return _edd ;};_gcbb :=_db (_cgdf );_gcbb .CryptBlocks (Perms ,Perms );_aedd .Perms =Perms [:16];return nil ;};func (_cgga stdHandlerR6 )alg2b (R int ,_eegd ,_eegf ,_faba []byte )([]byte ,error ){if R ==5{return _bga (_eegd );};return _fff (_eegd ,_eegf ,_faba );};func _cgg (_fcgf []byte )(_f .Block ,error ){_ace ,_ccb :=_ae .NewCipher (_fcgf );if _ccb !=nil {_fe .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_ccb );return nil ,_ccb ;};return _ace ,nil ;};type stdHandlerR6 struct{};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_ff stdHandlerR4 )alg3Key (R int ,_ccd []byte )[]byte {_gc :=_fb .New ();_dc :=_ff .paddedPass (_ccd );_gc .Write (_dc );if R >=3{for _gfd :=0;_gfd < 50;_gfd ++{_be :=_gc .Sum (nil );_gc =_fb .New ();_gc .Write (_be );};};_da :=_gc .Sum (nil );if R ==2{_da =_da [0:5];}else {_da =_da [0:_ff .Length /8];};return _da ;};func (_af errInvalidField )Error ()string {return _ge .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_af .Func ,_af .Field ,_af .Exp ,_af .Got );};type ecb struct{_gf _f .Block ;_dg int ;};func _fff (_fdg ,_ddg ,_ef []byte )([]byte ,error ){var (_egcd ,_bgg ,_baf _c .Hash ;);_egcd =_fc .New ();_ecc :=make ([]byte ,64);_fbg :=_egcd ;_fbg .Write (_fdg );K :=_fbg .Sum (_ecc [:0]);_ffa :=make ([]byte ,64*(127+64+48));_fbe :=func (_ead int )([]byte ,error ){_gaad :=len (_ddg )+len (K )+len (_ef );_dfe :=_ffa [:_gaad ];_fba :=copy (_dfe ,_ddg );_fba +=copy (_dfe [_fba :],K [:]);_fba +=copy (_dfe [_fba :],_ef );if _fba !=_gaad {_fe .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ec .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ffa [:_gaad *64];_bgf (K1 ,_gaad );_fbab ,_gdb :=_cgg (K [0:16]);if _gdb !=nil {return nil ,_gdb ;};_eca :=_f .NewCBCEncrypter (_fbab ,K [16:32]);_eca .CryptBlocks (K1 ,K1 );E :=K1 ;_fde :=0;for _fab :=0;_fab < 16;_fab ++{_fde +=int (E [_fab ]%3);};var _aff _c .Hash ;switch _fde %3{case 0:_aff =_egcd ;case 1:if _bgg ==nil {_bgg =_aa .New384 ();};_aff =_bgg ;case 2:if _baf ==nil {_baf =_aa .New ();};_aff =_baf ;};_aff .Reset ();_aff .Write (E );K =_aff .Sum (_ecc [:0]);return E ,nil ;};for _fgdg :=0;;{E ,_ede :=_fbe (_fgdg );if _ede !=nil {return nil ,_ede ;};_gef :=E [len (E )-1];_fgdg ++;if _fgdg >=64&&_gef <=uint8 (_fgdg -32){break ;};};return K [:32],nil ;};func (_eea stdHandlerR6 )alg9 (_fgfc *StdEncryptDict ,_ceb []byte ,_gdff []byte )error {if _cefa :=_fa ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_ceb );_cefa !=nil {return _cefa ;};if _ffgg :=_fa ("\u0061\u006c\u0067\u0039","\u0055",48,_fgfc .U );_ffgg !=nil {return _ffgg ;};var _ffe [16]byte ;if _ ,_ffc :=_e .ReadFull (_d .Reader ,_ffe [:]);_ffc !=nil {return _ffc ;};_agg :=_ffe [0:8];_acf :=_ffe [8:16];_dgde :=_fgfc .U [:48];_ccc :=make ([]byte ,len (_gdff )+len (_agg )+len (_dgde ));_bec :=copy (_ccc ,_gdff );_bec +=copy (_ccc [_bec :],_agg );_bec +=copy (_ccc [_bec :],_dgde );_cae ,_dde :=_eea .alg2b (_fgfc .R ,_ccc ,_gdff ,_dgde );if _dde !=nil {return _dde ;};O :=make ([]byte ,len (_cae )+len (_agg )+len (_acf ));_bec =copy (O ,_cae [:32]);_bec +=copy (O [_bec :],_agg );_bec +=copy (O [_bec :],_acf );_fgfc .O =O ;_bec =len (_gdff );_bec +=copy (_ccc [_bec :],_acf );_cae ,_dde =_eea .alg2b (_fgfc .R ,_ccc ,_gdff ,_dgde );if _dde !=nil {return _dde ;};_bcg ,_dde :=_cgg (_cae [:32]);if _dde !=nil {return _dde ;};_dab :=make ([]byte ,_ae .BlockSize );_ffd :=_f .NewCBCEncrypter (_bcg ,_dab );OE :=make ([]byte ,32);_ffd .CryptBlocks (OE ,_ceb [:32]);_fgfc .OE =OE ;return nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (stdHandlerR4 )paddedPass (_fg []byte )[]byte {_feg :=make ([]byte ,32);_aedf :=copy (_feg ,_fg );for ;_aedf < 32;_aedf ++{_feg [_aedf ]=_faf [_aedf -len (_fg )];};return _feg ;};

// Allowed checks if a set of permissions can be granted.
func (_dd Permissions )Allowed (p2 Permissions )bool {return _dd &p2 ==p2 };const (PermOwner =Permissions (_g .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_ab stdHandlerR4 )alg2 (_fda *StdEncryptDict ,_df []byte )[]byte {_fe .Log .Trace ("\u0061\u006c\u0067\u0032");_abd :=_ab .paddedPass (_df );_abe :=_fb .New ();_abe .Write (_abd );_abe .Write (_fda .O );var _cfd [4]byte ;_aae .LittleEndian .PutUint32 (_cfd [:],uint32 (_fda .P ));_abe .Write (_cfd [:]);_fe .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_cfd );_abe .Write ([]byte (_ab .ID0 ));_fe .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_fda .R ,_fda .EncryptMetadata );if (_fda .R >=4)&&!_fda .EncryptMetadata {_abe .Write ([]byte {0xff,0xff,0xff,0xff});};_ce :=_abe .Sum (nil );if _fda .R >=3{_abe =_fb .New ();for _dda :=0;_dda < 50;_dda ++{_abe .Reset ();_abe .Write (_ce [0:_ab .Length /8]);_ce =_abe .Sum (nil );};};if _fda .R >=3{return _ce [0:_ab .Length /8];};return _ce [0:5];};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_dag stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_adc :=make ([]byte ,32);if _ ,_abab :=_e .ReadFull (_d .Reader ,_adc );_abab !=nil {return nil ,_abab ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _adcb :=_dag .alg8 (d ,_adc ,upass );_adcb !=nil {return nil ,_adcb ;};if _cbga :=_dag .alg9 (d ,_adc ,opass );_cbga !=nil {return nil ,_cbga ;};if d .R ==5{return _adc ,nil ;};if _afdg :=_dag .alg10 (d ,_adc );_afdg !=nil {return nil ,_afdg ;};return _adc ,nil ;};func _bgf (_ggb []byte ,_fce int ){_fafb :=_fce ;for _fafb < len (_ggb ){copy (_ggb [_fafb :],_ggb [:_fafb ]);_fafb *=2;};};func (_cac stdHandlerR6 )alg2a (_edc *StdEncryptDict ,_cbe []byte )([]byte ,Permissions ,error ){if _bg :=_fa ("\u0061\u006c\u00672\u0061","\u004f",48,_edc .O );_bg !=nil {return nil ,0,_bg ;};if _eb :=_fa ("\u0061\u006c\u00672\u0061","\u0055",48,_edc .U );_eb !=nil {return nil ,0,_eb ;};if len (_cbe )> 127{_cbe =_cbe [:127];};_gg ,_bd :=_cac .alg12 (_edc ,_cbe );if _bd !=nil {return nil ,0,_bd ;};var (_dbf []byte ;_dgf []byte ;_bag []byte ;);var _bfa Permissions ;if len (_gg )!=0{_bfa =PermOwner ;_afb :=make ([]byte ,len (_cbe )+8+48);_bbd :=copy (_afb ,_cbe );_bbd +=copy (_afb [_bbd :],_edc .O [40:48]);copy (_afb [_bbd :],_edc .U [0:48]);_dbf =_afb ;_dgf =_edc .OE ;_bag =_edc .U [0:48];}else {_gg ,_bd =_cac .alg11 (_edc ,_cbe );if _bd ==nil &&len (_gg )==0{_gg ,_bd =_cac .alg11 (_edc ,[]byte (""));};if _bd !=nil {return nil ,0,_bd ;}else if len (_gg )==0{return nil ,0,nil ;};_bfa =_edc .P ;_eef :=make ([]byte ,len (_cbe )+8);_dgg :=copy (_eef ,_cbe );copy (_eef [_dgg :],_edc .U [40:48]);_dbf =_eef ;_dgf =_edc .UE ;_bag =nil ;};if _ggc :=_fa ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dgf );_ggc !=nil {return nil ,0,_ggc ;};_dgf =_dgf [:32];_cfc ,_bd :=_cac .alg2b (_edc .R ,_dbf ,_cbe ,_bag );if _bd !=nil {return nil ,0,_bd ;};_eed ,_bd :=_ae .NewCipher (_cfc [:32]);if _bd !=nil {return nil ,0,_bd ;};_bgb :=make ([]byte ,_ae .BlockSize );_cgfe :=_f .NewCBCDecrypter (_eed ,_bgb );_afc :=make ([]byte ,32);_cgfe .CryptBlocks (_afc ,_dgf );if _edc .R ==5{return _afc ,_bfa ,nil ;};_bd =_cac .alg13 (_edc ,_afc );if _bd !=nil {return nil ,0,_bd ;};return _afc ,_bfa ,nil ;};const _faf ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_b *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_b ._dg !=0{_fe .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_fe .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_b ._gf .Decrypt (dst ,src [:_b ._dg ]);src =src [_b ._dg :];dst =dst [_b ._dg :];};};func (_afcb stdHandlerR6 )alg11 (_baag *StdEncryptDict ,_gad []byte )([]byte ,error ){if _baad :=_fa ("\u0061\u006c\u00671\u0031","\u0055",48,_baag .U );_baad !=nil {return nil ,_baad ;};_dee :=make ([]byte ,len (_gad )+8);_fgfcb :=copy (_dee ,_gad );_fgfcb +=copy (_dee [_fgfcb :],_baag .U [32:40]);_aba ,_aebe :=_afcb .alg2b (_baag .R ,_dee ,_gad ,nil );if _aebe !=nil {return nil ,_aebe ;};_aba =_aba [:32];if !_aad .Equal (_aba ,_baag .U [:32]){return nil ,nil ;};return _aba ,nil ;};func _db (_ca _f .Block )_f .BlockMode {return (*ecbEncrypter )(_eg (_ca ))};

// Authenticate implements StdHandler interface.
func (_ebf stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _ebf .alg2a (d ,pass );};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func _fa (_ea ,_gff string ,_cc int ,_ga []byte )error {if len (_ga )< _cc {return errInvalidField {Func :_ea ,Field :_gff ,Exp :_cc ,Got :len (_ga )};};return nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_aed *ecbEncrypter )BlockSize ()int {return _aed ._dg };

// Authenticate implements StdHandler interface.
func (_fgf stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fe .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_gbb ,_bbe :=_fgf .alg7 (d ,pass );if _bbe !=nil {return nil ,0,_bbe ;};if _gbb !=nil {_fe .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gbb ,PermOwner ,nil ;};_fe .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gbb ,_bbe =_fgf .alg6 (d ,pass );if _bbe !=nil {return nil ,0,_bbe ;};if _gbb !=nil {_fe .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gbb ,d .P ,nil ;};return nil ,0,nil ;};func _bga (_bca []byte )([]byte ,error ){_acgf :=_fc .New ();_acgf .Write (_bca );return _acgf .Sum (nil ),nil ;};func (_abf stdHandlerR4 )alg7 (_cgf *StdEncryptDict ,_fcg []byte )([]byte ,error ){_fdc :=_abf .alg3Key (_cgf .R ,_fcg );_gaa :=make ([]byte ,len (_cgf .O ));if _cgf .R ==2{_aaaf ,_cdfd :=_aag .NewCipher (_fdc );if _cdfd !=nil {return nil ,_ec .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_aaaf .XORKeyStream (_gaa ,_cgf .O );}else if _cgf .R >=3{_dea :=append ([]byte {},_cgf .O ...);for _faaeg :=0;_faaeg < 20;_faaeg ++{_fdaeg :=append ([]byte {},_fdc ...);for _fee :=0;_fee < len (_fdc );_fee ++{_fdaeg [_fee ]^=byte (19-_faaeg );};_eec ,_bb :=_aag .NewCipher (_fdaeg );if _bb !=nil {return nil ,_ec .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_eec .XORKeyStream (_gaa ,_dea );_dea =append ([]byte {},_gaa ...);};}else {return nil ,_ec .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_cbf ,_ddf :=_abf .alg6 (_cgf ,_gaa );if _ddf !=nil {return nil ,nil ;};return _cbf ,nil ;};func (_ggg stdHandlerR6 )alg8 (_efe *StdEncryptDict ,_cgd []byte ,_abb []byte )error {if _ade :=_fa ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_cgd );_ade !=nil {return _ade ;};var _accc [16]byte ;if _ ,_edf :=_e .ReadFull (_d .Reader ,_accc [:]);_edf !=nil {return _edf ;};_dgb :=_accc [0:8];_dgc :=_accc [8:16];_edfb :=make ([]byte ,len (_abb )+len (_dgb ));_bcc :=copy (_edfb ,_abb );copy (_edfb [_bcc :],_dgb );_gcf ,_gdc :=_ggg .alg2b (_efe .R ,_edfb ,_abb ,nil );if _gdc !=nil {return _gdc ;};U :=make ([]byte ,len (_gcf )+len (_dgb )+len (_dgc ));_bcc =copy (U ,_gcf [:32]);_bcc +=copy (U [_bcc :],_dgb );copy (U [_bcc :],_dgc );_efe .U =U ;_bcc =len (_abb );copy (_edfb [_bcc :],_dgc );_gcf ,_gdc =_ggg .alg2b (_efe .R ,_edfb ,_abb ,nil );if _gdc !=nil {return _gdc ;};_afe ,_gdc :=_cgg (_gcf [:32]);if _gdc !=nil {return _gdc ;};_abg :=make ([]byte ,_ae .BlockSize );_ag :=_f .NewCBCEncrypter (_afe ,_abg );UE :=make ([]byte ,32);_ag .CryptBlocks (UE ,_cgd [:32]);_efe .UE =UE ;return nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type ecbDecrypter ecb ;func (_ed stdHandlerR4 )alg5 (_gcb []byte ,_egc []byte )([]byte ,error ){_ddae :=_fb .New ();_ddae .Write ([]byte (_faf ));_ddae .Write ([]byte (_ed .ID0 ));_dcf :=_ddae .Sum (nil );_fe .Log .Trace ("\u0061\u006c\u0067\u0035");_fe .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gcb );_fe .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ed .ID0 );if len (_dcf )!=16{return nil ,_ec .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_ffg ,_cdd :=_aag .NewCipher (_gcb );if _cdd !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ccda :=make ([]byte ,16);_ffg .XORKeyStream (_ccda ,_dcf );_gfe :=make ([]byte ,len (_gcb ));for _eag :=0;_eag < 19;_eag ++{for _bf :=0;_bf < len (_gcb );_bf ++{_gfe [_bf ]=_gcb [_bf ]^byte (_eag +1);};_ffg ,_cdd =_aag .NewCipher (_gfe );if _cdd !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ffg .XORKeyStream (_ccda ,_ccda );_fe .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_eag ,_gfe );_fe .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_eag ,_ccda );};_cg :=make ([]byte ,32);for _bea :=0;_bea < 16;_bea ++{_cg [_bea ]=_ccda [_bea ];};_ ,_cdd =_d .Read (_cg [16:32]);if _cdd !=nil {return nil ,_ec .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _cg ,nil ;};