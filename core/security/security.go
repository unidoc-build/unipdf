//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_fa "bytes";_a "crypto/aes";_g "crypto/cipher";_fg "crypto/md5";_cf "crypto/rand";_gd "crypto/rc4";_df "crypto/sha256";_d "crypto/sha512";_dfc "encoding/binary";_ad "errors";_eg "fmt";_aa "github.com/unidoc/unipdf/v3/common";_c "hash";_e "io";_fgf "math";);func (_fgfg stdHandlerR4 )alg3 (R int ,_adb ,_ff []byte )([]byte ,error ){var _ab []byte ;if len (_ff )> 0{_ab =_fgfg .alg3Key (R ,_ff );}else {_ab =_fgfg .alg3Key (R ,_adb );};_feg ,_bd :=_gd .NewCipher (_ab );if _bd !=nil {return nil ,_ad .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bdc :=_fgfg .paddedPass (_adb );_fd :=make ([]byte ,len (_bdc ));_feg .XORKeyStream (_fd ,_bdc );if R >=3{_caac :=make ([]byte ,len (_ab ));for _fgc :=0;_fgc < 19;_fgc ++{for _fb :=0;_fb < len (_ab );_fb ++{_caac [_fb ]=_ab [_fb ]^byte (_fgc +1);};_bb ,_gbc :=_gd .NewCipher (_caac );if _gbc !=nil {return nil ,_ad .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bb .XORKeyStream (_fd ,_fd );};};return _fd ,nil ;};func (_fba stdHandlerR4 )alg7 (_be *StdEncryptDict ,_dec []byte )([]byte ,error ){_ebb :=_fba .alg3Key (_be .R ,_dec );_ggd :=make ([]byte ,len (_be .O ));if _be .R ==2{_ffa ,_fcc :=_gd .NewCipher (_ebb );if _fcc !=nil {return nil ,_ad .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ffa .XORKeyStream (_ggd ,_be .O );}else if _be .R >=3{_aedc :=append ([]byte {},_be .O ...);for _cbf :=0;_cbf < 20;_cbf ++{_eeg :=append ([]byte {},_ebb ...);for _deg :=0;_deg < len (_ebb );_deg ++{_eeg [_deg ]^=byte (19-_cbf );};_bga ,_bfe :=_gd .NewCipher (_eeg );if _bfe !=nil {return nil ,_ad .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_bga .XORKeyStream (_ggd ,_aedc );_aedc =append ([]byte {},_ggd ...);};}else {return nil ,_ad .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_dff ,_ag :=_fba .alg6 (_be ,_ggd );if _ag !=nil {return nil ,nil ;};return _dff ,nil ;};type ecb struct{_ed _g .Block ;_ac int ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_aac *StdEncryptDict ,_fe ,_cb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_de *StdEncryptDict ,_af []byte )([]byte ,Permissions ,error );};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};var _ StdHandler =stdHandlerR4 {};func (_ee stdHandlerR4 )alg2 (_ece *StdEncryptDict ,_aec []byte )[]byte {_aa .Log .Trace ("\u0061\u006c\u0067\u0032");_ge :=_ee .paddedPass (_aec );_ecf :=_fg .New ();_ecf .Write (_ge );_ecf .Write (_ece .O );var _cad [4]byte ;_dfc .LittleEndian .PutUint32 (_cad [:],uint32 (_ece .P ));_ecf .Write (_cad [:]);_aa .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_cad );_ecf .Write ([]byte (_ee .ID0 ));_aa .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ece .R ,_ece .EncryptMetadata );if (_ece .R >=4)&&!_ece .EncryptMetadata {_ecf .Write ([]byte {0xff,0xff,0xff,0xff});};_aab :=_ecf .Sum (nil );if _ece .R >=3{_ecf =_fg .New ();for _da :=0;_da < 50;_da ++{_ecf .Reset ();_ecf .Write (_aab [0:_ee .Length /8]);_aab =_ecf .Sum (nil );};};if _ece .R >=3{return _aab [0:_ee .Length /8];};return _aab [0:5];};var _ StdHandler =stdHandlerR6 {};

// Authenticate implements StdHandler interface.
func (_eefg stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _eefg .alg2a (d ,pass );};func _dea (_cfc []byte )(_g .Block ,error ){_aaa ,_cge :=_a .NewCipher (_cfc );if _cge !=nil {_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_cge );return nil ,_cge ;};return _aaa ,nil ;};func _dd (_ef _g .Block )_g .BlockMode {return (*ecbEncrypter )(_ea (_ef ))};type ecbDecrypter ecb ;func (_ggb *ecbDecrypter )BlockSize ()int {return _ggb ._ac };

// Allowed checks if a set of permissions can be granted.
func (_ead Permissions )Allowed (p2 Permissions )bool {return _ead &p2 ==p2 };func (_gcd stdHandlerR6 )alg13 (_egcg *StdEncryptDict ,_ddcb []byte )error {if _gff :=_edb ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_ddcb );_gff !=nil {return _gff ;};if _cdb :=_edb ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_egcg .Perms );_cdb !=nil {return _cdb ;};_db :=make ([]byte ,16);copy (_db ,_egcg .Perms [:16]);_gggd ,_adeg :=_a .NewCipher (_ddcb [:32]);if _adeg !=nil {return _adeg ;};_cea :=_ca (_gggd );_cea .CryptBlocks (_db ,_db );if !_fa .Equal (_db [9:12],[]byte ("\u0061\u0064\u0062")){return _ad .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bdee :=Permissions (_dfc .LittleEndian .Uint32 (_db [0:4]));if _bdee !=_egcg .P {return _ad .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};var _dgfd bool ;if _db [8]=='T'{_dgfd =true ;}else if _db [8]=='F'{_dgfd =false ;}else {return _ad .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _dgfd !=_egcg .EncryptMetadata {return _ad .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};func (_cab stdHandlerR4 )alg6 (_daaa *StdEncryptDict ,_ebcf []byte )([]byte ,error ){var (_fee []byte ;_gbcc error ;);_fgfga :=_cab .alg2 (_daaa ,_ebcf );if _daaa .R ==2{_fee ,_gbcc =_cab .alg4 (_fgfga ,_ebcf );}else if _daaa .R >=3{_fee ,_gbcc =_cab .alg5 (_fgfga ,_ebcf );}else {return nil ,_ad .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _gbcc !=nil {return nil ,_gbcc ;};_aa .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_fee ),string (_daaa .U ));_dgf :=_fee ;_adf :=_daaa .U ;if _daaa .R >=3{if len (_dgf )> 16{_dgf =_dgf [0:16];};if len (_adf )> 16{_adf =_adf [0:16];};};if !_fa .Equal (_dgf ,_adf ){return nil ,nil ;};return _fgfga ,nil ;};type ecbEncrypter ecb ;

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func _edb (_gb ,_egd string ,_ec int ,_cg []byte )error {if len (_cg )< _ec {return errInvalidField {Func :_gb ,Field :_egd ,Exp :_ec ,Got :len (_cg )};};return nil ;};const (PermOwner =Permissions (_fgf .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););const _caa ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";type stdHandlerR6 struct{};func _dffc (_ged []byte ,_eca int ){_bge :=_eca ;for _bge < len (_ged ){copy (_ged [_bge :],_ged [:_bge ]);_bge *=2;};};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func _ca (_ce _g .Block )_g .BlockMode {return (*ecbDecrypter )(_ea (_ce ))};func (_add *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_add ._ac !=0{_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_aa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_add ._ed .Decrypt (dst ,src [:_add ._ac ]);src =src [_add ._ac :];dst =dst [_add ._ac :];};};func (_bdd stdHandlerR4 )alg5 (_gbd []byte ,_fbb []byte )([]byte ,error ){_gc :=_fg .New ();_gc .Write ([]byte (_caa ));_gc .Write ([]byte (_bdd .ID0 ));_gce :=_gc .Sum (nil );_aa .Log .Trace ("\u0061\u006c\u0067\u0035");_aa .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gbd );_aa .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bdd .ID0 );if len (_gce )!=16{return nil ,_ad .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_bddc ,_daa :=_gd .NewCipher (_gbd );if _daa !=nil {return nil ,_ad .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ffe :=make ([]byte ,16);_bddc .XORKeyStream (_ffe ,_gce );_aba :=make ([]byte ,len (_gbd ));for _aed :=0;_aed < 19;_aed ++{for _fff :=0;_fff < len (_gbd );_fff ++{_aba [_fff ]=_gbd [_fff ]^byte (_aed +1);};_bddc ,_daa =_gd .NewCipher (_aba );if _daa !=nil {return nil ,_ad .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bddc .XORKeyStream (_ffe ,_ffe );_aa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_aed ,_aba );_aa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_aed ,_ffe );};_dcf :=make ([]byte ,32);for _fdb :=0;_fdb < 16;_fdb ++{_dcf [_fdb ]=_ffe [_fdb ];};_ ,_daa =_cf .Read (_dcf [16:32]);if _daa !=nil {return nil ,_ad .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _dcf ,nil ;};func (_ecg stdHandlerR4 )alg3Key (R int ,_ede []byte )[]byte {_fge :=_fg .New ();_bc :=_ecg .paddedPass (_ede );_fge .Write (_bc );if R >=3{for _eb :=0;_eb < 50;_eb ++{_cd :=_fge .Sum (nil );_fge =_fg .New ();_fge .Write (_cd );};};_gbf :=_fge .Sum (nil );if R ==2{_gbf =_gbf [0:5];}else {_gbf =_gbf [0:_ecg .Length /8];};return _gbf ;};func (_cac stdHandlerR4 )alg4 (_ebc []byte ,_egb []byte )([]byte ,error ){_gda ,_cgd :=_gd .NewCipher (_ebc );if _cgd !=nil {return nil ,_ad .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_aag :=[]byte (_caa );_ade :=make ([]byte ,len (_aag ));_gda .XORKeyStream (_ade ,_aag );return _ade ,nil ;};func (_cgg stdHandlerR6 )alg2a (_ggg *StdEncryptDict ,_bed []byte )([]byte ,Permissions ,error ){if _gbfc :=_edb ("\u0061\u006c\u00672\u0061","\u004f",48,_ggg .O );_gbfc !=nil {return nil ,0,_gbfc ;};if _fbda :=_edb ("\u0061\u006c\u00672\u0061","\u0055",48,_ggg .U );_fbda !=nil {return nil ,0,_fbda ;};if len (_bed )> 127{_bed =_bed [:127];};_efd ,_gbb :=_cgg .alg12 (_ggg ,_bed );if _gbb !=nil {return nil ,0,_gbb ;};var (_efdb []byte ;_daf []byte ;_fae []byte ;);var _bbc Permissions ;if len (_efd )!=0{_bbc =PermOwner ;_eeb :=make ([]byte ,len (_bed )+8+48);_fag :=copy (_eeb ,_bed );_fag +=copy (_eeb [_fag :],_ggg .O [40:48]);copy (_eeb [_fag :],_ggg .U [0:48]);_efdb =_eeb ;_daf =_ggg .OE ;_fae =_ggg .U [0:48];}else {_efd ,_gbb =_cgg .alg11 (_ggg ,_bed );if _gbb ==nil &&len (_efd )==0{_efd ,_gbb =_cgg .alg11 (_ggg ,[]byte (""));};if _gbb !=nil {return nil ,0,_gbb ;}else if len (_efd )==0{return nil ,0,nil ;};_bbc =_ggg .P ;_abd :=make ([]byte ,len (_bed )+8);_cdd :=copy (_abd ,_bed );copy (_abd [_cdd :],_ggg .U [40:48]);_efdb =_abd ;_daf =_ggg .UE ;_fae =nil ;};if _ga :=_edb ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_daf );_ga !=nil {return nil ,0,_ga ;};_daf =_daf [:32];_gea ,_gbb :=_cgg .alg2b (_ggg .R ,_efdb ,_bed ,_fae );if _gbb !=nil {return nil ,0,_gbb ;};_aeda ,_gbb :=_a .NewCipher (_gea [:32]);if _gbb !=nil {return nil ,0,_gbb ;};_dffg :=make ([]byte ,_a .BlockSize );_ddg :=_g .NewCBCDecrypter (_aeda ,_dffg );_aedb :=make ([]byte ,32);_ddg .CryptBlocks (_aedb ,_daf );if _ggg .R ==5{return _aedb ,_bbc ,nil ;};_gbb =_cgg .alg13 (_ggg ,_aedb );if _gbb !=nil {return nil ,0,_gbb ;};return _aedb ,_bbc ,nil ;};func (_gbg stdHandlerR6 )alg9 (_ffaf *StdEncryptDict ,_ccb []byte ,_ecgf []byte )error {if _bedg :=_edb ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_ccb );_bedg !=nil {return _bedg ;};if _egbf :=_edb ("\u0061\u006c\u0067\u0039","\u0055",48,_ffaf .U );_egbf !=nil {return _egbf ;};var _abf [16]byte ;if _ ,_aaf :=_e .ReadFull (_cf .Reader ,_abf [:]);_aaf !=nil {return _aaf ;};_bfg :=_abf [0:8];_eac :=_abf [8:16];_ggc :=_ffaf .U [:48];_dee :=make ([]byte ,len (_ecgf )+len (_bfg )+len (_ggc ));_dcc :=copy (_dee ,_ecgf );_dcc +=copy (_dee [_dcc :],_bfg );_dcc +=copy (_dee [_dcc :],_ggc );_dfd ,_gad :=_gbg .alg2b (_ffaf .R ,_dee ,_ecgf ,_ggc );if _gad !=nil {return _gad ;};O :=make ([]byte ,len (_dfd )+len (_bfg )+len (_eac ));_dcc =copy (O ,_dfd [:32]);_dcc +=copy (O [_dcc :],_bfg );_dcc +=copy (O [_dcc :],_eac );_ffaf .O =O ;_dcc =len (_ecgf );_dcc +=copy (_dee [_dcc :],_eac );_dfd ,_gad =_gbg .alg2b (_ffaf .R ,_dee ,_ecgf ,_ggc );if _gad !=nil {return _gad ;};_fgbd ,_gad :=_dea (_dfd [:32]);if _gad !=nil {return _gad ;};_egbfb :=make ([]byte ,_a .BlockSize );_fbe :=_g .NewCBCEncrypter (_fgbd ,_egbfb );OE :=make ([]byte ,32);_fbe .CryptBlocks (OE ,_ccb [:32]);_ffaf .OE =OE ;return nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_eea stdHandlerR6 )alg12 (_fcdd *StdEncryptDict ,_daba []byte )([]byte ,error ){if _ccg :=_edb ("\u0061\u006c\u00671\u0032","\u0055",48,_fcdd .U );_ccg !=nil {return nil ,_ccg ;};if _afd :=_edb ("\u0061\u006c\u00671\u0032","\u004f",48,_fcdd .O );_afd !=nil {return nil ,_afd ;};_fgg :=make ([]byte ,len (_daba )+8+48);_fcg :=copy (_fgg ,_daba );_fcg +=copy (_fgg [_fcg :],_fcdd .O [32:40]);_fcg +=copy (_fgg [_fcg :],_fcdd .U [0:48]);_aecc ,_bdg :=_eea .alg2b (_fcdd .R ,_fgg ,_daba ,_fcdd .U [0:48]);if _bdg !=nil {return nil ,_bdg ;};_aecc =_aecc [:32];if !_fa .Equal (_aecc ,_fcdd .O [:32]){return nil ,nil ;};return _aecc ,nil ;};func (_bg errInvalidField )Error ()string {return _eg .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_bg .Func ,_bg .Field ,_bg .Exp ,_bg .Got );};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (stdHandlerR4 )paddedPass (_ae []byte )[]byte {_dg :=make ([]byte ,32);_bf :=copy (_dg ,_ae );for ;_bf < 32;_bf ++{_dg [_bf ]=_caa [_bf -len (_ae )];};return _dg ;};func (_ffg stdHandlerR6 )alg8 (_ddgf *StdEncryptDict ,_fagg []byte ,_fcd []byte )error {if _ebgd :=_edb ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_fagg );_ebgd !=nil {return _ebgd ;};var _bcf [16]byte ;if _ ,_bae :=_e .ReadFull (_cf .Reader ,_bcf [:]);_bae !=nil {return _bae ;};_egc :=_bcf [0:8];_egce :=_bcf [8:16];_gdb :=make ([]byte ,len (_fcd )+len (_egc ));_afc :=copy (_gdb ,_fcd );copy (_gdb [_afc :],_egc );_ccf ,_gcc :=_ffg .alg2b (_ddgf .R ,_gdb ,_fcd ,nil );if _gcc !=nil {return _gcc ;};U :=make ([]byte ,len (_ccf )+len (_egc )+len (_egce ));_afc =copy (U ,_ccf [:32]);_afc +=copy (U [_afc :],_egc );copy (U [_afc :],_egce );_ddgf .U =U ;_afc =len (_fcd );copy (_gdb [_afc :],_egce );_ccf ,_gcc =_ffg .alg2b (_ddgf .R ,_gdb ,_fcd ,nil );if _gcc !=nil {return _gcc ;};_dab ,_gcc :=_dea (_ccf [:32]);if _gcc !=nil {return _gcc ;};_gac :=make ([]byte ,_a .BlockSize );_bde :=_g .NewCBCEncrypter (_dab ,_gac );UE :=make ([]byte ,32);_bde .CryptBlocks (UE ,_fagg [:32]);_ddgf .UE =UE ;return nil ;};func _gga (_bcd []byte )([]byte ,error ){_gde :=_df .New ();_gde .Write (_bcd );return _gde .Sum (nil ),nil ;};func (_acg stdHandlerR6 )alg2b (R int ,_egdc ,_faf ,_cfg []byte )([]byte ,error ){if R ==5{return _gga (_egdc );};return _agc (_egdc ,_faf ,_cfg );};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _agc (_ddc ,_cc ,_cdf []byte )([]byte ,error ){var (_adff ,_ebg ,_ege _c .Hash ;);_adff =_df .New ();_aea :=make ([]byte ,64);_cde :=_adff ;_cde .Write (_ddc );K :=_cde .Sum (_aea [:0]);_eag :=make ([]byte ,64*(127+64+48));_aee :=func (_bgeg int )([]byte ,error ){_cade :=len (_cc )+len (K )+len (_cdf );_ddgg :=_eag [:_cade ];_aad :=copy (_ddgg ,_cc );_aad +=copy (_ddgg [_aad :],K [:]);_aad +=copy (_ddgg [_aad :],_cdf );if _aad !=_cade {_aa .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ad .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_eag [:_cade *64];_dffc (K1 ,_cade );_gggc ,_ddf :=_dea (K [0:16]);if _ddf !=nil {return nil ,_ddf ;};_gaf :=_g .NewCBCEncrypter (_gggc ,K [16:32]);_gaf .CryptBlocks (K1 ,K1 );E :=K1 ;_caag :=0;for _dfce :=0;_dfce < 16;_dfce ++{_caag +=int (E [_dfce ]%3);};var _cae _c .Hash ;switch _caag %3{case 0:_cae =_adff ;case 1:if _ebg ==nil {_ebg =_d .New384 ();};_cae =_ebg ;case 2:if _ege ==nil {_ege =_d .New ();};_cae =_ege ;};_cae .Reset ();_cae .Write (E );K =_cae .Sum (_aea [:0]);return E ,nil ;};for _ba :=0;;{E ,_dfe :=_aee (_ba );if _dfe !=nil {return nil ,_dfe ;};_dae :=E [len (E )-1];_ba ++;if _ba >=64&&_dae <=uint8 (_ba -32){break ;};};return K [:32],nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fbd stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_bff :=_fbd .alg3 (d .R ,upass ,opass );if _bff !=nil {_aa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bff );return nil ,_bff ;};d .O =O ;_aa .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_caace :=_fbd .alg2 (d ,upass );U ,_bff :=_fbd .alg5 (_caace ,upass );if _bff !=nil {_aa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bff );return nil ,_bff ;};d .U =U ;_aa .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _caace ,nil ;};func (_cgef stdHandlerR6 )alg10 (_eba *StdEncryptDict ,_dgc []byte )error {if _ebcfg :=_edb ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_dgc );_ebcfg !=nil {return _ebcfg ;};_aeb :=uint64 (uint32 (_eba .P ))|(_fgf .MaxUint32 <<32);Perms :=make ([]byte ,16);_dfc .LittleEndian .PutUint64 (Perms [:8],_aeb );if _eba .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_fcb :=_e .ReadFull (_cf .Reader ,Perms [12:16]);_fcb !=nil {return _fcb ;};_ffd ,_cacc :=_dea (_dgc [:32]);if _cacc !=nil {return _cacc ;};_bfd :=_dd (_ffd );_bfd .CryptBlocks (Perms ,Perms );_eba .Perms =Perms [:16];return nil ;};func (_gg *ecbEncrypter )BlockSize ()int {return _gg ._ac };func (_eef stdHandlerR6 )alg11 (_fbbc *StdEncryptDict ,_cba []byte )([]byte ,error ){if _bfc :=_edb ("\u0061\u006c\u00671\u0031","\u0055",48,_fbbc .U );_bfc !=nil {return nil ,_bfc ;};_ced :=make ([]byte ,len (_cba )+8);_fec :=copy (_ced ,_cba );_fec +=copy (_ced [_fec :],_fbbc .U [32:40]);_fdf ,_dcb :=_eef .alg2b (_fbbc .R ,_ced ,_cba ,nil );if _dcb !=nil {return nil ,_dcb ;};_fdf =_fdf [:32];if !_fa .Equal (_fdf ,_fbbc .U [:32]){return nil ,nil ;};return _fdf ,nil ;};func _ea (_b _g .Block )*ecb {return &ecb {_ed :_b ,_ac :_b .BlockSize ()}};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_dc *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dc ._ac !=0{_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_aa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_dc ._ed .Encrypt (dst ,src [:_dc ._ac ]);src =src [_dc ._ac :];dst =dst [_dc ._ac :];};};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_bce stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_gbgc :=make ([]byte ,32);if _ ,_fbc :=_e .ReadFull (_cf .Reader ,_gbgc );_fbc !=nil {return nil ,_fbc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cacd :=_bce .alg8 (d ,_gbgc ,upass );_cacd !=nil {return nil ,_cacd ;};if _caaf :=_bce .alg9 (d ,_gbgc ,opass );_caaf !=nil {return nil ,_caaf ;};if d .R ==5{return _gbgc ,nil ;};if _gadd :=_bce .alg10 (d ,_gbgc );_gadd !=nil {return nil ,_gadd ;};return _gbgc ,nil ;};

// Authenticate implements StdHandler interface.
func (_ebca stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_aa .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_fgb ,_bcg :=_ebca .alg7 (d ,pass );if _bcg !=nil {return nil ,0,_bcg ;};if _fgb !=nil {_aa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fgb ,PermOwner ,nil ;};_aa .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_fgb ,_bcg =_ebca .alg6 (d ,pass );if _bcg !=nil {return nil ,0,_bcg ;};if _fgb !=nil {_aa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fgb ,d .P ,nil ;};return nil ,0,nil ;};