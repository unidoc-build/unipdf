//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_db "bytes";_ga "crypto/aes";_b "crypto/cipher";_ee "crypto/md5";_cg "crypto/rand";_dc "crypto/rc4";_d "crypto/sha256";_c "crypto/sha512";_gf "encoding/binary";_gd "errors";_f "fmt";_gb "github.com/unidoc/unipdf/v3/common";_a "hash";_e "io";_cb "math";);func (_acgc stdHandlerR6 )alg9 (_bff *StdEncryptDict ,_gafga []byte ,_bdgb []byte )error {if _acb :=_cfb ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gafga );_acb !=nil {return _acb ;};if _fgga :=_cfb ("\u0061\u006c\u0067\u0039","\u0055",48,_bff .U );_fgga !=nil {return _fgga ;};var _cdfc [16]byte ;if _ ,_fedd :=_e .ReadFull (_cg .Reader ,_cdfc [:]);_fedd !=nil {return _fedd ;};_cga :=_cdfc [0:8];_agda :=_cdfc [8:16];_cgf :=_bff .U [:48];_efa :=make ([]byte ,len (_bdgb )+len (_cga )+len (_cgf ));_dgca :=copy (_efa ,_bdgb );_dgca +=copy (_efa [_dgca :],_cga );_dgca +=copy (_efa [_dgca :],_cgf );_bca ,_adc :=_acgc .alg2b (_bff .R ,_efa ,_bdgb ,_cgf );if _adc !=nil {return _adc ;};O :=make ([]byte ,len (_bca )+len (_cga )+len (_agda ));_dgca =copy (O ,_bca [:32]);_dgca +=copy (O [_dgca :],_cga );_dgca +=copy (O [_dgca :],_agda );_bff .O =O ;_dgca =len (_bdgb );_dgca +=copy (_efa [_dgca :],_agda );_bca ,_adc =_acgc .alg2b (_bff .R ,_efa ,_bdgb ,_cgf );if _adc !=nil {return _adc ;};_dfb ,_adc :=_bgf (_bca [:32]);if _adc !=nil {return _adc ;};_fad :=make ([]byte ,_ga .BlockSize );_acfa :=_b .NewCBCEncrypter (_dfb ,_fad );OE :=make ([]byte ,32);_acfa .CryptBlocks (OE ,_gafga [:32]);_bff .OE =OE ;return nil ;};var _ StdHandler =stdHandlerR4 {};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_cbg stdHandlerR4 )alg6 (_afg *StdEncryptDict ,_dde []byte )([]byte ,error ){var (_cbec []byte ;_gdb error ;);_gfg :=_cbg .alg2 (_afg ,_dde );if _afg .R ==2{_cbec ,_gdb =_cbg .alg4 (_gfg ,_dde );}else if _afg .R >=3{_cbec ,_gdb =_cbg .alg5 (_gfg ,_dde );}else {return nil ,_gd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _gdb !=nil {return nil ,_gdb ;};_gb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_cbec ),string (_afg .U ));_gdf :=_cbec ;_gea :=_afg .U ;if _afg .R >=3{if len (_gdf )> 16{_gdf =_gdf [0:16];};if len (_gea )> 16{_gea =_gea [0:16];};};if !_db .Equal (_gdf ,_gea ){return nil ,nil ;};return _gfg ,nil ;};func (_aab stdHandlerR6 )alg11 (_aabg *StdEncryptDict ,_cfdg []byte )([]byte ,error ){if _ddaa :=_cfb ("\u0061\u006c\u00671\u0031","\u0055",48,_aabg .U );_ddaa !=nil {return nil ,_ddaa ;};_efg :=make ([]byte ,len (_cfdg )+8);_acdb :=copy (_efg ,_cfdg );_acdb +=copy (_efg [_acdb :],_aabg .U [32:40]);_cba ,_acdad :=_aab .alg2b (_aabg .R ,_efg ,_cfdg ,nil );if _acdad !=nil {return nil ,_acdad ;};_cba =_cba [:32];if !_db .Equal (_cba ,_aabg .U [:32]){return nil ,nil ;};return _cba ,nil ;};func _gab (_ceb []byte )([]byte ,error ){_ggeg :=_d .New ();_ggeg .Write (_ceb );return _ggeg .Sum (nil ),nil ;};

// Authenticate implements StdHandler interface.
func (_ddee stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _ddee .alg2a (d ,pass );};func (_dfbf stdHandlerR6 )alg13 (_dfff *StdEncryptDict ,_edbg []byte )error {if _dfbc :=_cfb ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_edbg );_dfbc !=nil {return _dfbc ;};if _gcd :=_cfb ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_dfff .Perms );_gcd !=nil {return _gcd ;};_eggb :=make ([]byte ,16);copy (_eggb ,_dfff .Perms [:16]);_bec ,_dfea :=_ga .NewCipher (_edbg [:32]);if _dfea !=nil {return _dfea ;};_afc :=_afe (_bec );_afc .CryptBlocks (_eggb ,_eggb );if !_db .Equal (_eggb [9:12],[]byte ("\u0061\u0064\u0062")){return _gd .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bae :=Permissions (_gf .LittleEndian .Uint32 (_eggb [0:4]));if _bae !=_dfff .P {return _gd .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};var _agfa bool ;if _eggb [8]=='T'{_agfa =true ;}else if _eggb [8]=='F'{_agfa =false ;}else {return _gd .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _agfa !=_dfff .EncryptMetadata {return _gd .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;type ecbEncrypter ecb ;func (_agd stdHandlerR4 )alg5 (_bga []byte ,_ebe []byte )([]byte ,error ){_feg :=_ee .New ();_feg .Write ([]byte (_dd ));_feg .Write ([]byte (_agd .ID0 ));_dff :=_feg .Sum (nil );_gb .Log .Trace ("\u0061\u006c\u0067\u0035");_gb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_bga );_gb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_agd .ID0 );if len (_dff )!=16{return nil ,_gd .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_cca ,_dea :=_dc .NewCipher (_bga );if _dea !=nil {return nil ,_gd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cbef :=make ([]byte ,16);_cca .XORKeyStream (_cbef ,_dff );_acf :=make ([]byte ,len (_bga ));for _ggg :=0;_ggg < 19;_ggg ++{for _gad :=0;_gad < len (_bga );_gad ++{_acf [_gad ]=_bga [_gad ]^byte (_ggg +1);};_cca ,_dea =_dc .NewCipher (_acf );if _dea !=nil {return nil ,_gd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cca .XORKeyStream (_cbef ,_cbef );_gb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ggg ,_acf );_gb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ggg ,_cbef );};_eda :=make ([]byte ,32);for _cab :=0;_cab < 16;_cab ++{_eda [_cab ]=_cbef [_cab ];};_ ,_dea =_cg .Read (_eda [16:32]);if _dea !=nil {return nil ,_gd .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _eda ,nil ;};const _dd ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_af *ecbEncrypter )BlockSize ()int {return _af ._de };

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_ebg stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_gef :=_ebg .alg3 (d .R ,upass ,opass );if _gef !=nil {_gb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gef );return nil ,_gef ;};d .O =O ;_gb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_cag :=_ebg .alg2 (d ,upass );U ,_gef :=_ebg .alg5 (_cag ,upass );if _gef !=nil {_gb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gef );return nil ,_gef ;};d .U =U ;_gb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _cag ,nil ;};const (PermOwner =Permissions (_cb .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func _dgc (_fdf []byte ,_ccf int ){_cef :=_ccf ;for _cef < len (_fdf ){copy (_fdf [_cef :],_fdf [:_cef ]);_cef *=2;};};func (_ed *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ed ._de !=0{_gb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_gb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ed ._cc .Decrypt (dst ,src [:_ed ._de ]);src =src [_ed ._de :];dst =dst [_ed ._de :];};};func (_dga stdHandlerR4 )alg4 (_dbb []byte ,_ge []byte )([]byte ,error ){_eg ,_gaf :=_dc .NewCipher (_dbb );if _gaf !=nil {return nil ,_gd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ccg :=[]byte (_dd );_edb :=make ([]byte ,len (_ccg ));_eg .XORKeyStream (_edb ,_ccg );return _edb ,nil ;};func (_gg stdHandlerR4 )alg3 (R int ,_caa ,_bba []byte )([]byte ,error ){var _fbd []byte ;if len (_bba )> 0{_fbd =_gg .alg3Key (R ,_bba );}else {_fbd =_gg .alg3Key (R ,_caa );};_agf ,_ac :=_dc .NewCipher (_fbd );if _ac !=nil {return nil ,_gd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_aff :=_gg .paddedPass (_caa );_agg :=make ([]byte ,len (_aff ));_agf .XORKeyStream (_agg ,_aff );if R >=3{_bbb :=make ([]byte ,len (_fbd ));for _aggb :=0;_aggb < 19;_aggb ++{for _bac :=0;_bac < len (_fbd );_bac ++{_bbb [_bac ]=_fbd [_bac ]^byte (_aggb +1);};_adb ,_fc :=_dc .NewCipher (_bbb );if _fc !=nil {return nil ,_gd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_adb .XORKeyStream (_agg ,_agg );};};return _agg ,nil ;};func _ba (_da _b .Block )*ecb {return &ecb {_cc :_da ,_de :_da .BlockSize ()}};type ecb struct{_cc _b .Block ;_de int ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););type stdHandlerR6 struct{};func (_geb stdHandlerR6 )alg10 (_gada *StdEncryptDict ,_afea []byte )error {if _fef :=_cfb ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_afea );_fef !=nil {return _fef ;};_baca :=uint64 (uint32 (_gada .P ))|(_cb .MaxUint32 <<32);Perms :=make ([]byte ,16);_gf .LittleEndian .PutUint64 (Perms [:8],_baca );if _gada .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_gec :=_e .ReadFull (_cg .Reader ,Perms [12:16]);_gec !=nil {return _gec ;};_bbe ,_efe :=_bgf (_afea [:32]);if _efe !=nil {return _efe ;};_cda :=_eb (_bbe );_cda .CryptBlocks (Perms ,Perms );_gada .Perms =Perms [:16];return nil ;};func (_bb stdHandlerR4 )alg3Key (R int ,_fbc []byte )[]byte {_ca :=_ee .New ();_gde :=_bb .paddedPass (_fbc );_ca .Write (_gde );if R >=3{for _cbe :=0;_cbe < 50;_cbe ++{_ef :=_ca .Sum (nil );_ca =_ee .New ();_ca .Write (_ef );};};_be :=_ca .Sum (nil );if R ==2{_be =_be [0:5];}else {_be =_be [0:_bb .Length /8];};return _be ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};var _ StdHandler =stdHandlerR6 {};func (_aca stdHandlerR6 )alg2a (_cff *StdEncryptDict ,_bdg []byte )([]byte ,Permissions ,error ){if _daf :=_cfb ("\u0061\u006c\u00672\u0061","\u004f",48,_cff .O );_daf !=nil {return nil ,0,_daf ;};if _acd :=_cfb ("\u0061\u006c\u00672\u0061","\u0055",48,_cff .U );_acd !=nil {return nil ,0,_acd ;};if len (_bdg )> 127{_bdg =_bdg [:127];};_fba ,_dfe :=_aca .alg12 (_cff ,_bdg );if _dfe !=nil {return nil ,0,_dfe ;};var (_ffa []byte ;_efd []byte ;_ggc []byte ;);var _acg Permissions ;if len (_fba )!=0{_acg =PermOwner ;_dad :=make ([]byte ,len (_bdg )+8+48);_afga :=copy (_dad ,_bdg );_afga +=copy (_dad [_afga :],_cff .O [40:48]);copy (_dad [_afga :],_cff .U [0:48]);_ffa =_dad ;_efd =_cff .OE ;_ggc =_cff .U [0:48];}else {_fba ,_dfe =_aca .alg11 (_cff ,_bdg );if _dfe ==nil &&len (_fba )==0{_fba ,_dfe =_aca .alg11 (_cff ,[]byte (""));};if _dfe !=nil {return nil ,0,_dfe ;}else if len (_fba )==0{return nil ,0,nil ;};_acg =_cff .P ;_gbd :=make ([]byte ,len (_bdg )+8);_dead :=copy (_gbd ,_bdg );copy (_gbd [_dead :],_cff .U [40:48]);_ffa =_gbd ;_efd =_cff .UE ;_ggc =nil ;};if _dee :=_cfb ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_efd );_dee !=nil {return nil ,0,_dee ;};_efd =_efd [:32];_dca ,_dfe :=_aca .alg2b (_cff .R ,_ffa ,_bdg ,_ggc );if _dfe !=nil {return nil ,0,_dfe ;};_gc ,_dfe :=_ga .NewCipher (_dca [:32]);if _dfe !=nil {return nil ,0,_dfe ;};_aggg :=make ([]byte ,_ga .BlockSize );_bag :=_b .NewCBCDecrypter (_gc ,_aggg );_bgfg :=make ([]byte ,32);_bag .CryptBlocks (_bgfg ,_efd );if _cff .R ==5{return _bgfg ,_acg ,nil ;};_dfe =_aca .alg13 (_cff ,_bgfg );if _dfe !=nil {return nil ,0,_dfe ;};return _bgfg ,_acg ,nil ;};type ecbDecrypter ecb ;func (_edc stdHandlerR6 )alg12 (_dfcb *StdEncryptDict ,_agc []byte )([]byte ,error ){if _feff :=_cfb ("\u0061\u006c\u00671\u0032","\u0055",48,_dfcb .U );_feff !=nil {return nil ,_feff ;};if _dae :=_cfb ("\u0061\u006c\u00671\u0032","\u004f",48,_dfcb .O );_dae !=nil {return nil ,_dae ;};_bfb :=make ([]byte ,len (_agc )+8+48);_gbca :=copy (_bfb ,_agc );_gbca +=copy (_bfb [_gbca :],_dfcb .O [32:40]);_gbca +=copy (_bfb [_gbca :],_dfcb .U [0:48]);_ecd ,_eed :=_edc .alg2b (_dfcb .R ,_bfb ,_agc ,_dfcb .U [0:48]);if _eed !=nil {return nil ,_eed ;};_ecd =_ecd [:32];if !_db .Equal (_ecd ,_dfcb .O [:32]){return nil ,nil ;};return _ecd ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_egd stdHandlerR6 )alg8 (_gdc *StdEncryptDict ,_abc []byte ,_geg []byte )error {if _aea :=_cfb ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_abc );_aea !=nil {return _aea ;};var _fed [16]byte ;if _ ,_acff :=_e .ReadFull (_cg .Reader ,_fed [:]);_acff !=nil {return _acff ;};_cbgg :=_fed [0:8];_ffb :=_fed [8:16];_eeeb :=make ([]byte ,len (_geg )+len (_cbgg ));_edbd :=copy (_eeeb ,_geg );copy (_eeeb [_edbd :],_cbgg );_fa ,_fae :=_egd .alg2b (_gdc .R ,_eeeb ,_geg ,nil );if _fae !=nil {return _fae ;};U :=make ([]byte ,len (_fa )+len (_cbgg )+len (_ffb ));_edbd =copy (U ,_fa [:32]);_edbd +=copy (U [_edbd :],_cbgg );copy (U [_edbd :],_ffb );_gdc .U =U ;_edbd =len (_geg );copy (_eeeb [_edbd :],_ffb );_fa ,_fae =_egd .alg2b (_gdc .R ,_eeeb ,_geg ,nil );if _fae !=nil {return _fae ;};_cdf ,_fae :=_bgf (_fa [:32]);if _fae !=nil {return _fae ;};_fff :=make ([]byte ,_ga .BlockSize );_cfbdd :=_b .NewCBCEncrypter (_cdf ,_fff );UE :=make ([]byte ,32);_cfbdd .CryptBlocks (UE ,_abc [:32]);_gdc .UE =UE ;return nil ;};func (_gfd *ecbDecrypter )BlockSize ()int {return _gfd ._de };func (_ffc errInvalidField )Error ()string {return _f .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ffc .Func ,_ffc .Field ,_ffc .Exp ,_ffc .Got );};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func _bgf (_fcac []byte )(_b .Block ,error ){_afgd ,_dba :=_ga .NewCipher (_fcac );if _dba !=nil {_gb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_dba );return nil ,_dba ;};return _afgd ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_aee stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_cgd :=make ([]byte ,32);if _ ,_ggeb :=_e .ReadFull (_cg .Reader ,_cgd );_ggeb !=nil {return nil ,_ggeb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _egga :=_aee .alg8 (d ,_cgd ,upass );_egga !=nil {return nil ,_egga ;};if _cfdga :=_aee .alg9 (d ,_cgd ,opass );_cfdga !=nil {return nil ,_cfdga ;};if d .R ==5{return _cgd ,nil ;};if _ebef :=_aee .alg10 (d ,_cgd );_ebef !=nil {return nil ,_ebef ;};return _cgd ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};

// Allowed checks if a set of permissions can be granted.
func (_fg Permissions )Allowed (p2 Permissions )bool {return _fg &p2 ==p2 };func (_cbgd stdHandlerR6 )alg2b (R int ,_aa ,_bcc ,_fdb []byte )([]byte ,error ){if R ==5{return _gab (_aa );};return _ccgg (_aa ,_bcc ,_fdb );};func _cfb (_fd ,_bc string ,_ea int ,_dcg []byte )error {if len (_dcg )< _ea {return errInvalidField {Func :_fd ,Field :_bc ,Exp :_ea ,Got :len (_dcg )};};return nil ;};func _ccgg (_fce ,_ffd ,_egb []byte )([]byte ,error ){var (_bce ,_dce ,_aga _a .Hash ;);_bce =_d .New ();_gac :=make ([]byte ,64);_gafg :=_bce ;_gafg .Write (_fce );K :=_gafg .Sum (_gac [:0]);_fbce :=make ([]byte ,64*(127+64+48));_bab :=func (_ffag int )([]byte ,error ){_bf :=len (_ffd )+len (K )+len (_egb );_dda :=_fbce [:_bf ];_fda :=copy (_dda ,_ffd );_fda +=copy (_dda [_fda :],K [:]);_fda +=copy (_dda [_fda :],_egb );if _fda !=_bf {_gb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_gd .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_fbce [:_bf *64];_dgc (K1 ,_bf );_bgb ,_cfd :=_bgf (K [0:16]);if _cfd !=nil {return nil ,_cfd ;};_gbc :=_b .NewCBCEncrypter (_bgb ,K [16:32]);_gbc .CryptBlocks (K1 ,K1 );E :=K1 ;_cfc :=0;for _ggf :=0;_ggf < 16;_ggf ++{_cfc +=int (E [_ggf ]%3);};var _ggfe _a .Hash ;switch _cfc %3{case 0:_ggfe =_bce ;case 1:if _dce ==nil {_dce =_c .New384 ();};_ggfe =_dce ;case 2:if _aga ==nil {_aga =_c .New ();};_ggfe =_aga ;};_ggfe .Reset ();_ggfe .Write (E );K =_ggfe .Sum (_gac [:0]);return E ,nil ;};for _cae :=0;;{E ,_ege :=_bab (_cae );if _ege !=nil {return nil ,_ege ;};_acda :=E [len (E )-1];_cae ++;if _cae >=64&&_acda <=uint8 (_cae -32){break ;};};return K [:32],nil ;};func (_fee stdHandlerR4 )alg7 (_fcc *StdEncryptDict ,_caaf []byte )([]byte ,error ){_eef :=_fee .alg3Key (_fcc .R ,_caaf );_fde :=make ([]byte ,len (_fcc .O ));if _fcc .R ==2{_bgg ,_eee :=_dc .NewCipher (_eef );if _eee !=nil {return nil ,_gd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_bgg .XORKeyStream (_fde ,_fcc .O );}else if _fcc .R >=3{_gge :=append ([]byte {},_fcc .O ...);for _cd :=0;_cd < 20;_cd ++{_ccaf :=append ([]byte {},_eef ...);for _ffe :=0;_ffe < len (_eef );_ffe ++{_ccaf [_ffe ]^=byte (19-_cd );};_fgg ,_ab :=_dc .NewCipher (_ccaf );if _ab !=nil {return nil ,_gd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fgg .XORKeyStream (_fde ,_gge );_gge =append ([]byte {},_fde ...);};}else {return nil ,_gd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_abf ,_agfe :=_fee .alg6 (_fcc ,_fde );if _agfe !=nil {return nil ,nil ;};return _abf ,nil ;};func _afe (_gfa _b .Block )_b .BlockMode {return (*ecbDecrypter )(_ba (_gfa ))};func (_bdf stdHandlerR4 )alg2 (_df *StdEncryptDict ,_ag []byte )[]byte {_gb .Log .Trace ("\u0061\u006c\u0067\u0032");_fe :=_bdf .paddedPass (_ag );_dg :=_ee .New ();_dg .Write (_fe );_dg .Write (_df .O );var _dfc [4]byte ;_gf .LittleEndian .PutUint32 (_dfc [:],uint32 (_df .P ));_dg .Write (_dfc [:]);_gb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_dfc );_dg .Write ([]byte (_bdf .ID0 ));_gb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_df .R ,_df .EncryptMetadata );if (_df .R >=4)&&!_df .EncryptMetadata {_dg .Write ([]byte {0xff,0xff,0xff,0xff});};_dcgb :=_dg .Sum (nil );if _df .R >=3{_dg =_ee .New ();for _fb :=0;_fb < 50;_fb ++{_dg .Reset ();_dg .Write (_dcgb [0:_bdf .Length /8]);_dcgb =_dg .Sum (nil );};};if _df .R >=3{return _dcgb [0:_bdf .Length /8];};return _dcgb [0:5];};func (_ae *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ae ._de !=0{_gb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_gb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ae ._cc .Encrypt (dst ,src [:_ae ._de ]);src =src [_ae ._de :];dst =dst [_ae ._de :];};};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// Authenticate implements StdHandler interface.
func (_bggb stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_gb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_cfbd ,_bdd :=_bggb .alg7 (d ,pass );if _bdd !=nil {return nil ,0,_bdd ;};if _cfbd !=nil {_gb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cfbd ,PermOwner ,nil ;};_gb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cfbd ,_bdd =_bggb .alg6 (d ,pass );if _bdd !=nil {return nil ,0,_bdd ;};if _cfbd !=nil {_gb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cfbd ,d .P ,nil ;};return nil ,0,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ec *StdEncryptDict ,_cf ,_ff []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_bg *StdEncryptDict ,_ce []byte )([]byte ,Permissions ,error );};func (stdHandlerR4 )paddedPass (_ad []byte )[]byte {_bd :=make ([]byte ,32);_dcd :=copy (_bd ,_ad );for ;_dcd < 32;_dcd ++{_bd [_dcd ]=_dd [_dcd -len (_ad )];};return _bd ;};func _eb (_ccd _b .Block )_b .BlockMode {return (*ecbEncrypter )(_ba (_ccd ))};