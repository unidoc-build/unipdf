//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_dd "bufio";_aaf "bytes";_ac "compress/lzw";_c "compress/zlib";_gd "crypto/md5";_b "crypto/rand";_aa "encoding/hex";_fd "errors";_fbg "fmt";_gee "github.com/unidoc/unipdf/v3/common";_ee "github.com/unidoc/unipdf/v3/core/security";_dc "github.com/unidoc/unipdf/v3/core/security/crypt";_gda "github.com/unidoc/unipdf/v3/internal/ccittfax";_ade "github.com/unidoc/unipdf/v3/internal/imageutil";_ba "github.com/unidoc/unipdf/v3/internal/jbig2";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_be "github.com/unidoc/unipdf/v3/internal/jbig2/document";_gfg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ad "github.com/unidoc/unipdf/v3/internal/strutils";_df "golang.org/x/image/tiff/lzw";_ge "golang.org/x/xerrors";_gf "image";_a "image/color";_ag "image/jpeg";_fe "io";_g "reflect";_gc "regexp";_fb "sort";_d "strconv";_ab "strings";_gg "time";);func (_cfbdg *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _fcgc *PdfObjectDictionary ;_dddd ,_ecfd :=_cfbdg .readTextLine ();if _ecfd !=nil {return nil ,_ecfd ;};_gee .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_dddd );_dgadb :=-1;_bgda :=0;_efda :=false ;_ddge :="";for {_cfbdg .skipSpaces ();_ ,_gabee :=_cfbdg ._dbfg .Peek (1);if _gabee !=nil {return nil ,_gabee ;};_dddd ,_gabee =_cfbdg .readTextLine ();if _gabee !=nil {return nil ,_gabee ;};_dbb :=_adce .FindStringSubmatch (_dddd );if len (_dbb )==0{_gfgdd :=len (_ddge )> 0;_ddge +=_dddd +"\u000a";if _gfgdd {_dbb =_adce .FindStringSubmatch (_ddge );};};if len (_dbb )==3{_edg ,_ :=_d .Atoi (_dbb [1]);_bde ,_ :=_d .Atoi (_dbb [2]);_dgadb =_edg ;_bgda =_bde ;_efda =true ;_ddge ="";_gee .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_dgadb ,_bgda );continue ;};_ggb :=_ececg .FindStringSubmatch (_dddd );if len (_ggb )==4{if !_efda {_gee .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_fd .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_ggaa ,_ :=_d .ParseInt (_ggb [1],10,64);_gccb ,_ :=_d .Atoi (_ggb [2]);_egdb :=_ggb [3];_ddge ="";if _ab .ToLower (_egdb )=="\u006e"&&_ggaa > 1{_bgdad ,_ffcad :=_cfbdg ._gdfb .ObjectMap [_dgadb ];if !_ffcad ||_gccb > _bgdad .Generation {_cdgg :=XrefObject {ObjectNumber :_dgadb ,XType :XrefTypeTableEntry ,Offset :_ggaa ,Generation :_gccb };_cfbdg ._gdfb .ObjectMap [_dgadb ]=_cdgg ;};};_dgadb ++;continue ;};if (len (_dddd )> 6)&&(_dddd [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_gee .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_dddd );if len (_dddd )> 9{_fafb :=_cfbdg .GetFileOffset ();_cfbdg .SetFileOffset (_fafb -int64 (len (_dddd ))+7);};_cfbdg .skipSpaces ();_cfbdg .skipComments ();_gee .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_gee .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_dddd );_fcgc ,_gabee =_cfbdg .ParseDict ();_gee .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _gabee !=nil {_gee .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_gabee );return nil ,_gabee ;};break ;};if _dddd =="\u0025\u0025\u0045O\u0046"{_gee .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_fd .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_gee .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_dddd );};_gee .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _cfbdg ._ccgb ==nil {_eaea :=XrefTypeTableEntry ;_cfbdg ._ccgb =&_eaea ;};return _fcgc ,nil ;};const JB2ImageAutoThreshold =-1.0;var _gada =_gc .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_cbgfg *PdfParser )IsAuthenticated ()bool {return _cbgfg ._dfab ._bcb };

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_befe *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_dcda :=data ;var _dcdf error ;for _agde :=len (_befe ._cbgg )-1;_agde >=0;_agde --{_cddgf :=_befe ._cbgg [_agde ];_dcda ,_dcdf =_cddgf .EncodeBytes (_dcda );if _dcdf !=nil {return nil ,_dcdf ;};};return _dcda ,nil ;};func (_fbab *FlateEncoder )cleanImageData (_bfdc []byte )([]byte ,error ){if _fbab ._fcda ==nil {return _bfdc ,nil ;};if _fbab ._fcda .BitsPerComponent >=8{return _bfdc ,nil ;};_face :=_fbab ._fcda .BitsPerComponent *_fbab ._fcda .Width *_fbab ._fcda .ColorComponents *_fbab ._fcda .Height /8;_bfdc =_bfdc [:_face ];var _agf error ;_bfdc ,_agf =_ade .AddDataPadding (_fbab ._fcda .Width ,_fbab ._fcda .Height ,_fbab ._fcda .BitsPerComponent ,_fbab ._fcda .ColorComponents ,_bfdc );if _agf !=nil {return nil ,_agf ;};return _bfdc ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_dfac *PdfObjectName )WriteString ()string {var _cbdb _aaf .Buffer ;if len (*_dfac )> 127{_gee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_dfac );};_cbdb .WriteString ("\u002f");for _gaaaf :=0;_gaaaf < len (*_dfac );_gaaaf ++{_dcbb :=(*_dfac )[_gaaaf ];if !IsPrintable (_dcbb )||_dcbb =='#'||IsDelimiter (_dcbb ){_cbdb .WriteString (_fbg .Sprintf ("\u0023\u0025\u002e2\u0078",_dcbb ));}else {_cbdb .WriteByte (_dcbb );};};return _cbdb .String ();};

// GetParser returns the parser for lazy-loading or compare references.
func (_egfg *PdfObjectReference )GetParser ()*PdfParser {return _egfg ._gedg };

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_bedfa :=PdfObjectString {_ecea :s ,_ffdg :true };return &_bedfa ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_gged *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gged .DecodeBytes (streamObj .Stream );};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_decd *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _decd .DecodeBytes (streamObj .Stream );};

// String returns the state of the bool as "true" or "false".
func (_dbda *PdfObjectBool )String ()string {if *_dbda {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetFilterName returns the name of the encoding filter.
func (_cffd *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };func (_bfb *PdfCrypt )saveCryptFilters (_cecc *PdfObjectDictionary )error {if _bfb ._cdc .V < 4{return _fd .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_gfb :=MakeDict ();_cecc .Set ("\u0043\u0046",_gfb );for _gbe ,_eag :=range _bfb ._efb {if _gbe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_fag :=_fed (_eag ,"");_gfb .Set (PdfObjectName (_gbe ),_fag );};_cecc .Set ("\u0053\u0074\u0072\u0046",MakeName (_bfb ._aafa ));_cecc .Set ("\u0053\u0074\u006d\u0046",MakeName (_bfb ._cfc ));return nil ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_cffc string ,_febca bool ){_cbege ,_febca :=TraceToDirectObject (obj ).(*PdfObjectName );if _febca {return string (*_cbege ),true ;};return ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_gdda float64 ,_bddg bool ){_ddgef ,_bddg :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _bddg {return float64 (*_ddgef ),true ;};return 0,false ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_fafa *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_abfe :=MakeDict ();_abfe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fafa .GetFilterName ()));return _abfe ;};func _cfdb (_fadd *PdfObjectDictionary )(_cefaa *_ade .ImageBase ){var (_dded *PdfObjectInteger ;_aegbg bool ;);if _dded ,_aegbg =_fadd .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_aegbg {_cefaa =&_ade .ImageBase {Width :int (*_dded )};}else {return nil ;};if _dded ,_aegbg =_fadd .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_aegbg {_cefaa .Height =int (*_dded );};if _dded ,_aegbg =_fadd .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_aegbg {_cefaa .BitsPerComponent =int (*_dded );};if _dded ,_aegbg =_fadd .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_aegbg {_cefaa .ColorComponents =int (*_dded );};return _cefaa ;};

// Remove removes an element specified by key.
func (_befea *PdfObjectDictionary )Remove (key PdfObjectName ){_aebf :=-1;for _cdeb ,_fgefa :=range _befea ._aeba {if _fgefa ==key {_aebf =_cdeb ;break ;};};if _aebf >=0{_befea ._aeba =append (_befea ._aeba [:_aebf ],_befea ._aeba [_aebf +1:]...);delete (_befea ._bagbd ,key );};};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _fffaf _aaf .Buffer ;_fffaf .Write ([]byte {0xFE,0xFF});_fffaf .WriteString (_ad .StringToUTF16 (s ));return &PdfObjectString {_ecea :_fffaf .String (),_ffdg :true };};return &PdfObjectString {_ecea :string (_ad .StringToPDFDocEncoding (s )),_ffdg :false };};const (_acga =0;_bcfa =1;_bfcg =2;_cacb =3;_gba =4;);

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_geacf *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_geacf ._cbgg )==0{return nil ;};if len (_geacf ._cbgg )==1{return _geacf ._cbgg [0].MakeDecodeParams ();};_dcfe :=MakeArray ();for _ ,_fdg :=range _geacf ._cbgg {_fafag :=_fdg .MakeDecodeParams ();if _fafag ==nil {_dcfe .Append (MakeNull ());}else {_dcfe .Append (_fafag );};};return _dcfe ;};func (_dgaf *PdfParser )parseString ()(*PdfObjectString ,error ){_dgaf ._dbfg .ReadByte ();var _bcbg _aaf .Buffer ;_dade :=1;for {_defc ,_fagg :=_dgaf ._dbfg .Peek (1);if _fagg !=nil {return MakeString (_bcbg .String ()),_fagg ;};if _defc [0]=='\\'{_dgaf ._dbfg .ReadByte ();_fefc ,_eaacg :=_dgaf ._dbfg .ReadByte ();if _eaacg !=nil {return MakeString (_bcbg .String ()),_eaacg ;};if IsOctalDigit (_fefc ){_acgdc ,_gdad :=_dgaf ._dbfg .Peek (2);if _gdad !=nil {return MakeString (_bcbg .String ()),_gdad ;};var _ffbf []byte ;_ffbf =append (_ffbf ,_fefc );for _ ,_gadc :=range _acgdc {if IsOctalDigit (_gadc ){_ffbf =append (_ffbf ,_gadc );}else {break ;};};_dgaf ._dbfg .Discard (len (_ffbf )-1);_gee .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_ffbf );_feba ,_gdad :=_d .ParseUint (string (_ffbf ),8,32);if _gdad !=nil {return MakeString (_bcbg .String ()),_gdad ;};_bcbg .WriteByte (byte (_feba ));continue ;};switch _fefc {case 'n':_bcbg .WriteRune ('\n');case 'r':_bcbg .WriteRune ('\r');case 't':_bcbg .WriteRune ('\t');case 'b':_bcbg .WriteRune ('\b');case 'f':_bcbg .WriteRune ('\f');case '(':_bcbg .WriteRune ('(');case ')':_bcbg .WriteRune (')');case '\\':_bcbg .WriteRune ('\\');};continue ;}else if _defc [0]=='('{_dade ++;}else if _defc [0]==')'{_dade --;if _dade ==0{_dgaf ._dbfg .ReadByte ();break ;};};_cgbc ,_ :=_dgaf ._dbfg .ReadByte ();_bcbg .WriteByte (_cgbc );};return MakeString (_bcbg .String ()),nil ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_bddd *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _aefdd _aaf .Buffer ;for _eecgb :=0;_eecgb < len (data );_eecgb +=4{_badb :=data [_eecgb ];_ggab :=1;_acdba :=byte (0);if _eecgb +1< len (data ){_acdba =data [_eecgb +1];_ggab ++;};_geeb :=byte (0);if _eecgb +2< len (data ){_geeb =data [_eecgb +2];_ggab ++;};_bbce :=byte (0);if _eecgb +3< len (data ){_bbce =data [_eecgb +3];_ggab ++;};_aebd :=(uint32 (_badb )<<24)|(uint32 (_acdba )<<16)|(uint32 (_geeb )<<8)|uint32 (_bbce );if _aebd ==0{_aefdd .WriteByte ('z');}else {_fdab :=_bddd .base256Tobase85 (_aebd );for _ ,_gedd :=range _fdab [:_ggab +1]{_aefdd .WriteByte (_gedd +'!');};};};_aefdd .WriteString ("\u007e\u003e");return _aefdd .Bytes (),nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};var _cbaf =_gc .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_eff :=MultiEncoder {};_eff ._cbgg =[]StreamEncoder {};return &_eff ;};func (_eeae *FlateEncoder )postDecodePredict (_dgb []byte )([]byte ,error ){if _eeae .Predictor > 1{if _eeae .Predictor ==2{_gee .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gee .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_eeae .Colors );_cdf :=_eeae .Columns *_eeae .Colors ;if _cdf < 1{return []byte {},nil ;};_gade :=len (_dgb )/_cdf ;if len (_dgb )%_cdf !=0{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dgb ),_cdf );};if _cdf %_eeae .Colors !=0{return nil ,_fbg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_cdf ,_eeae .Colors );};if _cdf > len (_dgb ){_gee .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cdf ,len (_dgb ));return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gee .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dgb ),_dgb );_fcc :=_aaf .NewBuffer (nil );for _efga :=0;_efga < _gade ;_efga ++{_gbdg :=_dgb [_cdf *_efga :_cdf *(_efga +1)];for _ccg :=_eeae .Colors ;_ccg < _cdf ;_ccg ++{_gbdg [_ccg ]+=_gbdg [_ccg -_eeae .Colors ];};_fcc .Write (_gbdg );};_fedae :=_fcc .Bytes ();_gee .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fedae ),_fedae );return _fedae ,nil ;}else if _eeae .Predictor >=10&&_eeae .Predictor <=15{_gee .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_eda :=_eeae .Columns *_eeae .Colors +1;_aaee :=len (_dgb )/_eda ;if len (_dgb )%_eda !=0{return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dgb ),_eda );};if _eda > len (_dgb ){_gee .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_eda ,len (_dgb ));return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eebb :=_aaf .NewBuffer (nil );_gee .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_eeae .Columns );_gee .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dgb ),_eda ,_aaee );_gfba :=make ([]byte ,_eda );for _cgbg :=0;_cgbg < _eda ;_cgbg ++{_gfba [_cgbg ]=0;};_fccb :=_eeae .Colors ;for _ebe :=0;_ebe < _aaee ;_ebe ++{_gbcd :=_dgb [_eda *_ebe :_eda *(_ebe +1)];_cea :=_gbcd [0];switch _cea {case _acga :case _bcfa :for _fecf :=1+_fccb ;_fecf < _eda ;_fecf ++{_gbcd [_fecf ]+=_gbcd [_fecf -_fccb ];};case _bfcg :for _ffgcg :=1;_ffgcg < _eda ;_ffgcg ++{_gbcd [_ffgcg ]+=_gfba [_ffgcg ];};case _cacb :for _efbc :=1;_efbc < _fccb +1;_efbc ++{_gbcd [_efbc ]+=_gfba [_efbc ]/2;};for _egcg :=_fccb +1;_egcg < _eda ;_egcg ++{_gbcd [_egcg ]+=byte ((int (_gbcd [_egcg -_fccb ])+int (_gfba [_egcg ]))/2);};case _gba :for _aad :=1;_aad < _eda ;_aad ++{var _eaa ,_fca ,_baab byte ;_fca =_gfba [_aad ];if _aad >=_fccb +1{_eaa =_gbcd [_aad -_fccb ];_baab =_gfba [_aad -_fccb ];};_gbcd [_aad ]+=_dbga (_eaa ,_fca ,_baab );};default:_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_cea ,_ebe );return nil ,_fbg .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cea );};copy (_gfba ,_gbcd );_eebb .Write (_gbcd [1:]);};_gdfd :=_eebb .Bytes ();return _gdfd ,nil ;}else {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_eeae .Predictor );return nil ,_fbg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_eeae .Predictor );};};return _dgb ,nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cecd *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_cgeg :=MakeDict ();_cgeg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cecd .GetFilterName ()));_bedb :=_cecd .MakeDecodeParams ();if _bedb !=nil {_cgeg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bedb );};return _cgeg ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_bagbd map[PdfObjectName ]PdfObject ;_aeba []PdfObjectName ;_abfd *PdfParser ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_gedg *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// GetFilterName returns the name of the encoding filter.
func (_adab *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_cfgf *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cfgf .DecodeBytes (streamObj .Stream );};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_dgaa *JBIG2Image )ToGoImage ()(_gf .Image ,error ){const _cagc ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _dgaa .Data ==nil {return nil ,_gfg .Error (_cagc ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _dgaa .Width ==0||_dgaa .Height ==0{return nil ,_gfg .Error (_cagc ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_fced ,_fbdf :=_ade .NewImage (_dgaa .Width ,_dgaa .Height ,1,1,_dgaa .Data ,nil ,nil );if _fbdf !=nil {return nil ,_fbdf ;};return _fced ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// DecodeStream implements ASCII85 stream decoding.
func (_debe *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _debe .DecodeBytes (streamObj .Stream );};

// DecodeStream implements ASCII hex decoding.
func (_aeg *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aeg .DecodeBytes (streamObj .Stream );};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_cfgg *PdfObjectDictionary )Keys ()[]PdfObjectName {if _cfgg ==nil {return nil ;};return _cfgg ._aeba ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_afbc *PdfObjectStreams )Elements ()[]PdfObject {if _afbc ==nil {return nil ;};return _afbc ._cbbd ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_afcf int ,_gecd bool ){_eedc ,_gecd :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _gecd &&_eedc !=nil {return int (*_eedc ),true ;};return 0,false ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_cda *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cda .Predictor !=1&&_cda .Predictor !=11{_gee .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _cda .Predictor ==11{_cdcd :=_cda .Columns ;_ebad :=len (data )/_cdcd ;if len (data )%_cdcd !=0{_gee .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_fd .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_gcdc :=_aaf .NewBuffer (nil );_edd :=make ([]byte ,_cdcd );for _agg :=0;_agg < _ebad ;_agg ++{_eddg :=data [_cdcd *_agg :_cdcd *(_agg +1)];_edd [0]=_eddg [0];for _gecc :=1;_gecc < _cdcd ;_gecc ++{_edd [_gecc ]=byte (int (_eddg [_gecc ]-_eddg [_gecc -1])%256);};_gcdc .WriteByte (1);_gcdc .Write (_edd );};data =_gcdc .Bytes ();};var _dgad _aaf .Buffer ;_egff :=_c .NewWriter (&_dgad );_egff .Write (data );_egff .Close ();return _dgad .Bytes (),nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};var _ececg =_gc .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// String returns a string describing `streams`.
func (_ccbec *PdfObjectStreams )String ()string {return _fbg .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_ccbec .ObjectNumber );};const (DefaultJPEGQuality =75;);

// GetXrefType returns the type of the first xref object (table or stream).
func (_bcfcc *PdfParser )GetXrefType ()*xrefType {return _bcfcc ._ccgb };

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_cbbd :objects };};func (_cag *PdfCrypt )decryptBytes (_eecb []byte ,_dec string ,_faf []byte )([]byte ,error ){_gee .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_gdac ,_abd :=_cag ._efb [_dec ];if !_abd {return nil ,_fbg .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dec );};return _gdac .DecryptBytes (_eecb ,_faf );};

// UpdateParams updates the parameter values of the encoder.
func (_bgfe *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// PdfVersion returns version of the PDF file.
func (_daac *PdfParser )PdfVersion ()Version {return _daac ._dgcc };

// WriteString outputs the object as it is to be written to file.
func (_acce *PdfObjectBool )WriteString ()string {if *_acce {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// WriteString outputs the object as it is to be written to file.
func (_gbdd *PdfObjectStream )WriteString ()string {var _cgfg _ab .Builder ;_cgfg .WriteString (_d .FormatInt (_gbdd .ObjectNumber ,10));_cgfg .WriteString ("\u0020\u0030\u0020\u0052");return _cgfg .String ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ecec *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };var (ErrUnsupportedEncodingParameters =_fd .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_fd .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_fd .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_fd .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_fd .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_fd .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_ge .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_fd .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););func (_bae *PdfCrypt )checkAccessRights (_gbcc []byte )(bool ,_ee .Permissions ,error ){_fedd :=_bae .securityHandler ();_ebd ,_edbg ,_aagg :=_fedd .Authenticate (&_bae ._facd ,_gbcc );if _aagg !=nil {return false ,0,_aagg ;}else if _edbg ==0||len (_ebd )==0{return false ,0,nil ;};return true ,_edbg ,nil ;};type objectStream struct{N int ;_eg []byte ;_age map[int ]int64 ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_cbbd []PdfObject ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_bfga *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_gee .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_edbf :=MakeDict ();_edbf ._abfd =_bfga ;_bbdg ,_ :=_bfga ._dbfg .ReadByte ();if _bbdg !='<'{return nil ,_fd .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_bbdg ,_ =_bfga ._dbfg .ReadByte ();if _bbdg !='<'{return nil ,_fd .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_bfga .skipSpaces ();_bfga .skipComments ();_eggb ,_dbge :=_bfga ._dbfg .Peek (2);if _dbge !=nil {return nil ,_dbge ;};_gee .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_eggb ),string (_eggb ));if (_eggb [0]=='>')&&(_eggb [1]=='>'){_gee .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_bfga ._dbfg .ReadByte ();_bfga ._dbfg .ReadByte ();break ;};_gee .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_fdfe ,_dbge :=_bfga .parseName ();_gee .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_fdfe );if _dbge !=nil {_gee .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_dbge );return nil ,_dbge ;};if len (_fdfe )> 4&&_fdfe [len (_fdfe )-4:]=="\u006e\u0075\u006c\u006c"{_cfag :=_fdfe [0:len (_fdfe )-4];_gee .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_fdfe );_gee .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_cfag );_bfga .skipSpaces ();_agge ,_ :=_bfga ._dbfg .Peek (1);if _agge [0]=='/'{_edbf .Set (_cfag ,MakeNull ());continue ;};};_bfga .skipSpaces ();_gbdgb ,_dbge :=_bfga .parseObject ();if _dbge !=nil {return nil ,_dbge ;};_edbf .Set (_fdfe ,_gbdgb );if _gee .Log .IsLogLevel (_gee .LogLevelTrace ){_gee .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_fdfe ,_gbdgb .String ());};};_gee .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _edbf ,nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_bcce :=&ASCII85Encoder {};return _bcce };

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dffd *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// WriteString outputs the object as it is to be written to file.
func (_gacc *PdfObjectArray )WriteString ()string {var _cefa _ab .Builder ;_cefa .WriteString ("\u005b");for _feeg ,_aeaca :=range _gacc .Elements (){_cefa .WriteString (_aeaca .WriteString ());if _feeg < (_gacc .Len ()-1){_cefa .WriteString ("\u0020");};};_cefa .WriteString ("\u005d");return _cefa .String ();};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _gbda ,_edca :=obj .(*PdfObjectReference );_edca {obj =_gbda .Resolve ();};_ddba ,_gggd :=obj .(*PdfIndirectObject );_ggfbc :=0;for _gggd {obj =_ddba .PdfObject ;_ddba ,_gggd =GetIndirect (obj );_ggfbc ++;if _ggfbc > _gcaa {_gee .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_gcaa );return nil ;};};return obj ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_bfac *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bfac .GetFilterName ());return data ,ErrNoJPXDecode ;};

// Len returns the number of elements in the array.
func (_gadcg *PdfObjectArray )Len ()int {if _gadcg ==nil {return 0;};return len (_gadcg ._gfdc );};var _gcgb =_gc .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_gefa string ,_aebff bool ){_bdfae ,_aebff :=TraceToDirectObject (obj ).(*PdfObjectString );if _aebff {return _bdfae .Str (),true ;};return ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_daad *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// GetFilterName returns the name of the encoding filter.
func (_gcdcb *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// WriteString outputs the object as it is to be written to file.
func (_aade *PdfObjectStreams )WriteString ()string {var _efcc _ab .Builder ;_efcc .WriteString (_d .FormatInt (_aade .ObjectNumber ,10));_efcc .WriteString ("\u0020\u0030\u0020\u0052");return _efcc .String ();};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_geff *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _egag []byte ;_gee .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_bade :=0;_dgea :=false ;for _bade < len (encoded )&&!_dgea {_ccf :=[5]byte {0,0,0,0,0};_eac :=0;_acdb :=0;_faaa :=4;for _acdb < 5+_eac {if _bade +_acdb ==len (encoded ){break ;};_abcb :=encoded [_bade +_acdb ];if IsWhiteSpace (_abcb ){_eac ++;_acdb ++;continue ;}else if _abcb =='~'&&_bade +_acdb +1< len (encoded )&&encoded [_bade +_acdb +1]=='>'{_faaa =(_acdb -_eac )-1;if _faaa < 0{_faaa =0;};_dgea =true ;break ;}else if _abcb >='!'&&_abcb <='u'{_abcb -='!';}else if _abcb =='z'&&_acdb -_eac ==0{_faaa =4;_acdb ++;break ;}else {_gee .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_fd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_ccf [_acdb -_eac ]=_abcb ;_acdb ++;};_bade +=_acdb ;for _begb :=_faaa +1;_begb < 5;_begb ++{_ccf [_begb ]=84;};_gcea :=uint32 (_ccf [0])*85*85*85*85+uint32 (_ccf [1])*85*85*85+uint32 (_ccf [2])*85*85+uint32 (_ccf [3])*85+uint32 (_ccf [4]);_dfaa :=[]byte {byte ((_gcea >>24)&0xff),byte ((_gcea >>16)&0xff),byte ((_gcea >>8)&0xff),byte (_gcea &0xff)};_egag =append (_egag ,_dfaa [:_faaa ]...);};_gee .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_gee .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_egag );return _egag ,nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_fgdg *MultiEncoder )GetFilterArray ()*PdfObjectArray {_bfbb :=make ([]PdfObject ,len (_fgdg ._cbgg ));for _cffb ,_bgaff :=range _fgdg ._cbgg {_bfbb [_cffb ]=MakeName (_bgaff .GetFilterName ());};return MakeArray (_bfbb ...);};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func _dcf (_egga *_ee .StdEncryptDict ,_ddgd *PdfObjectDictionary )error {R ,_aedb :=_ddgd .Get ("\u0052").(*PdfObjectInteger );if !_aedb {return _fd .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_egga .R =int (*R );O ,_aedb :=_ddgd .GetString ("\u004f");if !_aedb {return _fd .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _egga .R ==5||_egga .R ==6{if len (O )< 48{return _fbg .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _fbg .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_egga .O =[]byte (O );U ,_aedb :=_ddgd .GetString ("\u0055");if !_aedb {return _fd .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _egga .R ==5||_egga .R ==6{if len (U )< 48{return _fbg .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_gee .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_egga .U =[]byte (U );if _egga .R >=5{OE ,_egde :=_ddgd .GetString ("\u004f\u0045");if !_egde {return _fd .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _fbg .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_egga .OE =[]byte (OE );UE ,_egde :=_ddgd .GetString ("\u0055\u0045");if !_egde {return _fd .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _fbg .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_egga .UE =[]byte (UE );};P ,_aedb :=_ddgd .Get ("\u0050").(*PdfObjectInteger );if !_aedb {return _fd .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_egga .P =_ee .Permissions (*P );if _egga .R ==6{Perms ,_deb :=_ddgd .GetString ("\u0050\u0065\u0072m\u0073");if !_deb {return _fd .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _fbg .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_egga .Perms =[]byte (Perms );};if _ddgde ,_bb :=_ddgd .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_bb {_egga .EncryptMetadata =bool (*_ddgde );}else {_egga .EncryptMetadata =true ;};return nil ;};var _dece =_gc .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_fbfg *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _gefd []float64 ;for _ ,_cceg :=range _fbfg .Elements (){_bcfaf ,_dgce :=GetNumberAsFloat (TraceToDirectObject (_cceg ));if _dgce !=nil {return nil ,_fbg .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_gefd =append (_gefd ,_bcfaf );};return _gefd ,nil ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _gfaf :=obj .(type ){case *PdfObjectFloat :return float64 (*_gfaf ),nil ;case *PdfObjectInteger :return float64 (*_gfaf ),nil ;};return 0,ErrNotANumber ;};

// UpdateParams updates the parameter values of the encoder.
func (_afeg *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_bdbb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_eeee error ){const _fegg ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _bdbb ==nil {return _gfg .Error (_fegg ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_bdbb .DefaultPageSettings ;};if _bdbb ._dgef ==nil {_bdbb ._dgef =_be .InitEncodeDocument (settings .FileMode );};if _eeee =settings .Validate ();_eeee !=nil {return _gfg .Wrap (_eeee ,_fegg ,"");};_fccc ,_eeee :=img .toBitmap ();if _eeee !=nil {return _gfg .Wrap (_eeee ,_fegg ,"");};switch settings .Compression {case JB2Generic :if _eeee =_bdbb ._dgef .AddGenericPage (_fccc ,settings .DuplicatedLinesRemoval );_eeee !=nil {return _gfg .Wrap (_eeee ,_fegg ,"");};case JB2SymbolCorrelation :return _gfg .Error (_fegg ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _gfg .Error (_fegg ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _gfg .Error (_fegg ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func (_eaacf *JBIG2Encoder )encodeImage (_gfff _gf .Image )([]byte ,error ){const _daab ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_ggad ,_aege :=GoImageToJBIG2 (_gfff ,JB2ImageAutoThreshold );if _aege !=nil {return nil ,_gfg .Wrap (_aege ,_daab ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _aege =_eaacf .AddPageImage (_ggad ,&_eaacf .DefaultPageSettings );_aege !=nil {return nil ,_gfg .Wrap (_aege ,_daab ,"");};return _eaacf .Encode ();};

// UpdateParams updates the parameter values of the encoder.
func (_gbdc *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_bbg ,_gca :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gca ==nil {_gbdc .ColorComponents =int (_bbg );};_degc ,_gca :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gca ==nil {_gbdc .BitsPerComponent =int (_degc );};_gfbe ,_gca :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gca ==nil {_gbdc .Width =int (_gfbe );};_gfae ,_gca :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gca ==nil {_gbdc .Height =int (_gfae );};_dag ,_gca :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _gca ==nil {_gbdc .Quality =int (_dag );};};func (_cdb *PdfParser )parsePdfVersion ()(int ,int ,error ){var _abcfc int64 =20;_cdba :=make ([]byte ,_abcfc );_cdb ._ggggc .Seek (0,_fe .SeekStart );_cdb ._ggggc .Read (_cdba );var _gedf error ;var _bbdc ,_cgge int ;if _dccc :=_cbaf .FindStringSubmatch (string (_cdba ));len (_dccc )< 3{if _bbdc ,_cgge ,_gedf =_cdb .seekPdfVersionTopDown ();_gedf !=nil {_gee .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_gedf ;};_cdb ._ggggc ,_gedf =_cae (_cdb ._ggggc ,_cdb .GetFileOffset ()-8);if _gedf !=nil {return 0,0,_gedf ;};}else {if _bbdc ,_gedf =_d .Atoi (_dccc [1]);_gedf !=nil {return 0,0,_gedf ;};if _cgge ,_gedf =_d .Atoi (_dccc [2]);_gedf !=nil {return 0,0,_gedf ;};_cdb .SetFileOffset (0);};_cdb ._dbfg =_dd .NewReader (_cdb ._ggggc );_gee .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_bbdc ,_cgge );return _bbdc ,_cgge ,nil ;};var _cbgac =_gc .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// String returns a string describing `ref`.
func (_edbag *PdfObjectReference )String ()string {return _fbg .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_edbag .ObjectNumber ,_edbag .GenerationNumber );};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_ecbdd *PdfObjectBool ,_gcacbb bool ){_ecbdd ,_gcacbb =TraceToDirectObject (obj ).(*PdfObjectBool );return _ecbdd ,_gcacbb ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_fcfd *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_egfd :=_aaf .NewReader (encoded );var _begf []byte ;for {_bdga ,_fead :=_egfd .ReadByte ();if _fead !=nil {return nil ,_fead ;};if _bdga =='>'{break ;};if IsWhiteSpace (_bdga ){continue ;};if (_bdga >='a'&&_bdga <='f')||(_bdga >='A'&&_bdga <='F')||(_bdga >='0'&&_bdga <='9'){_begf =append (_begf ,_bdga );}else {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_bdga );return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_bdga );};};if len (_begf )%2==1{_begf =append (_begf ,'0');};_gee .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_begf );_cdfa :=make ([]byte ,_aa .DecodedLen (len (_begf )));_ ,_fbaf :=_aa .Decode (_cdfa ,_begf );if _fbaf !=nil {return nil ,_fbaf ;};return _cdfa ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_bbgd *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_bbgd ._ggggc .Seek (offset ,_fe .SeekStart );_bbgd ._dbfg =_dd .NewReader (_bbgd ._ggggc );};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_gaffe *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dbfd :=encoded ;var _ccd error ;for _ ,_geffbe :=range _gaffe ._cbgg {_gee .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_geffbe ,_geffbe );_dbfd ,_ccd =_geffbe .DecodeBytes (_dbfd );if _ccd !=nil {return nil ,_ccd ;};};return _dbfd ,nil ;};func _ffbb (_bcge string )(PdfObjectReference ,error ){_ececga :=PdfObjectReference {};_ffgb :=_cbgac .FindStringSubmatch (_bcge );if len (_ffgb )< 3{_gee .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _ececga ,_fd .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_eabe ,_ :=_d .Atoi (_ffgb [1]);_aabfd ,_ :=_d .Atoi (_ffgb [2]);_ececga .ObjectNumber =int64 (_eabe );_ececga .GenerationNumber =int64 (_aabfd );return _ececga ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_daa *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_fad :=MakeDict ();_fad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_daa .GetFilterName ()));_decf :=_daa .MakeDecodeParams ();if _decf !=nil {_fad .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_decf );};return _fad ;};func (_dfbd *PdfParser )seekToEOFMarker (_cadb int64 )error {var _cdga int64 ;var _gaffa int64 =2048;for _cdga < _cadb -4{if _cadb <=(_gaffa +_cdga ){_gaffa =_cadb -_cdga ;};_ ,_bcca :=_dfbd ._ggggc .Seek (-_cdga -_gaffa ,_fe .SeekEnd );if _bcca !=nil {return _bcca ;};_edff :=make ([]byte ,_gaffa );_dfbd ._ggggc .Read (_edff );_gee .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_edff ));_agbf :=_fbbg .FindAllStringIndex (string (_edff ),-1);if _agbf !=nil {_fgea :=_agbf [len (_agbf )-1];_gee .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_agbf );_dfbd ._ggggc .Seek (-_cdga -_gaffa +int64 (_fgea [0]),_fe .SeekEnd );return nil ;};_gee .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_cdga +=_gaffa -4;};_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _fd .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// UpdateParams updates the parameter values of the encoder.
func (_dcac *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_fadeg *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_gfd :=_fadeg .GetFileOffset ();_ ,_dcdg :=_fadeg ._ggggc .Seek (offset ,_fe .SeekStart );if _dcdg !=nil {return nil ,_dcdg ;};_bgfb :=make ([]byte ,len );_ ,_dcdg =_fe .ReadAtLeast (_fadeg ._ggggc ,_bgfb ,int (len ));if _dcdg !=nil {return nil ,_dcdg ;};_fadeg .SetFileOffset (_gfd );return _bgfb ,nil ;};var _ggea =_gc .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cbea *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };func _dceb (_aacde PdfObject )(*float64 ,error ){switch _fdaba :=_aacde .(type ){case *PdfObjectFloat :_cddf :=float64 (*_fdaba );return &_cddf ,nil ;case *PdfObjectInteger :_eccg :=float64 (*_fdaba );return &_eccg ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};func _aacd (_bdd *_dc .FilterDict ,_bbd *PdfObjectDictionary )error {if _baa ,_dgc :=_bbd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dgc {if _dcfc :=string (*_baa );_dcfc !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_gee .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_dcfc );};};_bbc ,_egb :=_bbd .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_egb {return _fbg .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_bdd .CFM =string (*_bbc );if _cbe ,_geeg :=_bbd .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_geeg {_bdd .AuthEvent =_ee .AuthEvent (*_cbe );}else {_bdd .AuthEvent =_ee .EventDocOpen ;};if _bbde ,_adg :=_bbd .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_adg {_bdd .Length =int (*_bbde );};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_aebc *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_ace :=range _aebc ._cbgg {_ace .UpdateParams (params );};};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_eeaef *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gee .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_gee .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_eeaef .Predictor );if _eeaef .BitsPerComponent !=8{return nil ,_fbg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_eeaef .BitsPerComponent );};_aefd ,_dcb :=_eeaef .DecodeBytes (streamObj .Stream );if _dcb !=nil {return nil ,_dcb ;};_aefd ,_dcb =_eeaef .postDecodePredict (_aefd );if _dcb !=nil {return nil ,_dcb ;};return _eeaef .cleanImageData (_aefd );};type xrefType int ;

// GetXrefOffset returns the offset of the xref table.
func (_gfgd *PdfParser )GetXrefOffset ()int64 {return _gfgd ._abec };

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_afd *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bcba _aaf .Buffer ;for _ ,_eega :=range data {_bcba .WriteString (_fbg .Sprintf ("\u0025\u002e\u0032X\u0020",_eega ));};_bcba .WriteByte ('>');return _bcba .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcgd *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_cbg *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbbb :=MakeDict ();_gbbb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cbg .GetFilterName ()));return _gbbb ;};var _fbbg =_gc .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};func (_bfcgg *PdfObjectInteger )String ()string {return _fbg .Sprintf ("\u0025\u0064",*_bfcgg )};func _eec (_gdc int )cryptFilters {return cryptFilters {_bed :_dc .NewFilterV2 (_gdc )}};func _aae (_gad *PdfObjectStream ,_cbcf *PdfObjectDictionary )(*FlateEncoder ,error ){_geag :=NewFlateEncoder ();_fgef :=_gad .PdfObjectDictionary ;if _fgef ==nil {return _geag ,nil ;};_geag ._fcda =_cfdb (_fgef );if _cbcf ==nil {_edc :=TraceToDirectObject (_fgef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _gfeg :=_edc .(type ){case *PdfObjectArray :if _gfeg .Len ()!=1{_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_gfeg .Len ());return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _gfgg ,_egcb :=GetDict (_gfeg .Get (0));_egcb {_cbcf =_gfgg ;};case *PdfObjectDictionary :_cbcf =_gfeg ;case *PdfObjectNull ,nil :default:_gee .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_edc );return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cbcf ==nil {return _geag ,nil ;};_gee .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cbcf .String ());_ffgc :=_cbcf .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _ffgc ==nil {_gee .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_cdcb ,_cbeg :=_ffgc .(*PdfObjectInteger );if !_cbeg {_gee .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_ffgc );return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_geag .Predictor =int (*_cdcb );};_ffgc =_cbcf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _ffgc !=nil {_eeeb ,_dce :=_ffgc .(*PdfObjectInteger );if !_dce {_gee .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_fbg .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_geag .BitsPerComponent =int (*_eeeb );};if _geag .Predictor > 1{_geag .Columns =1;_ffgc =_cbcf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _ffgc !=nil {_bcef ,_ecee :=_ffgc .(*PdfObjectInteger );if !_ecee {return nil ,_fbg .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_geag .Columns =int (*_bcef );};_geag .Colors =1;_ffgc =_cbcf .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _ffgc !=nil {_fgdc ,_dcc :=_ffgc .(*PdfObjectInteger );if !_dcc {return nil ,_fbg .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_geag .Colors =int (*_fgdc );};};return _geag ,nil ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gee .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_caced ,_cafg :=NewEncoderFromStream (streamObj );if _cafg !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_cafg );return nil ,_cafg ;};_gee .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_caced );_acddc ,_cafg :=_caced .DecodeStream (streamObj );if _cafg !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_cafg );return nil ,_cafg ;};return _acddc ,nil ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_effg *PdfObjectArray )Get (i int )PdfObject {if _effg ==nil ||i >=len (_effg ._gfdc )||i < 0{return nil ;};return _effg ._gfdc [i ];};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_dfaac *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dfaac .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_cece *PdfObjectArray ,_deag bool ){_cece ,_deag =TraceToDirectObject (obj ).(*PdfObjectArray );return _cece ,_deag ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_dea *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_bc ,_bdg :=obj .(*PdfObjectReference );if !_bdg {return obj ,nil ;};_gab :=_dea .GetFileOffset ();defer func (){_dea .SetFileOffset (_gab )}();_af ,_aba :=_dea .LookupByReference (*_bc );if _aba !=nil {return nil ,_aba ;};_eeb ,_afb :=_af .(*PdfIndirectObject );if !_afb {return _af ,nil ;};_af =_eeb .PdfObject ;_ ,_bdg =_af .(*PdfObjectReference );if _bdg {return _eeb ,_fd .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _af ,nil ;};

// String returns a string describing `array`.
func (_dafa *PdfObjectArray )String ()string {_daff :="\u005b";for _abgc ,_bgbg :=range _dafa .Elements (){_daff +=_bgbg .String ();if _abgc < (_dafa .Len ()-1){_daff +="\u002c\u0020";};};_daff +="\u005d";return _daff ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_fceb :=MakeArray ();for _ ,_bgbf :=range vals {_fceb .Append (MakeFloat (_bgbf ));};return _fceb ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_cbgg []StreamEncoder };func _beed (_cagf *PdfObjectStream ,_cdd *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_abcd :=NewCCITTFaxEncoder ();_bgcd :=_cagf .PdfObjectDictionary ;if _bgcd ==nil {return _abcd ,nil ;};if _cdd ==nil {_eadb :=TraceToDirectObject (_bgcd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _eadb !=nil {switch _efae :=_eadb .(type ){case *PdfObjectDictionary :_cdd =_efae ;case *PdfObjectArray :if _efae .Len ()==1{if _ddff ,_bge :=GetDict (_efae .Get (0));_bge {_cdd =_ddff ;};};default:_gee .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_eadb );return nil ,_fd .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cdd ==nil {_gee .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_eadb );return nil ,_fd .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _deba ,_ddc :=GetNumberAsInt64 (_cdd .Get ("\u004b"));_ddc ==nil {_abcd .K =int (_deba );};if _aegb ,_cfgbg :=GetNumberAsInt64 (_cdd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_cfgbg ==nil {_abcd .Columns =int (_aegb );}else {_abcd .Columns =1728;};if _decc ,_eded :=GetNumberAsInt64 (_cdd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eded ==nil {_abcd .BlackIs1 =_decc > 0;}else {if _agda ,_cbee :=GetBoolVal (_cdd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cbee {_abcd .BlackIs1 =_agda ;}else {if _gde ,_fecd :=GetArray (_cdd .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_fecd {_cacc ,_geffb :=_gde .ToIntegerArray ();if _geffb ==nil {_abcd .BlackIs1 =_cacc [0]==1&&_cacc [1]==0;};};};};if _cde ,_eggd :=GetNumberAsInt64 (_cdd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_eggd ==nil {_abcd .EncodedByteAlign =_cde > 0;}else {if _baead ,_edag :=GetBoolVal (_cdd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_edag {_abcd .EncodedByteAlign =_baead ;};};if _caf ,_dafb :=GetNumberAsInt64 (_cdd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dafb ==nil {_abcd .EndOfLine =_caf > 0;}else {if _deaf ,_bggea :=GetBoolVal (_cdd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bggea {_abcd .EndOfLine =_deaf ;};};if _cbbb ,_dedc :=GetNumberAsInt64 (_cdd .Get ("\u0052\u006f\u0077\u0073"));_dedc ==nil {_abcd .Rows =int (_cbbb );};_abcd .EndOfBlock =true ;if _cfcc ,_cbga :=GetNumberAsInt64 (_cdd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cbga ==nil {_abcd .EndOfBlock =_cfcc > 0;}else {if _ffgf ,_gaee :=GetBoolVal (_cdd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gaee {_abcd .EndOfBlock =_ffgf ;};};if _efba ,_ccfb :=GetNumberAsInt64 (_cdd .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_ccfb !=nil {_abcd .DamagedRowsBeforeError =int (_efba );};_gee .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cdd .String ());return _abcd ,nil ;};

// String returns a string describing `null`.
func (_beedf *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func _dbad (_ffga _ade .Image )*JBIG2Image {_fded :=_ffga .Base ();return &JBIG2Image {Data :_fded .Data ,Width :_fded .Width ,Height :_fded .Height ,HasPadding :true };};

// WriteString outputs the object as it is to be written to file.
func (_bbbfb *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_fggc *PdfObjectFloat ,_ffdb bool ){_fggc ,_ffdb =TraceToDirectObject (obj ).(*PdfObjectFloat );return _fggc ,_ffdb ;};func (_feg *PdfParser )lookupByNumberWrapper (_acg int ,_ec bool )(PdfObject ,bool ,error ){_egdd ,_ggd ,_gfa :=_feg .lookupByNumber (_acg ,_ec );if _gfa !=nil {return nil ,_ggd ,_gfa ;};if !_ggd &&_feg ._dfab !=nil &&!_feg ._dfab .isDecrypted (_egdd ){_dff :=_feg ._dfab .Decrypt (_egdd ,0,0);if _dff !=nil {return nil ,_ggd ,_dff ;};};return _egdd ,_ggd ,nil ;};

// String returns a descriptive information string about the encryption method used.
func (_ebb *PdfCrypt )String ()string {if _ebb ==nil {return "";};_ggc :=_ebb ._cdc .Filter +"\u0020\u002d\u0020";if _ebb ._cdc .V ==0{_ggc +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _ebb ._cdc .V ==1{_ggc +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _ebb ._cdc .V ==2{_ggc +=_fbg .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_ebb ._cdc .Length );}else if _ebb ._cdc .V ==3{_ggc +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _ebb ._cdc .V >=4{_ggc +=_fbg .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_ebb ._cfc ,_ebb ._aafa );_ggc +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _fab ,_gdaf :=range _ebb ._efb {_ggc +=_fbg .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_fab ,_gdaf .Name (),_gdaf .KeyLength ());};};_cfga :=_ebb .GetAccessPermissions ();_ggc +=_fbg .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_cfga );return _ggc ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_eeebd *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cgff :=_aaf .NewReader (encoded );var _agd []byte ;for {_afgf ,_febd :=_cgff .ReadByte ();if _febd !=nil {return nil ,_febd ;};if _afgf > 128{_fceg ,_gagd :=_cgff .ReadByte ();if _gagd !=nil {return nil ,_gagd ;};for _fcae :=0;_fcae < 257-int (_afgf );_fcae ++{_agd =append (_agd ,_fceg );};}else if _afgf < 128{for _gbf :=0;_gbf < int (_afgf )+1;_gbf ++{_eccd ,_baae :=_cgff .ReadByte ();if _baae !=nil {return nil ,_baae ;};_agd =append (_agd ,_eccd );};}else {break ;};};return _agd ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_fbgc *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_fgabg :=range another .Keys (){_fbgg :=another .Get (_fgabg );_fbgc .Set (_fgabg ,_fbgg );};};return _fbgc ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_bec *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _baec _aaf .Buffer ;_ebgb :=_aaf .NewReader (encoded );var _geed _fe .ReadCloser ;if _bec .EarlyChange ==1{_geed =_df .NewReader (_ebgb ,_df .MSB ,8);}else {_geed =_ac .NewReader (_ebgb ,_ac .MSB ,8);};defer _geed .Close ();_ ,_cgecd :=_baec .ReadFrom (_geed );if _cgecd !=nil {return nil ,_cgecd ;};return _baec .Bytes (),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_aecb *PdfObjectString )WriteString ()string {var _defg _aaf .Buffer ;if _aecb ._ffdg {_dcgc :=_aa .EncodeToString (_aecb .Bytes ());_defg .WriteString ("\u003c");_defg .WriteString (_dcgc );_defg .WriteString ("\u003e");return _defg .String ();};_bbbf :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_defg .WriteString ("\u0028");for _abfg :=0;_abfg < len (_aecb ._ecea );_abfg ++{_cgfd :=_aecb ._ecea [_abfg ];if _afec ,_bdcd :=_bbbf [_cgfd ];_bdcd {_defg .WriteString (_afec );}else {_defg .WriteByte (_cgfd );};};_defg .WriteString ("\u0029");return _defg .String ();};func _fed (_ebbg _dc .Filter ,_ffbg _ee .AuthEvent )*PdfObjectDictionary {if _ffbg ==""{_ffbg =_ee .EventDocOpen ;};_ebcd :=MakeDict ();_ebcd .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_ebcd .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_ffbg )));_ebcd .Set ("\u0043\u0046\u004d",MakeName (_ebbg .Name ()));_ebcd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_ebbg .KeyLength ())));return _ebcd ;};func (_ggfa *ASCII85Encoder )base256Tobase85 (_gfc uint32 )[5]byte {_eafe :=[5]byte {0,0,0,0,0};_fcca :=_gfc ;for _bcg :=0;_bcg < 5;_bcg ++{_bcefe :=uint32 (1);for _dadd :=0;_dadd < 4-_bcg ;_dadd ++{_bcefe *=85;};_eebbf :=_fcca /_bcefe ;_fcca =_fcca %_bcefe ;_eafe [_bcg ]=byte (_eebbf );};return _eafe ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_bfdg *PdfObjectString ,_fcbcd bool ){_bfdg ,_fcbcd =TraceToDirectObject (obj ).(*PdfObjectString );return _bfdg ,_fcbcd ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _gcace (o ,0,traversed );};func _cae (_acag _fe .ReadSeeker ,_fbbca int64 )(*offsetReader ,error ){_ggga :=&offsetReader {_fefd :_acag ,_bacg :_fbbca };_ ,_bcga :=_ggga .Seek (0,_fe .SeekStart );return _ggga ,_bcga ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _dc .Filter ,userPass ,ownerPass []byte ,perm _ee .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_dfd :=&PdfCrypt {_efa :make (map[PdfObject ]bool ),_efb :make (cryptFilters ),_facd :_ee .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _cbd Version ;if cf !=nil {_gce :=cf .PDFVersion ();_cbd .Major ,_cbd .Minor =_gce [0],_gce [1];V ,R :=cf .HandlerVersion ();_dfd ._cdc .V =V ;_dfd ._facd .R =R ;_dfd ._cdc .Length =cf .KeyLength ()*8;};const (_ddg =_bed ;);_dfd ._efb [_ddg ]=cf ;if _dfd ._cdc .V >=4{_dfd ._cfc =_ddg ;_dfd ._aafa =_ddg ;};_gag :=_dfd .newEncryptDict ();_eee :=_gd .Sum ([]byte (_gg .Now ().Format (_gg .RFC850 )));_eae :=string (_eee [:]);_ageg :=make ([]byte ,100);_b .Read (_ageg );_eee =_gd .Sum (_ageg );_faa :=string (_eee [:]);_gee .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_ageg );_gee .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_eae );_dfd ._ed =_eae ;_ae :=_dfd .generateParams (userPass ,ownerPass );if _ae !=nil {return nil ,nil ,_ae ;};_cac (&_dfd ._facd ,_gag );if _dfd ._cdc .V >=4{if _bgf :=_dfd .saveCryptFilters (_gag );_bgf !=nil {return nil ,nil ,_bgf ;};};return _dfd ,&EncryptInfo {Version :_cbd ,Encrypt :_gag ,ID0 :_eae ,ID1 :_faa },nil ;};func (_dcge *PdfParser )parseBool ()(PdfObjectBool ,error ){_gdacb ,_fbbd :=_dcge ._dbfg .Peek (4);if _fbbd !=nil {return PdfObjectBool (false ),_fbbd ;};if (len (_gdacb )>=4)&&(string (_gdacb [:4])=="\u0074\u0072\u0075\u0065"){_dcge ._dbfg .Discard (4);return PdfObjectBool (true ),nil ;};_gdacb ,_fbbd =_dcge ._dbfg .Peek (5);if _fbbd !=nil {return PdfObjectBool (false ),_fbbd ;};if (len (_gdacb )>=5)&&(string (_gdacb [:5])=="\u0066\u0061\u006cs\u0065"){_dcge ._dbfg .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_fd .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cfcfb *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fdc *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fdc .isEncrypted (obj ){return nil ;};switch _eccb :=obj .(type ){case *PdfIndirectObject :_fdc ._efa [_eccb ]=true ;_gee .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_eccb .ObjectNumber ,_eccb .GenerationNumber );_daf :=_eccb .ObjectNumber ;_fffa :=_eccb .GenerationNumber ;_dfae :=_fdc .Encrypt (_eccb .PdfObject ,_daf ,_fffa );if _dfae !=nil {return _dfae ;};return nil ;case *PdfObjectStream :_fdc ._efa [_eccb ]=true ;_cbed :=_eccb .PdfObjectDictionary ;if _fbc ,_dffg :=_cbed .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dffg &&*_fbc =="\u0058\u0052\u0065\u0066"{return nil ;};_cfec :=_eccb .ObjectNumber ;_fdca :=_eccb .GenerationNumber ;_gee .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_cfec ,_fdca );_aefg :=_bed ;if _fdc ._cdc .V >=4{_aefg =_fdc ._cfc ;_gee .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fdc ._cfc );if _aca ,_add :=_cbed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_add {if _gbcg ,_bfaa :=GetName (_aca .Get (0));_bfaa {if *_gbcg =="\u0043\u0072\u0079p\u0074"{_aefg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ecd ,_aefc :=_cbed .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_aefc {if _eadd ,_aeb :=_ecd .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_aeb {if _ ,_bcea :=_fdc ._efb [string (*_eadd )];_bcea {_gee .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_eadd );_aefg =string (*_eadd );};};};};};};_gee .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_aefg );if _aefg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_fgfc :=_fdc .Encrypt (_eccb .PdfObjectDictionary ,_cfec ,_fdca );if _fgfc !=nil {return _fgfc ;};_acf ,_fgfc :=_fdc .makeKey (_aefg ,uint32 (_cfec ),uint32 (_fdca ),_fdc ._aed );if _fgfc !=nil {return _fgfc ;};_eccb .Stream ,_fgfc =_fdc .encryptBytes (_eccb .Stream ,_aefg ,_acf );if _fgfc !=nil {return _fgfc ;};_cbed .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eccb .Stream ))));return nil ;case *PdfObjectString :_gee .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gdd :=_bed ;if _fdc ._cdc .V >=4{_gee .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fdc ._aafa );if _fdc ._aafa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gdd =_fdc ._aafa ;};_ega ,_cgfe :=_fdc .makeKey (_gdd ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fdc ._aed );if _cgfe !=nil {return _cgfe ;};_dgg :=_eccb .Str ();_abdb :=make ([]byte ,len (_dgg ));for _adf :=0;_adf < len (_dgg );_adf ++{_abdb [_adf ]=_dgg [_adf ];};_gee .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_abdb ,_abdb );_abdb ,_cgfe =_fdc .encryptBytes (_abdb ,_gdd ,_ega );if _cgfe !=nil {return _cgfe ;};_eccb ._ecea =string (_abdb );return nil ;case *PdfObjectArray :for _ ,_fbbc :=range _eccb .Elements (){_febf :=_fdc .Encrypt (_fbbc ,parentObjNum ,parentGenNum );if _febf !=nil {return _febf ;};};return nil ;case *PdfObjectDictionary :_fef :=false ;if _cbb :=_eccb .Get ("\u0054\u0079\u0070\u0065");_cbb !=nil {_ccb ,_edba :=_cbb .(*PdfObjectName );if _edba &&*_ccb =="\u0053\u0069\u0067"{_fef =true ;};};for _ ,_baea :=range _eccb .Keys (){_bbcc :=_eccb .Get (_baea );if _fef &&string (_baea )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_baea )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_baea )!="\u0050\u0072\u0065\u0076"&&string (_baea )!="\u004c\u0061\u0073\u0074"{_gfab :=_fdc .Encrypt (_bbcc ,parentObjNum ,parentGenNum );if _gfab !=nil {return _gfab ;};};};return nil ;};return nil ;};func _agae (_ffac int )int {_aabc :=_ffac >>(_aaca -1);return (_ffac ^_aabc )-_aabc };

// UpdateParams updates the parameter values of the encoder.
func (_ccgg *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_fbfa *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_dcg :=_aaf .NewReader (data );var _efe []byte ;var _gge []byte ;_cgce ,_geega :=_dcg .ReadByte ();if _geega ==_fe .EOF {return []byte {},nil ;}else if _geega !=nil {return nil ,_geega ;};_fbac :=1;for {_ffd ,_dcdcg :=_dcg .ReadByte ();if _dcdcg ==_fe .EOF {break ;}else if _dcdcg !=nil {return nil ,_dcdcg ;};if _ffd ==_cgce {if len (_gge )> 0{_gge =_gge [:len (_gge )-1];if len (_gge )> 0{_efe =append (_efe ,byte (len (_gge )-1));_efe =append (_efe ,_gge ...);};_fbac =1;_gge =[]byte {};};_fbac ++;if _fbac >=127{_efe =append (_efe ,byte (257-_fbac ),_cgce );_fbac =0;};}else {if _fbac > 0{if _fbac ==1{_gge =[]byte {_cgce };}else {_efe =append (_efe ,byte (257-_fbac ),_cgce );};_fbac =0;};_gge =append (_gge ,_ffd );if len (_gge )>=127{_efe =append (_efe ,byte (len (_gge )-1));_efe =append (_efe ,_gge ...);_gge =[]byte {};};};_cgce =_ffd ;};if len (_gge )> 0{_efe =append (_efe ,byte (len (_gge )-1));_efe =append (_efe ,_gge ...);}else if _fbac > 0{_efe =append (_efe ,byte (257-_fbac ),_cgce );};_efe =append (_efe ,128);return _efe ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgfb *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_baac :=MakeDict ();_baac .Set ("\u004b",MakeInteger (int64 (_fgfb .K )));_baac .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgfb .Columns )));if _fgfb .BlackIs1 {_baac .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_fgfb .BlackIs1 ));};if _fgfb .EncodedByteAlign {_baac .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_fgfb .EncodedByteAlign ));};if _fgfb .EndOfLine &&_fgfb .K >=0{_baac .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_fgfb .EndOfLine ));};if _fgfb .Rows !=0&&!_fgfb .EndOfBlock {_baac .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_fgfb .Rows )));};if !_fgfb .EndOfBlock {_baac .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_fgfb .EndOfBlock ));};if _fgfb .DamagedRowsBeforeError !=0{_baac .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_fgfb .DamagedRowsBeforeError )));};return _baac ;};func _dbga (_cfcge ,_feag ,_fage uint8 )uint8 {_bdabg :=int (_fage );_aface :=int (_feag )-_bdabg ;_aabf :=int (_cfcge )-_bdabg ;_bdabg =_agae (_aface +_aabf );_aface =_agae (_aface );_aabf =_agae (_aabf );if _aface <=_aabf &&_aface <=_bdabg {return _cfcge ;}else if _aabf <=_bdabg {return _feag ;};return _fage ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_egdg *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_eebda *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_cce :=MakeDict ();_cce .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eebda .GetFilterName ()));_gabe :=_eebda .MakeDecodeParams ();if _gabe !=nil {_cce .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gabe );};_cce .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_eebda .EarlyChange )));return _cce ;};

// UpdateParams updates the parameter values of the encoder.
func (_cbcg *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_bdgg ,_fde :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _fde ==nil {_cbcg .Predictor =int (_bdgg );};_acgga ,_fde :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fde ==nil {_cbcg .BitsPerComponent =int (_acgga );};_cfcb ,_fde :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fde ==nil {_cbcg .Columns =int (_cfcb );};_bbe ,_fde :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fde ==nil {_cbcg .Colors =int (_bbe );};};func (_fgg *PdfCrypt )authenticate (_fba []byte )(bool ,error ){_fgg ._bcb =false ;_abb :=_fgg .securityHandler ();_bccb ,_bad ,_fgb :=_abb .Authenticate (&_fgg ._facd ,_fba );if _fgb !=nil {return false ,_fgb ;}else if _bad ==0||len (_bccb )==0{return false ,nil ;};_fgg ._bcb =true ;_fgg ._aed =_bccb ;return true ,nil ;};func (_bfbdf *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_bfbdf ._dbfg )};

// Clear resets the dictionary to an empty state.
func (_dfgg *PdfObjectDictionary )Clear (){_dfgg ._aeba =[]PdfObjectName {};_dfgg ._bagbd =map[PdfObjectName ]PdfObject {};};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_eedb *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_eedb ._gfdc ){return _fd .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_eedb ._gfdc [i ]=obj ;return nil ;};const _gcaa =10;const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_aga *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _aga .isDecrypted (obj ){return nil ;};switch _cgec :=obj .(type ){case *PdfIndirectObject :_aga ._ggf [_cgec ]=true ;_gee .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_cgec .ObjectNumber ,_cgec .GenerationNumber );_ddd :=_cgec .ObjectNumber ;_cbc :=_cgec .GenerationNumber ;_gea :=_aga .Decrypt (_cgec .PdfObject ,_ddd ,_cbc );if _gea !=nil {return _gea ;};return nil ;case *PdfObjectStream :_aga ._ggf [_cgec ]=true ;_fcb :=_cgec .PdfObjectDictionary ;if _aga ._facd .R !=5{if _acgg ,_bfc :=_fcb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bfc &&*_acgg =="\u0058\u0052\u0065\u0066"{return nil ;};};_cdcc :=_cgec .ObjectNumber ;_gfag :=_cgec .GenerationNumber ;_gee .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_cdcc ,_gfag );_gafd :=_bed ;if _aga ._cdc .V >=4{_gafd =_aga ._cfc ;_gee .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_aga ._cfc );if _bfbg ,_bcf :=_fcb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_bcf {if _feda ,_gdcb :=GetName (_bfbg .Get (0));_gdcb {if *_feda =="\u0043\u0072\u0079p\u0074"{_gafd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eecg ,_bca :=_fcb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_bca {if _geg ,_bbcb :=_eecg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bbcb {if _ ,_dfa :=_aga ._efb [string (*_geg )];_dfa {_gee .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_geg );_gafd =string (*_geg );};};};};};};_gee .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gafd );if _gafd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_fedb :=_aga .Decrypt (_fcb ,_cdcc ,_gfag );if _fedb !=nil {return _fedb ;};_fec ,_fedb :=_aga .makeKey (_gafd ,uint32 (_cdcc ),uint32 (_gfag ),_aga ._aed );if _fedb !=nil {return _fedb ;};_cgec .Stream ,_fedb =_aga .decryptBytes (_cgec .Stream ,_gafd ,_fec );if _fedb !=nil {return _fedb ;};_fcb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cgec .Stream ))));return nil ;case *PdfObjectString :_gee .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_efc :=_bed ;if _aga ._cdc .V >=4{_gee .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_aga ._aafa );if _aga ._aafa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_efc =_aga ._aafa ;};_gae ,_dbe :=_aga .makeKey (_efc ,uint32 (parentObjNum ),uint32 (parentGenNum ),_aga ._aed );if _dbe !=nil {return _dbe ;};_bbf :=_cgec .Str ();_accg :=make ([]byte ,len (_bbf ));for _bcaf :=0;_bcaf < len (_bbf );_bcaf ++{_accg [_bcaf ]=_bbf [_bcaf ];};_gee .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_accg ,_accg );_accg ,_dbe =_aga .decryptBytes (_accg ,_efc ,_gae );if _dbe !=nil {return _dbe ;};_cgec ._ecea =string (_accg );return nil ;case *PdfObjectArray :for _ ,_gabd :=range _cgec .Elements (){_fgf :=_aga .Decrypt (_gabd ,parentObjNum ,parentGenNum );if _fgf !=nil {return _fgf ;};};return nil ;case *PdfObjectDictionary :_dfdb :=false ;if _cgd :=_cgec .Get ("\u0054\u0079\u0070\u0065");_cgd !=nil {_gafa ,_geac :=_cgd .(*PdfObjectName );if _geac &&*_gafa =="\u0053\u0069\u0067"{_dfdb =true ;};};for _ ,_bcae :=range _cgec .Keys (){_aef :=_cgec .Get (_bcae );if _dfdb &&string (_bcae )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_bcae )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_bcae )!="\u0050\u0072\u0065\u0076"&&string (_bcae )!="\u004c\u0061\u0073\u0074"{_bfd :=_aga .Decrypt (_aef ,parentObjNum ,parentGenNum );if _bfd !=nil {return _bfd ;};};};return nil ;};return nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_gfdc []PdfObject };

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_edgg :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_edgg .PdfObjectDictionary =encoder .MakeStreamDict ();_cbcfa ,_dbbf :=encoder .EncodeBytes (contents );if _dbbf !=nil {return nil ,_dbbf ;};_edgg .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cbcfa ))));_edgg .Stream =_cbcfa ;return _edgg ,nil ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_bgac :=MakeArray ();for _ ,_cfgcg :=range vals {_bgac .Append (MakeInteger (_cfgcg ));};return _bgac ;};func (_gadf *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _gadf ._cbedg {return nil ,_fbg .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_gadf ._cbedg =true ;_gadf ._ggggc .Seek (0,_fe .SeekStart );_gadf ._dbfg =_dd .NewReader (_gadf ._ggggc );_efdc :=20;_eacb :=make ([]byte ,_efdc );_eedge :=XrefTable {};_eedge .ObjectMap =make (map[int ]XrefObject );for {_deeg ,_ddce :=_gadf ._dbfg .ReadByte ();if _ddce !=nil {if _ddce ==_fe .EOF {break ;}else {return nil ,_ddce ;};};if _deeg =='j'&&_eacb [_efdc -1]=='b'&&_eacb [_efdc -2]=='o'&&IsWhiteSpace (_eacb [_efdc -3]){_cfcfe :=_efdc -4;for IsWhiteSpace (_eacb [_cfcfe ])&&_cfcfe > 0{_cfcfe --;};if _cfcfe ==0||!IsDecimalDigit (_eacb [_cfcfe ]){continue ;};for IsDecimalDigit (_eacb [_cfcfe ])&&_cfcfe > 0{_cfcfe --;};if _cfcfe ==0||!IsWhiteSpace (_eacb [_cfcfe ]){continue ;};for IsWhiteSpace (_eacb [_cfcfe ])&&_cfcfe > 0{_cfcfe --;};if _cfcfe ==0||!IsDecimalDigit (_eacb [_cfcfe ]){continue ;};for IsDecimalDigit (_eacb [_cfcfe ])&&_cfcfe > 0{_cfcfe --;};if _cfcfe ==0{continue ;};_gefad :=_gadf .GetFileOffset ()-int64 (_efdc -_cfcfe );_ebag :=append (_eacb [_cfcfe +1:],_deeg );_eddgf ,_afbgc ,_bdgf :=_acffd (string (_ebag ));if _bdgf !=nil {_gee .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_bdgf );return nil ,_bdgf ;};if _daga ,_cfbc :=_eedge .ObjectMap [_eddgf ];!_cfbc ||_daga .Generation < _afbgc {_abgg :=XrefObject {};_abgg .XType =XrefTypeTableEntry ;_abgg .ObjectNumber =_eddgf ;_abgg .Generation =_afbgc ;_abgg .Offset =_gefad ;_eedge .ObjectMap [_eddgf ]=_abgg ;};};_eacb =append (_eacb [1:_efdc ],_deeg );};return &_eedge ,nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_gbeg *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_fgdga ,_becbb :=_gbeg ._bagbd [key ];if !_becbb {return nil ;};return _fgdga ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_dafc *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gee .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_ffca :=_aaf .NewReader (encoded );_bgfa ,_gdae :=_c .NewReader (_ffca );if _gdae !=nil {_gee .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_gdae );_gee .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_gdae ;};defer _bgfa .Close ();var _gdf _aaf .Buffer ;_gdf .ReadFrom (_bgfa );return _gdf .Bytes (),nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_dgef *_be .Document ;

// Globals are the JBIG2 global segments.
Globals _ba .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_bacb *PdfObjectArray )Elements ()[]PdfObject {if _bacb ==nil {return nil ;};return _bacb ._gfdc ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_cggf *FlateEncoder )SetPredictor (columns int ){_cggf .Predictor =11;_cggf .Columns =columns };

// GetFilterName returns the name of the encoding filter.
func (_cdfb *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_becc *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_dagf :=PdfIndirectObject {};_dagf ._gedg =_becc ;_gee .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_eadf ,_eceda :=_becc ._dbfg .Peek (20);if _eceda !=nil {if _eceda !=_fe .EOF {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_dagf ,_eceda ;};};_gee .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_eadf ));_eabf :=_gcgb .FindStringSubmatchIndex (string (_eadf ));if len (_eabf )< 6{if _eceda ==_fe .EOF {return nil ,_eceda ;};_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_eadf ));return &_dagf ,_fd .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_becc ._dbfg .Discard (_eabf [0]);_gee .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_eabf );_bbfe :=_eabf [1]-_eabf [0];_adae :=make ([]byte ,_bbfe );_ ,_eceda =_becc .ReadAtLeast (_adae ,_bbfe );if _eceda !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_eceda );return nil ,_eceda ;};_gee .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_adae );_ffab :=_gcgb .FindStringSubmatch (string (_adae ));if len (_ffab )< 3{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_adae ));return &_dagf ,_fd .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_egdf ,_ :=_d .Atoi (_ffab [1]);_bgee ,_ :=_d .Atoi (_ffab [2]);_dagf .ObjectNumber =int64 (_egdf );_dagf .GenerationNumber =int64 (_bgee );for {_becb ,_ffeag :=_becc ._dbfg .Peek (2);if _ffeag !=nil {return &_dagf ,_ffeag ;};_gee .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_becb ),string (_becb ));if IsWhiteSpace (_becb [0]){_becc .skipSpaces ();}else if _becb [0]=='%'{_becc .skipComments ();}else if (_becb [0]=='<')&&(_becb [1]=='<'){_gee .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_dagf .PdfObject ,_ffeag =_becc .ParseDict ();_gee .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_ffeag );if _ffeag !=nil {return &_dagf ,_ffeag ;};_gee .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_becb [0]=='/')||(_becb [0]=='(')||(_becb [0]=='[')||(_becb [0]=='<'){_dagf .PdfObject ,_ffeag =_becc .parseObject ();if _ffeag !=nil {return &_dagf ,_ffeag ;};_gee .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _becb [0]==']'{_gee .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_becc ._dbfg .Discard (1);}else {if _becb [0]=='e'{_daegb ,_gfbea :=_becc .readTextLine ();if _gfbea !=nil {return nil ,_gfbea ;};if len (_daegb )>=6&&_daegb [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _becb [0]=='s'{_becb ,_ =_becc ._dbfg .Peek (10);if string (_becb [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_bbff :=6;if len (_becb )> 6{if IsWhiteSpace (_becb [_bbff ])&&_becb [_bbff ]!='\r'&&_becb [_bbff ]!='\n'{_gee .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_bbff ++;};if _becb [_bbff ]=='\r'{_bbff ++;if _becb [_bbff ]=='\n'{_bbff ++;};}else if _becb [_bbff ]=='\n'{_bbff ++;};};_becc ._dbfg .Discard (_bbff );_ggdac ,_fgee :=_dagf .PdfObject .(*PdfObjectDictionary );if !_fgee {return nil ,_fd .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gee .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_ggdac );_ggbe ,_cccg :=_becc .traceStreamLength (_ggdac .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _cccg !=nil {_gee .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_cccg );return nil ,_cccg ;};_gee .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_ggbe );_dgeb ,_ggade :=_ggbe .(*PdfObjectInteger );if !_ggade {return nil ,_fd .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_fgaaa :=*_dgeb ;if _fgaaa < 0{return nil ,_fd .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_efeeb :=_becc .GetFileOffset ();_gbced :=_becc .xrefNextObjectOffset (_efeeb );if _efeeb +int64 (_fgaaa )> _gbced &&_gbced > _efeeb {_gee .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_efeeb +int64 (_fgaaa ));_gee .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_gbced );_afef :=_gbced -_efeeb -17;if _afef < 0{return nil ,_fd .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_gee .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_afef );_fgaaa =PdfObjectInteger (_afef );_ggdac .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_afef ));};if int64 (_fgaaa )> _becc ._eagf {_gee .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_fd .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_ccef :=make ([]byte ,_fgaaa );_ ,_cccg =_becc .ReadAtLeast (_ccef ,int (_fgaaa ));if _cccg !=nil {_gee .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_ccef ),_ccef );_gee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cccg );return nil ,_cccg ;};_cbbba :=PdfObjectStream {};_cbbba .Stream =_ccef ;_cbbba .PdfObjectDictionary =_dagf .PdfObject .(*PdfObjectDictionary );_cbbba .ObjectNumber =_dagf .ObjectNumber ;_cbbba .GenerationNumber =_dagf .GenerationNumber ;_cbbba .PdfObjectReference ._gedg =_becc ;_becc .skipSpaces ();_becc ._dbfg .Discard (9);_becc .skipSpaces ();return &_cbbba ,nil ;};};_dagf .PdfObject ,_ffeag =_becc .parseObject ();if _dagf .PdfObject ==nil {_gee .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_dagf .PdfObject =MakeNull ();};return &_dagf ,_ffeag ;};};if _dagf .PdfObject ==nil {_gee .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_dagf .PdfObject =MakeNull ();};_gee .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_dagf ,nil ;};var _adce =_gc .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// UpdateParams updates the parameter values of the encoder.
func (_eeba *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _dced ,_abcf :=GetNumberAsInt64 (params .Get ("\u004b"));_abcf ==nil {_eeba .K =int (_dced );};if _bdgee ,_daee :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_daee ==nil {_eeba .Columns =int (_bdgee );}else if _bdgee ,_daee =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_daee ==nil {_eeba .Columns =int (_bdgee );};if _aebdc ,_dgfg :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dgfg ==nil {_eeba .BlackIs1 =_aebdc > 0;}else {if _ddfc ,_cfda :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cfda {_eeba .BlackIs1 =_ddfc ;}else {if _aab ,_dgee :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_dgee {_egfa ,_aagb :=_aab .ToIntegerArray ();if _aagb ==nil {_eeba .BlackIs1 =_egfa [0]==1&&_egfa [1]==0;};};};};if _fddf ,_fgaa :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fgaa ==nil {_eeba .EncodedByteAlign =_fddf > 0;}else {if _babe ,_bebc :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bebc {_eeba .EncodedByteAlign =_babe ;};};if _geaa ,_dage :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dage ==nil {_eeba .EndOfLine =_geaa > 0;}else {if _bdb ,_gcga :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gcga {_eeba .EndOfLine =_bdb ;};};if _gaff ,_fffe :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_fffe ==nil {_eeba .Rows =int (_gaff );}else if _gaff ,_fffe =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_fffe ==nil {_eeba .Rows =int (_gaff );};if _babea ,_deac :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_deac ==nil {_eeba .EndOfBlock =_babea > 0;}else {if _begg ,_abe :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_abe {_eeba .EndOfBlock =_begg ;};};if _cfgae ,_baeg :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_baeg !=nil {_eeba .DamagedRowsBeforeError =int (_cfgae );};};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_gbg *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gbg .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// String returns a string describing `ind`.
func (_bddb *PdfIndirectObject )String ()string {return _fbg .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_bddb ).ObjectNumber );};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_dfddb :=&ASCIIHexEncoder {};return _dfddb };func _cec (_ea XrefTable ){_gee .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_gee .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_fac :=0;for _ ,_cgg :=range _ea .ObjectMap {_gee .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_fac +1,_cgg .ObjectNumber ,_cgg .Generation ,_cgg .Offset );_fac ++;};};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ggdad *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _ecbbc []int ;for _ ,_eccba :=range _ggdad .Elements (){if _gcgbb ,_bggc :=_eccba .(*PdfObjectInteger );_bggc {_ecbbc =append (_ecbbc ,int (*_gcgbb ));}else {return nil ,ErrTypeError ;};};return _ecbbc ,nil ;};func _cddb (_efded PdfObject ,_gaec int )PdfObject {if _gaec > _gcaa {_gee .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_gcaa );return MakeNull ();};switch _cdea :=_efded .(type ){case *PdfIndirectObject :_efded =_cddb ((*_cdea ).PdfObject ,_gaec +1);case *PdfObjectArray :for _dcad ,_abda :=range (*_cdea )._gfdc {(*_cdea )._gfdc [_dcad ]=_cddb (_abda ,_gaec +1);};case *PdfObjectDictionary :for _geacd ,_dbeag :=range (*_cdea )._bagbd {(*_cdea )._bagbd [_geacd ]=_cddb (_dbeag ,_gaec +1);};_fb .Slice ((*_cdea )._aeba ,func (_edbfe ,_ddcbb int )bool {return (*_cdea )._aeba [_edbfe ]< (*_cdea )._aeba [_ddcbb ]});};return _efded ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_adbd :=&PdfIndirectObject {};_adbd .PdfObject =obj ;return _adbd ;};func (_ffed *PdfCrypt )loadCryptFilters (_edf *PdfObjectDictionary )error {_ffed ._efb =cryptFilters {};_baf :=_edf .Get ("\u0043\u0046");_baf =TraceToDirectObject (_baf );if _ggda ,_bdf :=_baf .(*PdfObjectReference );_bdf {_facc ,_fda :=_ffed ._fcd .LookupByReference (*_ggda );if _fda !=nil {_gee .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _fda ;};_baf =TraceToDirectObject (_facc );};_dcd ,_ece :=_baf .(*PdfObjectDictionary );if !_ece {_gee .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_baf );return _fd .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_aea :=range _dcd .Keys (){_abac :=_dcd .Get (_aea );if _ceg ,_bccd :=_abac .(*PdfObjectReference );_bccd {_egdc ,_bce :=_ffed ._fcd .LookupByReference (*_ceg );if _bce !=nil {_gee .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _bce ;};_abac =TraceToDirectObject (_egdc );};_gdgd ,_gbce :=_abac .(*PdfObjectDictionary );if !_gbce {return _fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_aea ,_abac );};if _aea =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _gbb _dc .FilterDict ;if _ddf :=_aacd (&_gbb ,_gdgd );_ddf !=nil {return _ddf ;};_adb ,_ebc :=_dc .NewFilter (_gbb );if _ebc !=nil {return _ebc ;};_ffed ._efb [string (_aea )]=_adb ;};_ffed ._efb ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_dc .NewIdentity ();_ffed ._aafa ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fce ,_ecc :=_edf .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ecc {if _ ,_bdge :=_ffed ._efb [string (*_fce )];!_bdge {return _fbg .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fce );};_ffed ._aafa =string (*_fce );};_ffed ._cfc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dge ,_bbcf :=_edf .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_bbcf {if _ ,_eeg :=_ffed ._efb [string (*_dge )];!_eeg {return _fbg .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dge );};_ffed ._cfc =string (*_dge );};return nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_dceg *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_dface :=_dceg ._bagbd [key ];if !_dface {_dceg ._aeba =append (_dceg ._aeba ,key );};_dceg ._bagbd [key ]=val ;};func _gec (_dfg PdfObject )(int64 ,int64 ,error ){if _bd ,_feb :=_dfg .(*PdfIndirectObject );_feb {return _bd .ObjectNumber ,_bd .GenerationNumber ,nil ;};if _adc ,_cff :=_dfg .(*PdfObjectStream );_cff {return _adc .ObjectNumber ,_adc .GenerationNumber ,nil ;};return 0,0,_fd .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_gbfd []float64 ,_cabf error ){for _ ,_fafd :=range objects {_gagfd ,_bgeb :=GetNumberAsFloat (_fafd );if _bgeb !=nil {return nil ,_bgeb ;};_gbfd =append (_gbfd ,_gagfd );};return _gbfd ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fegc *PdfObjectInteger )WriteString ()string {return _d .FormatInt (int64 (*_fegc ),10)};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_dfdd *PdfObjectDictionary );EncodeBytes (_cfgd []byte )([]byte ,error );DecodeBytes (_cee []byte )([]byte ,error );DecodeStream (_abg *PdfObjectStream )([]byte ,error );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_def *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_dfge :=MakeDict ();_dfge .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_def .GetFilterName ()));return _dfge ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_ddfgd *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gffb :=&_gda .Encoder {K :_ddfgd .K ,Columns :_ddfgd .Columns ,EndOfLine :_ddfgd .EndOfLine ,EndOfBlock :_ddfgd .EndOfBlock ,BlackIs1 :_ddfgd .BlackIs1 ,DamagedRowsBeforeError :_ddfgd .DamagedRowsBeforeError ,Rows :_ddfgd .Rows ,EncodedByteAlign :_ddfgd .EncodedByteAlign };_adcb ,_eaac :=_gffb .Decode (encoded );if _eaac !=nil {return nil ,_eaac ;};var _fffb []byte ;_fffc :=0;var _gbcb byte ;var _ffcf byte ;for _beac :=range _adcb {if _gbcb !=0{_fffb =append (_fffb ,_ffcf );_ffcf =0;_fffc ++;_gbcb =0;};for _eebba :=range _adcb [_beac ]{_ffcf |=_adcb [_beac ][_eebba ]<<(7-_gbcb );_gbcb ++;if _gbcb ==8{_fffb =append (_fffb ,_ffcf );_ffcf =0;_fffc ++;_gbcb =0;};};};if _gbcb > 0{_fffb =append (_fffb ,_ffcf );};return _fffb ,nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_gbdcg :=PdfObjectString {_ecea :s };return &_gbdcg };

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_de *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_da ,_ ,_gaf :=_de .lookupByNumberWrapper (objNumber ,true );return _da ,_gaf ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_dagc *PdfParser )GetCrypter ()*PdfCrypt {return _dagc ._dfab };type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_dc .FilterDict ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_gecb :=MakeArray ();for _ ,_gcge :=range vals {_gecb .Append (MakeInteger (int64 (_gcge )));};return _gecb ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_aee *PdfParser )GetTrailer ()*PdfObjectDictionary {return _aee ._bdce };func (_gcac *offsetReader )Read (p []byte )(_bbceg int ,_fee error ){return _gcac ._fefd .Read (p )};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_dabg *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dabg ._cbbd ){return _fd .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dabg ._cbbd [i ]=obj ;return nil ;};type offsetReader struct{_fefd _fe .ReadSeeker ;_bacg int64 ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_afcc *PdfObjectInteger ,_ebda bool ){_afcc ,_ebda =TraceToDirectObject (obj ).(*PdfObjectInteger );return _afcc ,_ebda ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_dgcc Version ;_ggggc _fe .ReadSeeker ;_dbfg *_dd .Reader ;_eagf int64 ;_gdfb XrefTable ;_abec int64 ;_ccgb *xrefType ;_edbb objectStreams ;_bdce *PdfObjectDictionary ;_dfab *PdfCrypt ;_cbedg bool ;ObjCache objectCache ;_afdg map[int64 ]bool ;};func _cac (_bcc *_ee .StdEncryptDict ,_ebf *PdfObjectDictionary ){_ebf .Set ("\u0052",MakeInteger (int64 (_bcc .R )));_ebf .Set ("\u0050",MakeInteger (int64 (_bcc .P )));_ebf .Set ("\u004f",MakeStringFromBytes (_bcc .O ));_ebf .Set ("\u0055",MakeStringFromBytes (_bcc .U ));if _bcc .R >=5{_ebf .Set ("\u004f\u0045",MakeStringFromBytes (_bcc .OE ));_ebf .Set ("\u0055\u0045",MakeStringFromBytes (_bcc .UE ));_ebf .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_bcc .EncryptMetadata ));if _bcc .R > 5{_ebf .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_bcc .Perms ));};};};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dbcb *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _febc []int64 ;for _ ,_edaf :=range _dbcb .Elements (){if _gaaaa ,_ggfb :=_edaf .(*PdfObjectInteger );_ggfb {_febc =append (_febc ,int64 (*_gaaaa ));}else {return nil ,ErrTypeError ;};};return _febc ,nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_bfdd *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gee .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_gee .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_bfdd .Predictor );_cace ,_bfe :=_bfdd .DecodeBytes (streamObj .Stream );if _bfe !=nil {return nil ,_bfe ;};_gee .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_gee .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_cace ),_cace );if _bfdd .Predictor > 1{if _bfdd .Predictor ==2{_gee .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_eaf :=_bfdd .Columns *_bfdd .Colors ;if _eaf < 1{return []byte {},nil ;};_fcdf :=len (_cace )/_eaf ;if len (_cace )%_eaf !=0{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cace ),_eaf );};if _eaf %_bfdd .Colors !=0{return nil ,_fbg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_eaf ,_bfdd .Colors );};if _eaf > len (_cace ){_gee .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_eaf ,len (_cace ));return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gee .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_cace ),_cace );_dbc :=_aaf .NewBuffer (nil );for _dddc :=0;_dddc < _fcdf ;_dddc ++{_dgcb :=_cace [_eaf *_dddc :_eaf *(_dddc +1)];for _fabg :=_bfdd .Colors ;_fabg < _eaf ;_fabg ++{_dgcb [_fabg ]=byte (int (_dgcb [_fabg ]+_dgcb [_fabg -_bfdd .Colors ])%256);};_dbc .Write (_dgcb );};_ebdd :=_dbc .Bytes ();_gee .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_ebdd ),_ebdd );return _ebdd ,nil ;}else if _bfdd .Predictor >=10&&_bfdd .Predictor <=15{_gee .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bdgd :=_bfdd .Columns *_bfdd .Colors +1;if _bdgd < 1{return []byte {},nil ;};_beab :=len (_cace )/_bdgd ;if len (_cace )%_bdgd !=0{return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cace ),_bdgd );};if _bdgd > len (_cace ){_gee .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bdgd ,len (_cace ));return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cdfg :=_aaf .NewBuffer (nil );_gee .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_bfdd .Columns );_gee .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_cace ),_bdgd ,_beab );_cga :=make ([]byte ,_bdgd );for _dbfb :=0;_dbfb < _bdgd ;_dbfb ++{_cga [_dbfb ]=0;};for _bddc :=0;_bddc < _beab ;_bddc ++{_bfg :=_cace [_bdgd *_bddc :_bdgd *(_bddc +1)];_cdg :=_bfg [0];switch _cdg {case 0:case 1:for _abbf :=2;_abbf < _bdgd ;_abbf ++{_bfg [_abbf ]=byte (int (_bfg [_abbf ]+_bfg [_abbf -1])%256);};case 2:for _gef :=1;_gef < _bdgd ;_gef ++{_bfg [_gef ]=byte (int (_bfg [_gef ]+_cga [_gef ])%256);};default:_gee .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cdg );return nil ,_fbg .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cdg );};for _afa :=0;_afa < _bdgd ;_afa ++{_cga [_afa ]=_bfg [_afa ];};_cdfg .Write (_bfg [1:]);};_dad :=_cdfg .Bytes ();return _dad ,nil ;}else {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_bfdd .Predictor );return nil ,_fbg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_bfdd .Predictor );};};return _cace ,nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_ceee *PdfObjectStream ,_bafd bool ){obj =ResolveReference (obj );_ceee ,_bafd =obj .(*PdfObjectStream );return _ceee ,_bafd ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_dgd *PdfCrypt )GetAccessPermissions ()_ee .Permissions {return _dgd ._facd .P };func (_eebd *PdfCrypt )makeKey (_efg string ,_dgcd ,_dbg uint32 ,_dbf []byte )([]byte ,error ){_cba ,_dffb :=_eebd ._efb [_efg ];if !_dffb {return nil ,_fbg .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_efg );};return _cba .MakeKey (_dgcd ,_dbg ,_dbf );};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_dfdc :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _dfdc ==nil {return NewRawEncoder (),nil ;};if _ ,_edbgc :=_dfdc .(*PdfObjectNull );_edbgc {return NewRawEncoder (),nil ;};_bbdbd ,_cgffee :=_dfdc .(*PdfObjectName );if !_cgffee {_ecca ,_fbdbf :=_dfdc .(*PdfObjectArray );if !_fbdbf {return nil ,_fbg .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _ecca .Len ()==0{return NewRawEncoder (),nil ;};if _ecca .Len ()!=1{_cbafd ,_ccec :=_bgaf (streamObj );if _ccec !=nil {_gee .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_ccec );return nil ,_ccec ;};_gee .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_cbafd );return _cbafd ,nil ;};_dfdc =_ecca .Get (0);_bbdbd ,_fbdbf =_dfdc .(*PdfObjectName );if !_fbdbf {return nil ,_fbg .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_bbdbd {case StreamEncodingFilterNameFlate :return _aae (streamObj ,nil );case StreamEncodingFilterNameLZW :return _dee (streamObj ,nil );case StreamEncodingFilterNameDCT :return _ebac (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _fcfcc (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _beed (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _agc (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_gee .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_fbg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bbdbd );};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _aaag :=obj .(type ){case *PdfObjectFloat :_gee .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_aaag ),nil ;case *PdfObjectInteger :return int64 (*_aaag ),nil ;};return 0,ErrNotANumber ;};func (_caab *PdfParser )parseXrefStream (_cgdb *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _cgdb !=nil {_gee .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_cgdb );_caab ._ggggc .Seek (int64 (*_cgdb ),_fe .SeekStart );_caab ._dbfg =_dd .NewReader (_caab ._ggggc );};_fcgdc :=_caab .GetFileOffset ();_bgdd ,_gbaa :=_caab .ParseIndirectObject ();if _gbaa !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_fd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_gee .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_bgdd );_gdb ,_adfg :=_bgdd .(*PdfObjectStream );if !_adfg {_gee .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_fd .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_gdddg :=_gdb .PdfObjectDictionary ;_dbbg ,_adfg :=_gdb .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_adfg {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_fd .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_dbbg )> 8388607{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_dbbg );return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_efbad :=_gdb .PdfObjectDictionary .Get ("\u0057");_aedeb ,_adfg :=_efbad .(*PdfObjectArray );if !_adfg {return nil ,_fd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_gbef :=_aedeb .Len ();if _gbef !=3{_gee .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_gbef );return nil ,_fd .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _ffgab []int64 ;for _ffeaa :=0;_ffeaa < 3;_ffeaa ++{_gbca ,_gbbc :=GetInt (_aedeb .Get (_ffeaa ));if !_gbbc {return nil ,_fd .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_ffgab =append (_ffgab ,int64 (*_gbca ));};_daaa ,_gbaa :=DecodeStream (_gdb );if _gbaa !=nil {_gee .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_gbaa );return nil ,_gbaa ;};_gddfa :=int (_ffgab [0]);_dgab :=int (_ffgab [0]+_ffgab [1]);_baabc :=int (_ffgab [0]+_ffgab [1]+_ffgab [2]);_efddd :=int (_ffgab [0]+_ffgab [1]+_ffgab [2]);if _gddfa < 0||_dgab < 0||_baabc < 0{_gee .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_gddfa ,_dgab ,_baabc );return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _efddd ==0{_gee .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _gdddg ,nil ;};_efag :=len (_daaa )/_efddd ;_dfe :=0;_baddd :=_gdb .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _dggb []int ;if _baddd !=nil {_gee .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_baddd );_fgcad ,_dcdaa :=_baddd .(*PdfObjectArray );if !_dcdaa {_gee .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_fd .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _fgcad .Len ()%2!=0{_gee .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_fd .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dfe =0;_edbc ,_cggb :=_fgcad .ToIntegerArray ();if _cggb !=nil {_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_cggb );return nil ,_cggb ;};for _abea :=0;_abea < len (_edbc );_abea +=2{_bdace :=_edbc [_abea ];_dafd :=_edbc [_abea +1];for _ebba :=0;_ebba < _dafd ;_ebba ++{_dggb =append (_dggb ,_bdace +_ebba );};_dfe +=_dafd ;};}else {for _cbcga :=0;_cbcga < int (*_dbbg );_cbcga ++{_dggb =append (_dggb ,_cbcga );};_dfe =int (*_dbbg );};if _efag ==_dfe +1{_gee .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_acgdg :=_dfe -1;for _ ,_eebg :=range _dggb {if _eebg > _acgdg {_acgdg =_eebg ;};};_dggb =append (_dggb ,_acgdg +1);_dfe ++;};if _efag !=len (_dggb ){_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_efag ,len (_dggb ));return nil ,_fd .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_gee .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_dfe );_gee .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_dggb );_gead :=func (_cfcbb []byte )int64 {var _afdf int64 ;for _dgac :=0;_dgac < len (_cfcbb );_dgac ++{_afdf +=int64 (_cfcbb [_dgac ])*(1<<uint (8*(len (_cfcbb )-_dgac -1)));};return _afdf ;};_gee .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_daaa ));_beba :=0;for _addg :=0;_addg < len (_daaa );_addg +=_efddd {_fcad :=_fgac (len (_daaa ),_addg ,_addg +_gddfa );if _fcad !=nil {_gee .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcad );return nil ,_fcad ;};_bffd :=_daaa [_addg :_addg +_gddfa ];_fcad =_fgac (len (_daaa ),_addg +_gddfa ,_addg +_dgab );if _fcad !=nil {_gee .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcad );return nil ,_fcad ;};_dgdc :=_daaa [_addg +_gddfa :_addg +_dgab ];_fcad =_fgac (len (_daaa ),_addg +_dgab ,_addg +_baabc );if _fcad !=nil {_gee .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcad );return nil ,_fcad ;};_efece :=_daaa [_addg +_dgab :_addg +_baabc ];_ffgca :=_gead (_bffd );_eaeac :=_gead (_dgdc );_agfd :=_gead (_efece );if _ffgab [0]==0{_ffgca =1;};if _beba >=len (_dggb ){_gee .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_gcgc :=_dggb [_beba ];_beba ++;_gee .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_gcgc ,_bffd );_gee .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_gcgc ,_dgdc );_gee .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_gcgc ,_efece );_gee .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_gcgc ,_ffgca ,_eaeac ,_agfd );if _ffgca ==0{_gee .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _ffgca ==1{_gee .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_dgdc );if _eaeac ==_fcgdc {_gee .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_gcgc ,_gdb .ObjectNumber );_gcgc =int (_gdb .ObjectNumber );};if _cecdb ,_abfa :=_caab ._gdfb .ObjectMap [_gcgc ];!_abfa ||int (_agfd )> _cecdb .Generation {_bfdda :=XrefObject {ObjectNumber :_gcgc ,XType :XrefTypeTableEntry ,Offset :_eaeac ,Generation :int (_agfd )};_caab ._gdfb .ObjectMap [_gcgc ]=_bfdda ;};}else if _ffgca ==2{_gee .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_efde :=_caab ._gdfb .ObjectMap [_gcgc ];!_efde {_gbff :=XrefObject {ObjectNumber :_gcgc ,XType :XrefTypeObjectStream ,OsObjNumber :int (_eaeac ),OsObjIndex :int (_agfd )};_caab ._gdfb .ObjectMap [_gcgc ]=_gbff ;_gee .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_gbff );};}else {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _caab ._ccgb ==nil {_bbdb :=XrefTypeObjectStream ;_caab ._ccgb =&_bbdb ;};return _gdddg ,nil ;};

// LookupByReference looks up a PdfObject by a reference.
func (_egg *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_gee .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _egg .LookupByNumber (int (ref .ObjectNumber ));};func (_ccde *PdfParser )skipComments ()error {if _ ,_gbdgg :=_ccde .skipSpaces ();_gbdgg !=nil {return _gbdgg ;};_bcfbg :=true ;for {_edab ,_cfdae :=_ccde ._dbfg .Peek (1);if _cfdae !=nil {_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cfdae .Error ());return _cfdae ;};if _bcfbg &&_edab [0]!='%'{return nil ;};_bcfbg =false ;if (_edab [0]!='\r')&&(_edab [0]!='\n'){_ccde ._dbfg .ReadByte ();}else {break ;};};return _ccde .skipComments ();};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_bbb *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bbb .DecodeBytes (streamObj .Stream );};

// WriteString outputs the object as it is to be written to file.
func (_cfgdg *PdfObjectFloat )WriteString ()string {return _d .FormatFloat (float64 (*_cfgdg ),'f',-1,64);};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_bac *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ba .DecodeBytes (encoded ,_e .Parameters {},_bac .Globals );};func _gcace (_dcfb PdfObject ,_beacb int ,_ebbf map[PdfObject ]struct{})error {_gee .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_beacb );if _ ,_fddb :=_ebbf [_dcfb ];_fddb {_gee .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_ebbf [_dcfb ]=struct{}{};switch _bgbfg :=_dcfb .(type ){case *PdfIndirectObject :_abcg :=_bgbfg ;_gee .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_abcg );_gee .Log .Trace ("\u002d\u0020\u0025\u0073",_abcg .PdfObject );return _gcace (_abcg .PdfObject ,_beacb +1,_ebbf );case *PdfObjectStream :_baeca :=_bgbfg ;return _gcace (_baeca .PdfObjectDictionary ,_beacb +1,_ebbf );case *PdfObjectDictionary :_baaef :=_bgbfg ;_gee .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_baaef );for _ ,_ccfbc :=range _baaef .Keys (){_egge :=_baaef .Get (_ccfbc );if _fbge ,_dcba :=_egge .(*PdfObjectReference );_dcba {_cgfc :=_fbge .Resolve ();_baaef .Set (_ccfbc ,_cgfc );_fgdd :=_gcace (_cgfc ,_beacb +1,_ebbf );if _fgdd !=nil {return _fgdd ;};}else {_fgefb :=_gcace (_egge ,_beacb +1,_ebbf );if _fgefb !=nil {return _fgefb ;};};};return nil ;case *PdfObjectArray :_ccgbff :=_bgbfg ;_gee .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_ccgbff );for _dgfc ,_fcec :=range _ccgbff .Elements (){if _fbece ,_cfcgec :=_fcec .(*PdfObjectReference );_cfcgec {_acfb :=_fbece .Resolve ();_ccgbff .Set (_dgfc ,_acfb );_bcde :=_gcace (_acfb ,_beacb +1,_ebbf );if _bcde !=nil {return _bcde ;};}else {_acdde :=_gcace (_fcec ,_beacb +1,_ebbf );if _acdde !=nil {return _acdde ;};};};return nil ;case *PdfObjectReference :_gee .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _fd .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};var _gbdf =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_cffbf :=PdfObjectName (s );return &_cffbf };

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_ecgf :=_aaf .NewReader ([]byte (txt ));_becbf :=&PdfParser {ObjCache :objectCache {},_ggggc :_ecgf ,_dbfg :_dd .NewReader (_ecgf ),_eagf :int64 (len (txt )),_afdg :map[int64 ]bool {}};_becbf ._gdfb .ObjectMap =make (map[int ]XrefObject );return _becbf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fecb *RawEncoder )MakeDecodeParams ()PdfObject {return nil };func _bgaf (_cgffe *PdfObjectStream )(*MultiEncoder ,error ){_fade :=NewMultiEncoder ();_ecb :=_cgffe .PdfObjectDictionary ;if _ecb ==nil {return _fade ,nil ;};var _fedfa *PdfObjectDictionary ;var _cgcb []PdfObject ;_bcfc :=_ecb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _bcfc !=nil {_gbbbe ,_bda :=_bcfc .(*PdfObjectDictionary );if _bda {_fedfa =_gbbbe ;};_bgea ,_aggb :=_bcfc .(*PdfObjectArray );if _aggb {for _ ,_gabeg :=range _bgea .Elements (){_gabeg =TraceToDirectObject (_gabeg );if _bebef ,_gggg :=_gabeg .(*PdfObjectDictionary );_gggg {_cgcb =append (_cgcb ,_bebef );}else {_cgcb =append (_cgcb ,MakeDict ());};};};};_bcfc =_ecb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _bcfc ==nil {return nil ,_fbg .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_cfcg ,_gbde :=_bcfc .(*PdfObjectArray );if !_gbde {return nil ,_fbg .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _egad ,_afacd :=range _cfcg .Elements (){_ddga ,_gdab :=_afacd .(*PdfObjectName );if !_gdab {return nil ,_fbg .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _ebeb PdfObject ;if _fedfa !=nil {_ebeb =_fedfa ;}else {if len (_cgcb )> 0{if _egad >=len (_cgcb ){return nil ,_fbg .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_ebeb =_cgcb [_egad ];};};var _ebbb *PdfObjectDictionary ;if _fgad ,_fdff :=_ebeb .(*PdfObjectDictionary );_fdff {_ebbb =_fgad ;};_gee .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_ddga ,_ebeb ,_ebbb );if *_ddga ==StreamEncodingFilterNameFlate {_gdeg ,_cfde :=_aae (_cgffe ,_ebbb );if _cfde !=nil {return nil ,_cfde ;};_fade .AddEncoder (_gdeg );}else if *_ddga ==StreamEncodingFilterNameLZW {_fegaf ,_dcca :=_dee (_cgffe ,_ebbb );if _dcca !=nil {return nil ,_dcca ;};_fade .AddEncoder (_fegaf );}else if *_ddga ==StreamEncodingFilterNameASCIIHex {_fgca :=NewASCIIHexEncoder ();_fade .AddEncoder (_fgca );}else if *_ddga ==StreamEncodingFilterNameASCII85 {_gefb :=NewASCII85Encoder ();_fade .AddEncoder (_gefb );}else if *_ddga ==StreamEncodingFilterNameDCT {_aeac ,_gbcf :=_ebac (_cgffe ,_fade );if _gbcf !=nil {return nil ,_gbcf ;};_fade .AddEncoder (_aeac );_gee .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_gee .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_fade );}else {_gee .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_ddga );return nil ,_fbg .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _fade ,nil ;};

// String returns a string representation of the *PdfObjectString.
func (_dggc *PdfObjectString )String ()string {return _dggc ._ecea };func (_cfagf *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_cfagf ._ggggc .Seek (0,_fe .SeekStart );_cfagf ._dbfg =_dd .NewReader (_cfagf ._ggggc );_cbgb :=20;_fdfg :=make ([]byte ,_cbgb );for {_adfed ,_fcde :=_cfagf ._dbfg .ReadByte ();if _fcde !=nil {if _fcde ==_fe .EOF {break ;}else {return 0,0,_fcde ;};};if IsDecimalDigit (_adfed )&&_fdfg [_cbgb -1]=='.'&&IsDecimalDigit (_fdfg [_cbgb -2])&&_fdfg [_cbgb -3]=='-'&&_fdfg [_cbgb -4]=='F'&&_fdfg [_cbgb -5]=='D'&&_fdfg [_cbgb -6]=='P'{_gcbf :=int (_fdfg [_cbgb -2]-'0');_acee :=int (_adfed -'0');return _gcbf ,_acee ,nil ;};_fdfg =append (_fdfg [1:_cbgb ],_adfed );};return 0,0,_fd .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgbf *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dbd *LZWEncoder )MakeDecodeParams ()PdfObject {if _dbd .Predictor > 1{_gddd :=MakeDict ();_gddd .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_dbd .Predictor )));if _dbd .BitsPerComponent !=8{_gddd .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_dbd .BitsPerComponent )));};if _dbd .Columns !=1{_gddd .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_dbd .Columns )));};if _dbd .Colors !=1{_gddd .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_dbd .Colors )));};return _gddd ;};return nil ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_cdfba *PdfParser )IsEncrypted ()(bool ,error ){if _cdfba ._dfab !=nil {return true ,nil ;}else if _cdfba ._bdce ==nil {return false ,nil ;};_gee .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_addf :=_cdfba ._bdce .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _addf ==nil {return false ,nil ;};_gee .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_fedgd *PdfObjectDictionary ;);switch _cbbc :=_addf .(type ){case *PdfObjectDictionary :_fedgd =_cbbc ;case *PdfObjectReference :_gee .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_cbbc );_cgeb ,_ecbb :=_cdfba .LookupByReference (*_cbbc );_gee .Log .Trace ("\u0031\u003a\u0020%\u0071",_cgeb );if _ecbb !=nil {return false ,_ecbb ;};_geffe ,_acb :=_cgeb .(*PdfIndirectObject );if !_acb {_gee .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_fd .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_egab ,_acb :=_geffe .PdfObject .(*PdfObjectDictionary );_gee .Log .Trace ("\u0032\u003a\u0020%\u0071",_egab );if !_acb {return false ,_fd .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_fedgd =_egab ;case *PdfObjectNull :_gee .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_fbg .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_cbbc );};_eagbc ,_gagdd :=PdfCryptNewDecrypt (_cdfba ,_fedgd ,_cdfba ._bdce );if _gagdd !=nil {return false ,_gagdd ;};for _ ,_eadc :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_dgcdg :=_cdfba ._bdce .Get (PdfObjectName (_eadc ));if _dgcdg ==nil {continue ;};switch _gfec :=_dgcdg .(type ){case *PdfObjectReference :_eagbc ._dg [int (_gfec .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_eagbc ._ggf [_gfec ]=true ;_eagbc ._dg [int (_gfec .ObjectNumber )]=struct{}{};};};_cdfba ._dfab =_eagbc ;_gee .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_eagbc );return true ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_afac *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_fgcf :=&DCTEncoder {};_fgcf .ColorComponents =3;_fgcf .BitsPerComponent =8;_fgcf .Quality =DefaultJPEGQuality ;return _fgcf ;};type objectStreams map[int ]objectStream ;

// UpdateParams updates the parameter values of the encoder.
func (_dgf *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_dgef :_be .InitEncodeDocument (false )}};

// Bytes returns the PdfObjectString content as a []byte array.
func (_afc *PdfObjectString )Bytes ()[]byte {return []byte (_afc ._ecea )};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _cddb (obj ,0)};

// GetFilterName returns the name of the encoding filter.
func (_ged *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func _fgac (_egee ,_fcgfc ,_cgbd int )error {if _fcgfc < 0||_fcgfc > _egee {return _fd .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _cgbd < _fcgfc {return _fd .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _cgbd > _egee {return _fd .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_dbea JBIG2EncoderSettings )Validate ()error {const _efdd ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _dbea .Threshold < 0||_dbea .Threshold > 1.0{return _gfg .Errorf (_efdd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_dbea .Threshold );};if _dbea .ResolutionX < 0{return _gfg .Errorf (_efdd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_dbea .ResolutionX );};if _dbea .ResolutionY < 0{return _gfg .Errorf (_efdd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_dbea .ResolutionY );};if _dbea .DefaultPixelValue !=0&&_dbea .DefaultPixelValue !=1{return _gfg .Errorf (_efdd ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_dbea .DefaultPixelValue );};if _dbea .Compression !=JB2Generic {return _gfg .Errorf (_efdd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_cdc encryptDict ;_facd _ee .StdEncryptDict ;_ed string ;_aed []byte ;_ggf map[PdfObject ]bool ;_efa map[PdfObject ]bool ;_bcb bool ;_efb cryptFilters ;_cfc string ;_aafa string ;_fcd *PdfParser ;_dg map[int ]struct{};};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ddb *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_cagb :=&FlateEncoder {};_cagb .Predictor =1;_cagb .BitsPerComponent =8;_cagb .Colors =1;_cagb .Columns =1;return _cagb ;};func (_eab *PdfCrypt )isDecrypted (_ffad PdfObject )bool {_ ,_dga :=_eab ._ggf [_ffad ];if _dga {_gee .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _ede :=_ffad .(type ){case *PdfObjectStream :if _eab ._facd .R !=5{if _cbf ,_acd :=_ede .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_acd &&*_cbf =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_dga =_eab ._dg [int (_ede .ObjectNumber )];_dga {return true ;};switch _abc :=_ede .PdfObject .(type ){case *PdfObjectDictionary :_deg :=true ;for _ ,_cfe :=range _gbdf {if _abc .Get (_cfe )==nil {_deg =false ;break ;};};if _deg {return true ;};};};_gee .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};func (_eeef *PdfParser )traceStreamLength (_adbg PdfObject )(PdfObject ,error ){_fbec ,_efgc :=_adbg .(*PdfObjectReference );if _efgc {_cgaa ,_gfca :=_eeef ._afdg [_fbec .ObjectNumber ];if _gfca &&_cgaa {_gee .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_fd .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_eeef ._afdg [_fbec .ObjectNumber ]=true ;};_eada ,_cage :=_eeef .Resolve (_adbg );if _cage !=nil {return nil ,_cage ;};_gee .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_eada );if _efgc {_eeef ._afdg [_fbec .ObjectNumber ]=false ;};return _eada ,nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_dbcc *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _cfbd ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _cbcfd :=_dbcc .AddPageImage (img ,&_dbcc .DefaultPageSettings );_cbcfd !=nil {return nil ,_gfg .Wrap (_cbcfd ,_cfbd ,"");};return _dbcc .Encode ();};

// GetFilterName returns the name of the encoding filter.
func (_faccf *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_cbfe *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_gbgg ,_ebddb :=_cbfe ._bagbd [key ].(*PdfObjectString );if !_ebddb {return "",false ;};return _gbgg .Str (),true ;};

// UpdateParams updates the parameter values of the encoder.
func (_gddf *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_ffadc ,_dde :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _dde ==nil {_gddf .Predictor =int (_ffadc );};_bea ,_dde :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _dde ==nil {_gddf .BitsPerComponent =int (_bea );};_ada ,_dde :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dde ==nil {_gddf .Columns =int (_ada );};_fccg ,_dde :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _dde ==nil {_gddf .Colors =int (_fccg );};_gfef ,_dde :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _dde ==nil {_gddf .EarlyChange =int (_gfef );};};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_dd .Reader )(PdfObject ,error ){_befee :=false ;_ecda :=true ;var _gfecb _aaf .Buffer ;for {if _gee .Log .IsLogLevel (_gee .LogLevelTrace ){_gee .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_gfecb .String ());};_acfa ,_edebg :=buf .Peek (1);if _edebg ==_fe .EOF {break ;};if _edebg !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_edebg );return nil ,_edebg ;};if _ecda &&(_acfa [0]=='-'||_acfa [0]=='+'){_gfde ,_ :=buf .ReadByte ();_gfecb .WriteByte (_gfde );_ecda =false ;}else if IsDecimalDigit (_acfa [0]){_egdcd ,_ :=buf .ReadByte ();_gfecb .WriteByte (_egdcd );}else if _acfa [0]=='.'{_edega ,_ :=buf .ReadByte ();_gfecb .WriteByte (_edega );_befee =true ;}else if _acfa [0]=='e'||_acfa [0]=='E'{_gcbff ,_ :=buf .ReadByte ();_gfecb .WriteByte (_gcbff );_befee =true ;_ecda =true ;}else {break ;};};var _bbgf PdfObject ;if _befee {_gefff ,_bfbgd :=_d .ParseFloat (_gfecb .String (),64);if _bfbgd !=nil {_gee .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_gfecb .String (),_bfbgd );_gefff =0.0;};_dggca :=PdfObjectFloat (_gefff );_bbgf =&_dggca ;}else {_efcfc ,_gfac :=_d .ParseInt (_gfecb .String (),10,64);if _gfac !=nil {_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_gfecb .String (),_gfac );_efcfc =0;};_gafag :=PdfObjectInteger (_efcfc );_bbgf =&_gafag ;};return _bbgf ,nil ;};type cryptFilters map[string ]_dc .Filter ;

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// Append appends PdfObject(s) to the array.
func (_fecg *PdfObjectArray )Append (objects ...PdfObject ){if _fecg ==nil {_gee .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_fecg ._gfdc =append (_fecg ._gfdc ,objects ...);};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_egba :=&PdfCrypt {_bcb :false ,_ggf :make (map[PdfObject ]bool ),_efa :make (map[PdfObject ]bool ),_dg :make (map[int ]struct{}),_fcd :parser };_fgc ,_aag :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_aag {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _egba ,_fd .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_fgc !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_gee .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_fgc );return _egba ,_fd .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_egba ._cdc .Filter =string (*_fgc );if _bgb ,_egf :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_egf {_egba ._cdc .SubFilter =_bgb .Str ();_gee .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_bgb );};if L ,_ffa :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_ffa {if (*L %8)!=0{_gee .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _egba ,_fd .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_egba ._cdc .Length =int (*L );}else {_egba ._cdc .Length =40;};_egba ._cdc .V =0;if _eca ,_eced :=ed .Get ("\u0056").(*PdfObjectInteger );_eced {V :=int (*_eca );_egba ._cdc .V =V ;if V >=1&&V <=2{_egba ._efb =_eec (_egba ._cdc .Length );}else if V >=4&&V <=5{if _gbd :=_egba .loadCryptFilters (ed );_gbd !=nil {return _egba ,_gbd ;};}else {_gee .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _egba ,_fd .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _fbb :=_dcf (&_egba ._facd ,ed );_fbb !=nil {return _egba ,_fbb ;};_bgd :="";if _fgd ,_bedc :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_bedc &&_fgd .Len ()>=1{_fedg ,_edb :=GetString (_fgd .Get (0));if !_edb {return _egba ,_fd .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_bgd =_fedg .Str ();}else {_gee .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_egba ._ed =_bgd ;return _egba ,nil ;};func (_febae *PdfParser )inspect ()(map[string ]int ,error ){_gee .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_gee .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_febe :=map[string ]int {};_abga :=0;_aadc :=0;var _cbda []int ;for _aeeg :=range _febae ._gdfb .ObjectMap {_cbda =append (_cbda ,_aeeg );};_fb .Ints (_cbda );_aabb :=0;for _ ,_bfbge :=range _cbda {_dbeea :=_febae ._gdfb .ObjectMap [_bfbge ];if _dbeea .ObjectNumber ==0{continue ;};_abga ++;_gee .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_gee .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_dbeea .ObjectNumber );_aegd ,_abcfd :=_febae .LookupByNumber (_dbeea .ObjectNumber );if _abcfd !=nil {_gee .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_dbeea .ObjectNumber ,_abcfd );_aadc ++;continue ;};_gee .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_aegd );_gddc ,_gdddb :=_aegd .(*PdfIndirectObject );if _gdddb {_gee .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_dbeea .ObjectNumber ,_gddc );_edfec ,_bfba :=_gddc .PdfObject .(*PdfObjectDictionary );if _bfba {if _ggae ,_gafg :=_edfec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gafg {_bcaa :=string (*_ggae );_gee .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_bcaa );_ ,_cbeae :=_febe [_bcaa ];if _cbeae {_febe [_bcaa ]++;}else {_febe [_bcaa ]=1;};}else if _addgb ,_edccg :=_edfec .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_edccg {_baba :=string (*_addgb );_gee .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_baba );_ ,_bdgdf :=_febe [_baba ];if _bdgdf {_febe [_baba ]++;}else {_febe [_baba ]=1;};};if _efeg ,_eebga :=_edfec .Get ("\u0053").(*PdfObjectName );_eebga &&*_efeg =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_gfgf :=_febe ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _gfgf {_febe ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_febe ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _cdgd ,_babf :=_aegd .(*PdfObjectStream );_babf {if _dcbgb ,_eaeb :=_cdgd .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eaeb {_gee .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_dcbgb );_cfccf :=string (*_dcbgb );_febe [_cfccf ]++;};}else {_ceda ,_babaa :=_aegd .(*PdfObjectDictionary );if _babaa {_afbcc ,_efcf :=_ceda .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _efcf {_ccbea :=string (*_afbcc );_gee .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_ccbea );_febe [_ccbea ]++;};};_gee .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_dbeea .ObjectNumber ,_aegd );};_aabb ++;};_gee .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_gee .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_gee .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_abga );_gee .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_aadc );for _dfcg ,_cecce :=range _febe {_gee .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_dfcg ,_cecce );};_gee .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_febae ._gdfb .ObjectMap )< 1{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_fbg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_gaeb ,_eafc :=_febe ["\u0046\u006f\u006e\u0074"];if !_eafc ||_gaeb < 2{_gee .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_gee .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _febe ,nil ;};func (_cdee *PdfObjectFloat )String ()string {return _fbg .Sprintf ("\u0025\u0066",*_cdee )};func (_aaeeb *PdfParser )resolveReference (_cccd *PdfObjectReference )(PdfObject ,bool ,error ){_edeg ,_ccdc :=_aaeeb .ObjCache [int (_cccd .ObjectNumber )];if _ccdc {return _edeg ,true ,nil ;};_ffee ,_ebaaa :=_aaeeb .LookupByReference (*_cccd );if _ebaaa !=nil {return nil ,false ,_ebaaa ;};_aaeeb .ObjCache [int (_cccd .ObjectNumber )]=_ffee ;return _ffee ,false ,nil ;};func _dee (_fdf *PdfObjectStream ,_ebg *PdfObjectDictionary )(*LZWEncoder ,error ){_fega :=NewLZWEncoder ();_cfa :=_fdf .PdfObjectDictionary ;if _cfa ==nil {return _fega ,nil ;};if _ebg ==nil {_dcef :=TraceToDirectObject (_cfa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dcef !=nil {if _abf ,_eebf :=_dcef .(*PdfObjectDictionary );_eebf {_ebg =_abf ;}else if _bfde ,_efd :=_dcef .(*PdfObjectArray );_efd {if _bfde .Len ()==1{if _cacbb ,_ddeb :=GetDict (_bfde .Get (0));_ddeb {_ebg =_cacbb ;};};};if _ebg ==nil {_gee .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dcef );return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_gdfg :=_cfa .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _gdfg !=nil {_cfcf ,_cdff :=_gdfg .(*PdfObjectInteger );if !_cdff {_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_gdfg );return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_cfcf !=0&&*_cfcf !=1{return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_fega .EarlyChange =int (*_cfcf );}else {_fega .EarlyChange =1;};if _ebg ==nil {return _fega ,nil ;};_gdfg =_ebg .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _gdfg !=nil {_fga ,_abab :=_gdfg .(*PdfObjectInteger );if !_abab {_gee .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_gdfg );return nil ,_fbg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fega .Predictor =int (*_fga );};_gdfg =_ebg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _gdfg !=nil {_efdf ,_dbee :=_gdfg .(*PdfObjectInteger );if !_dbee {_gee .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_fbg .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fega .BitsPerComponent =int (*_efdf );};if _fega .Predictor > 1{_fega .Columns =1;_gdfg =_ebg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _gdfg !=nil {_acff ,_bff :=_gdfg .(*PdfObjectInteger );if !_bff {return nil ,_fbg .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fega .Columns =int (*_acff );};_fega .Colors =1;_gdfg =_ebg .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _gdfg !=nil {_fcf ,_fgab :=_gdfg .(*PdfObjectInteger );if !_fgab {return nil ,_fbg .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_fega .Colors =int (*_fcf );};};_gee .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_ebg .String ());return _fega ,nil ;};func (_cd *PdfParser )lookupObjectViaOS (_ff int ,_bg int )(PdfObject ,error ){var _ffe *_aaf .Reader ;var _gfe objectStream ;var _fdd bool ;_gfe ,_fdd =_cd ._edbb [_ff ];if !_fdd {_cfg ,_fc :=_cd .LookupByNumber (_ff );if _fc !=nil {_gee .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ff );return nil ,_fc ;};_ga ,_cc :=_cfg .(*PdfObjectStream );if !_cc {return nil ,_fd .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _cd ._dfab !=nil &&!_cd ._dfab .isDecrypted (_ga ){return nil ,_fd .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_bef :=_ga .PdfObjectDictionary ;_gee .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_bef .String ());_cg ,_cc :=_bef .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_cc {_gee .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_fd .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _ab .ToLower (string (*_cg ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_fd .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_cc :=_bef .Get ("\u004e").(*PdfObjectInteger );if !_cc {return nil ,_fd .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_bga ,_cc :=_bef .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_cc {return nil ,_fd .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gee .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cg ,*N );_dfc ,_fc :=DecodeStream (_ga );if _fc !=nil {return nil ,_fc ;};_gee .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_dfc );_gdg :=_cd .GetFileOffset ();defer func (){_cd .SetFileOffset (_gdg )}();_ffe =_aaf .NewReader (_dfc );_cd ._dbfg =_dd .NewReader (_ffe );_gee .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_fg :=map[int ]int64 {};for _cfd :=0;_cfd < int (*N );_cfd ++{_cd .skipSpaces ();_ce ,_bag :=_cd .parseNumber ();if _bag !=nil {return nil ,_bag ;};_gcg ,_gcb :=_ce .(*PdfObjectInteger );if !_gcb {return nil ,_fd .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_cd .skipSpaces ();_ce ,_bag =_cd .parseNumber ();if _bag !=nil {return nil ,_bag ;};_ced ,_gcb :=_ce .(*PdfObjectInteger );if !_gcb {return nil ,_fd .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_gee .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_gcg ,*_ced );_fg [int (*_gcg )]=int64 (*_bga +*_ced );};_gfe =objectStream {N :int (*N ),_eg :_dfc ,_age :_fg };_cd ._edbb [_ff ]=_gfe ;}else {_egd :=_cd .GetFileOffset ();defer func (){_cd .SetFileOffset (_egd )}();_ffe =_aaf .NewReader (_gfe ._eg );_cd ._dbfg =_dd .NewReader (_ffe );};_gff :=_gfe ._age [_bg ];_gee .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_bg ,_gff );_ffe .Seek (_gff ,_fe .SeekStart );_cd ._dbfg =_dd .NewReader (_ffe );_eb ,_ :=_cd ._dbfg .Peek (100);_gee .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_eb ));_ffc ,_ef :=_cd .parseObject ();if _ef !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_ef );return nil ,_ef ;};if _ffc ==nil {return nil ,_fd .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_bf :=PdfIndirectObject {};_bf .ObjectNumber =int64 (_bg );_bf .PdfObject =_ffc ;return &_bf ,nil ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_dbfad :=PdfObjectInteger (val );return &_dbfad };

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_eaae *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_fbbb ,_bgfg :=_ade .NewImage (_eaae .Width ,_eaae .Height ,_eaae .BitsPerComponent ,_eaae .ColorComponents ,data ,nil ,nil );if _bgfg !=nil {return nil ,_bgfg ;};_fcbe :=_ag .Options {};_fcbe .Quality =_eaae .Quality ;var _gcdd _aaf .Buffer ;if _bgfg =_ag .Encode (&_gcdd ,_fbbb ,&_fcbe );_bgfg !=nil {return nil ,_bgfg ;};return _gcdd .Bytes (),nil ;};const _aaca =32<<(^uint (0)>>63);func (_bbcd *PdfCrypt )securityHandler ()_ee .StdHandler {if _bbcd ._facd .R >=5{return _ee .NewHandlerR6 ();};return _ee .NewHandlerR4 (_bbcd ._ed ,_bbcd ._cdc .Length );};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_ebaa *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ba .Globals ,error ){return _ba .DecodeGlobals (encoded );};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _ddcb (obj1 ,obj2 ,0)};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_feca *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func (_bdcc *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fcdcf :=MakeArray ();_bdcc ._dbfg .ReadByte ();for {_bdcc .skipSpaces ();_effa ,_eagb :=_bdcc ._dbfg .Peek (1);if _eagb !=nil {return _fcdcf ,_eagb ;};if _effa [0]==']'{_bdcc ._dbfg .ReadByte ();break ;};_bcad ,_eagb :=_bdcc .parseObject ();if _eagb !=nil {return _fcdcf ,_eagb ;};_fcdcf .Append (_bcad );};return _fcdcf ,nil ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_ecea string ;_ffdg bool ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};func (_beff *PdfParser )lookupByNumber (_gcd int ,_aac bool )(PdfObject ,bool ,error ){_gga ,_bee :=_beff .ObjCache [_gcd ];if _bee {_gee .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_gcd );return _gga ,false ,nil ;};_eba ,_bee :=_beff ._gdfb .ObjectMap [_gcd ];if !_bee {_gee .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _gac PdfObjectNull ;return &_gac ,false ,nil ;};_gee .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_gcd );if _eba .XType ==XrefTypeTableEntry {_gee .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_eba .ObjectNumber );_gee .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_eba .Generation );_gee .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_eba .Offset );_beff ._ggggc .Seek (_eba .Offset ,_fe .SeekStart );_beff ._dbfg =_dd .NewReader (_beff ._ggggc );_ca ,_fge :=_beff .ParseIndirectObject ();if _fge !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_fge );if _aac {_gee .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_db ,_gbc :=_beff .repairRebuildXrefsTopDown ();if _gbc !=nil {_gee .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_gbc );return nil ,false ,_gbc ;};_beff ._gdfb =*_db ;return _beff .lookupByNumber (_gcd ,false );};return nil ,false ,_fge ;};if _aac {_dac ,_ ,_ :=_gec (_ca );if int (_dac )!=_gcd {_gee .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_fcg :=_beff .rebuildXrefTable ();if _fcg !=nil {return nil ,false ,_fcg ;};_beff .ObjCache =objectCache {};return _beff .lookupByNumberWrapper (_gcd ,false );};};_gee .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_beff .ObjCache [_gcd ]=_ca ;return _ca ,false ,nil ;}else if _eba .XType ==XrefTypeObjectStream {_gee .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_gee .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_gee .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_eba .OsObjNumber ,_eba .OsObjIndex );if _eba .OsObjNumber ==_gcd {_gee .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_fd .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_fa :=_beff ._gdfb .ObjectMap [_eba .OsObjNumber ];_fa {_ffea ,_egc :=_beff .lookupObjectViaOS (_eba .OsObjNumber ,_gcd );if _egc !=nil {_gee .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_egc );return nil ,true ,_egc ;};_gee .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_beff .ObjCache [_gcd ]=_ffea ;if _beff ._dfab !=nil {_beff ._dfab ._ggf [_ffea ]=true ;};return _ffea ,true ,nil ;};_gee .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_fd .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_fd .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_bdba *PdfObjectName ,_ddcgb bool ){_bdba ,_ddcgb =TraceToDirectObject (obj ).(*PdfObjectName );return _bdba ,_ddcgb ;};

// WriteString outputs the object as it is to be written to file.
func (_eeff *PdfIndirectObject )WriteString ()string {var _bbae _ab .Builder ;_bbae .WriteString (_d .FormatInt (_eeff .ObjectNumber ,10));_bbae .WriteString ("\u0020\u0030\u0020\u0052");return _bbae .String ();};

// GetFilterName returns the name of the encoding filter.
func (_dcbg *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };var _ffedb =_gc .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");type objectCache map[int ]PdfObject ;

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_ddde *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_bdfcg ,_ggec :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ggec ==nil {_ddde .BitsPerComponent =int (_bdfcg );};_faced ,_ggec :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ggec ==nil {_ddde .Width =int (_faced );};_bagb ,_ggec :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ggec ==nil {_ddde .Height =int (_bagb );};_dbgb ,_ggec :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ggec ==nil {_ddde .ColorComponents =int (_dbgb );};};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_gbede *MultiEncoder )AddEncoder (encoder StreamEncoder ){_gbede ._cbgg =append (_gbede ._cbgg ,encoder );};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_a .Model ;Bounds ()_gf .Rectangle ;At (_eed ,_gbba int )_a .Color ;Set (_bbac ,_fgfcc int ,_afg _a .Color );};func (_dda *PdfParser )skipSpaces ()(int ,error ){_fdad :=0;for {_dged ,_eecd :=_dda ._dbfg .ReadByte ();if _eecd !=nil {return 0,_eecd ;};if IsWhiteSpace (_dged ){_fdad ++;}else {_dda ._dbfg .UnreadByte ();break ;};};return _fdad ,nil ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_cafb *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _efec [][]byte ;for _bgad :=0;_bgad < len (data );_bgad +=_cafb .Columns {_ccge :=make ([]byte ,_cafb .Columns );_gfagf :=0;for _fecda :=0;_fecda < _cafb .Columns ;_fecda ++{if data [_bgad +_fecda ]==255{_ccge [_gfagf ]=1;}else {_ccge [_gfagf ]=0;};_gfagf ++;};_efec =append (_efec ,_ccge );};_febfb :=&_gda .Encoder {K :_cafb .K ,Columns :_cafb .Columns ,EndOfLine :_cafb .EndOfLine ,EndOfBlock :_cafb .EndOfBlock ,BlackIs1 :_cafb .BlackIs1 ,DamagedRowsBeforeError :_cafb .DamagedRowsBeforeError ,Rows :_cafb .Rows ,EncodedByteAlign :_cafb .EncodedByteAlign };return _febfb .Encode (_efec ),nil ;};func (_dedb *PdfParser )parseHexString ()(*PdfObjectString ,error ){_dedb ._dbfg .ReadByte ();var _ccgbf _aaf .Buffer ;for {_gfdd ,_ecbc :=_dedb ._dbfg .Peek (1);if _ecbc !=nil {return MakeString (""),_ecbc ;};if _gfdd [0]=='>'{_dedb ._dbfg .ReadByte ();break ;};_adaf ,_ :=_dedb ._dbfg .ReadByte ();if !IsWhiteSpace (_adaf ){_ccgbf .WriteByte (_adaf );};};if _ccgbf .Len ()%2==1{_ccgbf .WriteRune ('0');};_cdag ,_ :=_aa .DecodeString (_ccgbf .String ());return MakeHexString (string (_cdag )),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ddda *FlateEncoder )MakeDecodeParams ()PdfObject {if _ddda .Predictor > 1{_fea :=MakeDict ();_fea .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ddda .Predictor )));if _ddda .BitsPerComponent !=8{_fea .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ddda .BitsPerComponent )));};if _ddda .Columns !=1{_fea .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ddda .Columns )));};if _ddda .Colors !=1{_fea .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ddda .Colors )));};return _fea ;};return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fcdg *PdfObjectDictionary )WriteString ()string {var _edgc _ab .Builder ;_edgc .WriteString ("\u003c\u003c");for _ ,_gggb :=range _fcdg ._aeba {_dfdde :=_fcdg ._bagbd [_gggb ];_edgc .WriteString (_gggb .WriteString ());_edgc .WriteString ("\u0020");_edgc .WriteString (_dfdde .WriteString ());};_edgc .WriteString ("\u003e\u003e");return _edgc .String ();};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_cb []XrefObject ;};const _bed ="\u0053\u0074\u0064C\u0046";

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_aaa *PdfParser )Decrypt (password []byte )(bool ,error ){if _aaa ._dfab ==nil {return false ,_fd .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_dcgfa ,_fcge :=_aaa ._dfab .authenticate (password );if _fcge !=nil {return false ,_fcge ;};if !_dcgfa {_dcgfa ,_fcge =_aaa ._dfab .authenticate ([]byte (""));};return _dcgfa ,_fcge ;};func (_egdef *PdfCrypt )isEncrypted (_cfgbd PdfObject )bool {_ ,_fff :=_egdef ._efa [_cfgbd ];if _fff {_gee .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_gee .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_gfdc :objects }};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_afgb *PdfIndirectObject ,_fege bool ){obj =ResolveReference (obj );_afgb ,_fege =obj .(*PdfIndirectObject );return _afgb ,_fege ;};

// String returns a string representation of `name`.
func (_fdac *PdfObjectName )String ()string {return string (*_fdac )};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eef *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_ddbe *MultiEncoder )GetFilterName ()string {_fefe :="";for _cddg ,_gfed :=range _ddbe ._cbgg {_fefe +=_gfed .GetFilterName ();if _cddg < len (_ddbe ._cbgg )-1{_fefe +="\u0020";};};return _fefe ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_gfagfe *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _dgca ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _gfagfe .ColorComponents !=1||_gfagfe .BitsPerComponent !=1{return nil ,_gfg .Errorf (_dgca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_geb *_cf .Bitmap ;_edcd error ;);_efdfb :=(_gfagfe .Width *_gfagfe .Height )==len (data );if _efdfb {_geb ,_edcd =_cf .NewWithUnpaddedData (_gfagfe .Width ,_gfagfe .Height ,data );}else {_geb ,_edcd =_cf .NewWithData (_gfagfe .Width ,_gfagfe .Height ,data );};if _edcd !=nil {return nil ,_edcd ;};_cfb :=_gfagfe .DefaultPageSettings ;if _edcd =_cfb .Validate ();_edcd !=nil {return nil ,_gfg .Wrap (_edcd ,_dgca ,"");};switch _cfb .Compression {case JB2Generic :if _edcd =_gfagfe ._dgef .AddGenericPage (_geb ,_cfb .DuplicatedLinesRemoval );_edcd !=nil {return nil ,_gfg .Wrap (_edcd ,_dgca ,"");};case JB2SymbolCorrelation :return nil ,_gfg .Error (_dgca ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_gfg .Error (_dgca ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_gfg .Error (_dgca ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _gfagfe .Encode ();};func _ebac (_cgea *PdfObjectStream ,_bdfc *MultiEncoder )(*DCTEncoder ,error ){_cgfa :=NewDCTEncoder ();_beb :=_cgea .PdfObjectDictionary ;if _beb ==nil {return _cgfa ,nil ;};_bebe :=_cgea .Stream ;if _bdfc !=nil {_bba ,_dcdc :=_bdfc .DecodeBytes (_bebe );if _dcdc !=nil {return nil ,_dcdc ;};_bebe =_bba ;};_aagf :=_aaf .NewReader (_bebe );_fedf ,_eagg :=_ag .DecodeConfig (_aagf );if _eagg !=nil {_gee .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_eagg );return nil ,_eagg ;};switch _fedf .ColorModel {case _a .RGBAModel :_cgfa .BitsPerComponent =8;_cgfa .ColorComponents =3;case _a .RGBA64Model :_cgfa .BitsPerComponent =16;_cgfa .ColorComponents =3;case _a .GrayModel :_cgfa .BitsPerComponent =8;_cgfa .ColorComponents =1;case _a .Gray16Model :_cgfa .BitsPerComponent =16;_cgfa .ColorComponents =1;case _a .CMYKModel :_cgfa .BitsPerComponent =8;_cgfa .ColorComponents =4;case _a .YCbCrModel :_cgfa .BitsPerComponent =8;_cgfa .ColorComponents =3;default:return nil ,_fd .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_cgfa .Width =_fedf .Width ;_cgfa .Height =_fedf .Height ;_gee .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_cgfa );_cgfa .Quality =DefaultJPEGQuality ;return _cgfa ,nil ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_dcfd :=&LZWEncoder {};_dcfd .Predictor =1;_dcfd .BitsPerComponent =8;_dcfd .Colors =1;_dcfd .Columns =1;_dcfd .EarlyChange =1;return _dcfd ;};

// GetFilterName returns the name of the encoding filter.
func (_aec *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcbc *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_degcf :=MakeDict ();_degcf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_fcbc .GetFilterArray ());for _ ,_abdg :=range _fcbc ._cbgg {_abdbe :=_abdg .MakeStreamDict ();for _ ,_eegac :=range _abdbe .Keys (){_agdag :=_abdbe .Get (_eegac );if _eegac !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_eegac !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_degcf .Set (_eegac ,_agdag );};};};_aadb :=_fcbc .MakeDecodeParams ();if _aadb !=nil {_degcf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_aadb );};return _degcf ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_efea *PdfParser )GetFileOffset ()int64 {_ebddg ,_ :=_efea ._ggggc .Seek (0,_fe .SeekCurrent );_ebddg -=int64 (_efea ._dbfg .Buffered ());return _ebddg ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_gee .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_effc ,_gaae :=NewEncoderFromStream (streamObj );if _gaae !=nil {_gee .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_gaae );return _gaae ;};if _gcde ,_cgffa :=_effc .(*LZWEncoder );_cgffa {_gcde .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_gee .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_effc );_aaef ,_gaae :=_effc .EncodeBytes (streamObj .Stream );if _gaae !=nil {_gee .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_gaae );return _gaae ;};streamObj .Stream =_aaef ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aaef ))));return nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_bffc *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bffc .DecodeBytes (streamObj .Stream );};

// Len returns the number of elements in the streams.
func (_cfed *PdfObjectStreams )Len ()int {if _cfed ==nil {return 0;};return len (_cfed ._cbbd );};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_daeg *JBIG2Encoder )DecodeImages (encoded []byte )([]_gf .Image ,error ){const _fbd ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ffeg ,_edfe :=_e .Decode (encoded ,_e .Parameters {},_daeg .Globals .ToDocumentGlobals ());if _edfe !=nil {return nil ,_gfg .Wrap (_edfe ,_fbd ,"");};_cbef ,_edfe :=_ffeg .PageNumber ();if _edfe !=nil {return nil ,_gfg .Wrap (_edfe ,_fbd ,"");};_dcbe :=[]_gf .Image {};var _agdeg _gf .Image ;for _fefa :=1;_fefa <=_cbef ;_fefa ++{_agdeg ,_edfe =_ffeg .DecodePageImage (_fefa );if _edfe !=nil {return nil ,_gfg .Wrapf (_edfe ,_fbd ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fefa );};_dcbe =append (_dcbe ,_agdeg );};return _dcbe ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cgb *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// Append appends PdfObject(s) to the streams.
func (_fefec *PdfObjectStreams )Append (objects ...PdfObject ){if _fefec ==nil {_gee .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_fefec ._cbbd =append (_fefec ._cbbd ,objects ...);};func (_effe *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _gcba =20;_gaad ,_ :=_effe ._dbfg .Peek (_gcba );for _addc :=0;_addc < 2;_addc ++{if _effe ._abec ==0{_effe ._abec =_effe .GetFileOffset ();};if _gcgb .Match (_gaad ){_gee .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_gee .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_gaad ));return _effe .parseXrefStream (nil );};if _gada .Match (_gaad ){_gee .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _effe .parseXrefTable ();};_cgdg :=_effe .GetFileOffset ();if _effe ._abec ==0{_effe ._abec =_cgdg ;};_effe .SetFileOffset (_cgdg -_gcba );defer _effe .SetFileOffset (_cgdg );_gcgd ,_ :=_effe ._dbfg .Peek (_gcba );_gaad =append (_gcgd ,_gaad ...);};_gee .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _eaba :=_effe .repairSeekXrefMarker ();_eaba !=nil {_gee .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_eaba );return nil ,_eaba ;};return _effe .parseXrefTable ();};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _gf .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _fbdb ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_gfg .Error (_fbdb ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_gbcge uint8 ;_bceg _ade .Image ;_fedaf error ;);if bwThreshold ==JB2ImageAutoThreshold {_bceg ,_fedaf =_ade .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_gfg .Error (_fbdb ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_gbcge =uint8 (255*bwThreshold );_bceg ,_fedaf =_ade .MonochromeThresholdConverter (_gbcge ).Convert (i );};if _fedaf !=nil {return nil ,_fedaf ;};return _dbad (_bceg ),nil ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _fe .ReadSeeker )(*PdfParser ,error ){_dcgf :=&PdfParser {_ggggc :rs ,ObjCache :make (objectCache ),_afdg :map[int64 ]bool {}};_abeab ,_gccd ,_dedcb :=_dcgf .parsePdfVersion ();if _dedcb !=nil {_gee .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_dedcb );return nil ,_dedcb ;};_dcgf ._dgcc .Major =_abeab ;_dcgf ._dgcc .Minor =_gccd ;if _dcgf ._bdce ,_dedcb =_dcgf .loadXrefs ();_dedcb !=nil {_gee .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_dedcb );return nil ,_dedcb ;};_gee .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_dcgf ._bdce );if len (_dcgf ._gdfb .ObjectMap )==0{return nil ,_fbg .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _dcgf ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ddcc *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_efee :=MakeDict ();_efee .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ddcc .GetFilterName ()));return _efee ;};func _fcfcc (_dead *PdfObjectStream ,_fcdc *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};func (_adfd *PdfParser )parseObject ()(PdfObject ,error ){_gee .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_adfd .skipSpaces ();for {_ceec ,_aede :=_adfd ._dbfg .Peek (2);if _aede !=nil {if _aede !=_fe .EOF ||len (_ceec )==0{return nil ,_aede ;};if len (_ceec )==1{_ceec =append (_ceec ,' ');};};_gee .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_ceec ));if _ceec [0]=='/'{_gagf ,_cadf :=_adfd .parseName ();_gee .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_gagf );return &_gagf ,_cadf ;}else if _ceec [0]=='('{_gee .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_faed ,_ddbg :=_adfd .parseString ();return _faed ,_ddbg ;}else if _ceec [0]=='['{_gee .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_fefca ,_ebgbe :=_adfd .parseArray ();return _fefca ,_ebgbe ;}else if (_ceec [0]=='<')&&(_ceec [1]=='<'){_gee .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_efafd ,_cggc :=_adfd .ParseDict ();return _efafd ,_cggc ;}else if _ceec [0]=='<'{_gee .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_bdbd ,_bcefd :=_adfd .parseHexString ();return _bdbd ,_bcefd ;}else if _ceec [0]=='%'{_adfd .readComment ();_adfd .skipSpaces ();}else {_gee .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_ceec ,_ =_adfd ._dbfg .Peek (15);_fedea :=string (_ceec );_gee .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_fedea );if (len (_fedea )> 3)&&(_fedea [:4]=="\u006e\u0075\u006c\u006c"){_ggdg ,_fadg :=_adfd .parseNull ();return &_ggdg ,_fadg ;}else if (len (_fedea )> 4)&&(_fedea [:5]=="\u0066\u0061\u006cs\u0065"){_gcf ,_cadff :=_adfd .parseBool ();return &_gcf ,_cadff ;}else if (len (_fedea )> 3)&&(_fedea [:4]=="\u0074\u0072\u0075\u0065"){_ecf ,_fecbf :=_adfd .parseBool ();return &_ecf ,_fecbf ;};_abfed :=_cbgac .FindStringSubmatch (_fedea );if len (_abfed )> 1{_ceec ,_ =_adfd ._dbfg .ReadBytes ('R');_gee .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_ceec [:]));_bfgc ,_ddee :=_ffbb (string (_ceec ));_bfgc ._gedg =_adfd ;return &_bfgc ,_ddee ;};_fbca :=_bedd .FindStringSubmatch (_fedea );if len (_fbca )> 1{_gee .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_cddd ,_ddcg :=_adfd .parseNumber ();return _cddd ,_ddcg ;};_fbca =_ggea .FindStringSubmatch (_fedea );if len (_fbca )> 1{_gee .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_gee .Log .Trace ("\u0025\u0020\u0073",_fbca );_ffdc ,_edbgg :=_adfd .parseNumber ();return _ffdc ,_edbgg ;};_gee .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_fedea );return nil ,_fd .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};func (_eaacb *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_edeb :=_eaacb ._dbfg .Discard (4);return PdfObjectNull {},_edeb ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_fcda *_ade .ImageBase ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_ffabc *PdfObjectDictionary ,_facg bool ){_ffabc ,_facg =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _ffabc ,_facg ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};func (_faeb *PdfParser )xrefNextObjectOffset (_eedg int64 )int64 {_ddgee :=int64 (0);if len (_faeb ._gdfb .ObjectMap )==0{return 0;};if len (_faeb ._gdfb ._cb )==0{_eeac :=0;for _ ,_egdba :=range _faeb ._gdfb .ObjectMap {if _egdba .Offset > 0{_eeac ++;};};if _eeac ==0{return 0;};_faeb ._gdfb ._cb =make ([]XrefObject ,_eeac );_badf :=0;for _ ,_gdgg :=range _faeb ._gdfb .ObjectMap {if _gdgg .Offset > 0{_faeb ._gdfb ._cb [_badf ]=_gdgg ;_badf ++;};};_fb .Slice (_faeb ._gdfb ._cb ,func (_ebcg ,_eaeg int )bool {return _faeb ._gdfb ._cb [_ebcg ].Offset < _faeb ._gdfb ._cb [_eaeg ].Offset });};_eade :=_fb .Search (len (_faeb ._gdfb ._cb ),func (_ebfe int )bool {return _faeb ._gdfb ._cb [_ebfe ].Offset >=_eedg });if _eade < len (_faeb ._gdfb ._cb ){_ddgee =_faeb ._gdfb ._cb [_eade ].Offset ;};return _ddgee ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bbad ,_aabce :=obj .(*PdfObjectReference );_aabce {return _bbad .Resolve ();};return obj ;};func (_fgeag *PdfParser )rebuildXrefTable ()error {_bbfc :=XrefTable {};_bbfc .ObjectMap =map[int ]XrefObject {};_eaegd :=make ([]int ,0,len (_fgeag ._gdfb .ObjectMap ));for _bcee :=range _fgeag ._gdfb .ObjectMap {_eaegd =append (_eaegd ,_bcee );};_fb .Ints (_eaegd );for _ ,_ggeg :=range _eaegd {_eddf :=_fgeag ._gdfb .ObjectMap [_ggeg ];_acfc ,_ ,_afca :=_fgeag .lookupByNumberWrapper (_ggeg ,false );if _afca !=nil {_gee .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_afca );_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_ebfa ,_caae :=_fgeag .repairRebuildXrefsTopDown ();if _caae !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_caae );return _caae ;};_fgeag ._gdfb =*_ebfa ;_gee .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_cgbb ,_fgdb ,_afca :=_gec (_acfc );if _afca !=nil {return _afca ;};_eddf .ObjectNumber =int (_cgbb );_eddf .Generation =int (_fgdb );_bbfc .ObjectMap [int (_cgbb )]=_eddf ;};_fgeag ._gdfb =_bbfc ;_gee .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_cec (_fgeag ._gdfb );return nil ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_ebcgf *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _fedef :=val .(type ){case *PdfObjectName :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectDictionary :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectStream :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectString :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectNull :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectInteger :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectArray :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectBool :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectFloat :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfObjectReference :if _fedef !=nil {_ebcgf .Set (key ,val );};case *PdfIndirectObject :if _fedef !=nil {_ebcgf .Set (key ,val );};default:_gee .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// GetXrefTable returns the PDFs xref table.
func (_dgcbc *PdfParser )GetXrefTable ()XrefTable {return _dgcbc ._gdfb };func (_ffg *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_deaa :=MakeDict ();_deaa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_deaa .Set ("\u0056",MakeInteger (int64 (_ffg ._cdc .V )));_deaa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_ffg ._cdc .Length )));return _deaa ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_bcfb *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _bcfb .Predictor !=1{return nil ,_fbg .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _bcfb .EarlyChange ==1{return nil ,_fbg .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _bfbd _aaf .Buffer ;_agb :=_ac .NewWriter (&_bfbd ,_ac .MSB ,8);_agb .Write (data );_agb .Close ();return _bfbd .Bytes (),nil ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_afbd :=PdfObjectNull {};return &_afbd };func _eaed (_gebb int )int {if _gebb < 0{return -_gebb ;};return _gebb ;};func (_aaed *JBIG2Image )toBitmap ()(_caa *_cf .Bitmap ,_egac error ){const _dgba ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _aaed .Data ==nil {return nil ,_gfg .Error (_dgba ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _aaed .Width ==0||_aaed .Height ==0{return nil ,_gfg .Error (_dgba ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _aaed .HasPadding {_caa ,_egac =_cf .NewWithData (_aaed .Width ,_aaed .Height ,_aaed .Data );}else {_caa ,_egac =_cf .NewWithUnpaddedData (_aaed .Width ,_aaed .Height ,_aaed .Data );};if _egac !=nil {return nil ,_gfg .Wrap (_egac ,_dgba ,"");};return _caa ,nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_ecbd *JBIG2Encoder )Encode ()(_acge []byte ,_fdag error ){const _fdb ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _ecbd ._dgef ==nil {return nil ,_gfg .Errorf (_fdb ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_ecbd ._dgef .FullHeaders =_ecbd .DefaultPageSettings .FileMode ;_acge ,_fdag =_ecbd ._dgef .Encode ();if _fdag !=nil {return nil ,_gfg .Wrap (_fdag ,_fdb ,"");};return _acge ,nil ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_fgfba *PdfObjectReference )Resolve ()PdfObject {if _fgfba ._gedg ==nil {return MakeNull ();};_dfbg ,_ ,_dbgea :=_fgfba ._gedg .resolveReference (_fgfba );if _dbgea !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_dbgea );return MakeNull ();};if _dfbg ==nil {_gee .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _dfbg ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_fbbaf *PdfObjectString )Decoded ()string {if _fbbaf ==nil {return "";};_cdfef :=[]byte (_fbbaf ._ecea );if len (_cdfef )>=2&&_cdfef [0]==0xFE&&_cdfef [1]==0xFF{return _ad .UTF16ToString (_cdfef [2:]);};return _ad .PDFDocEncodingToString (_cdfef );};func (_ggde *PdfParser )readComment ()(string ,error ){var _cddc _aaf .Buffer ;_ ,_fbcd :=_ggde .skipSpaces ();if _fbcd !=nil {return _cddc .String (),_fbcd ;};_dbgc :=true ;for {_ccga ,_ceab :=_ggde ._dbfg .Peek (1);if _ceab !=nil {_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ceab .Error ());return _cddc .String (),_ceab ;};if _dbgc &&_ccga [0]!='%'{return _cddc .String (),_fd .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_dbgc =false ;if (_ccga [0]!='\r')&&(_ccga [0]!='\n'){_acfd ,_ :=_ggde ._dbfg .ReadByte ();_cddc .WriteByte (_acfd );}else {break ;};};return _cddc .String (),nil ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_bdec :=TraceToDirectObject (obj ).(*PdfObjectNull );return _bdec ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_bdfa :=PdfObjectBool (val );return &_bdfa };

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// SetImage sets the image base for given flate encoder.
func (_ccc *FlateEncoder )SetImage (img *_ade .ImageBase ){_ccc ._fcda =img };func _acffd (_fgcd string )(int ,int ,error ){_dcegd :=_gcgb .FindStringSubmatch (_fgcd );if len (_dcegd )< 3{return 0,0,_fd .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_fabgd ,_ :=_d .Atoi (_dcegd [1]);_dcgcb ,_ :=_d .Atoi (_dcegd [2]);return _fabgd ,_dcgcb ,nil ;};var _bedd =_gc .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ecg *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_cdad :=MakeDict ();_cdad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ecg .GetFilterName ()));return _cdad ;};func (_cefd *PdfCrypt )generateParams (_cad ,_ded []byte )error {_egbaa :=_cefd .securityHandler ();_fcbd ,_ddfg :=_egbaa .GenerateParams (&_cefd ._facd ,_ded ,_cad );if _ddfg !=nil {return _ddfg ;};_cefd ._aed =_fcbd ;return nil ;};func (_ebgf *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_ebgf ._gdfb .ObjectMap =make (map[int ]XrefObject );_ebgf ._edbb =make (objectStreams );_fagd ,_acdda :=_ebgf ._ggggc .Seek (0,_fe .SeekEnd );if _acdda !=nil {return nil ,_acdda ;};_gee .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_fagd );_ebgf ._eagf =_fagd ;_acdda =_ebgf .seekToEOFMarker (_fagd );if _acdda !=nil {_gee .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_acdda );return nil ,_acdda ;};_febff ,_acdda :=_ebgf ._ggggc .Seek (0,_fe .SeekCurrent );if _acdda !=nil {return nil ,_acdda ;};var _bgcda int64 =64;_febaf :=_febff -_bgcda ;if _febaf < 0{_febaf =0;};_ ,_acdda =_ebgf ._ggggc .Seek (_febaf ,_fe .SeekStart );if _acdda !=nil {return nil ,_acdda ;};_ggag :=make ([]byte ,_bgcda );_ ,_acdda =_ebgf ._ggggc .Read (_ggag );if _acdda !=nil {_gee .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_acdda );return nil ,_acdda ;};_bedfg :=_dece .FindStringSubmatch (string (_ggag ));if len (_bedfg )< 2{_gee .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_fd .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_bedfg )> 2{_gee .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_ggag );return nil ,_fd .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_dbgeb ,_ :=_d .ParseInt (_bedfg [1],10,64);_gee .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_dbgeb );if _dbgeb > _fagd {_gee .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_gee .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_dbgeb ,_acdda =_ebgf .repairLocateXref ();if _acdda !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_acdda ;};};_ebgf ._ggggc .Seek (_dbgeb ,_fe .SeekStart );_ebgf ._dbfg =_dd .NewReader (_ebgf ._ggggc );_ccbe ,_acdda :=_ebgf .parseXref ();if _acdda !=nil {return nil ,_acdda ;};_ddaa :=_ccbe .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _ddaa !=nil {_dafbg ,_agfe :=_ddaa .(*PdfObjectInteger );if !_agfe {return nil ,_fd .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_acdda =_ebgf .parseXrefStream (_dafbg );if _acdda !=nil {return nil ,_acdda ;};};var _aabd []int64 ;_gefg :=func (_addcc int64 ,_fbe []int64 )bool {for _ ,_dcgb :=range _fbe {if _dcgb ==_addcc {return true ;};};return false ;};_ddaa =_ccbe .Get ("\u0050\u0072\u0065\u0076");for _ddaa !=nil {_cgged ,_gdcc :=_ddaa .(*PdfObjectInteger );if !_gdcc {_gee .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_ddaa );return _ccbe ,nil ;};_fffbb :=*_cgged ;_gee .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_fffbb );_ebgf ._ggggc .Seek (int64 (_fffbb ),_fe .SeekStart );_ebgf ._dbfg =_dd .NewReader (_ebgf ._ggggc );_daba ,_bgec :=_ebgf .parseXref ();if _bgec !=nil {_gee .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_gee .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_ddaa =_daba .Get ("\u0050\u0072\u0065\u0076");if _ddaa !=nil {_fccf :=*(_ddaa .(*PdfObjectInteger ));if _gefg (int64 (_fccf ),_aabd ){_gee .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_aabd =append (_aabd ,int64 (_fccf ));};};return _ccbe ,nil ;};func (_bedf *PdfParser )parseName ()(PdfObjectName ,error ){var _egaa _aaf .Buffer ;_cada :=false ;for {_gebd ,_cbgfc :=_bedf ._dbfg .Peek (1);if _cbgfc ==_fe .EOF {break ;};if _cbgfc !=nil {return PdfObjectName (_egaa .String ()),_cbgfc ;};if !_cada {if _gebd [0]=='/'{_cada =true ;_bedf ._dbfg .ReadByte ();}else if _gebd [0]=='%'{_bedf .readComment ();_bedf .skipSpaces ();}else {_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_gebd ,_gebd );return PdfObjectName (_egaa .String ()),_fbg .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_gebd [0]);};}else {if IsWhiteSpace (_gebd [0]){break ;}else if (_gebd [0]=='/')||(_gebd [0]=='[')||(_gebd [0]=='(')||(_gebd [0]==']')||(_gebd [0]=='<')||(_gebd [0]=='>'){break ;}else if _gebd [0]=='#'{_fcegb ,_gbge :=_bedf ._dbfg .Peek (3);if _gbge !=nil {return PdfObjectName (_egaa .String ()),_gbge ;};_fbdfa ,_gbge :=_aa .DecodeString (string (_fcegb [1:3]));if _gbge !=nil {_gee .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_egaa .WriteByte ('#');_bedf ._dbfg .Discard (1);continue ;};_bedf ._dbfg .Discard (3);_egaa .Write (_fbdfa );}else {_badd ,_ :=_bedf ._dbfg .ReadByte ();_egaa .WriteByte (_badd );};};};return PdfObjectName (_egaa .String ()),nil ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_ceb bool ,_fcgfd bool ){_egadg ,_fcgfd :=TraceToDirectObject (obj ).(*PdfObjectBool );if _fcgfd {return bool (*_egadg ),true ;};return false ,false ;};func (_baff *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_fe .SeekStart {offset +=_baff ._bacg ;};_bdbc ,_ffedg :=_baff ._fefd .Seek (offset ,whence );if _ffedg !=nil {return _bdbc ,_ffedg ;};if whence ==_fe .SeekCurrent {_bdbc -=_baff ._bacg ;};if _bdbc < 0{return 0,_fd .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _bdbc ,nil ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_fbba *PdfParser )CheckAccessRights (password []byte )(bool ,_ee .Permissions ,error ){if _fbba ._dfab ==nil {return true ,_ee .PermOwner ,nil ;};return _fbba ._dfab .checkAccessRights (password );};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_agea *PdfObjectString )Str ()string {return _agea ._ecea };

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_dgbc Version )String ()string {return _fbg .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_dgbc .Major ,_dgbc .Minor );};

// Clear resets the array to an empty state.
func (_fcgf *PdfObjectArray )Clear (){_fcgf ._gfdc =[]PdfObject {}};func _agc (_cdaf *PdfObjectStream ,_cbae *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _fede ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_bgga :=&JBIG2Encoder {};_bdfb :=_cdaf .PdfObjectDictionary ;if _bdfb ==nil {return _bgga ,nil ;};if _cbae ==nil {_adfe :=_bdfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _adfe !=nil {switch _bdab :=_adfe .(type ){case *PdfObjectDictionary :_cbae =_bdab ;case *PdfObjectArray :if _bdab .Len ()==1{if _acaa ,_ebdf :=GetDict (_bdab .Get (0));_ebdf {_cbae =_acaa ;};};default:_gee .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_adfe );return nil ,_gfg .Errorf (_fede ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_bdab );};};};if _cbae ==nil {return _bgga ,nil ;};_bgga .UpdateParams (_cbae );_eagc :=_cbae .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _eagc ==nil {return _bgga ,nil ;};var _dbaf error ;_bcd ,_eegb :=_eagc .(*PdfObjectStream );if !_eegb {_dbaf =_gfg .Error (_fede ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_gee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dbaf );return nil ,_dbaf ;};_bgga .Globals ,_dbaf =_ba .DecodeGlobals (_bcd .Stream );if _dbaf !=nil {_dbaf =_gfg .Wrap (_dbaf ,_fede ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_gee .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dbaf );return nil ,_dbaf ;};return _bgga ,nil ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// String returns a string describing `d`.
func (_facf *PdfObjectDictionary )String ()string {var _ecfdb _ab .Builder ;_ecfdb .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_dfed :=range _facf ._aeba {_baabg :=_facf ._bagbd [_dfed ];_ecfdb .WriteString ("\u0022"+_dfed .String ()+"\u0022\u003a\u0020");_ecfdb .WriteString (_baabg .String ());_ecfdb .WriteString ("\u002c\u0020");};_ecfdb .WriteString ("\u0029");return _ecfdb .String ();};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_adgg *JBIG2Encoder )EncodeImage (img _gf .Image )([]byte ,error ){return _adgg .encodeImage (img )};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_dada *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dca :=_aaf .NewReader (encoded );_dba ,_adec :=_ag .Decode (_dca );if _adec !=nil {_gee .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_adec );return nil ,_adec ;};_gacf :=_dba .Bounds ();var _fabgb =make ([]byte ,_gacf .Dx ()*_gacf .Dy ()*_dada .ColorComponents *_dada .BitsPerComponent /8);_gcdg :=0;for _gacd :=_gacf .Min .Y ;_gacd < _gacf .Max .Y ;_gacd ++{for _bggd :=_gacf .Min .X ;_bggd < _gacf .Max .X ;_bggd ++{_fcfc :=_dba .At (_bggd ,_gacd );if _dada .ColorComponents ==1{if _dada .BitsPerComponent ==16{_dfde ,_gbae :=_fcfc .(_a .Gray16 );if !_gbae {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fabgb [_gcdg ]=byte ((_dfde .Y >>8)&0xff);_gcdg ++;_fabgb [_gcdg ]=byte (_dfde .Y &0xff);_gcdg ++;}else {_afe ,_dab :=_fcfc .(_a .Gray );if !_dab {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fabgb [_gcdg ]=_afe .Y &0xff;_gcdg ++;};}else if _dada .ColorComponents ==3{if _dada .BitsPerComponent ==16{_gbed ,_gaa :=_fcfc .(_a .RGBA64 );if !_gaa {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fabgb [_gcdg ]=byte ((_gbed .R >>8)&0xff);_gcdg ++;_fabgb [_gcdg ]=byte (_gbed .R &0xff);_gcdg ++;_fabgb [_gcdg ]=byte ((_gbed .G >>8)&0xff);_gcdg ++;_fabgb [_gcdg ]=byte (_gbed .G &0xff);_gcdg ++;_fabgb [_gcdg ]=byte ((_gbed .B >>8)&0xff);_gcdg ++;_fabgb [_gcdg ]=byte (_gbed .B &0xff);_gcdg ++;}else {_bfdb ,_gaaa :=_fcfc .(_a .RGBA );if _gaaa {_fabgb [_gcdg ]=_bfdb .R &0xff;_gcdg ++;_fabgb [_gcdg ]=_bfdb .G &0xff;_gcdg ++;_fabgb [_gcdg ]=_bfdb .B &0xff;_gcdg ++;}else {_cab ,_afbf :=_fcfc .(_a .YCbCr );if !_afbf {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cca ,_acgd ,_bccbb ,_ :=_cab .RGBA ();_fabgb [_gcdg ]=byte (_cca >>8);_gcdg ++;_fabgb [_gcdg ]=byte (_acgd >>8);_gcdg ++;_fabgb [_gcdg ]=byte (_bccbb >>8);_gcdg ++;};};}else if _dada .ColorComponents ==4{_gcbd ,_dcab :=_fcfc .(_a .CMYK );if !_dcab {return nil ,_fd .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fabgb [_gcdg ]=255-_gcbd .C &0xff;_gcdg ++;_fabgb [_gcdg ]=255-_gcbd .M &0xff;_gcdg ++;_fabgb [_gcdg ]=255-_gcbd .Y &0xff;_gcdg ++;_fabgb [_gcdg ]=255-_gcbd .K &0xff;_gcdg ++;};};};return _fabgb ,nil ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_afbg []byte ,_dbbgb bool ){_dcdgb ,_dbbgb :=TraceToDirectObject (obj ).(*PdfObjectString );if _dbbgb {return _dcdgb .Bytes (),true ;};return ;};func (_eddb *PdfParser )repairSeekXrefMarker ()error {_abae ,_gced :=_eddb ._ggggc .Seek (0,_fe .SeekEnd );if _gced !=nil {return _gced ;};_dgcgc :=_gc .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _fbce int64 ;var _efca int64 =1000;for _fbce < _abae {if _abae <=(_efca +_fbce ){_efca =_abae -_fbce ;};_ ,_fbcc :=_eddb ._ggggc .Seek (-_fbce -_efca ,_fe .SeekEnd );if _fbcc !=nil {return _fbcc ;};_fggf :=make ([]byte ,_efca );_eddb ._ggggc .Read (_fggf );_gee .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_fggf ));_gbbcd :=_dgcgc .FindAllStringIndex (string (_fggf ),-1);if _gbbcd !=nil {_fdaf :=_gbbcd [len (_gbbcd )-1];_gee .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gbbcd );_eddb ._ggggc .Seek (-_fbce -_efca +int64 (_fdaf [0]),_fe .SeekEnd );_eddb ._dbfg =_dd .NewReader (_eddb ._ggggc );for {_gcgbf ,_cfeb :=_eddb ._dbfg .Peek (1);if _cfeb !=nil {return _cfeb ;};_gee .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_gcgbf [0],_gcgbf [0]);if !IsWhiteSpace (_gcgbf [0]){break ;};_eddb ._dbfg .Discard (1);};return nil ;};_gee .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_fbce +=_efca ;};_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _fd .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};func _ddcb (_bfdea ,_dgdca PdfObject ,_fdbg int )bool {if _fdbg > _gcaa {_gee .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_gcaa );return false ;};if _bfdea ==nil &&_dgdca ==nil {return true ;}else if _bfdea ==nil ||_dgdca ==nil {return false ;};if _g .TypeOf (_bfdea )!=_g .TypeOf (_dgdca ){return false ;};switch _ebbc :=_bfdea .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_ebbc ==*(_dgdca .(*PdfObjectName ));case *PdfObjectString :return *_ebbc ==*(_dgdca .(*PdfObjectString ));case *PdfObjectInteger :return *_ebbc ==*(_dgdca .(*PdfObjectInteger ));case *PdfObjectBool :return *_ebbc ==*(_dgdca .(*PdfObjectBool ));case *PdfObjectFloat :return *_ebbc ==*(_dgdca .(*PdfObjectFloat ));case *PdfIndirectObject :return _ddcb (TraceToDirectObject (_bfdea ),TraceToDirectObject (_dgdca ),_fdbg +1);case *PdfObjectArray :_cgbcc :=_dgdca .(*PdfObjectArray );if len ((*_ebbc )._gfdc )!=len ((*_cgbcc )._gfdc ){return false ;};for _cbfef ,_bggdd :=range (*_ebbc )._gfdc {if !_ddcb (_bggdd ,(*_cgbcc )._gfdc [_cbfef ],_fdbg +1){return false ;};};return true ;case *PdfObjectDictionary :_fbccf :=_dgdca .(*PdfObjectDictionary );_fecad ,_gceag :=(*_ebbc )._bagbd ,(*_fbccf )._bagbd ;if len (_fecad )!=len (_gceag ){return false ;};for _fdba ,_agad :=range _fecad {_bgba ,_gbfb :=_gceag [_fdba ];if !_gbfb ||!_ddcb (_agad ,_bgba ,_fdbg +1){return false ;};};return true ;case *PdfObjectStream :_ccggf :=_dgdca .(*PdfObjectStream );return _ddcb ((*_ebbc ).PdfObjectDictionary ,(*_ccggf ).PdfObjectDictionary ,_fdbg +1);default:_gee .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_bfdea );};return false ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_faff *PdfParser )Inspect ()(map[string ]int ,error ){return _faff .inspect ()};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_gbdb *PdfParser )GetObjectNums ()[]int {var _feegf []int ;for _ ,_dcfdb :=range _gbdb ._gdfb .ObjectMap {_feegf =append (_feegf ,_dcfdb .ObjectNumber );};_fb .Ints (_feegf );return _feegf ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_ecfe :=PdfObjectFloat (val );return &_ecfe };

// WriteString outputs the object as it is to be written to file.
func (_aaba *PdfObjectReference )WriteString ()string {var _eccf _ab .Builder ;_eccf .WriteString (_d .FormatInt (_aaba .ObjectNumber ,10));_eccf .WriteString ("\u0020");_eccf .WriteString (_d .FormatInt (_aaba .GenerationNumber ,10));_eccf .WriteString ("\u0020\u0052");return _eccf .String ();};

// String returns a string describing `stream`.
func (_fcff *PdfObjectStream )String ()string {return _fbg .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_fcff .ObjectNumber ,_fcff .PdfObjectDictionary );};func _bgbe ()string {return _gee .Version };func (_badbd *PdfParser )readTextLine ()(string ,error ){var _caea _aaf .Buffer ;for {_cdfe ,_fae :=_badbd ._dbfg .Peek (1);if _fae !=nil {_gee .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fae .Error ());return _caea .String (),_fae ;};if (_cdfe [0]!='\r')&&(_cdfe [0]!='\n'){_efaf ,_ :=_badbd ._dbfg .ReadByte ();_caea .WriteByte (_efaf );}else {break ;};};return _caea .String (),nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_afce *PdfObjectStreams ,_eede bool ){_afce ,_eede =obj .(*PdfObjectStreams );return _afce ,_eede ;};func (_beg *PdfCrypt )encryptBytes (_ggge []byte ,_bfa string ,_caca []byte )([]byte ,error ){_gee .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cgf ,_cgef :=_beg ._efb [_bfa ];if !_cgef {return nil ,_fbg .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bfa );};return _cgf .EncryptBytes (_ggge ,_caca );};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_gcacb *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _feaa []float64 ;for _ ,_degf :=range _gcacb .Elements (){switch _abge :=_degf .(type ){case *PdfObjectInteger :_feaa =append (_feaa ,float64 (*_abge ));case *PdfObjectFloat :_feaa =append (_feaa ,float64 (*_abge ));default:return nil ,ErrTypeError ;};};return _feaa ,nil ;};func (_bbfa *PdfParser )repairLocateXref ()(int64 ,error ){_gfegb :=int64 (1000);_bbfa ._ggggc .Seek (-_gfegb ,_fe .SeekCurrent );_fdeg ,_eeea :=_bbfa ._ggggc .Seek (0,_fe .SeekCurrent );if _eeea !=nil {return 0,_eeea ;};_gcddb :=make ([]byte ,_gfegb );_bbfa ._ggggc .Read (_gcddb );_bfag :=_ffedb .FindAllStringIndex (string (_gcddb ),-1);if len (_bfag )< 1{_gee .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_fd .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_gbdgbe :=int64 (_bfag [len (_bfag )-1][0]);_daed :=_fdeg +_gbdgbe ;return _daed ,nil ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_afbfd :=&PdfObjectDictionary {};_afbfd ._bagbd =map[PdfObjectName ]PdfObject {};_afbfd ._aeba =[]PdfObjectName {};return _afbfd ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_fffca *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_ddfa :=n ;_abgf :=0;_gfga :=0;for _ddfa > 0{_cbaee ,_gafde :=_fffca ._dbfg .Read (p [_abgf :]);if _gafde !=nil {_gee .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_cbaee ,_gfga ,_gafde .Error ());return _abgf ,_fd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_gfga ++;_abgf +=_cbaee ;_ddfa -=_cbaee ;};return _abgf ,nil ;};