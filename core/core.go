//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_de "bufio";_eg "bytes";_fc "compress/lzw";_ce "compress/zlib";_eb "crypto/md5";_ba "crypto/rand";_gg "encoding/hex";_b "errors";_gb "fmt";_egd "github.com/unidoc/unipdf/v3/common";_bc "github.com/unidoc/unipdf/v3/core/security";_gc "github.com/unidoc/unipdf/v3/core/security/crypt";_fe "github.com/unidoc/unipdf/v3/internal/ccittfax";_ecc "github.com/unidoc/unipdf/v3/internal/imageutil";_be "github.com/unidoc/unipdf/v3/internal/jbig2";_fea "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ec "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_cd "github.com/unidoc/unipdf/v3/internal/jbig2/document";_egg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_fa "github.com/unidoc/unipdf/v3/internal/strutils";_dd "golang.org/x/image/tiff/lzw";_bg "golang.org/x/xerrors";_dc "image";_c "image/color";_d "image/jpeg";_dg "io";_f "reflect";_g "regexp";_ed "sort";_bf "strconv";_fb "strings";_gf "time";);func (_bed *PdfCrypt )generateParams (_aeff ,_dfc []byte )error {_bbeg :=_bed .securityHandler ();_bef ,_gae :=_bbeg .GenerateParams (&_bed ._adg ,_dfc ,_aeff );if _gae !=nil {return _gae ;};_bed ._fde =_bef ;return nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};func (_fca *PdfCrypt )isEncrypted (_fda PdfObject )bool {_ ,_ccc :=_fca ._bec [_fda ];if _ccc {_egd .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_egd .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_bcbe *PdfObjectStream ,_cded bool ){obj =ResolveReference (obj );_bcbe ,_cded =obj .(*PdfObjectStream );return _bcbe ,_cded ;};const JB2ImageAutoThreshold =-1.0;

// GetFilterName returns the name of the encoding filter.
func (_eged *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// DecodeBytes decodes the CCITTFax encoded image data.
func (_acbd *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eabg :=&_fe .Encoder {K :_acbd .K ,Columns :_acbd .Columns ,EndOfLine :_acbd .EndOfLine ,EndOfBlock :_acbd .EndOfBlock ,BlackIs1 :_acbd .BlackIs1 ,DamagedRowsBeforeError :_acbd .DamagedRowsBeforeError ,Rows :_acbd .Rows ,EncodedByteAlign :_acbd .EncodedByteAlign };_dddg ,_fefg :=_eabg .Decode (encoded );if _fefg !=nil {return nil ,_fefg ;};var _aadb []byte ;_deff :=0;var _bccd byte ;var _dbbb byte ;for _ggac :=range _dddg {if _bccd !=0{_aadb =append (_aadb ,_dbbb );_dbbb =0;_deff ++;_bccd =0;};for _bgfa :=range _dddg [_ggac ]{_dbbb |=_dddg [_ggac ][_bgfa ]<<(7-_bccd );_bccd ++;if _bccd ==8{_aadb =append (_aadb ,_dbbb );_dbbb =0;_deff ++;_bccd =0;};};};if _bccd > 0{_aadb =append (_aadb ,_dbbb );};return _aadb ,nil ;};func _eca (_bcg *_bc .StdEncryptDict ,_dag *PdfObjectDictionary )error {R ,_fge :=_dag .Get ("\u0052").(*PdfObjectInteger );if !_fge {return _b .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_bcg .R =int (*R );O ,_fge :=_dag .GetString ("\u004f");if !_fge {return _b .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _bcg .R ==5||_bcg .R ==6{if len (O )< 48{return _gb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _gb .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_bcg .O =[]byte (O );U ,_fge :=_dag .GetString ("\u0055");if !_fge {return _b .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _bcg .R ==5||_bcg .R ==6{if len (U )< 48{return _gb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_egd .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_bcg .U =[]byte (U );if _bcg .R >=5{OE ,_abe :=_dag .GetString ("\u004f\u0045");if !_abe {return _b .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _gb .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_bcg .OE =[]byte (OE );UE ,_abe :=_dag .GetString ("\u0055\u0045");if !_abe {return _b .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _gb .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_bcg .UE =[]byte (UE );};P ,_fge :=_dag .Get ("\u0050").(*PdfObjectInteger );if !_fge {return _b .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_bcg .P =_bc .Permissions (*P );if _bcg .R ==6{Perms ,_agf :=_dag .GetString ("\u0050\u0065\u0072m\u0073");if !_agf {return _b .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _gb .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_bcg .Perms =[]byte (Perms );};if _bae ,_egfb :=_dag .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_egfb {_bcg .EncryptMetadata =bool (*_bae );}else {_bcg .EncryptMetadata =true ;};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fdde *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_ggbb *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_egd .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_egd .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ggbb .Predictor );if _ggbb .BitsPerComponent !=8{return nil ,_gb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_ggbb .BitsPerComponent );};_bdc ,_cdggb :=_ggbb .DecodeBytes (streamObj .Stream );if _cdggb !=nil {return nil ,_cdggb ;};_bdc ,_cdggb =_ggbb .postDecodePredict (_bdc );if _cdggb !=nil {return nil ,_cdggb ;};return _ggbb .cleanImageData (_bdc );};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_bdce :=_eg .NewReader ([]byte (txt ));_cbac :=&PdfParser {ObjCache :objectCache {},_ecgc :_bdce ,_degc :_de .NewReader (_bdce ),_aacb :int64 (len (txt )),_dffa :map[int64 ]bool {}};_cbac ._cggf .ObjectMap =make (map[int ]XrefObject );return _cbac ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_edba *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_egd .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_befdf :=MakeDict ();_befdf ._cgab =_edba ;_gbdee ,_ :=_edba ._degc .ReadByte ();if _gbdee !='<'{return nil ,_b .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_gbdee ,_ =_edba ._degc .ReadByte ();if _gbdee !='<'{return nil ,_b .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_edba .skipSpaces ();_edba .skipComments ();_gcba ,_gdae :=_edba ._degc .Peek (2);if _gdae !=nil {return nil ,_gdae ;};_egd .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_gcba ),string (_gcba ));if (_gcba [0]=='>')&&(_gcba [1]=='>'){_egd .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_edba ._degc .ReadByte ();_edba ._degc .ReadByte ();break ;};_egd .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_adfa ,_gdae :=_edba .parseName ();_egd .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_adfa );if _gdae !=nil {_egd .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_gdae );return nil ,_gdae ;};if len (_adfa )> 4&&_adfa [len (_adfa )-4:]=="\u006e\u0075\u006c\u006c"{_dgbg :=_adfa [0:len (_adfa )-4];_egd .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_adfa );_egd .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_dgbg );_edba .skipSpaces ();_feee ,_ :=_edba ._degc .Peek (1);if _feee [0]=='/'{_befdf .Set (_dgbg ,MakeNull ());continue ;};};_edba .skipSpaces ();_ccae ,_gdae :=_edba .parseObject ();if _gdae !=nil {return nil ,_gdae ;};_befdf .Set (_adfa ,_ccae );if _egd .Log .IsLogLevel (_egd .LogLevelTrace ){_egd .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_adfa ,_ccae .String ());};};_egd .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _befdf ,nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_gfba *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _ccgga ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _adagbf :=_gfba .AddPageImage (img ,&_gfba .DefaultPageSettings );_adagbf !=nil {return nil ,_egg .Wrap (_adagbf ,_ccgga ,"");};return _gfba .Encode ();};type objectCache map[int ]PdfObject ;

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func (_gbeaa *PdfParser )parseObject ()(PdfObject ,error ){_egd .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_gbeaa .skipSpaces ();for {_gbdd ,_abfff :=_gbeaa ._degc .Peek (2);if _abfff !=nil {if _abfff !=_dg .EOF ||len (_gbdd )==0{return nil ,_abfff ;};if len (_gbdd )==1{_gbdd =append (_gbdd ,' ');};};_egd .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_gbdd ));if _gbdd [0]=='/'{_egdcg ,_cgfa :=_gbeaa .parseName ();_egd .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_egdcg );return &_egdcg ,_cgfa ;}else if _gbdd [0]=='('{_egd .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_bfgbg ,_fffac :=_gbeaa .parseString ();return _bfgbg ,_fffac ;}else if _gbdd [0]=='['{_egd .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_efec ,_bcae :=_gbeaa .parseArray ();return _efec ,_bcae ;}else if (_gbdd [0]=='<')&&(_gbdd [1]=='<'){_egd .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_cfdg ,_fdea :=_gbeaa .ParseDict ();return _cfdg ,_fdea ;}else if _gbdd [0]=='<'{_egd .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_bdcg ,_daad :=_gbeaa .parseHexString ();return _bdcg ,_daad ;}else if _gbdd [0]=='%'{_gbeaa .readComment ();_gbeaa .skipSpaces ();}else {_egd .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_gbdd ,_ =_gbeaa ._degc .Peek (15);_bfed :=string (_gbdd );_egd .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_bfed );if (len (_bfed )> 3)&&(_bfed [:4]=="\u006e\u0075\u006c\u006c"){_abcea ,_cdeg :=_gbeaa .parseNull ();return &_abcea ,_cdeg ;}else if (len (_bfed )> 4)&&(_bfed [:5]=="\u0066\u0061\u006cs\u0065"){_cfgc ,_dcdf :=_gbeaa .parseBool ();return &_cfgc ,_dcdf ;}else if (len (_bfed )> 3)&&(_bfed [:4]=="\u0074\u0072\u0075\u0065"){_ffdfg ,_beab :=_gbeaa .parseBool ();return &_ffdfg ,_beab ;};_dbad :=_cbf .FindStringSubmatch (_bfed );if len (_dbad )> 1{_gbdd ,_ =_gbeaa ._degc .ReadBytes ('R');_egd .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_gbdd [:]));_egab ,_aaeda :=_cafbc (string (_gbdd ));_egab ._fabe =_gbeaa ;return &_egab ,_aaeda ;};_cebd :=_dcbbe .FindStringSubmatch (_bfed );if len (_cebd )> 1{_egd .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_dea ,_adgf :=_gbeaa .parseNumber ();return _dea ,_adgf ;};_cebd =_cfee .FindStringSubmatch (_bfed );if len (_cebd )> 1{_egd .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_egd .Log .Trace ("\u0025\u0020\u0073",_cebd );_aacd ,_cdagc :=_gbeaa .parseNumber ();return _aacd ,_cdagc ;};_egd .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_bfed );return nil ,_b .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};func _cbdg (_fbac string )(int ,int ,error ){_bace :=_gcef .FindStringSubmatch (_fbac );if len (_bace )< 3{return 0,0,_b .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_egga ,_ :=_bf .Atoi (_bace [1]);_eadfb ,_ :=_bf .Atoi (_bace [2]);return _egga ,_eadfb ,nil ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_bfff *PdfObjectFloat ,_fbfbg bool ){_bfff ,_fbfbg =TraceToDirectObject (obj ).(*PdfObjectFloat );return _bfff ,_fbfbg ;};func (_eadf *PdfParser )resolveReference (_aaggc *PdfObjectReference )(PdfObject ,bool ,error ){_cdfe ,_gdgg :=_eadf .ObjCache [int (_aaggc .ObjectNumber )];if _gdgg {return _cdfe ,true ,nil ;};_fbeac ,_fdgd :=_eadf .LookupByReference (*_aaggc );if _fdgd !=nil {return nil ,false ,_fdgd ;};_eadf .ObjCache [int (_aaggc .ObjectNumber )]=_fbeac ;return _fbeac ,false ,nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _cgfd _eg .Buffer ;_cgfd .Write ([]byte {0xFE,0xFF});_cgfd .WriteString (_fa .StringToUTF16 (s ));return &PdfObjectString {_cdfb :_cgfd .String (),_bfae :true };};return &PdfObjectString {_cdfb :string (_fa .StringToPDFDocEncoding (s )),_bfae :false };};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_aagc *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_fabfe :=MakeDict ();_fabfe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aagc .GetFilterName ()));return _fabfe ;};

// Append appends PdfObject(s) to the streams.
func (_ggacg *PdfObjectStreams )Append (objects ...PdfObject ){if _ggacg ==nil {_egd .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_ggacg ._abea =append (_ggacg ._abea ,objects ...);};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dbca *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _bgcc []int64 ;for _ ,_defd :=range _dbca .Elements (){if _efff ,_ffcba :=_defd .(*PdfObjectInteger );_ffcba {_bgcc =append (_bgcc ,int64 (*_efff ));}else {return nil ,ErrTypeError ;};};return _bgcc ,nil ;};func _cfb (_eega *PdfObjectStream ,_ccg *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// String returns a string describing `d`.
func (_fegea *PdfObjectDictionary )String ()string {var _bfecf _fb .Builder ;_bfecf .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_ecbgg :=range _fegea ._cecc {_gbdcc :=_fegea ._ffeb [_ecbgg ];_bfecf .WriteString ("\u0022"+_ecbgg .String ()+"\u0022\u003a\u0020");_bfecf .WriteString (_gbdcc .String ());_bfecf .WriteString ("\u002c\u0020");};_bfecf .WriteString ("\u0029");return _bfecf .String ();};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_ebd *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _fgfg []byte ;_egd .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_fdbe :=0;_bfdee :=false ;for _fdbe < len (encoded )&&!_bfdee {_geff :=[5]byte {0,0,0,0,0};_cegd :=0;_cebc :=0;_bgea :=4;for _cebc < 5+_cegd {if _fdbe +_cebc ==len (encoded ){break ;};_bfcag :=encoded [_fdbe +_cebc ];if IsWhiteSpace (_bfcag ){_cegd ++;_cebc ++;continue ;}else if _bfcag =='~'&&_fdbe +_cebc +1< len (encoded )&&encoded [_fdbe +_cebc +1]=='>'{_bgea =(_cebc -_cegd )-1;if _bgea < 0{_bgea =0;};_bfdee =true ;break ;}else if _bfcag >='!'&&_bfcag <='u'{_bfcag -='!';}else if _bfcag =='z'&&_cebc -_cegd ==0{_bgea =4;_cebc ++;break ;}else {_egd .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_geff [_cebc -_cegd ]=_bfcag ;_cebc ++;};_fdbe +=_cebc ;for _gfbff :=_bgea +1;_gfbff < 5;_gfbff ++{_geff [_gfbff ]=84;};_aed :=uint32 (_geff [0])*85*85*85*85+uint32 (_geff [1])*85*85*85+uint32 (_geff [2])*85*85+uint32 (_geff [3])*85+uint32 (_geff [4]);_fbda :=[]byte {byte ((_aed >>24)&0xff),byte ((_aed >>16)&0xff),byte ((_aed >>8)&0xff),byte (_aed &0xff)};_fgfg =append (_fgfg ,_fbda [:_bgea ]...);};_egd .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_egd .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_fgfg );return _fgfg ,nil ;};func _agga (_acc _gc .Filter ,_ffb _bc .AuthEvent )*PdfObjectDictionary {if _ffb ==""{_ffb =_bc .EventDocOpen ;};_ece :=MakeDict ();_ece .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_ece .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_ffb )));_ece .Set ("\u0043\u0046\u004d",MakeName (_acc .Name ()));_ece .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_acc .KeyLength ())));return _ece ;};

// WriteString outputs the object as it is to be written to file.
func (_badbd *PdfObjectFloat )WriteString ()string {return _bf .FormatFloat (float64 (*_badbd ),'f',-1,64);};

// Remove removes an element specified by key.
func (_fbbgb *PdfObjectDictionary )Remove (key PdfObjectName ){_baea :=-1;for _bbge ,_gaaa :=range _fbbgb ._cecc {if _gaaa ==key {_baea =_bbge ;break ;};};if _baea >=0{_fbbgb ._cecc =append (_fbbgb ._cecc [:_baea ],_fbbgb ._cecc [_baea +1:]...);delete (_fbbgb ._ffeb ,key );};};func (_egdde *PdfParser )parseString ()(*PdfObjectString ,error ){_egdde ._degc .ReadByte ();var _dbbba _eg .Buffer ;_bgff :=1;for {_abcee ,_abdd :=_egdde ._degc .Peek (1);if _abdd !=nil {return MakeString (_dbbba .String ()),_abdd ;};if _abcee [0]=='\\'{_egdde ._degc .ReadByte ();_ggbaf ,_gdgf :=_egdde ._degc .ReadByte ();if _gdgf !=nil {return MakeString (_dbbba .String ()),_gdgf ;};if IsOctalDigit (_ggbaf ){_dae ,_ace :=_egdde ._degc .Peek (2);if _ace !=nil {return MakeString (_dbbba .String ()),_ace ;};var _fbea []byte ;_fbea =append (_fbea ,_ggbaf );for _ ,_adc :=range _dae {if IsOctalDigit (_adc ){_fbea =append (_fbea ,_adc );}else {break ;};};_egdde ._degc .Discard (len (_fbea )-1);_egd .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_fbea );_fgag ,_ace :=_bf .ParseUint (string (_fbea ),8,32);if _ace !=nil {return MakeString (_dbbba .String ()),_ace ;};_dbbba .WriteByte (byte (_fgag ));continue ;};switch _ggbaf {case 'n':_dbbba .WriteRune ('\n');case 'r':_dbbba .WriteRune ('\r');case 't':_dbbba .WriteRune ('\t');case 'b':_dbbba .WriteRune ('\b');case 'f':_dbbba .WriteRune ('\f');case '(':_dbbba .WriteRune ('(');case ')':_dbbba .WriteRune (')');case '\\':_dbbba .WriteRune ('\\');};continue ;}else if _abcee [0]=='('{_bgff ++;}else if _abcee [0]==')'{_bgff --;if _bgff ==0{_egdde ._degc .ReadByte ();break ;};};_ddcd ,_ :=_egdde ._degc .ReadByte ();_dbbba .WriteByte (_ddcd );};return MakeString (_dbbba .String ()),nil ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;func (_bbcb *PdfParser )parseName ()(PdfObjectName ,error ){var _cbaf _eg .Buffer ;_ggab :=false ;for {_cdba ,_cfbag :=_bbcb ._degc .Peek (1);if _cfbag ==_dg .EOF {break ;};if _cfbag !=nil {return PdfObjectName (_cbaf .String ()),_cfbag ;};if !_ggab {if _cdba [0]=='/'{_ggab =true ;_bbcb ._degc .ReadByte ();}else if _cdba [0]=='%'{_bbcb .readComment ();_bbcb .skipSpaces ();}else {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_cdba ,_cdba );return PdfObjectName (_cbaf .String ()),_gb .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_cdba [0]);};}else {if IsWhiteSpace (_cdba [0]){break ;}else if (_cdba [0]=='/')||(_cdba [0]=='[')||(_cdba [0]=='(')||(_cdba [0]==']')||(_cdba [0]=='<')||(_cdba [0]=='>'){break ;}else if _cdba [0]=='#'{_fddca ,_gege :=_bbcb ._degc .Peek (3);if _gege !=nil {return PdfObjectName (_cbaf .String ()),_gege ;};_feb ,_gege :=_gg .DecodeString (string (_fddca [1:3]));if _gege !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_cbaf .WriteByte ('#');_bbcb ._degc .Discard (1);continue ;};_bbcb ._degc .Discard (3);_cbaf .Write (_feb );}else {_cged ,_ :=_bbcb ._degc .ReadByte ();_cbaf .WriteByte (_cged );};};};return PdfObjectName (_cbaf .String ()),nil ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_abaa *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _abaa .DecodeBytes (streamObj .Stream );};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_df []XrefObject ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_ggae string ,_bedg bool ){_eecbb ,_bedg :=TraceToDirectObject (obj ).(*PdfObjectName );if _bedg {return string (*_eecbb ),true ;};return ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_eaca []StreamEncoder };

// GetXrefOffset returns the offset of the xref table.
func (_fadcf *PdfParser )GetXrefOffset ()int64 {return _fadcf ._edeb };

// GetFilterName returns the name of the encoding filter.
func (_bbd *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cadg *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_cddee string ,_bbad bool ){_feagg ,_bbad :=TraceToDirectObject (obj ).(*PdfObjectString );if _bbad {return _feagg .Str (),true ;};return ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_cdgcf *PdfIndirectObject ,_abfe bool ){obj =ResolveReference (obj );_cdgcf ,_abfe =obj .(*PdfIndirectObject );return _cdgcf ,_abfe ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dbg *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_dbg ._eaca )==0{return nil ;};if len (_dbg ._eaca )==1{return _dbg ._eaca [0].MakeDecodeParams ();};_fba :=MakeArray ();for _ ,_bgdc :=range _dbg ._eaca {_gbf :=_bgdc .MakeDecodeParams ();if _gbf ==nil {_fba .Append (MakeNull ());}else {_fba .Append (_gbf );};};return _fba ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_bbda :=PdfObjectNull {};return &_bbda };var _cfee =_g .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_abb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_cbed :=MakeDict ();_cbed .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_abb .GetFilterName ()));_agee :=_abb .MakeDecodeParams ();if _agee !=nil {_cbed .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_agee );};return _cbed ;};func _bdeb (_aace ,_agae ,_ddaeg uint8 )uint8 {_bcde :=int (_ddaeg );_fcdb :=int (_agae )-_bcde ;_fdfd :=int (_aace )-_bcde ;_bcde =_cafd (_fcdb +_fdfd );_fcdb =_cafd (_fcdb );_fdfd =_cafd (_fdfd );if _fcdb <=_fdfd &&_fcdb <=_bcde {return _aace ;}else if _fdfd <=_bcde {return _agae ;};return _ddaeg ;};func (_fgca *PdfCrypt )checkAccessRights (_aebd []byte )(bool ,_bc .Permissions ,error ){_eba :=_fgca .securityHandler ();_eeb ,_ccb ,_fac :=_eba .Authenticate (&_fgca ._adg ,_aebd );if _fac !=nil {return false ,0,_fac ;}else if _ccb ==0||len (_eeb )==0{return false ,0,nil ;};return true ,_ccb ,nil ;};

// Clear resets the array to an empty state.
func (_dgefb *PdfObjectArray )Clear (){_dgefb ._afda =[]PdfObject {}};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_eddd :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _eddd ==nil {return NewRawEncoder (),nil ;};if _ ,_fbeb :=_eddd .(*PdfObjectNull );_fbeb {return NewRawEncoder (),nil ;};_cdgbgb ,_afbf :=_eddd .(*PdfObjectName );if !_afbf {_ebfb ,_cdda :=_eddd .(*PdfObjectArray );if !_cdda {return nil ,_gb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _ebfb .Len ()==0{return NewRawEncoder (),nil ;};if _ebfb .Len ()!=1{_edfg ,_bcffd :=_fbfc (streamObj );if _bcffd !=nil {_egd .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bcffd );return nil ,_bcffd ;};_egd .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_edfg );return _edfg ,nil ;};_eddd =_ebfb .Get (0);_cdgbgb ,_cdda =_eddd .(*PdfObjectName );if !_cdda {return nil ,_gb .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_cdgbgb {case StreamEncodingFilterNameFlate :return _bgab (streamObj ,nil );case StreamEncodingFilterNameLZW :return _cdaf (streamObj ,nil );case StreamEncodingFilterNameDCT :return _eebd (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _cfb (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _accc (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _gfbe (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_egd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_gb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_cdgbgb );};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_fdbg *PdfParser )GetFileOffset ()int64 {_gcfb ,_ :=_fdbg ._ecgc .Seek (0,_dg .SeekCurrent );_gcfb -=int64 (_fdbg ._degc .Buffered ());return _gcfb ;};func _fdd (_dac XrefTable ){_egd .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_egd .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_dcg :=0;for _ ,_fcc :=range _dac .ObjectMap {_egd .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_dcg +1,_fcc .ObjectNumber ,_fcc .Generation ,_fcc .Offset );_dcg ++;};};

// GetFilterName returns the name of the encoding filter.
func (_gfdb *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_bcbf :=&DCTEncoder {};_bcbf .ColorComponents =3;_bcbf .BitsPerComponent =8;_bcbf .Quality =DefaultJPEGQuality ;return _bcbf ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_abee *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _abee .DecodeBytes (streamObj .Stream );};

// GetParser returns the parser for lazy-loading or compare references.
func (_bbga *PdfObjectReference )GetParser ()*PdfParser {return _bbga ._fabe };

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_cgbe *PdfObjectBool ,_ddaad bool ){_cgbe ,_ddaad =TraceToDirectObject (obj ).(*PdfObjectBool );return _cgbe ,_ddaad ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfgg *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gecd *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgfc *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_fgcf :=MakeDict ();_fgcf .Set ("\u004b",MakeInteger (int64 (_fgfc .K )));_fgcf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgfc .Columns )));if _fgfc .BlackIs1 {_fgcf .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_fgfc .BlackIs1 ));};if _fgfc .EncodedByteAlign {_fgcf .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_fgfc .EncodedByteAlign ));};if _fgfc .EndOfLine &&_fgfc .K >=0{_fgcf .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_fgfc .EndOfLine ));};if _fgfc .Rows !=0&&!_fgfc .EndOfBlock {_fgcf .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_fgfc .Rows )));};if !_fgfc .EndOfBlock {_fgcf .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_fgfc .EndOfBlock ));};if _fgfc .DamagedRowsBeforeError !=0{_fgcf .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_fgfc .DamagedRowsBeforeError )));};return _fgcf ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _dc .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _aefc ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_egg .Error (_aefc ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_afeb uint8 ;_efgagd _ecc .Image ;_defa error ;);if bwThreshold ==JB2ImageAutoThreshold {_efgagd ,_defa =_ecc .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_egg .Error (_aefc ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_afeb =uint8 (255*bwThreshold );_efgagd ,_defa =_ecc .MonochromeThresholdConverter (_afeb ).Convert (i );};if _defa !=nil {return nil ,_defa ;};return _ffbb (_efgagd ),nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_abeeb *JBIG2Image )ToGoImage ()(_dc .Image ,error ){const _ebge ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _abeeb .Data ==nil {return nil ,_egg .Error (_ebge ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _abeeb .Width ==0||_abeeb .Height ==0{return nil ,_egg .Error (_ebge ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_aagg ,_cgd :=_ecc .NewImage (_abeeb .Width ,_abeeb .Height ,1,1,_abeeb .Data ,nil ,nil );if _cgd !=nil {return nil ,_cgd ;};return _aagg ,nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_efcc *PdfParser )Decrypt (password []byte )(bool ,error ){if _efcc ._fccd ==nil {return false ,_b .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_ccce ,_beac :=_efcc ._fccd .authenticate (password );if _beac !=nil {return false ,_beac ;};if !_ccce {_ccce ,_beac =_efcc ._fccd .authenticate ([]byte (""));};return _ccce ,_beac ;};

// String returns a string describing `ref`.
func (_cagd *PdfObjectReference )String ()string {return _gb .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_cagd .ObjectNumber ,_cagd .GenerationNumber );};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_fege *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_egd .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_gfd :=_eg .NewReader (encoded );_effc ,_ccfd :=_ce .NewReader (_gfd );if _ccfd !=nil {_egd .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_ccfd );_egd .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_ccfd ;};defer _effc .Close ();var _fgcd _eg .Buffer ;_fgcd .ReadFrom (_effc );return _fgcd .Bytes (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_cbcf *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _fage ,_gacfb :=GetNumberAsInt64 (params .Get ("\u004b"));_gacfb ==nil {_cbcf .K =int (_fage );};if _bgde ,_degd :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_degd ==nil {_cbcf .Columns =int (_bgde );}else if _bgde ,_degd =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_degd ==nil {_cbcf .Columns =int (_bgde );};if _gece ,_accg :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_accg ==nil {_cbcf .BlackIs1 =_gece > 0;}else {if _ecacg ,_cegg :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cegg {_cbcf .BlackIs1 =_ecacg ;}else {if _dcf ,_cfde :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_cfde {_efgag ,_dbebe :=_dcf .ToIntegerArray ();if _dbebe ==nil {_cbcf .BlackIs1 =_efgag [0]==1&&_efgag [1]==0;};};};};if _ddcg ,_ccfdd :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ccfdd ==nil {_cbcf .EncodedByteAlign =_ddcg > 0;}else {if _abag ,_cgcg :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cgcg {_cbcf .EncodedByteAlign =_abag ;};};if _accb ,_cdaa :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cdaa ==nil {_cbcf .EndOfLine =_accb > 0;}else {if _gbaa ,_fdgb :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fdgb {_cbcf .EndOfLine =_gbaa ;};};if _eeec ,_faccb :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_faccb ==nil {_cbcf .Rows =int (_eeec );}else if _eeec ,_faccb =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_faccb ==nil {_cbcf .Rows =int (_eeec );};if _bgdd ,_agd :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_agd ==nil {_cbcf .EndOfBlock =_bgdd > 0;}else {if _fcdc ,_gbaad :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gbaad {_cbcf .EndOfBlock =_fcdc ;};};if _dbcg ,_egef :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_egef !=nil {_cbcf .DamagedRowsBeforeError =int (_dbcg );};};func _eed (_cfc *_gc .FilterDict ,_abff *PdfObjectDictionary )error {if _gca ,_dce :=_abff .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dce {if _eafd :=string (*_gca );_eafd !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_egd .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_eafd );};};_dcb ,_cgf :=_abff .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_cgf {return _gb .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_cfc .CFM =string (*_dcb );if _ac ,_gbab :=_abff .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_gbab {_cfc .AuthEvent =_bc .AuthEvent (*_ac );}else {_cfc .AuthEvent =_bc .EventDocOpen ;};if _ggeb ,_cbe :=_abff .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_cbe {_cfc .Length =int (*_ggeb );};return nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_cfag :=PdfObjectName (s );return &_cfag };func _fbfc (_bcec *PdfObjectStream )(*MultiEncoder ,error ){_eede :=NewMultiEncoder ();_ecbc :=_bcec .PdfObjectDictionary ;if _ecbc ==nil {return _eede ,nil ;};var _cea *PdfObjectDictionary ;var _ddeb []PdfObject ;_cbeb :=_ecbc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cbeb !=nil {_gfee ,_gfca :=_cbeb .(*PdfObjectDictionary );if _gfca {_cea =_gfee ;};_ddab ,_bded :=_cbeb .(*PdfObjectArray );if _bded {for _ ,_efgff :=range _ddab .Elements (){_efgff =TraceToDirectObject (_efgff );if _cagg ,_dcc :=_efgff .(*PdfObjectDictionary );_dcc {_ddeb =append (_ddeb ,_cagg );}else {_ddeb =append (_ddeb ,MakeDict ());};};};};_cbeb =_ecbc .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _cbeb ==nil {return nil ,_gb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_egede ,_begge :=_cbeb .(*PdfObjectArray );if !_begge {return nil ,_gb .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _bceaa ,_gcgg :=range _egede .Elements (){_cga ,_efbe :=_gcgg .(*PdfObjectName );if !_efbe {return nil ,_gb .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _edd PdfObject ;if _cea !=nil {_edd =_cea ;}else {if len (_ddeb )> 0{if _bceaa >=len (_ddeb ){return nil ,_gb .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_edd =_ddeb [_bceaa ];};};var _ecbcc *PdfObjectDictionary ;if _badd ,_eebc :=_edd .(*PdfObjectDictionary );_eebc {_ecbcc =_badd ;};_egd .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_cga ,_edd ,_ecbcc );if *_cga ==StreamEncodingFilterNameFlate {_bbcc ,_dcfb :=_bgab (_bcec ,_ecbcc );if _dcfb !=nil {return nil ,_dcfb ;};_eede .AddEncoder (_bbcc );}else if *_cga ==StreamEncodingFilterNameLZW {_egba ,_edea :=_cdaf (_bcec ,_ecbcc );if _edea !=nil {return nil ,_edea ;};_eede .AddEncoder (_egba );}else if *_cga ==StreamEncodingFilterNameASCIIHex {_aab :=NewASCIIHexEncoder ();_eede .AddEncoder (_aab );}else if *_cga ==StreamEncodingFilterNameASCII85 {_aaed :=NewASCII85Encoder ();_eede .AddEncoder (_aaed );}else if *_cga ==StreamEncodingFilterNameDCT {_badf ,_fce :=_eebd (_bcec ,_eede );if _fce !=nil {return nil ,_fce ;};_eede .AddEncoder (_badf );_egd .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_egd .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_eede );}else {_egd .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_cga );return nil ,_gb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _eede ,nil ;};func (_eebda *PdfParser )repairSeekXrefMarker ()error {_fcbfc ,_cdbgc :=_eebda ._ecgc .Seek (0,_dg .SeekEnd );if _cdbgc !=nil {return _cdbgc ;};_febf :=_g .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _ffae int64 ;var _gbda int64 =1000;for _ffae < _fcbfc {if _fcbfc <=(_gbda +_ffae ){_gbda =_fcbfc -_ffae ;};_ ,_bdba :=_eebda ._ecgc .Seek (-_ffae -_gbda ,_dg .SeekEnd );if _bdba !=nil {return _bdba ;};_eegff :=make ([]byte ,_gbda );_eebda ._ecgc .Read (_eegff );_egd .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_eegff ));_gfebf :=_febf .FindAllStringIndex (string (_eegff ),-1);if _gfebf !=nil {_ggegf :=_gfebf [len (_gfebf )-1];_egd .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gfebf );_eebda ._ecgc .Seek (-_ffae -_gbda +int64 (_ggegf [0]),_dg .SeekEnd );_eebda ._degc =_de .NewReader (_eebda ._ecgc );for {_ecgd ,_aebcg :=_eebda ._degc .Peek (1);if _aebcg !=nil {return _aebcg ;};_egd .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_ecgd [0],_ecgd [0]);if !IsWhiteSpace (_ecgd [0]){break ;};_eebda ._degc .Discard (1);};return nil ;};_egd .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_ffae +=_gbda ;};_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _b .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// GetFilterName returns the name of the encoding filter.
func (_dbfd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func _eebd (_bgc *PdfObjectStream ,_gfb *MultiEncoder )(*DCTEncoder ,error ){_ffd :=NewDCTEncoder ();_fcf :=_bgc .PdfObjectDictionary ;if _fcf ==nil {return _ffd ,nil ;};_gaec :=_bgc .Stream ;if _gfb !=nil {_edfc ,_afgg :=_gfb .DecodeBytes (_gaec );if _afgg !=nil {return nil ,_afgg ;};_gaec =_edfc ;};_ffee :=_eg .NewReader (_gaec );_gcgc ,_adbb :=_d .DecodeConfig (_ffee );if _adbb !=nil {_egd .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_adbb );return nil ,_adbb ;};switch _gcgc .ColorModel {case _c .RGBAModel :_ffd .BitsPerComponent =8;_ffd .ColorComponents =3;case _c .RGBA64Model :_ffd .BitsPerComponent =16;_ffd .ColorComponents =3;case _c .GrayModel :_ffd .BitsPerComponent =8;_ffd .ColorComponents =1;case _c .Gray16Model :_ffd .BitsPerComponent =16;_ffd .ColorComponents =1;case _c .CMYKModel :_ffd .BitsPerComponent =8;_ffd .ColorComponents =4;case _c .YCbCrModel :_ffd .BitsPerComponent =8;_ffd .ColorComponents =3;default:return nil ,_b .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_ffd .Width =_gcgc .Width ;_ffd .Height =_gcgc .Height ;_egd .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_ffd );_ffd .Quality =DefaultJPEGQuality ;return _ffd ,nil ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_bcgab *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _cdae []float64 ;for _ ,_gcad :=range _bcgab .Elements (){_fbc ,_fcdef :=GetNumberAsFloat (TraceToDirectObject (_gcad ));if _fcdef !=nil {return nil ,_gb .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_cdae =append (_cdae ,_fbc );};return _cdae ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_dba *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_dceg ,_eebe :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _eebe ==nil {_dba .ColorComponents =int (_dceg );};_fabd ,_eebe :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _eebe ==nil {_dba .BitsPerComponent =int (_fabd );};_cddb ,_eebe :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _eebe ==nil {_dba .Width =int (_cddb );};_abec ,_eebe :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _eebe ==nil {_dba .Height =int (_abec );};_bagg ,_eebe :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _eebe ==nil {_dba .Quality =int (_bagg );};};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gedg *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_acdg :=range another .Keys (){_eecb :=another .Get (_acdg );_gedg .Set (_acdg ,_eecb );};};return _gedg ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};func (_aec *FlateEncoder )cleanImageData (_bfde []byte )([]byte ,error ){if _aec ._gda ==nil {return _bfde ,nil ;};if _aec ._gda .BitsPerComponent >=8{return _bfde ,nil ;};_degg :=_aec ._gda .BitsPerComponent *_aec ._gda .Width *_aec ._gda .ColorComponents *_aec ._gda .Height /8;_bfde =_bfde [:_degg ];var _dbc error ;_bfde ,_dbc =_ecc .AddDataPadding (_aec ._gda .Width ,_aec ._gda .Height ,_aec ._gda .BitsPerComponent ,_aec ._gda .ColorComponents ,_bfde );if _dbc !=nil {return nil ,_dbc ;};return _bfde ,nil ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_ecac *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gegf _eg .Buffer ;for _ ,_add :=range data {_gegf .WriteString (_gb .Sprintf ("\u0025\u002e\u0032X\u0020",_add ));};_gegf .WriteByte ('>');return _gegf .Bytes (),nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_bede *PdfParser )GetCrypter ()*PdfCrypt {return _bede ._fccd };

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_bcb encryptDict ;_adg _bc .StdEncryptDict ;_cdfd string ;_fde []byte ;_bad map[PdfObject ]bool ;_bec map[PdfObject ]bool ;_eaf bool ;_bfce cryptFilters ;_bda string ;_bfd string ;_gdg *PdfParser ;_gag map[int ]struct{};};var _dcbbe =_g .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_beff *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_bebe *PdfObjectStreams ,_bfcfg bool ){_bebe ,_bfcfg =obj .(*PdfObjectStreams );return _bebe ,_bfcfg ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_fadb *JBIG2Encoder )DecodeGlobals (encoded []byte )(_be .Globals ,error ){return _be .DecodeGlobals (encoded );};func (_ceaf *PdfObjectInteger )String ()string {return _gb .Sprintf ("\u0025\u0064",*_ceaf )};

// Append appends PdfObject(s) to the array.
func (_bcad *PdfObjectArray )Append (objects ...PdfObject ){if _bcad ==nil {_egd .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_bcad ._afda =append (_bcad ._afda ,objects ...);};func (_edfb *PdfCrypt )securityHandler ()_bc .StdHandler {if _edfb ._adg .R >=5{return _bc .NewHandlerR6 ();};return _bc .NewHandlerR4 (_edfb ._cdfd ,_edfb ._bcb .Length );};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _bbbc (obj1 ,obj2 ,0)};func _eacf (_bgcb PdfObject )(*float64 ,error ){switch _eedf :=_bgcb .(type ){case *PdfObjectFloat :_gafc :=float64 (*_eedf );return &_gafc ,nil ;case *PdfObjectInteger :_bfcaf :=float64 (*_eedf );return &_bfcaf ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ffdf *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_acadg :=MakeDict ();_acadg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ffdf .GetFilterName ()));_bgbg :=_ffdf .MakeDecodeParams ();if _bgbg !=nil {_acadg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bgbg );};return _acadg ;};func (_ddbe *PdfParser )readTextLine ()(string ,error ){var _fdacf _eg .Buffer ;for {_bgfaf ,_abce :=_ddbe ._degc .Peek (1);if _abce !=nil {_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abce .Error ());return _fdacf .String (),_abce ;};if (_bgfaf [0]!='\r')&&(_bgfaf [0]!='\n'){_ebeb ,_ :=_ddbe ._degc .ReadByte ();_fdacf .WriteByte (_ebeb );}else {break ;};};return _fdacf .String (),nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _gc .Filter ,userPass ,ownerPass []byte ,perm _bc .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_aafd :=&PdfCrypt {_bec :make (map[PdfObject ]bool ),_bfce :make (cryptFilters ),_adg :_bc .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _aac Version ;if cf !=nil {_gbcb :=cf .PDFVersion ();_aac .Major ,_aac .Minor =_gbcb [0],_gbcb [1];V ,R :=cf .HandlerVersion ();_aafd ._bcb .V =V ;_aafd ._adg .R =R ;_aafd ._bcb .Length =cf .KeyLength ()*8;};const (_ddg =_gbga ;);_aafd ._bfce [_ddg ]=cf ;if _aafd ._bcb .V >=4{_aafd ._bda =_ddg ;_aafd ._bfd =_ddg ;};_decd :=_aafd .newEncryptDict ();_gfaf :=_eb .Sum ([]byte (_gf .Now ().Format (_gf .RFC850 )));_ddf :=string (_gfaf [:]);_abf :=make ([]byte ,100);_ba .Read (_abf );_gfaf =_eb .Sum (_abf );_cfgd :=string (_gfaf [:]);_egd .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_abf );_egd .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ddf );_aafd ._cdfd =_ddf ;_ged :=_aafd .generateParams (userPass ,ownerPass );if _ged !=nil {return nil ,nil ,_ged ;};_bece (&_aafd ._adg ,_decd );if _aafd ._bcb .V >=4{if _gdd :=_aafd .saveCryptFilters (_decd );_gdd !=nil {return nil ,nil ,_gdd ;};};return _aafd ,&EncryptInfo {Version :_aac ,Encrypt :_decd ,ID0 :_ddf ,ID1 :_cfgd },nil ;};func (_deb *JBIG2Encoder )encodeImage (_cfba _dc .Image )([]byte ,error ){const _ccgf ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_ggebd ,_dga :=GoImageToJBIG2 (_cfba ,JB2ImageAutoThreshold );if _dga !=nil {return nil ,_egg .Wrap (_dga ,_ccgf ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _dga =_deb .AddPageImage (_ggebd ,&_deb .DefaultPageSettings );_dga !=nil {return nil ,_egg .Wrap (_dga ,_ccgf ,"");};return _deb .Encode ();};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_ffeb map[PdfObjectName ]PdfObject ;_cecc []PdfObjectName ;_cgab *PdfParser ;};func (_cdacf *PdfParser )xrefNextObjectOffset (_eabadg int64 )int64 {_agea :=int64 (0);if len (_cdacf ._cggf .ObjectMap )==0{return 0;};if len (_cdacf ._cggf ._df )==0{_adcd :=0;for _ ,_bdbf :=range _cdacf ._cggf .ObjectMap {if _bdbf .Offset > 0{_adcd ++;};};if _adcd ==0{return 0;};_cdacf ._cggf ._df =make ([]XrefObject ,_adcd );_dfg :=0;for _ ,_dggbc :=range _cdacf ._cggf .ObjectMap {if _dggbc .Offset > 0{_cdacf ._cggf ._df [_dfg ]=_dggbc ;_dfg ++;};};_ed .Slice (_cdacf ._cggf ._df ,func (_becc ,_cbbab int )bool {return _cdacf ._cggf ._df [_becc ].Offset < _cdacf ._cggf ._df [_cbbab ].Offset });};_dddc :=_ed .Search (len (_cdacf ._cggf ._df ),func (_gfef int )bool {return _cdacf ._cggf ._df [_gfef ].Offset >=_eabadg });if _dddc < len (_cdacf ._cggf ._df ){_agea =_cdacf ._cggf ._df [_dddc ].Offset ;};return _agea ;};

// Clear resets the dictionary to an empty state.
func (_ecdg *PdfObjectDictionary )Clear (){_ecdg ._cecc =[]PdfObjectName {};_ecdg ._ffeb =map[PdfObjectName ]PdfObject {};};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_ddgb :=&FlateEncoder {};_ddgb .Predictor =1;_ddgb .BitsPerComponent =8;_ddgb .Colors =1;_ddgb .Columns =1;return _ddgb ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_gbagf *PdfObjectInteger ,_daab bool ){_gbagf ,_daab =TraceToDirectObject (obj ).(*PdfObjectInteger );return _gbagf ,_daab ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dgf *RawEncoder )MakeDecodeParams ()PdfObject {return nil };var _ffga =_g .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_ffac *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_adee :=PdfIndirectObject {};_adee ._fabe =_ffac ;_egd .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_accd ,_eeedc :=_ffac ._degc .Peek (20);if _eeedc !=nil {if _eeedc !=_dg .EOF {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_adee ,_eeedc ;};};_egd .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_accd ));_cdab :=_gcef .FindStringSubmatchIndex (string (_accd ));if len (_cdab )< 6{if _eeedc ==_dg .EOF {return nil ,_eeedc ;};_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_accd ));return &_adee ,_b .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_ffac ._degc .Discard (_cdab [0]);_egd .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_cdab );_fgbb :=_cdab [1]-_cdab [0];_ggdg :=make ([]byte ,_fgbb );_ ,_eeedc =_ffac .ReadAtLeast (_ggdg ,_fgbb );if _eeedc !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_eeedc );return nil ,_eeedc ;};_egd .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_ggdg );_gdcac :=_gcef .FindStringSubmatch (string (_ggdg ));if len (_gdcac )< 3{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_ggdg ));return &_adee ,_b .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_bebc ,_ :=_bf .Atoi (_gdcac [1]);_gcfe ,_ :=_bf .Atoi (_gdcac [2]);_adee .ObjectNumber =int64 (_bebc );_adee .GenerationNumber =int64 (_gcfe );for {_fdbgg ,_affa :=_ffac ._degc .Peek (2);if _affa !=nil {return &_adee ,_affa ;};_egd .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fdbgg ),string (_fdbgg ));if IsWhiteSpace (_fdbgg [0]){_ffac .skipSpaces ();}else if _fdbgg [0]=='%'{_ffac .skipComments ();}else if (_fdbgg [0]=='<')&&(_fdbgg [1]=='<'){_egd .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_adee .PdfObject ,_affa =_ffac .ParseDict ();_egd .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_affa );if _affa !=nil {return &_adee ,_affa ;};_egd .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_fdbgg [0]=='/')||(_fdbgg [0]=='(')||(_fdbgg [0]=='[')||(_fdbgg [0]=='<'){_adee .PdfObject ,_affa =_ffac .parseObject ();if _affa !=nil {return &_adee ,_affa ;};_egd .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _fdbgg [0]==']'{_egd .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_ffac ._degc .Discard (1);}else {if _fdbgg [0]=='e'{_aafeg ,_bdgd :=_ffac .readTextLine ();if _bdgd !=nil {return nil ,_bdgd ;};if len (_aafeg )>=6&&_aafeg [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _fdbgg [0]=='s'{_fdbgg ,_ =_ffac ._degc .Peek (10);if string (_fdbgg [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_efdd :=6;if len (_fdbgg )> 6{if IsWhiteSpace (_fdbgg [_efdd ])&&_fdbgg [_efdd ]!='\r'&&_fdbgg [_efdd ]!='\n'{_egd .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_efdd ++;};if _fdbgg [_efdd ]=='\r'{_efdd ++;if _fdbgg [_efdd ]=='\n'{_efdd ++;};}else if _fdbgg [_efdd ]=='\n'{_efdd ++;};};_ffac ._degc .Discard (_efdd );_agdb ,_gedb :=_adee .PdfObject .(*PdfObjectDictionary );if !_gedb {return nil ,_b .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_egd .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_agdb );_feegc ,_ccbea :=_ffac .traceStreamLength (_agdb .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _ccbea !=nil {_egd .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_ccbea );return nil ,_ccbea ;};_egd .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_feegc );_bbegc ,_ffbg :=_feegc .(*PdfObjectInteger );if !_ffbg {return nil ,_b .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_fdfbb :=*_bbegc ;if _fdfbb < 0{return nil ,_b .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_fgacg :=_ffac .GetFileOffset ();_ageeg :=_ffac .xrefNextObjectOffset (_fgacg );if _fgacg +int64 (_fdfbb )> _ageeg &&_ageeg > _fgacg {_egd .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_fgacg +int64 (_fdfbb ));_egd .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ageeg );_fefa :=_ageeg -_fgacg -17;if _fefa < 0{return nil ,_b .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_egd .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_fefa );_fdfbb =PdfObjectInteger (_fefa );_agdb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_fefa ));};if int64 (_fdfbb )> _ffac ._aacb {_egd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_b .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_gcd :=make ([]byte ,_fdfbb );_ ,_ccbea =_ffac .ReadAtLeast (_gcd ,int (_fdfbb ));if _ccbea !=nil {_egd .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_gcd ),_gcd );_egd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ccbea );return nil ,_ccbea ;};_ccaef :=PdfObjectStream {};_ccaef .Stream =_gcd ;_ccaef .PdfObjectDictionary =_adee .PdfObject .(*PdfObjectDictionary );_ccaef .ObjectNumber =_adee .ObjectNumber ;_ccaef .GenerationNumber =_adee .GenerationNumber ;_ccaef .PdfObjectReference ._fabe =_ffac ;_ffac .skipSpaces ();_ffac ._degc .Discard (9);_ffac .skipSpaces ();return &_ccaef ,nil ;};};_adee .PdfObject ,_affa =_ffac .parseObject ();if _adee .PdfObject ==nil {_egd .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_adee .PdfObject =MakeNull ();};return &_adee ,_affa ;};};if _adee .PdfObject ==nil {_egd .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_adee .PdfObject =MakeNull ();};_egd .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_adee ,nil ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_cdga []byte ,_abffb bool ){_dfe ,_abffb :=TraceToDirectObject (obj ).(*PdfObjectString );if _abffb {return _dfe .Bytes (),true ;};return ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_bfbd *PdfObjectString )Str ()string {return _bfbd ._cdfb };

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};var _aada =_g .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_cdgbg *PdfObjectDictionary ,_eaea bool ){_cdgbg ,_eaea =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _cdgbg ,_eaea ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_decf *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_decf .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_geb *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// String returns a string representation of `name`.
func (_bbeb *PdfObjectName )String ()string {return string (*_bbeb )};

// WriteString outputs the object as it is to be written to file.
func (_acgb *PdfObjectInteger )WriteString ()string {return _bf .FormatInt (int64 (*_acgb ),10)};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbbf *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_fdf :=MakeDict ();_fdf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbbf .GetFilterName ()));return _fdf ;};

// WriteString outputs the object as it is to be written to file.
func (_fgace *PdfObjectArray )WriteString ()string {var _cdfce _fb .Builder ;_cdfce .WriteString ("\u005b");for _edbg ,_dcfeg :=range _fgace .Elements (){_cdfce .WriteString (_dcfeg .WriteString ());if _edbg < (_fgace .Len ()-1){_cdfce .WriteString ("\u0020");};};_cdfce .WriteString ("\u005d");return _cdfce .String ();};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_aaaac *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_edccc :=encoded ;var _ecg error ;for _ ,_aaaeb :=range _aaaac ._eaca {_egd .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_aaaeb ,_aaaeb );_edccc ,_ecg =_aaaeb .DecodeBytes (_edccc );if _ecg !=nil {return nil ,_ecg ;};};return _edccc ,nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_bage *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bage .DecodeBytes (streamObj .Stream );};func (_ddgd *JBIG2Image )toBitmap ()(_gagb *_fea .Bitmap ,_beeb error ){const _agba ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _ddgd .Data ==nil {return nil ,_egg .Error (_agba ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _ddgd .Width ==0||_ddgd .Height ==0{return nil ,_egg .Error (_agba ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _ddgd .HasPadding {_gagb ,_beeb =_fea .NewWithData (_ddgd .Width ,_ddgd .Height ,_ddgd .Data );}else {_gagb ,_beeb =_fea .NewWithUnpaddedData (_ddgd .Width ,_ddgd .Height ,_ddgd .Data );};if _beeb !=nil {return nil ,_egg .Wrap (_beeb ,_agba ,"");};return _gagb ,nil ;};func (_adgg *PdfParser )parseBool ()(PdfObjectBool ,error ){_cggc ,_cbgf :=_adgg ._degc .Peek (4);if _cbgf !=nil {return PdfObjectBool (false ),_cbgf ;};if (len (_cggc )>=4)&&(string (_cggc [:4])=="\u0074\u0072\u0075\u0065"){_adgg ._degc .Discard (4);return PdfObjectBool (true ),nil ;};_cggc ,_cbgf =_adgg ._degc .Peek (5);if _cbgf !=nil {return PdfObjectBool (false ),_cbgf ;};if (len (_cggc )>=5)&&(string (_cggc [:5])=="\u0066\u0061\u006cs\u0065"){_adgg ._degc .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_b .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};const (DefaultJPEGQuality =75;);func (_gecc *PdfParser )readComment ()(string ,error ){var _fdag _eg .Buffer ;_ ,_dgdg :=_gecc .skipSpaces ();if _dgdg !=nil {return _fdag .String (),_dgdg ;};_cddd :=true ;for {_fafa ,_caef :=_gecc ._degc .Peek (1);if _caef !=nil {_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_caef .Error ());return _fdag .String (),_caef ;};if _cddd &&_fafa [0]!='%'{return _fdag .String (),_b .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_cddd =false ;if (_fafa [0]!='\r')&&(_fafa [0]!='\n'){_bgcf ,_ :=_gecc ._degc .ReadByte ();_fdag .WriteByte (_bgcf );}else {break ;};};return _fdag .String (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcce *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_ccgg :=MakeDict ();_ccgg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fcce .GetFilterName ()));return _ccgg ;};

// UpdateParams updates the parameter values of the encoder.
func (_edfe *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetFilterName returns the name of the encoding filter.
func (_bdg *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_efag *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dffe :=_eg .NewReader (encoded );var _gbeb []byte ;for {_fgbd ,_dbaa :=_dffe .ReadByte ();if _dbaa !=nil {return nil ,_dbaa ;};if _fgbd =='>'{break ;};if IsWhiteSpace (_fgbd ){continue ;};if (_fgbd >='a'&&_fgbd <='f')||(_fgbd >='A'&&_fgbd <='F')||(_fgbd >='0'&&_fgbd <='9'){_gbeb =append (_gbeb ,_fgbd );}else {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_fgbd );return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_fgbd );};};if len (_gbeb )%2==1{_gbeb =append (_gbeb ,'0');};_egd .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_gbeb );_dbbc :=make ([]byte ,_gg .DecodedLen (len (_gbeb )));_ ,_cacd :=_gg .Decode (_dbbc ,_gbeb );if _cacd !=nil {return nil ,_cacd ;};return _dbbc ,nil ;};func _ffbb (_cdcf _ecc .Image )*JBIG2Image {_bcd :=_cdcf .Base ();return &JBIG2Image {Data :_bcd .Data ,Width :_bcd .Width ,Height :_bcd .Height ,HasPadding :true };};func (_fefcf *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_fefcf ._degc )};func (_ddgec *PdfParser )parseArray ()(*PdfObjectArray ,error ){_ebead :=MakeArray ();_ddgec ._degc .ReadByte ();for {_ddgec .skipSpaces ();_ggbe ,_edfbc :=_ddgec ._degc .Peek (1);if _edfbc !=nil {return _ebead ,_edfbc ;};if _ggbe [0]==']'{_ddgec ._degc .ReadByte ();break ;};_ffgd ,_edfbc :=_ddgec .parseObject ();if _edfbc !=nil {return _ebead ,_edfbc ;};_ebead .Append (_ffgd );};return _ebead ,nil ;};func (_cgfad *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_cgfad ._ecgc .Seek (0,_dg .SeekStart );_cgfad ._degc =_de .NewReader (_cgfad ._ecgc );_geefd :=20;_fbae :=make ([]byte ,_geefd );for {_gfgd ,_dadcc :=_cgfad ._degc .ReadByte ();if _dadcc !=nil {if _dadcc ==_dg .EOF {break ;}else {return 0,0,_dadcc ;};};if IsDecimalDigit (_gfgd )&&_fbae [_geefd -1]=='.'&&IsDecimalDigit (_fbae [_geefd -2])&&_fbae [_geefd -3]=='-'&&_fbae [_geefd -4]=='F'&&_fbae [_geefd -5]=='D'&&_fbae [_geefd -6]=='P'{_eefdb :=int (_fbae [_geefd -2]-'0');_gecg :=int (_gfgd -'0');return _eefdb ,_gecg ,nil ;};_fbae =append (_fbae [1:_geefd ],_gfgd );};return 0,0,_b .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};func (_cde *PdfParser )lookupObjectViaOS (_fab int ,_gge int )(PdfObject ,error ){var _cf *_eg .Reader ;var _bfc objectStream ;var _af bool ;_bfc ,_af =_cde ._bggfg [_fab ];if !_af {_ggg ,_cdf :=_cde .LookupByNumber (_fab );if _cdf !=nil {_egd .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_fab );return nil ,_cdf ;};_bfcb ,_ad :=_ggg .(*PdfObjectStream );if !_ad {return nil ,_b .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _cde ._fccd !=nil &&!_cde ._fccd .isDecrypted (_bfcb ){return nil ,_b .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_ae :=_bfcb .PdfObjectDictionary ;_egd .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_ae .String ());_ge ,_ad :=_ae .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ad {_egd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_b .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _fb .ToLower (string (*_ge ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_b .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ad :=_ae .Get ("\u004e").(*PdfObjectInteger );if !_ad {return nil ,_b .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gfa ,_ad :=_ae .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ad {return nil ,_b .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_egd .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ge ,*N );_def ,_cdf :=DecodeStream (_bfcb );if _cdf !=nil {return nil ,_cdf ;};_egd .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_def );_gbc :=_cde .GetFileOffset ();defer func (){_cde .SetFileOffset (_gbc )}();_cf =_eg .NewReader (_def );_cde ._degc =_de .NewReader (_cf );_egd .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_eccf :=map[int ]int64 {};for _cee :=0;_cee < int (*N );_cee ++{_cde .skipSpaces ();_cfa ,_ee :=_cde .parseNumber ();if _ee !=nil {return nil ,_ee ;};_cda ,_fbg :=_cfa .(*PdfObjectInteger );if !_fbg {return nil ,_b .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_cde .skipSpaces ();_cfa ,_ee =_cde .parseNumber ();if _ee !=nil {return nil ,_ee ;};_gef ,_fbg :=_cfa .(*PdfObjectInteger );if !_fbg {return nil ,_b .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_egd .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_cda ,*_gef );_eccf [int (*_cda )]=int64 (*_gfa +*_gef );};_bfc =objectStream {N :int (*N ),_ff :_def ,_a :_eccf };_cde ._bggfg [_fab ]=_bfc ;}else {_ef :=_cde .GetFileOffset ();defer func (){_cde .SetFileOffset (_ef )}();_cf =_eg .NewReader (_bfc ._ff );_cde ._degc =_de .NewReader (_cf );};_adb :=_bfc ._a [_gge ];_egd .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_gge ,_adb );_cf .Seek (_adb ,_dg .SeekStart );_cde ._degc =_de .NewReader (_cf );_feaf ,_ :=_cde ._degc .Peek (100);_egd .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_feaf ));_ag ,_ea :=_cde .parseObject ();if _ea !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_ea );return nil ,_ea ;};if _ag ==nil {return nil ,_b .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_efd :=PdfIndirectObject {};_efd .ObjectNumber =int64 (_gge );_efd .PdfObject =_ag ;return &_efd ,nil ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgd *LZWEncoder )MakeDecodeParams ()PdfObject {if _fgd .Predictor > 1{_bgg :=MakeDict ();_bgg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_fgd .Predictor )));if _fgd .BitsPerComponent !=8{_bgg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_fgd .BitsPerComponent )));};if _fgd .Columns !=1{_bgg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgd .Columns )));};if _fgd .Colors !=1{_bgg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_fgd .Colors )));};return _bgg ;};return nil ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_cdfb string ;_bfae bool ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _afbgg ,_fdab :=obj .(*PdfObjectReference );_fdab {return _afbgg .Resolve ();};return obj ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_gfcf *PdfParser )CheckAccessRights (password []byte )(bool ,_bc .Permissions ,error ){if _gfcf ._fccd ==nil {return true ,_bc .PermOwner ,nil ;};return _gfcf ._fccd .checkAccessRights (password );};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_gafb int ,_cgba bool ){_eedb ,_cgba :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _cgba &&_eedb !=nil {return int (*_eedb ),true ;};return 0,false ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_fbdc :=PdfObjectFloat (val );return &_fbdc };

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_dabd *MultiEncoder )AddEncoder (encoder StreamEncoder ){_dabd ._eaca =append (_dabd ._eaca ,encoder );};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_addf *MultiEncoder )GetFilterArray ()*PdfObjectArray {_faaea :=make ([]PdfObject ,len (_addf ._eaca ));for _cbebc ,_dadf :=range _addf ._eaca {_faaea [_cbebc ]=MakeName (_dadf .GetFilterName ());};return MakeArray (_faaea ...);};func (_bfcac *offsetReader )Read (p []byte )(_bggf int ,_cceg error ){return _bfcac ._fgdg .Read (p )};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_afda :objects }};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_fabcb *PdfObjectDictionary )Keys ()[]PdfObjectName {if _fabcb ==nil {return nil ;};return _fabcb ._cecc ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_egd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_affad ,_fbdd :=NewEncoderFromStream (streamObj );if _fbdd !=nil {_egd .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fbdd );return _fbdd ;};if _bgcff ,_gefe :=_affad .(*LZWEncoder );_gefe {_bgcff .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_egd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_affad );_ebcc ,_fbdd :=_affad .EncodeBytes (streamObj .Stream );if _fbdd !=nil {_egd .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_fbdd );return _fbdd ;};streamObj .Stream =_ebcc ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ebcc ))));return nil ;};func (_faef *PdfCrypt )decryptBytes (_deg []byte ,_fcg string ,_bea []byte )([]byte ,error ){_egd .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cbc ,_gbdc :=_faef ._bfce [_fcg ];if !_gbdc {return nil ,_gb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_fcg );};return _cbc .DecryptBytes (_deg ,_bea );};

// WriteString outputs the object as it is to be written to file.
func (_eeab *PdfObjectDictionary )WriteString ()string {var _caabf _fb .Builder ;_caabf .WriteString ("\u003c\u003c");for _ ,_dbacb :=range _eeab ._cecc {_gddfe :=_eeab ._ffeb [_dbacb ];_caabf .WriteString (_dbacb .WriteString ());_caabf .WriteString ("\u0020");_caabf .WriteString (_gddfe .WriteString ());};_caabf .WriteString ("\u003e\u003e");return _caabf .String ();};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bfg *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bfg .isDecrypted (obj ){return nil ;};switch _fcge :=obj .(type ){case *PdfIndirectObject :_bfg ._bad [_fcge ]=true ;_egd .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fcge .ObjectNumber ,_fcge .GenerationNumber );_gff :=_fcge .ObjectNumber ;_fffc :=_fcge .GenerationNumber ;_aeab :=_bfg .Decrypt (_fcge .PdfObject ,_gff ,_fffc );if _aeab !=nil {return _aeab ;};return nil ;case *PdfObjectStream :_bfg ._bad [_fcge ]=true ;_adf :=_fcge .PdfObjectDictionary ;if _bfg ._adg .R !=5{if _effe ,_eebg :=_adf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eebg &&*_effe =="\u0058\u0052\u0065\u0066"{return nil ;};};_bbb :=_fcge .ObjectNumber ;_dgdb :=_fcge .GenerationNumber ;_egd .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_bbb ,_dgdb );_cgg :=_gbga ;if _bfg ._bcb .V >=4{_cgg =_bfg ._bda ;_egd .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bfg ._bda );if _ebeg ,_gga :=_adf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_gga {if _ggcg ,_fcbg :=GetName (_ebeg .Get (0));_fcbg {if *_ggcg =="\u0043\u0072\u0079p\u0074"{_cgg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fbd ,_faeb :=_adf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_faeb {if _ffe ,_cdea :=_fbd .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cdea {if _ ,_cbb :=_bfg ._bfce [string (*_ffe )];_cbb {_egd .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ffe );_cgg =string (*_ffe );};};};};};};_egd .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cgg );if _cgg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_edcg :=_bfg .Decrypt (_adf ,_bbb ,_dgdb );if _edcg !=nil {return _edcg ;};_gffg ,_edcg :=_bfg .makeKey (_cgg ,uint32 (_bbb ),uint32 (_dgdb ),_bfg ._fde );if _edcg !=nil {return _edcg ;};_fcge .Stream ,_edcg =_bfg .decryptBytes (_fcge .Stream ,_cgg ,_gffg );if _edcg !=nil {return _edcg ;};_adf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fcge .Stream ))));return nil ;case *PdfObjectString :_egd .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_afgb :=_gbga ;if _bfg ._bcb .V >=4{_egd .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bfg ._bfd );if _bfg ._bfd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_afgb =_bfg ._bfd ;};_cab ,_bbe :=_bfg .makeKey (_afgb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bfg ._fde );if _bbe !=nil {return _bbe ;};_dcbb :=_fcge .Str ();_ggd :=make ([]byte ,len (_dcbb ));for _gbb :=0;_gbb < len (_dcbb );_gbb ++{_ggd [_gbb ]=_dcbb [_gbb ];};_egd .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ggd ,_ggd );_ggd ,_bbe =_bfg .decryptBytes (_ggd ,_afgb ,_cab );if _bbe !=nil {return _bbe ;};_fcge ._cdfb =string (_ggd );return nil ;case *PdfObjectArray :for _ ,_fee :=range _fcge .Elements (){_eebf :=_bfg .Decrypt (_fee ,parentObjNum ,parentGenNum );if _eebf !=nil {return _eebf ;};};return nil ;case *PdfObjectDictionary :_dgc :=false ;if _cae :=_fcge .Get ("\u0054\u0079\u0070\u0065");_cae !=nil {_eea ,_aaaa :=_cae .(*PdfObjectName );if _aaaa &&*_eea =="\u0053\u0069\u0067"{_dgc =true ;};};for _ ,_ggbd :=range _fcge .Keys (){_gfag :=_fcge .Get (_ggbd );if _dgc &&string (_ggbd )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_ggbd )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_ggbd )!="\u0050\u0072\u0065\u0076"&&string (_ggbd )!="\u004c\u0061\u0073\u0074"{_bgf :=_bfg .Decrypt (_gfag ,parentObjNum ,parentGenNum );if _bgf !=nil {return _bgf ;};};};return nil ;};return nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_egca *PdfParser )GetXrefType ()*xrefType {return _egca ._bcdef };

// DecodeStream implements ASCII hex decoding.
func (_bacg *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bacg .DecodeBytes (streamObj .Stream );};

// String returns a string describing `streams`.
func (_fade *PdfObjectStreams )String ()string {return _gb .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_fade .ObjectNumber );};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_beaaf :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_beaaf .PdfObjectDictionary =encoder .MakeStreamDict ();_ffbbe ,_agffd :=encoder .EncodeBytes (contents );if _agffd !=nil {return nil ,_agffd ;};_beaaf .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ffbbe ))));_beaaf .Stream =_ffbbe ;return _beaaf ,nil ;};func (_gadd *PdfCrypt )encryptBytes (_ecd []byte ,_bcc string ,_agfg []byte )([]byte ,error ){_egd .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_efdb ,_bdfg :=_gadd ._bfce [_bcc ];if !_bdfg {return nil ,_gb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bcc );};return _efdb .EncryptBytes (_ecd ,_agfg );};

// WriteString outputs the object as it is to be written to file.
func (_ebbbd *PdfObjectReference )WriteString ()string {var _egfec _fb .Builder ;_egfec .WriteString (_bf .FormatInt (_ebbbd .ObjectNumber ,10));_egfec .WriteString ("\u0020");_egfec .WriteString (_bf .FormatInt (_ebbbd .GenerationNumber ,10));_egfec .WriteString ("\u0020\u0052");return _egfec .String ();};func (_gdcga *PdfCrypt )authenticate (_bag []byte )(bool ,error ){_gdcga ._eaf =false ;_gcg :=_gdcga .securityHandler ();_fad ,_gcgd ,_efc :=_gcg .Authenticate (&_gdcga ._adg ,_bag );if _efc !=nil {return false ,_efc ;}else if _gcgd ==0||len (_fad )==0{return false ,nil ;};_gdcga ._eaf =true ;_gdcga ._fde =_fad ;return true ,nil ;};

// String returns a string describing `stream`.
func (_ceafa *PdfObjectStream )String ()string {return _gb .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_ceafa .ObjectNumber ,_ceafa .PdfObjectDictionary );};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_bdag *PdfParser )IsAuthenticated ()bool {return _bdag ._fccd ._eaf };

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_gc .FilterDict ;};func (_feag *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_feag ._cggf .ObjectMap =make (map[int ]XrefObject );_feag ._bggfg =make (objectStreams );_dcdc ,_dgbd :=_feag ._ecgc .Seek (0,_dg .SeekEnd );if _dgbd !=nil {return nil ,_dgbd ;};_egd .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_dcdc );_feag ._aacb =_dcdc ;_dgbd =_feag .seekToEOFMarker (_dcdc );if _dgbd !=nil {_egd .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_dgbd );return nil ,_dgbd ;};_beagc ,_dgbd :=_feag ._ecgc .Seek (0,_dg .SeekCurrent );if _dgbd !=nil {return nil ,_dgbd ;};var _cdfae int64 =64;_gddf :=_beagc -_cdfae ;if _gddf < 0{_gddf =0;};_ ,_dgbd =_feag ._ecgc .Seek (_gddf ,_dg .SeekStart );if _dgbd !=nil {return nil ,_dgbd ;};_baef :=make ([]byte ,_cdfae );_ ,_dgbd =_feag ._ecgc .Read (_baef );if _dgbd !=nil {_egd .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_dgbd );return nil ,_dgbd ;};_deed :=_aada .FindStringSubmatch (string (_baef ));if len (_deed )< 2{_egd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_b .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_deed )> 2{_egd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_baef );return nil ,_b .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_gbbd ,_ :=_bf .ParseInt (_deed [1],10,64);_egd .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_gbbd );if _gbbd > _dcdc {_egd .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_egd .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_gbbd ,_dgbd =_feag .repairLocateXref ();if _dgbd !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_dgbd ;};};_feag ._ecgc .Seek (_gbbd ,_dg .SeekStart );_feag ._degc =_de .NewReader (_feag ._ecgc );_afffb ,_dgbd :=_feag .parseXref ();if _dgbd !=nil {return nil ,_dgbd ;};_egdf :=_afffb .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _egdf !=nil {_dcbf ,_cdfc :=_egdf .(*PdfObjectInteger );if !_cdfc {return nil ,_b .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_dgbd =_feag .parseXrefStream (_dcbf );if _dgbd !=nil {return nil ,_dgbd ;};};var _eaag []int64 ;_ebcg :=func (_geddg int64 ,_fcdg []int64 )bool {for _ ,_faea :=range _fcdg {if _faea ==_geddg {return true ;};};return false ;};_egdf =_afffb .Get ("\u0050\u0072\u0065\u0076");for _egdf !=nil {_dfbg ,_becd :=_egdf .(*PdfObjectInteger );if !_becd {_egd .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_egdf );return _afffb ,nil ;};_afad :=*_dfbg ;_egd .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_afad );_feag ._ecgc .Seek (int64 (_afad ),_dg .SeekStart );_feag ._degc =_de .NewReader (_feag ._ecgc );_agcac ,_baec :=_feag .parseXref ();if _baec !=nil {_egd .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_egd .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_egdf =_agcac .Get ("\u0050\u0072\u0065\u0076");if _egdf !=nil {_feeb :=*(_egdf .(*PdfObjectInteger ));if _ebcg (int64 (_feeb ),_eaag ){_egd .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_eaag =append (_eaag ,int64 (_feeb ));};};return _afffb ,nil ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_ddb *PdfObjectDictionary );EncodeBytes (_dgdc []byte )([]byte ,error );DecodeBytes (_daf []byte )([]byte ,error );DecodeStream (_dge *PdfObjectStream )([]byte ,error );};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_beef :=PdfObjectBool (val );return &_beef };

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_bbfe *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_bbfe ._abea ){return _b .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_bbfe ._abea [i ]=obj ;return nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cef *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_bcaf *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gead :=_eg .NewReader (encoded );var _ffa []byte ;for {_ccab ,_ead :=_gead .ReadByte ();if _ead !=nil {return nil ,_ead ;};if _ccab > 128{_gbde ,_egfc :=_gead .ReadByte ();if _egfc !=nil {return nil ,_egfc ;};for _fgfa :=0;_fgfa < 257-int (_ccab );_fgfa ++{_ffa =append (_ffa ,_gbde );};}else if _ccab < 128{for _edbd :=0;_edbd < int (_ccab )+1;_edbd ++{_fdg ,_bcea :=_gead .ReadByte ();if _bcea !=nil {return nil ,_bcea ;};_ffa =append (_ffa ,_fdg );};}else {break ;};};return _ffa ,nil ;};func _gfbe (_ebdf *PdfObjectStream ,_dca *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _dfb ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_cagga :=&JBIG2Encoder {};_ddee :=_ebdf .PdfObjectDictionary ;if _ddee ==nil {return _cagga ,nil ;};if _dca ==nil {_cabf :=_ddee .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cabf !=nil {switch _cgb :=_cabf .(type ){case *PdfObjectDictionary :_dca =_cgb ;case *PdfObjectArray :if _cgb .Len ()==1{if _bff ,_gaa :=GetDict (_cgb .Get (0));_gaa {_dca =_bff ;};};default:_egd .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_cabf );return nil ,_egg .Errorf (_dfb ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_cgb );};};};if _dca ==nil {return _cagga ,nil ;};_cagga .UpdateParams (_dca );_gdde :=_dca .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _gdde ==nil {return _cagga ,nil ;};var _fegeb error ;_bgdg ,_acfc :=_gdde .(*PdfObjectStream );if !_acfc {_fegeb =_egg .Error (_dfb ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_egd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fegeb );return nil ,_fegeb ;};_cagga .Globals ,_fegeb =_be .DecodeGlobals (_bgdg .Stream );if _fegeb !=nil {_fegeb =_egg .Wrap (_fegeb ,_dfb ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_egd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fegeb );return nil ,_fegeb ;};return _cagga ,nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_agab *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dcege :=_eg .NewReader (encoded );_gfbf ,_ecfg :=_d .Decode (_dcege );if _ecfg !=nil {_egd .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ecfg );return nil ,_ecfg ;};_bfac :=_gfbf .Bounds ();var _dace =make ([]byte ,_bfac .Dx ()*_bfac .Dy ()*_agab .ColorComponents *_agab .BitsPerComponent /8);_cfeb :=0;for _cabc :=_bfac .Min .Y ;_cabc < _bfac .Max .Y ;_cabc ++{for _fbbg :=_bfac .Min .X ;_fbbg < _bfac .Max .X ;_fbbg ++{_degf :=_gfbf .At (_fbbg ,_cabc );if _agab .ColorComponents ==1{if _agab .BitsPerComponent ==16{_abbe ,_beagaa :=_degf .(_c .Gray16 );if !_beagaa {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dace [_cfeb ]=byte ((_abbe .Y >>8)&0xff);_cfeb ++;_dace [_cfeb ]=byte (_abbe .Y &0xff);_cfeb ++;}else {_bcff ,_aeaf :=_degf .(_c .Gray );if !_aeaf {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dace [_cfeb ]=_bcff .Y &0xff;_cfeb ++;};}else if _agab .ColorComponents ==3{if _agab .BitsPerComponent ==16{_bcgc ,_fdbd :=_degf .(_c .RGBA64 );if !_fdbd {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dace [_cfeb ]=byte ((_bcgc .R >>8)&0xff);_cfeb ++;_dace [_cfeb ]=byte (_bcgc .R &0xff);_cfeb ++;_dace [_cfeb ]=byte ((_bcgc .G >>8)&0xff);_cfeb ++;_dace [_cfeb ]=byte (_bcgc .G &0xff);_cfeb ++;_dace [_cfeb ]=byte ((_bcgc .B >>8)&0xff);_cfeb ++;_dace [_cfeb ]=byte (_bcgc .B &0xff);_cfeb ++;}else {_gaeg ,_egdc :=_degf .(_c .RGBA );if _egdc {_dace [_cfeb ]=_gaeg .R &0xff;_cfeb ++;_dace [_cfeb ]=_gaeg .G &0xff;_cfeb ++;_dace [_cfeb ]=_gaeg .B &0xff;_cfeb ++;}else {_cdbg ,_bccc :=_degf .(_c .YCbCr );if !_bccc {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_edg ,_cbge ,_ded ,_ :=_cdbg .RGBA ();_dace [_cfeb ]=byte (_edg >>8);_cfeb ++;_dace [_cfeb ]=byte (_cbge >>8);_cfeb ++;_dace [_cfeb ]=byte (_ded >>8);_cfeb ++;};};}else if _agab .ColorComponents ==4{_cbbc ,_faae :=_degf .(_c .CMYK );if !_faae {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dace [_cfeb ]=255-_cbbc .C &0xff;_cfeb ++;_dace [_cfeb ]=255-_cbbc .M &0xff;_cfeb ++;_dace [_cfeb ]=255-_cbbc .Y &0xff;_cfeb ++;_dace [_cfeb ]=255-_cbbc .K &0xff;_cfeb ++;};};};return _dace ,nil ;};var _gcef =_g .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_egcc *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _fbfe ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _egcc .ColorComponents !=1||_egcc .BitsPerComponent !=1{return nil ,_egg .Errorf (_fbfe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_fdfb *_fea .Bitmap ;_faff error ;);_bdgg :=(_egcc .Width *_egcc .Height )==len (data );if _bdgg {_fdfb ,_faff =_fea .NewWithUnpaddedData (_egcc .Width ,_egcc .Height ,data );}else {_fdfb ,_faff =_fea .NewWithData (_egcc .Width ,_egcc .Height ,data );};if _faff !=nil {return nil ,_faff ;};_ddge :=_egcc .DefaultPageSettings ;if _faff =_ddge .Validate ();_faff !=nil {return nil ,_egg .Wrap (_faff ,_fbfe ,"");};switch _ddge .Compression {case JB2Generic :if _faff =_egcc ._fbfa .AddGenericPage (_fdfb ,_ddge .DuplicatedLinesRemoval );_faff !=nil {return nil ,_egg .Wrap (_faff ,_fbfe ,"");};case JB2SymbolCorrelation :return nil ,_egg .Error (_fbfe ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_egg .Error (_fbfe ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_egg .Error (_fbfe ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _egcc .Encode ();};func _cafd (_bbfc int )int {_cadd :=_bbfc >>(_ffcb -1);return (_bbfc ^_cadd )-_cadd };

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_dfffd *JBIG2Encoder )EncodeImage (img _dc .Image )([]byte ,error ){return _dfffd .encodeImage (img );};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _faeba ,_cfff :=obj .(*PdfObjectReference );_cfff {obj =_faeba .Resolve ();};_bbdc ,_beba :=obj .(*PdfIndirectObject );_acea :=0;for _beba {obj =_bbdc .PdfObject ;_bbdc ,_beba =GetIndirect (obj );_acea ++;if _acea > _fdce {_egd .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_fdce );return nil ;};};return obj ;};

// String returns the state of the bool as "true" or "false".
func (_gbad *PdfObjectBool )String ()string {if *_gbad {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func _dde (_aeb PdfObject )(int64 ,int64 ,error ){if _ecb ,_agg :=_aeb .(*PdfIndirectObject );_agg {return _ecb .ObjectNumber ,_ecb .GenerationNumber ,nil ;};if _da ,_bga :=_aeb .(*PdfObjectStream );_bga {return _da .ObjectNumber ,_da .GenerationNumber ,nil ;};return 0,0,_b .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_fbbd *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_efdg :=_eg .NewReader (data );var _abc []byte ;var _fccf []byte ;_dbe ,_ccff :=_efdg .ReadByte ();if _ccff ==_dg .EOF {return []byte {},nil ;}else if _ccff !=nil {return nil ,_ccff ;};_afgc :=1;for {_gbea ,_bcfe :=_efdg .ReadByte ();if _bcfe ==_dg .EOF {break ;}else if _bcfe !=nil {return nil ,_bcfe ;};if _gbea ==_dbe {if len (_fccf )> 0{_fccf =_fccf [:len (_fccf )-1];if len (_fccf )> 0{_abc =append (_abc ,byte (len (_fccf )-1));_abc =append (_abc ,_fccf ...);};_afgc =1;_fccf =[]byte {};};_afgc ++;if _afgc >=127{_abc =append (_abc ,byte (257-_afgc ),_dbe );_afgc =0;};}else {if _afgc > 0{if _afgc ==1{_fccf =[]byte {_dbe };}else {_abc =append (_abc ,byte (257-_afgc ),_dbe );};_afgc =0;};_fccf =append (_fccf ,_gbea );if len (_fccf )>=127{_abc =append (_abc ,byte (len (_fccf )-1));_abc =append (_abc ,_fccf ...);_fccf =[]byte {};};};_dbe =_gbea ;};if len (_fccf )> 0{_abc =append (_abc ,byte (len (_fccf )-1));_abc =append (_abc ,_fccf ...);}else if _afgc > 0{_abc =append (_abc ,byte (257-_afgc ),_dbe );};_abc =append (_abc ,128);return _abc ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_gbaf *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _gbaf .Predictor !=1&&_gbaf .Predictor !=11{_egd .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _gbaf .Predictor ==11{_gbbc :=_gbaf .Columns ;_geca :=len (data )/_gbbc ;if len (data )%_gbbc !=0{_egd .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_b .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_acaa :=_eg .NewBuffer (nil );_gea :=make ([]byte ,_gbbc );for _cdgcd :=0;_cdgcd < _geca ;_cdgcd ++{_gcff :=data [_gbbc *_cdgcd :_gbbc *(_cdgcd +1)];_gea [0]=_gcff [0];for _dbb :=1;_dbb < _gbbc ;_dbb ++{_gea [_dbb ]=byte (int (_gcff [_dbb ]-_gcff [_dbb -1])%256);};_acaa .WriteByte (1);_acaa .Write (_gea );};data =_acaa .Bytes ();};var _beag _eg .Buffer ;_cdgb :=_ce .NewWriter (&_beag );_cdgb .Write (data );_cdgb .Close ();return _beag .Bytes (),nil ;};func (_acfd *PdfParser )skipSpaces ()(int ,error ){_fagef :=0;for {_ffff ,_bdfgd :=_acfd ._degc .ReadByte ();if _bdfgd !=nil {return 0,_bdfgd ;};if IsWhiteSpace (_ffff ){_fagef ++;}else {_acfd ._degc .UnreadByte ();break ;};};return _fagef ,nil ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_caag *PdfObjectArray )Get (i int )PdfObject {if _caag ==nil ||i >=len (_caag ._afda )||i < 0{return nil ;};return _caag ._afda [i ];};

// WriteString outputs the object as it is to be written to file.
func (_beaaa *PdfObjectStreams )WriteString ()string {var _fgcdc _fb .Builder ;_fgcdc .WriteString (_bf .FormatInt (_beaaa .ObjectNumber ,10));_fgcdc .WriteString ("\u0020\u0030\u0020\u0052");return _fgcdc .String ();};

// GetFilterName returns the name of the encoding filter.
func (_aeg *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_ggf :=PdfObjectInteger (val );return &_ggf };func _ecfb (_ddaae PdfObject ,_bgdgg int ,_facb map[PdfObject ]struct{})error {_egd .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_bgdgg );if _ ,_dcge :=_facb [_ddaae ];_dcge {_egd .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_facb [_ddaae ]=struct{}{};switch _ebgc :=_ddaae .(type ){case *PdfIndirectObject :_fdcd :=_ebgc ;_egd .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_fdcd );_egd .Log .Trace ("\u002d\u0020\u0025\u0073",_fdcd .PdfObject );return _ecfb (_fdcd .PdfObject ,_bgdgg +1,_facb );case *PdfObjectStream :_bcdb :=_ebgc ;return _ecfb (_bcdb .PdfObjectDictionary ,_bgdgg +1,_facb );case *PdfObjectDictionary :_bggbf :=_ebgc ;_egd .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_bggbf );for _ ,_fceb :=range _bggbf .Keys (){_dfaa :=_bggbf .Get (_fceb );if _fffacc ,_bdbc :=_dfaa .(*PdfObjectReference );_bdbc {_gaedb :=_fffacc .Resolve ();_bggbf .Set (_fceb ,_gaedb );_acda :=_ecfb (_gaedb ,_bgdgg +1,_facb );if _acda !=nil {return _acda ;};}else {_ccfg :=_ecfb (_dfaa ,_bgdgg +1,_facb );if _ccfg !=nil {return _ccfg ;};};};return nil ;case *PdfObjectArray :_fcab :=_ebgc ;_egd .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_fcab );for _cgda ,_adaa :=range _fcab .Elements (){if _afdae ,_fbcd :=_adaa .(*PdfObjectReference );_fbcd {_agecg :=_afdae .Resolve ();_fcab .Set (_cgda ,_agecg );_cdad :=_ecfb (_agecg ,_bgdgg +1,_facb );if _cdad !=nil {return _cdad ;};}else {_egcd :=_ecfb (_adaa ,_bgdgg +1,_facb );if _egcd !=nil {return _egcd ;};};};return nil ;case *PdfObjectReference :_egd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _b .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_ddc :=&ASCIIHexEncoder {};return _ddc };

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ggeg *FlateEncoder )MakeDecodeParams ()PdfObject {if _ggeg .Predictor > 1{_fcac :=MakeDict ();_fcac .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ggeg .Predictor )));if _ggeg .BitsPerComponent !=8{_fcac .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ggeg .BitsPerComponent )));};if _ggeg .Columns !=1{_fcac .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ggeg .Columns )));};if _ggeg .Colors !=1{_fcac .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ggeg .Colors )));};return _fcac ;};return nil ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_dgga *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_eeba ,_cage :=_dgga ._ffeb [key ].(*PdfObjectString );if !_cage {return "",false ;};return _eeba .Str (),true ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_gbbe *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_adagb error ){const _abgb ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _gbbe ==nil {return _egg .Error (_abgb ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_gbbe .DefaultPageSettings ;};if _gbbe ._fbfa ==nil {_gbbe ._fbfa =_cd .InitEncodeDocument (settings .FileMode );};if _adagb =settings .Validate ();_adagb !=nil {return _egg .Wrap (_adagb ,_abgb ,"");};_dgef ,_adagb :=img .toBitmap ();if _adagb !=nil {return _egg .Wrap (_adagb ,_abgb ,"");};switch settings .Compression {case JB2Generic :if _adagb =_gbbe ._fbfa .AddGenericPage (_dgef ,settings .DuplicatedLinesRemoval );_adagb !=nil {return _egg .Wrap (_adagb ,_abgb ,"");};case JB2SymbolCorrelation :return _egg .Error (_abgb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _egg .Error (_abgb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _egg .Error (_abgb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_dced *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_fffg ,_dcd :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _dcd ==nil {_dced .Predictor =int (_fffg );};_aba ,_dcd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _dcd ==nil {_dced .BitsPerComponent =int (_aba );};_gadc ,_dcd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dcd ==nil {_dced .Columns =int (_gadc );};_cabb ,_dcd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _dcd ==nil {_dced .Colors =int (_cabb );};_bfgb ,_dcd :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _dcd ==nil {_dced .EarlyChange =int (_bfgb );};};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_abea :objects };};

// PdfVersion returns version of the PDF file.
func (_bbfg *PdfParser )PdfVersion ()Version {return _bbfg ._fdae };func (_dcfa *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _efgg *PdfObjectDictionary ;_cddgc ,_gfec :=_dcfa .readTextLine ();if _gfec !=nil {return nil ,_gfec ;};_egd .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cddgc );_dbfe :=-1;_cbba :=0;_badfc :=false ;_ccca :="";for {_dcfa .skipSpaces ();_ ,_agbf :=_dcfa ._degc .Peek (1);if _agbf !=nil {return nil ,_agbf ;};_cddgc ,_agbf =_dcfa .readTextLine ();if _agbf !=nil {return nil ,_agbf ;};_gffbc :=_abffd .FindStringSubmatch (_cddgc );if len (_gffbc )==0{_caab :=len (_ccca )> 0;_ccca +=_cddgc +"\u000a";if _caab {_gffbc =_abffd .FindStringSubmatch (_ccca );};};if len (_gffbc )==3{_deaf ,_ :=_bf .Atoi (_gffbc [1]);_eedcf ,_ :=_bf .Atoi (_gffbc [2]);_dbfe =_deaf ;_cbba =_eedcf ;_badfc =true ;_ccca ="";_egd .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_dbfe ,_cbba );continue ;};_acga :=_faab .FindStringSubmatch (_cddgc );if len (_acga )==4{if !_badfc {_egd .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_b .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_fbbe ,_ :=_bf .ParseInt (_acga [1],10,64);_dgffd ,_ :=_bf .Atoi (_acga [2]);_bcdd :=_acga [3];_ccca ="";if _fb .ToLower (_bcdd )=="\u006e"&&_fbbe > 1{_bgfd ,_gega :=_dcfa ._cggf .ObjectMap [_dbfe ];if !_gega ||_dgffd > _bgfd .Generation {_eeee :=XrefObject {ObjectNumber :_dbfe ,XType :XrefTypeTableEntry ,Offset :_fbbe ,Generation :_dgffd };_dcfa ._cggf .ObjectMap [_dbfe ]=_eeee ;};};_dbfe ++;continue ;};if (len (_cddgc )> 6)&&(_cddgc [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_egd .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_cddgc );if len (_cddgc )> 9{_cdbd :=_dcfa .GetFileOffset ();_dcfa .SetFileOffset (_cdbd -int64 (len (_cddgc ))+7);};_dcfa .skipSpaces ();_dcfa .skipComments ();_egd .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_egd .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_cddgc );_efgg ,_agbf =_dcfa .ParseDict ();_egd .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _agbf !=nil {_egd .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_agbf );return nil ,_agbf ;};break ;};if _cddgc =="\u0025\u0025\u0045O\u0046"{_egd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_b .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_egd .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_cddgc );};_egd .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _dcfa ._bcdef ==nil {_dccf :=XrefTypeTableEntry ;_dcfa ._bcdef =&_dccf ;};return _efgg ,nil ;};func (_aade *PdfParser )parseXrefStream (_ceeee *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _ceeee !=nil {_egd .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_ceeee );_aade ._ecgc .Seek (int64 (*_ceeee ),_dg .SeekStart );_aade ._degc =_de .NewReader (_aade ._ecgc );};_dbcgg :=_aade .GetFileOffset ();_beaee ,_ggca :=_aade .ParseIndirectObject ();if _ggca !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_egd .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_beaee );_edee ,_ddaf :=_beaee .(*PdfObjectStream );if !_ddaf {_egd .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_b .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_bdddd :=_edee .PdfObjectDictionary ;_gbcc ,_ddaf :=_edee .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_ddaf {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_b .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_gbcc )> 8388607{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_gbcc );return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dcfab :=_edee .PdfObjectDictionary .Get ("\u0057");_aaaf ,_ddaf :=_dcfab .(*PdfObjectArray );if !_ddaf {return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_babf :=_aaaf .Len ();if _babf !=3{_egd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_babf );return nil ,_b .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _aded []int64 ;for _gfgg :=0;_gfgg < 3;_gfgg ++{_eeedd ,_cbff :=GetInt (_aaaf .Get (_gfgg ));if !_cbff {return nil ,_b .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_aded =append (_aded ,int64 (*_eeedd ));};_feab ,_ggca :=DecodeStream (_edee );if _ggca !=nil {_egd .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_ggca );return nil ,_ggca ;};_edgc :=int (_aded [0]);_acab :=int (_aded [0]+_aded [1]);_cabd :=int (_aded [0]+_aded [1]+_aded [2]);_ggag :=int (_aded [0]+_aded [1]+_aded [2]);if _edgc < 0||_acab < 0||_cabd < 0{_egd .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_edgc ,_acab ,_cabd );return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ggag ==0{_egd .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _bdddd ,nil ;};_aaea :=len (_feab )/_ggag ;_ddfb :=0;_bgbgg :=_edee .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _ddfd []int ;if _bgbgg !=nil {_egd .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_bgbgg );_cacc ,_cgdg :=_bgbgg .(*PdfObjectArray );if !_cgdg {_egd .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_b .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _cacc .Len ()%2!=0{_egd .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ddfb =0;_dcfe ,_cfebd :=_cacc .ToIntegerArray ();if _cfebd !=nil {_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_cfebd );return nil ,_cfebd ;};for _afff :=0;_afff < len (_dcfe );_afff +=2{_dfdb :=_dcfe [_afff ];_bdab :=_dcfe [_afff +1];for _fcdd :=0;_fcdd < _bdab ;_fcdd ++{_ddfd =append (_ddfd ,_dfdb +_fcdd );};_ddfb +=_bdab ;};}else {for _ebad :=0;_ebad < int (*_gbcc );_ebad ++{_ddfd =append (_ddfd ,_ebad );};_ddfb =int (*_gbcc );};if _aaea ==_ddfb +1{_egd .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_cdcb :=_ddfb -1;for _ ,_cfgfd :=range _ddfd {if _cfgfd > _cdcb {_cdcb =_cfgfd ;};};_ddfd =append (_ddfd ,_cdcb +1);_ddfb ++;};if _aaea !=len (_ddfd ){_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_aaea ,len (_ddfd ));return nil ,_b .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_egd .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ddfb );_egd .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_ddfd );_eabad :=func (_ecfa []byte )int64 {var _acbe int64 ;for _bfdfc :=0;_bfdfc < len (_ecfa );_bfdfc ++{_acbe +=int64 (_ecfa [_bfdfc ])*(1<<uint (8*(len (_ecfa )-_bfdfc -1)));};return _acbe ;};_egd .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_feab ));_gbbafe :=0;for _ecbg :=0;_ecbg < len (_feab );_ecbg +=_ggag {_fcde :=_fecg (len (_feab ),_ecbg ,_ecbg +_edgc );if _fcde !=nil {_egd .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcde );return nil ,_fcde ;};_cgff :=_feab [_ecbg :_ecbg +_edgc ];_fcde =_fecg (len (_feab ),_ecbg +_edgc ,_ecbg +_acab );if _fcde !=nil {_egd .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcde );return nil ,_fcde ;};_cgdc :=_feab [_ecbg +_edgc :_ecbg +_acab ];_fcde =_fecg (len (_feab ),_ecbg +_acab ,_ecbg +_cabd );if _fcde !=nil {_egd .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcde );return nil ,_fcde ;};_ggge :=_feab [_ecbg +_acab :_ecbg +_cabd ];_gccd :=_eabad (_cgff );_deggd :=_eabad (_cgdc );_becf :=_eabad (_ggge );if _aded [0]==0{_gccd =1;};if _gbbafe >=len (_ddfd ){_egd .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_acgg :=_ddfd [_gbbafe ];_gbbafe ++;_egd .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_acgg ,_cgff );_egd .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_acgg ,_cgdc );_egd .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_acgg ,_ggge );_egd .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_acgg ,_gccd ,_deggd ,_becf );if _gccd ==0{_egd .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _gccd ==1{_egd .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_cgdc );if _deggd ==_dbcgg {_egd .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_acgg ,_edee .ObjectNumber );_acgg =int (_edee .ObjectNumber );};if _gdga ,_afca :=_aade ._cggf .ObjectMap [_acgg ];!_afca ||int (_becf )> _gdga .Generation {_bggc :=XrefObject {ObjectNumber :_acgg ,XType :XrefTypeTableEntry ,Offset :_deggd ,Generation :int (_becf )};_aade ._cggf .ObjectMap [_acgg ]=_bggc ;};}else if _gccd ==2{_egd .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_dece :=_aade ._cggf .ObjectMap [_acgg ];!_dece {_dacbb :=XrefObject {ObjectNumber :_acgg ,XType :XrefTypeObjectStream ,OsObjNumber :int (_deggd ),OsObjIndex :int (_becf )};_aade ._cggf .ObjectMap [_acgg ]=_dacbb ;_egd .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_dacbb );};}else {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _aade ._bcdef ==nil {_cfebb :=XrefTypeObjectStream ;_aade ._bcdef =&_cfebb ;};return _bdddd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_aegf *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _dg .ReadSeeker )(*PdfParser ,error ){_ebae :=&PdfParser {_ecgc :rs ,ObjCache :make (objectCache ),_dffa :map[int64 ]bool {}};_dgbeb ,_eecd ,_aede :=_ebae .parsePdfVersion ();if _aede !=nil {_egd .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_aede );return nil ,_aede ;};_ebae ._fdae .Major =_dgbeb ;_ebae ._fdae .Minor =_eecd ;if _ebae ._fddc ,_aede =_ebae .loadXrefs ();_aede !=nil {_egd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_aede );return nil ,_aede ;};_egd .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ebae ._fddc );if len (_ebae ._cggf .ObjectMap )==0{return nil ,_gb .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _ebae ,nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_de .Reader )(PdfObject ,error ){_fgfb :=false ;_dgdf :=true ;var _cafcd _eg .Buffer ;for {if _egd .Log .IsLogLevel (_egd .LogLevelTrace ){_egd .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_cafcd .String ());};_bbde ,_ggga :=buf .Peek (1);if _ggga ==_dg .EOF {break ;};if _ggga !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_ggga );return nil ,_ggga ;};if _dgdf &&(_bbde [0]=='-'||_bbde [0]=='+'){_deffd ,_ :=buf .ReadByte ();_cafcd .WriteByte (_deffd );_dgdf =false ;}else if IsDecimalDigit (_bbde [0]){_abfa ,_ :=buf .ReadByte ();_cafcd .WriteByte (_abfa );}else if _bbde [0]=='.'{_bfgbgb ,_ :=buf .ReadByte ();_cafcd .WriteByte (_bfgbgb );_fgfb =true ;}else if _bbde [0]=='e'||_bbde [0]=='E'{_fcff ,_ :=buf .ReadByte ();_cafcd .WriteByte (_fcff );_fgfb =true ;_dgdf =true ;}else {break ;};};var _fgcde PdfObject ;if _fgfb {_gdafg ,_bagb :=_bf .ParseFloat (_cafcd .String (),64);if _bagb !=nil {_egd .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_cafcd .String (),_bagb );_gdafg =0.0;};_beefg :=PdfObjectFloat (_gdafg );_fgcde =&_beefg ;}else {_acdac ,_ffgcf :=_bf .ParseInt (_cafcd .String (),10,64);if _ffgcf !=nil {_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_cafcd .String (),_ffgcf );_acdac =0;};_fefd :=PdfObjectInteger (_acdac );_fgcde =&_fefd ;};return _fgcde ,nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_fag *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_ceb ,_ ,_agc :=_fag .lookupByNumberWrapper (objNumber ,true );return _ceb ,_agc ;};var _gbcbf =_g .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");func _fggec (_bffd PdfObject ,_aaedb int )PdfObject {if _aaedb > _fdce {_egd .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_fdce );return MakeNull ();};switch _bbgb :=_bffd .(type ){case *PdfIndirectObject :_bffd =_fggec ((*_bbgb ).PdfObject ,_aaedb +1);case *PdfObjectArray :for _ebdc ,_ggdgf :=range (*_bbgb )._afda {(*_bbgb )._afda [_ebdc ]=_fggec (_ggdgf ,_aaedb +1);};case *PdfObjectDictionary :for _dcbg ,_bcca :=range (*_bbgb )._ffeb {(*_bbgb )._ffeb [_dcbg ]=_fggec (_bcca ,_aaedb +1);};_ed .Slice ((*_bbgb )._cecc ,func (_abfeb ,_ebga int )bool {return (*_bbgb )._cecc [_abfeb ]< (*_bbgb )._cecc [_ebga ]});};return _bffd ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _ecfb (o ,0,traversed );};type objectStreams map[int ]objectStream ;

// WriteString outputs the object as it is to be written to file.
func (_bcbc *PdfObjectStream )WriteString ()string {var _agabb _fb .Builder ;_agabb .WriteString (_bf .FormatInt (_bcbc .ObjectNumber ,10));_agabb .WriteString ("\u0020\u0030\u0020\u0052");return _agabb .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_eab *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_ebca *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_ebca ._ecgc .Seek (offset ,_dg .SeekStart );_ebca ._degc =_de .NewReader (_ebca ._ecgc );};func (_beeg *PdfParser )seekToEOFMarker (_cfgfca int64 )error {var _agbe int64 ;var _fffb int64 =2048;for _agbe < _cfgfca -4{if _cfgfca <=(_fffb +_agbe ){_fffb =_cfgfca -_agbe ;};_ ,_aedg :=_beeg ._ecgc .Seek (-_agbe -_fffb ,_dg .SeekEnd );if _aedg !=nil {return _aedg ;};_dega :=make ([]byte ,_fffb );_beeg ._ecgc .Read (_dega );_egd .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_dega ));_cfcb :=_gdff .FindAllStringIndex (string (_dega ),-1);if _cfcb !=nil {_ccd :=_cfcb [len (_cfcb )-1];_egd .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cfcb );_beeg ._ecgc .Seek (-_agbe -_fffb +int64 (_ccd [0]),_dg .SeekEnd );return nil ;};_egd .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_agbe +=_fffb -4;};_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _b .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_dgda *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_edeaa :=n ;_fcca :=0;_bgae :=0;for _edeaa > 0{_feeg ,_aeeb :=_dgda ._degc .Read (p [_fcca :]);if _aeeb !=nil {_egd .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_feeg ,_bgae ,_aeeb .Error ());return _fcca ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_bgae ++;_fcca +=_feeg ;_edeaa -=_feeg ;};return _fcca ,nil ;};var (ErrUnsupportedEncodingParameters =_b .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_b .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_b .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_b .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_b .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_b .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_bg .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_b .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_egdd *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gecdb [][]byte ;for _egfe :=0;_egfe < len (data );_egfe +=_egdd .Columns {_gaed :=make ([]byte ,_egdd .Columns );_cbdc :=0;for _afdg :=0;_afdg < _egdd .Columns ;_afdg ++{if data [_egfe +_afdg ]==255{_gaed [_cbdc ]=1;}else {_gaed [_cbdc ]=0;};_cbdc ++;};_gecdb =append (_gecdb ,_gaed );};_cbef :=&_fe .Encoder {K :_egdd .K ,Columns :_egdd .Columns ,EndOfLine :_egdd .EndOfLine ,EndOfBlock :_egdd .EndOfBlock ,BlackIs1 :_egdd .BlackIs1 ,DamagedRowsBeforeError :_egdd .DamagedRowsBeforeError ,Rows :_egdd .Rows ,EncodedByteAlign :_egdd .EncodedByteAlign };return _cbef .Encode (_gecdb ),nil ;};

// Len returns the number of elements in the streams.
func (_gbfa *PdfObjectStreams )Len ()int {if _gbfa ==nil {return 0;};return len (_gbfa ._abea );};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_fgfd *JBIG2Encoder )DecodeImages (encoded []byte )([]_dc .Image ,error ){const _abd ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ecca ,_edce :=_ec .Decode (encoded ,_ec .Parameters {},_fgfd .Globals .ToDocumentGlobals ());if _edce !=nil {return nil ,_egg .Wrap (_edce ,_abd ,"");};_agff ,_edce :=_ecca .PageNumber ();if _edce !=nil {return nil ,_egg .Wrap (_edce ,_abd ,"");};_acaag :=[]_dc .Image {};var _beeab _dc .Image ;for _eegf :=1;_eegf <=_agff ;_eegf ++{_beeab ,_edce =_ecca .DecodePageImage (_eegf );if _edce !=nil {return nil ,_egg .Wrapf (_edce ,_abd ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eegf );};_acaag =append (_acaag ,_beeab );};return _acaag ,nil ;};var _cbf =_g .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// Len returns the number of elements in the array.
func (_abbc *PdfObjectArray )Len ()int {if _abbc ==nil {return 0;};return len (_abbc ._afda );};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_bbab :=MakeArray ();for _ ,_fgdgd :=range vals {_bbab .Append (MakeInteger (_fgdgd ));};return _bbab ;};type xrefType int ;

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_fbe *MultiEncoder )GetFilterName ()string {_ccbe :="";for _fecd ,_cface :=range _fbe ._eaca {_ccbe +=_cface .GetFilterName ();if _fecd < len (_fbe ._eaca )-1{_ccbe +="\u0020";};};return _ccbe ;};

// String returns a descriptive information string about the encryption method used.
func (_fae *PdfCrypt )String ()string {if _fae ==nil {return "";};_dff :=_fae ._bcb .Filter +"\u0020\u002d\u0020";if _fae ._bcb .V ==0{_dff +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _fae ._bcb .V ==1{_dff +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _fae ._bcb .V ==2{_dff +=_gb .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_fae ._bcb .Length );}else if _fae ._bcb .V ==3{_dff +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _fae ._bcb .V >=4{_dff +=_gb .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_fae ._bda ,_fae ._bfd );_dff +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _ca ,_fggf :=range _fae ._bfce {_dff +=_gb .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_ca ,_fggf .Name (),_fggf .KeyLength ());};};_fgc :=_fae .GetAccessPermissions ();_dff +=_gb .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_fgc );return _dff ;};func _aacec (_agbea *PdfObjectDictionary )(_bcaa *_ecc .ImageBase ){var (_ceba *PdfObjectInteger ;_ccabg bool ;);if _ceba ,_ccabg =_agbea .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_ccabg {_bcaa =&_ecc .ImageBase {Width :int (*_ceba )};}else {return nil ;};if _ceba ,_ccabg =_agbea .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_ccabg {_bcaa .Height =int (*_ceba );};if _ceba ,_ccabg =_agbea .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_ccabg {_bcaa .BitsPerComponent =int (*_ceba );};if _ceba ,_ccabg =_agbea .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_ccabg {_bcaa .ColorComponents =int (*_ceba );};return _bcaa ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_aaa *PdfCrypt )GetAccessPermissions ()_bc .Permissions {return _aaa ._adg .P };

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_fedf *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _faed :=val .(type ){case *PdfObjectName :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectDictionary :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectStream :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectString :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectNull :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectInteger :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectArray :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectBool :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectFloat :if _faed !=nil {_fedf .Set (key ,val );};case *PdfObjectReference :if _faed !=nil {_fedf .Set (key ,val );};case *PdfIndirectObject :if _faed !=nil {_fedf .Set (key ,val );};default:_egd .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_eebb *PdfObjectString )Decoded ()string {if _eebb ==nil {return "";};_fbeg :=[]byte (_eebb ._cdfb );if len (_fbeg )>=2&&_fbeg [0]==0xFE&&_fbeg [1]==0xFF{return _fa .UTF16ToString (_fbeg [2:]);};return _fa .PDFDocEncodingToString (_fbeg );};func (_bbba *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_dg .SeekStart {offset +=_bbba ._acfg ;};_caee ,_eddg :=_bbba ._fgdg .Seek (offset ,whence );if _eddg !=nil {return _caee ,_eddg ;};if whence ==_dg .SeekCurrent {_caee -=_bbba ._acfg ;};if _caee < 0{return 0,_b .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _caee ,nil ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_egd .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_egfgb ,_dded :=NewEncoderFromStream (streamObj );if _dded !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dded );return nil ,_dded ;};_egd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_egfgb );_cafbg ,_dded :=_egfgb .DecodeStream (streamObj );if _dded !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dded );return nil ,_dded ;};return _cafbg ,nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);const (_dgbb =0;_defb =1;_befd =2;_fabf =3;_cff =4;);func _fecg (_feecc ,_bbea ,_gegb int )error {if _bbea < 0||_bbea > _feecc {return _b .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _gegb < _bbea {return _b .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _gegb > _feecc {return _b .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fgb *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fgb .isEncrypted (obj ){return nil ;};switch _dffb :=obj .(type ){case *PdfIndirectObject :_fgb ._bec [_dffb ]=true ;_egd .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_dffb .ObjectNumber ,_dffb .GenerationNumber );_cfac :=_dffb .ObjectNumber ;_eeac :=_dffb .GenerationNumber ;_cfgf :=_fgb .Encrypt (_dffb .PdfObject ,_cfac ,_eeac );if _cfgf !=nil {return _cfgf ;};return nil ;case *PdfObjectStream :_fgb ._bec [_dffb ]=true ;_gfg :=_dffb .PdfObjectDictionary ;if _cbeg ,_efe :=_gfg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_efe &&*_cbeg =="\u0058\u0052\u0065\u0066"{return nil ;};_fgf :=_dffb .ObjectNumber ;_eee :=_dffb .GenerationNumber ;_egd .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fgf ,_eee );_ega :=_gbga ;if _fgb ._bcb .V >=4{_ega =_fgb ._bda ;_egd .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fgb ._bda );if _eedc ,_dfff :=_gfg .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_dfff {if _fdb ,_aacf :=GetName (_eedc .Get (0));_aacf {if *_fdb =="\u0043\u0072\u0079p\u0074"{_ega ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dbd ,_fbf :=_gfg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_fbf {if _fbff ,_aef :=_dbd .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_aef {if _ ,_gde :=_fgb ._bfce [string (*_fbff )];_gde {_egd .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_fbff );_ega =string (*_fbff );};};};};};};_egd .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ega );if _ega =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_efb :=_fgb .Encrypt (_dffb .PdfObjectDictionary ,_fgf ,_eee );if _efb !=nil {return _efb ;};_gac ,_efb :=_fgb .makeKey (_ega ,uint32 (_fgf ),uint32 (_eee ),_fgb ._fde );if _efb !=nil {return _efb ;};_dffb .Stream ,_efb =_fgb .encryptBytes (_dffb .Stream ,_ega ,_gac );if _efb !=nil {return _efb ;};_gfg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dffb .Stream ))));return nil ;case *PdfObjectString :_egd .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_bfaf :=_gbga ;if _fgb ._bcb .V >=4{_egd .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fgb ._bfd );if _fgb ._bfd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_bfaf =_fgb ._bfd ;};_ffge ,_beb :=_fgb .makeKey (_bfaf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fgb ._fde );if _beb !=nil {return _beb ;};_agef :=_dffb .Str ();_ccbf :=make ([]byte ,len (_agef ));for _gffb :=0;_gffb < len (_agef );_gffb ++{_ccbf [_gffb ]=_agef [_gffb ];};_egd .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ccbf ,_ccbf );_ccbf ,_beb =_fgb .encryptBytes (_ccbf ,_bfaf ,_ffge );if _beb !=nil {return _beb ;};_dffb ._cdfb =string (_ccbf );return nil ;case *PdfObjectArray :for _ ,_beea :=range _dffb .Elements (){_gce :=_fgb .Encrypt (_beea ,parentObjNum ,parentGenNum );if _gce !=nil {return _gce ;};};return nil ;case *PdfObjectDictionary :_eagd :=false ;if _fbb :=_dffb .Get ("\u0054\u0079\u0070\u0065");_fbb !=nil {_eagc ,_agec :=_fbb .(*PdfObjectName );if _agec &&*_eagc =="\u0053\u0069\u0067"{_eagd =true ;};};for _ ,_abeb :=range _dffb .Keys (){_abg :=_dffb .Get (_abeb );if _eagd &&string (_abeb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_abeb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_abeb )!="\u0050\u0072\u0065\u0076"&&string (_abeb )!="\u004c\u0061\u0073\u0074"{_cec :=_fgb .Encrypt (_abg ,parentObjNum ,parentGenNum );if _cec !=nil {return _cec ;};};};return nil ;};return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_acdc *PdfIndirectObject )WriteString ()string {var _efaf _fb .Builder ;_efaf .WriteString (_bf .FormatInt (_acdc .ObjectNumber ,10));_efaf .WriteString ("\u0020\u0030\u0020\u0052");return _efaf .String ();};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_cdd *FlateEncoder )SetPredictor (columns int ){_cdd .Predictor =11;_cdd .Columns =columns };

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_bcgd :=PdfObjectString {_cdfb :s };return &_bcgd };

// Validate validates the page settings for the JBIG2 encoder.
func (_efca JBIG2EncoderSettings )Validate ()error {const _abge ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _efca .Threshold < 0||_efca .Threshold > 1.0{return _egg .Errorf (_abge ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_efca .Threshold );};if _efca .ResolutionX < 0{return _egg .Errorf (_abge ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_efca .ResolutionX );};if _efca .ResolutionY < 0{return _egg .Errorf (_abge ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_efca .ResolutionY );};if _efca .DefaultPixelValue !=0&&_efca .DefaultPixelValue !=1{return _egg .Errorf (_abge ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_efca .DefaultPixelValue );};if _efca .Compression !=JB2Generic {return _egg .Errorf (_abge ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_afda []PdfObject };

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_degac *PdfObjectArray ,_cdcfe bool ){_degac ,_cdcfe =TraceToDirectObject (obj ).(*PdfObjectArray );return _degac ,_cdcfe ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bcfb *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_fggfg :=MakeDict ();_fggfg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_bcfb .GetFilterArray ());for _ ,_dee :=range _bcfb ._eaca {_gbfd :=_dee .MakeStreamDict ();for _ ,_degga :=range _gbfd .Keys (){_bdd :=_gbfd .Get (_degga );if _degga !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_degga !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_fggfg .Set (_degga ,_bdd );};};};_ffdd :=_bcfb .MakeDecodeParams ();if _ffdd !=nil {_fggfg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ffdd );};return _fggfg ;};var _faab =_g .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _cebb :=obj .(type ){case *PdfObjectFloat :return float64 (*_cebb ),nil ;case *PdfObjectInteger :return float64 (*_cebb ),nil ;};return 0,ErrNotANumber ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_gfaa :=MakeArray ();for _ ,_adcb :=range vals {_gfaa .Append (MakeInteger (int64 (_adcb )));};return _gfaa ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_adeg :=PdfObjectString {_cdfb :s ,_bfae :true };return &_adeg ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_fcged Version )String ()string {return _gb .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_fcged .Major ,_fcged .Minor );};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_gda *_ecc .ImageBase ;};

// WriteString outputs the object as it is to be written to file.
func (_adfdg *PdfObjectName )WriteString ()string {var _gffa _eg .Buffer ;if len (*_adfdg )> 127{_egd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_adfdg );};_gffa .WriteString ("\u002f");for _cbfe :=0;_cbfe < len (*_adfdg );_cbfe ++{_bgeg :=(*_adfdg )[_cbfe ];if !IsPrintable (_bgeg )||_bgeg =='#'||IsDelimiter (_bgeg ){_gffa .WriteString (_gb .Sprintf ("\u0023\u0025\u002e2\u0078",_bgeg ));}else {_gffa .WriteByte (_bgeg );};};return _gffa .String ();};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;const _ffcb =32<<(^uint (0)>>63);

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_adfd :=MakeArray ();for _ ,_cdcd :=range vals {_adfd .Append (MakeFloat (_cdcd ));};return _adfd ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_gaeb *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _eceeb []int ;for _ ,_egfg :=range _gaeb .Elements (){if _geddgf ,_gdcb :=_egfg .(*PdfObjectInteger );_gdcb {_eceeb =append (_eceeb ,int (*_geddgf ));}else {return nil ,ErrTypeError ;};};return _eceeb ,nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fbfb *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// WriteString outputs the object as it is to be written to file.
func (_ddbb *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};func (_dgad *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _dgad ._bfdf {return nil ,_gb .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_dgad ._bfdf =true ;_dgad ._ecgc .Seek (0,_dg .SeekStart );_dgad ._degc =_de .NewReader (_dgad ._ecgc );_adab :=20;_edec :=make ([]byte ,_adab );_ecbcgg :=XrefTable {};_ecbcgg .ObjectMap =make (map[int ]XrefObject );for {_deea ,_cfgb :=_dgad ._degc .ReadByte ();if _cfgb !=nil {if _cfgb ==_dg .EOF {break ;}else {return nil ,_cfgb ;};};if _deea =='j'&&_edec [_adab -1]=='b'&&_edec [_adab -2]=='o'&&IsWhiteSpace (_edec [_adab -3]){_edebc :=_adab -4;for IsWhiteSpace (_edec [_edebc ])&&_edebc > 0{_edebc --;};if _edebc ==0||!IsDecimalDigit (_edec [_edebc ]){continue ;};for IsDecimalDigit (_edec [_edebc ])&&_edebc > 0{_edebc --;};if _edebc ==0||!IsWhiteSpace (_edec [_edebc ]){continue ;};for IsWhiteSpace (_edec [_edebc ])&&_edebc > 0{_edebc --;};if _edebc ==0||!IsDecimalDigit (_edec [_edebc ]){continue ;};for IsDecimalDigit (_edec [_edebc ])&&_edebc > 0{_edebc --;};if _edebc ==0{continue ;};_bffgg :=_dgad .GetFileOffset ()-int64 (_adab -_edebc );_bgbf :=append (_edec [_edebc +1:],_deea );_bedd ,_adbda ,_egbae :=_cbdg (string (_bgbf ));if _egbae !=nil {_egd .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_egbae );return nil ,_egbae ;};if _fgfge ,_ebcfa :=_ecbcgg .ObjectMap [_bedd ];!_ebcfa ||_fgfge .Generation < _adbda {_fged :=XrefObject {};_fged .XType =XrefTypeTableEntry ;_fged .ObjectNumber =_bedd ;_fged .Generation =_adbda ;_fged .Offset =_bffgg ;_ecbcgg .ObjectMap [_bedd ]=_fged ;};};_edec =append (_edec [1:_adab ],_deea );};return &_ecbcgg ,nil ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_gcdb *PdfParser )IsEncrypted ()(bool ,error ){if _gcdb ._fccd !=nil {return true ,nil ;}else if _gcdb ._fddc ==nil {return false ,nil ;};_egd .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_bddf :=_gcdb ._fddc .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _bddf ==nil {return false ,nil ;};_egd .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_eafe *PdfObjectDictionary ;);switch _bgfca :=_bddf .(type ){case *PdfObjectDictionary :_eafe =_bgfca ;case *PdfObjectReference :_egd .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_bgfca );_ddgf ,_ggdc :=_gcdb .LookupByReference (*_bgfca );_egd .Log .Trace ("\u0031\u003a\u0020%\u0071",_ddgf );if _ggdc !=nil {return false ,_ggdc ;};_afed ,_facd :=_ddgf .(*PdfIndirectObject );if !_facd {_egd .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_b .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_cbae ,_facd :=_afed .PdfObject .(*PdfObjectDictionary );_egd .Log .Trace ("\u0032\u003a\u0020%\u0071",_cbae );if !_facd {return false ,_b .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_eafe =_cbae ;case *PdfObjectNull :_egd .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_gb .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_bgfca );};_ecbcg ,_fgaf :=PdfCryptNewDecrypt (_gcdb ,_eafe ,_gcdb ._fddc );if _fgaf !=nil {return false ,_fgaf ;};for _ ,_bcdg :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_degb :=_gcdb ._fddc .Get (PdfObjectName (_bcdg ));if _degb ==nil {continue ;};switch _ffcg :=_degb .(type ){case *PdfObjectReference :_ecbcg ._gag [int (_ffcg .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_ecbcg ._bad [_ffcg ]=true ;_ecbcg ._gag [int (_ffcg .ObjectNumber )]=struct{}{};};};_gcdb ._fccd =_ecbcg ;_egd .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_ecbcg );return true ,nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_aabc *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_aeafd ,_fgdb :=_aabc ._ffeb [key ];if !_fgdb {return nil ;};return _aeafd ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_cfgfc :=MultiEncoder {};_cfgfc ._eaca =[]StreamEncoder {};return &_cfgfc ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_bacgf *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_cbafa :=_bacgf ._ffeb [key ];if !_cbafa {_bacgf ._cecc =append (_bacgf ._cecc ,key );};_bacgf ._ffeb [key ]=val ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_fgba *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_gbbaf ,_fdac :=_ecc .NewImage (_fgba .Width ,_fgba .Height ,_fgba .BitsPerComponent ,_fgba .ColorComponents ,data ,nil ,nil );if _fdac !=nil {return nil ,_fdac ;};_bcef :=_d .Options {};_bcef .Quality =_fgba .Quality ;var _gaea _eg .Buffer ;if _fdac =_d .Encode (&_gaea ,_gbbaf ,&_bcef );_fdac !=nil {return nil ,_fdac ;};return _gaea .Bytes (),nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_gab *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gab .GetFilterName ());return data ,ErrNoJPXDecode ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_acfda *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_acfda ._afda ){return _b .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_acfda ._afda [i ]=obj ;return nil ;};

// String returns a string describing `array`.
func (_efed *PdfObjectArray )String ()string {_dgbda :="\u005b";for _fcbc ,_ffbef :=range _efed .Elements (){_dgbda +=_ffbef .String ();if _fcbc < (_efed .Len ()-1){_dgbda +="\u002c\u0020";};};_dgbda +="\u005d";return _dgbda ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_dadc :=&PdfIndirectObject {};_dadc .PdfObject =obj ;return _dadc ;};type objectStream struct{N int ;_ff []byte ;_a map[int ]int64 ;};func _cdaf (_gbag *PdfObjectStream ,_fgga *PdfObjectDictionary )(*LZWEncoder ,error ){_bdcb :=NewLZWEncoder ();_bfb :=_gbag .PdfObjectDictionary ;if _bfb ==nil {return _bdcb ,nil ;};if _fgga ==nil {_gfde :=TraceToDirectObject (_bfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _gfde !=nil {if _gaef ,_efda :=_gfde .(*PdfObjectDictionary );_efda {_fgga =_gaef ;}else if _ecf ,_eeg :=_gfde .(*PdfObjectArray );_eeg {if _ecf .Len ()==1{if _dgbc ,_cbeaf :=GetDict (_ecf .Get (0));_cbeaf {_fgga =_dgbc ;};};};if _fgga ==nil {_egd .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gfde );return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_fec :=_bfb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _fec !=nil {_bagc ,_caf :=_fec .(*PdfObjectInteger );if !_caf {_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_fec );return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_bagc !=0&&*_bagc !=1{return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_bdcb .EarlyChange =int (*_bagc );}else {_bdcb .EarlyChange =1;};if _fgga ==nil {return _bdcb ,nil ;};_fec =_fgga .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _fec !=nil {_ddfc ,_fadf :=_fec .(*PdfObjectInteger );if !_fadf {_egd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_fec );return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bdcb .Predictor =int (*_ddfc );};_fec =_fgga .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _fec !=nil {_bfcf ,_bacc :=_fec .(*PdfObjectInteger );if !_bacc {_egd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_gb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bdcb .BitsPerComponent =int (*_bfcf );};if _bdcb .Predictor > 1{_bdcb .Columns =1;_fec =_fgga .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _fec !=nil {_cgc ,_fefc :=_fec .(*PdfObjectInteger );if !_fefc {return nil ,_gb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bdcb .Columns =int (*_cgc );};_bdcb .Colors =1;_fec =_fgga .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _fec !=nil {_bggb ,_dagdb :=_fec .(*PdfObjectInteger );if !_dagdb {return nil ,_gb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_bdcb .Colors =int (*_bggb );};};_egd .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_fgga .String ());return _bdcb ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_fed *PdfObjectArray )Elements ()[]PdfObject {if _fed ==nil {return nil ;};return _fed ._afda ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_eeef *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _bde _eg .Buffer ;for _fgbgd :=0;_fgbgd < len (data );_fgbgd +=4{_gfe :=data [_fgbgd ];_acad :=1;_gbdf :=byte (0);if _fgbgd +1< len (data ){_gbdf =data [_fgbgd +1];_acad ++;};_aaae :=byte (0);if _fgbgd +2< len (data ){_aaae =data [_fgbgd +2];_acad ++;};_dgdd :=byte (0);if _fgbgd +3< len (data ){_dgdd =data [_fgbgd +3];_acad ++;};_ecfc :=(uint32 (_gfe )<<24)|(uint32 (_gbdf )<<16)|(uint32 (_aaae )<<8)|uint32 (_dgdd );if _ecfc ==0{_bde .WriteByte ('z');}else {_ebdd :=_eeef .base256Tobase85 (_ecfc );for _ ,_ced :=range _ebdd [:_acad +1]{_bde .WriteByte (_ced +'!');};};};_bde .WriteString ("\u007e\u003e");return _bde .Bytes (),nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _fggec (obj ,0)};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func (_cfce *PdfParser )skipComments ()error {if _ ,_fadfb :=_cfce .skipSpaces ();_fadfb !=nil {return _fadfb ;};_ccggd :=true ;for {_dgff ,_fcba :=_cfce ._degc .Peek (1);if _fcba !=nil {_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fcba .Error ());return _fcba ;};if _ccggd &&_dgff [0]!='%'{return nil ;};_ccggd =false ;if (_dgff [0]!='\r')&&(_dgff [0]!='\n'){_cfce ._degc .ReadByte ();}else {break ;};};return _cfce .skipComments ();};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_fcad float64 ,_acgaf bool ){_cbbaf ,_acgaf :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _acgaf {return float64 (*_cbbaf ),true ;};return 0,false ;};

// SetImage sets the image base for given flate encoder.
func (_bge *FlateEncoder )SetImage (img *_ecc .ImageBase ){_bge ._gda =img };

// String returns a string describing `null`.
func (_efcb *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func (_ebec *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _gbcbe =20;_dedc ,_ :=_ebec ._degc .Peek (_gbcbe );for _cfcff :=0;_cfcff < 2;_cfcff ++{if _ebec ._edeb ==0{_ebec ._edeb =_ebec .GetFileOffset ();};if _gcef .Match (_dedc ){_egd .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_egd .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dedc ));return _ebec .parseXrefStream (nil );};if _gcccc .Match (_dedc ){_egd .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _ebec .parseXrefTable ();};_fefgd :=_ebec .GetFileOffset ();if _ebec ._edeb ==0{_ebec ._edeb =_fefgd ;};_ebec .SetFileOffset (_fefgd -_gbcbe );defer _ebec .SetFileOffset (_fefgd );_fggag ,_ :=_ebec ._degc .Peek (_gbcbe );_dedc =append (_fggag ,_dedc ...);};_egd .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _degdb :=_ebec .repairSeekXrefMarker ();_degdb !=nil {_egd .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_degdb );return nil ,_degdb ;};return _ebec .parseXrefTable ();};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_dbbg *PdfObjectReference )Resolve ()PdfObject {if _dbbg ._fabe ==nil {return MakeNull ();};_edeaad ,_ ,_cdbe :=_dbbg ._fabe .resolveReference (_dbbg );if _cdbe !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_cdbe );return MakeNull ();};if _edeaad ==nil {_egd .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _edeaad ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_edfcc *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_fadd ,_bddd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bddd ==nil {_edfcc .BitsPerComponent =int (_fadd );};_fdfe ,_bddd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bddd ==nil {_edfcc .Width =int (_fdfe );};_bacd ,_bddd :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _bddd ==nil {_edfcc .Height =int (_bacd );};_egac ,_bddd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bddd ==nil {_edfcc .ColorComponents =int (_egac );};};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_abad *PdfParser )Inspect ()(map[string ]int ,error ){return _abad .inspect ()};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_ecda *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_defbf :=data ;var _ceee error ;for _ecdae :=len (_ecda ._eaca )-1;_ecdae >=0;_ecdae --{_bfec :=_ecda ._eaca [_ecdae ];_defbf ,_ceee =_bfec .EncodeBytes (_defbf );if _ceee !=nil {return nil ,_ceee ;};};return _defbf ,nil ;};var _gcccc =_g .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// UpdateParams updates the parameter values of the encoder.
func (_cfga *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_fadc ,_acd :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _acd ==nil {_cfga .Predictor =int (_fadc );};_gdaf ,_acd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _acd ==nil {_cfga .BitsPerComponent =int (_gdaf );};_gbba ,_acd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _acd ==nil {_cfga .Columns =int (_gbba );};_gcf ,_acd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _acd ==nil {_cfga .Colors =int (_gcf );};};func (_efg *PdfCrypt )loadCryptFilters (_cbea *PdfObjectDictionary )error {_efg ._bfce =cryptFilters {};_fcd :=_cbea .Get ("\u0043\u0046");_fcd =TraceToDirectObject (_fcd );if _dda ,_feg :=_fcd .(*PdfObjectReference );_feg {_cag ,_gdce :=_efg ._gdg .LookupByReference (*_dda );if _gdce !=nil {_egd .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _gdce ;};_fcd =TraceToDirectObject (_cag );};_dgb ,_aga :=_fcd .(*PdfObjectDictionary );if !_aga {_egd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_fcd );return _b .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_ggc :=range _dgb .Keys (){_ada :=_dgb .Get (_ggc );if _ffg ,_ebg :=_ada .(*PdfObjectReference );_ebg {_ggb ,_bce :=_efg ._gdg .LookupByReference (*_ffg );if _bce !=nil {_egd .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _bce ;};_ada =TraceToDirectObject (_ggb );};_fga ,_ebcf :=_ada .(*PdfObjectDictionary );if !_ebcf {return _gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_ggc ,_ada );};if _ggc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _ebcff _gc .FilterDict ;if _eac :=_eed (&_ebcff ,_fga );_eac !=nil {return _eac ;};_dagd ,_bb :=_gc .NewFilter (_ebcff );if _bb !=nil {return _bb ;};_efg ._bfce [string (_ggc )]=_dagd ;};_efg ._bfce ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_gc .NewIdentity ();_efg ._bfd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eag ,_eec :=_cbea .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_eec {if _ ,_dfd :=_efg ._bfce [string (*_eag )];!_dfd {return _gb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_eag );};_efg ._bfd =string (*_eag );};_efg ._bda ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bba ,_fdeb :=_cbea .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_fdeb {if _ ,_cad :=_efg ._bfce [string (*_bba )];!_cad {return _gb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_bba );};_efg ._bda =string (*_bba );};return nil ;};const _gbga ="\u0053\u0074\u0064C\u0046";func _eefb ()string {return _egd .Version };const _fdce =10;

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};func _accc (_dbce *PdfObjectStream ,_ebba *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_ffdb :=NewCCITTFaxEncoder ();_daa :=_dbce .PdfObjectDictionary ;if _daa ==nil {return _ffdb ,nil ;};if _ebba ==nil {_geffb :=TraceToDirectObject (_daa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _geffb !=nil {switch _dafa :=_geffb .(type ){case *PdfObjectDictionary :_ebba =_dafa ;case *PdfObjectArray :if _dafa .Len ()==1{if _efde ,_dacf :=GetDict (_dafa .Get (0));_dacf {_ebba =_efde ;};};default:_egd .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_geffb );return nil ,_b .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _ebba ==nil {_egd .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_geffb );return nil ,_b .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _fgee ,_afd :=GetNumberAsInt64 (_ebba .Get ("\u004b"));_afd ==nil {_ffdb .K =int (_fgee );};if _ggba ,_ceec :=GetNumberAsInt64 (_ebba .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_ceec ==nil {_ffdb .Columns =int (_ggba );}else {_ffdb .Columns =1728;};if _gacfd ,_acdf :=GetNumberAsInt64 (_ebba .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_acdf ==nil {_ffdb .BlackIs1 =_gacfd > 0;}else {if _afe ,_efee :=GetBoolVal (_ebba .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_efee {_ffdb .BlackIs1 =_afe ;}else {if _ggbg ,_dbaaa :=GetArray (_ebba .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_dbaaa {_gcbc ,_begf :=_ggbg .ToIntegerArray ();if _begf ==nil {_ffdb .BlackIs1 =_gcbc [0]==1&&_gcbc [1]==0;};};};};if _aff ,_aaca :=GetNumberAsInt64 (_ebba .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_aaca ==nil {_ffdb .EncodedByteAlign =_aff > 0;}else {if _ecfe ,_caac :=GetBoolVal (_ebba .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_caac {_ffdb .EncodedByteAlign =_ecfe ;};};if _ddac ,_eagcf :=GetNumberAsInt64 (_ebba .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_eagcf ==nil {_ffdb .EndOfLine =_ddac > 0;}else {if _cddgd ,_dbfdc :=GetBoolVal (_ebba .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dbfdc {_ffdb .EndOfLine =_cddgd ;};};if _fggd ,_gccc :=GetNumberAsInt64 (_ebba .Get ("\u0052\u006f\u0077\u0073"));_gccc ==nil {_ffdb .Rows =int (_fggd );};_ffdb .EndOfBlock =true ;if _fdc ,_edbc :=GetNumberAsInt64 (_ebba .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_edbc ==nil {_ffdb .EndOfBlock =_fdc > 0;}else {if _gced ,_dbeb :=GetBoolVal (_ebba .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dbeb {_ffdb .EndOfBlock =_gced ;};};if _fbbb ,_cdde :=GetNumberAsInt64 (_ebba .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_cdde !=nil {_ffdb .DamagedRowsBeforeError =int (_fbbb );};_egd .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_ebba .String ());return _ffdb ,nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_bfef *JBIG2Encoder )Encode ()(_beda []byte ,_fdad error ){const _efdf ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _bfef ._fbfa ==nil {return nil ,_egg .Errorf (_efdf ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_bfef ._fbfa .FullHeaders =_bfef .DefaultPageSettings .FileMode ;_beda ,_fdad =_bfef ._fbfa .Encode ();if _fdad !=nil {return nil ,_egg .Wrap (_fdad ,_efdf ,"");};return _beda ,nil ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func _bgab (_ccef *PdfObjectStream ,_dadb *PdfObjectDictionary )(*FlateEncoder ,error ){_egb :=NewFlateEncoder ();_bfca :=_ccef .PdfObjectDictionary ;if _bfca ==nil {return _egb ,nil ;};_egb ._gda =_aacec (_bfca );if _dadb ==nil {_bcga :=TraceToDirectObject (_bfca .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _cdfa :=_bcga .(type ){case *PdfObjectArray :if _cdfa .Len ()!=1{_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_cdfa .Len ());return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _gdf ,_cbeac :=GetDict (_cdfa .Get (0));_cbeac {_dadb =_gdf ;};case *PdfObjectDictionary :_dadb =_cdfa ;case *PdfObjectNull ,nil :default:_egd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_bcga );return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _dadb ==nil {return _egb ,nil ;};_egd .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dadb .String ());_aca :=_dadb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _aca ==nil {_egd .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_aafc ,_aefd :=_aca .(*PdfObjectInteger );if !_aefd {_egd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_aca );return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_egb .Predictor =int (*_aafc );};_aca =_dadb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _aca !=nil {_dgg ,_cgga :=_aca .(*PdfObjectInteger );if !_cgga {_egd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_gb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_egb .BitsPerComponent =int (*_dgg );};if _egb .Predictor > 1{_egb .Columns =1;_aca =_dadb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _aca !=nil {_bfaa ,_facc :=_aca .(*PdfObjectInteger );if !_facc {return nil ,_gb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_egb .Columns =int (*_bfaa );};_egb .Colors =1;_aca =_dadb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _aca !=nil {_bcf ,_ede :=_aca .(*PdfObjectInteger );if !_ede {return nil ,_gb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_egb .Colors =int (*_bcf );};};return _egb ,nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_fbba :=&ASCII85Encoder {};return _fbba };

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_bbc *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_egd .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_egd .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_bbc .Predictor );_gbee ,_ebb :=_bbc .DecodeBytes (streamObj .Stream );if _ebb !=nil {return nil ,_ebb ;};_egd .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_egd .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_gbee ),_gbee );if _bbc .Predictor > 1{if _bbc .Predictor ==2{_egd .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ade :=_bbc .Columns *_bbc .Colors ;if _ade < 1{return []byte {},nil ;};_ddba :=len (_gbee )/_ade ;if len (_gbee )%_ade !=0{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gbee ),_ade );};if _ade %_bbc .Colors !=0{return nil ,_gb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ade ,_bbc .Colors );};if _ade > len (_gbee ){_egd .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ade ,len (_gbee ));return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_egd .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_gbee ),_gbee );_gdb :=_eg .NewBuffer (nil );for _bbcf :=0;_bbcf < _ddba ;_bbcf ++{_cbga :=_gbee [_ade *_bbcf :_ade *(_bbcf +1)];for _bgd :=_bbc .Colors ;_bgd < _ade ;_bgd ++{_cbga [_bgd ]=byte (int (_cbga [_bgd ]+_cbga [_bgd -_bbc .Colors ])%256);};_gdb .Write (_cbga );};_cddg :=_gdb .Bytes ();_egd .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_cddg ),_cddg );return _cddg ,nil ;}else if _bbc .Predictor >=10&&_bbc .Predictor <=15{_egd .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gceb :=_bbc .Columns *_bbc .Colors +1;if _gceb < 1{return []byte {},nil ;};_geab :=len (_gbee )/_gceb ;if len (_gbee )%_gceb !=0{return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gbee ),_gceb );};if _gceb > len (_gbee ){_egd .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gceb ,len (_gbee ));return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cdag :=_eg .NewBuffer (nil );_egd .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_bbc .Columns );_egd .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_gbee ),_gceb ,_geab );_faad :=make ([]byte ,_gceb );for _bdfb :=0;_bdfb < _gceb ;_bdfb ++{_faad [_bdfb ]=0;};for _ggbbg :=0;_ggbbg < _geab ;_ggbbg ++{_ebf :=_gbee [_gceb *_ggbbg :_gceb *(_ggbbg +1)];_cfad :=_ebf [0];switch _cfad {case 0:case 1:for _aae :=2;_aae < _gceb ;_aae ++{_ebf [_aae ]=byte (int (_ebf [_aae ]+_ebf [_aae -1])%256);};case 2:for _fgdd :=1;_fgdd < _gceb ;_fgdd ++{_ebf [_fgdd ]=byte (int (_ebf [_fgdd ]+_faad [_fgdd ])%256);};default:_egd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cfad );return nil ,_gb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cfad );};for _eege :=0;_eege < _gceb ;_eege ++{_faad [_eege ]=_ebf [_eege ];};_cdag .Write (_ebf [1:]);};_babb :=_cdag .Bytes ();return _babb ,nil ;}else {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_bbc .Predictor );return nil ,_gb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_bbc .Predictor );};};return _gbee ,nil ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_bcafg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _be .DecodeBytes (encoded ,_ec .Parameters {},_bcafg .Globals );};func _eda (_fbaa _dg .ReadSeeker ,_cgge int64 )(*offsetReader ,error ){_gdcd :=&offsetReader {_fgdg :_fbaa ,_acfg :_cgge };_ ,_abgeg :=_gdcd .Seek (0,_dg .SeekStart );return _gdcd ,_abgeg ;};var _gdff =_g .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");func (_fcb *PdfCrypt )saveCryptFilters (_ege *PdfObjectDictionary )error {if _fcb ._bcb .V < 4{return _b .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_gec :=MakeDict ();_ege .Set ("\u0043\u0046",_gec );for _ebe ,_aea :=range _fcb ._bfce {if _ebe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_ffc :=_agga (_aea ,"");_gec .Set (PdfObjectName (_ebe ),_ffc );};_ege .Set ("\u0053\u0074\u0072\u0046",MakeName (_fcb ._bfd ));_ege .Set ("\u0053\u0074\u006d\u0046",MakeName (_fcb ._bda ));return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cba *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func (_gbddd *PdfParser )repairLocateXref ()(int64 ,error ){_gffgf :=int64 (1000);_gbddd ._ecgc .Seek (-_gffgf ,_dg .SeekCurrent );_eceee ,_adec :=_gbddd ._ecgc .Seek (0,_dg .SeekCurrent );if _adec !=nil {return 0,_adec ;};_ddbd :=make ([]byte ,_gffgf );_gbddd ._ecgc .Read (_ddbd );_bead :=_gbcbf .FindAllStringIndex (string (_ddbd ),-1);if len (_bead )< 1{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_b .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_daeg :=int64 (_bead [len (_bead )-1][0]);_cddf :=_eceee +_daeg ;return _cddf ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// String returns a string describing `ind`.
func (_eaac *PdfIndirectObject )String ()string {return _gb .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_eaac ).ObjectNumber );};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_fdae Version ;_ecgc _dg .ReadSeeker ;_degc *_de .Reader ;_aacb int64 ;_cggf XrefTable ;_edeb int64 ;_bcdef *xrefType ;_bggfg objectStreams ;_fddc *PdfObjectDictionary ;_fccd *PdfCrypt ;_bfdf bool ;ObjCache objectCache ;_adfe map[int ]bool ;_dffa map[int64 ]bool ;};

// GetFilterName returns the name of the encoding filter.
func (_ffbe *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_fbfa :_cd .InitEncodeDocument (false )}};

// UpdateParams updates the parameter values of the encoder.
func (_fgac *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_fdcc :=range _fgac ._eaca {_fdcc .UpdateParams (params );};};

// WriteString outputs the object as it is to be written to file.
func (_aeba *PdfObjectBool )WriteString ()string {if *_aeba {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// UpdateParams updates the parameter values of the encoder.
func (_eacba *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};type offsetReader struct{_fgdg _dg .ReadSeeker ;_acfg int64 ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_dgdge *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _ebegf []float64 ;for _ ,_geccb :=range _dgdge .Elements (){switch _baccd :=_geccb .(type ){case *PdfObjectInteger :_ebegf =append (_ebegf ,float64 (*_baccd ));case *PdfObjectFloat :_ebegf =append (_ebegf ,float64 (*_baccd ));default:return nil ,ErrTypeError ;};};return _ebegf ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_fbfa *_cd .Document ;

// Globals are the JBIG2 global segments.
Globals _be .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_fffa *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_caa :=MakeDict ();_caa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fffa .GetFilterName ()));_bab :=_fffa .MakeDecodeParams ();if _bab !=nil {_caa .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bab );};_caa .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_fffa .EarlyChange )));return _caa ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_feec *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _feec .Predictor !=1{return nil ,_gb .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _feec .EarlyChange ==1{return nil ,_gb .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _ageg _eg .Buffer ;_ddfg :=_fc .NewWriter (&_ageg ,_fc .MSB ,8);_ddfg .Write (data );_ddfg .Close ();return _ageg .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_cefd *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_eeed *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eeed .DecodeBytes (streamObj .Stream );};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};func (_cfd *PdfParser )lookupByNumberWrapper (_beg int ,_aa bool )(PdfObject ,bool ,error ){_gbd ,_gcc ,_fg :=_cfd .lookupByNumber (_beg ,_aa );if _fg !=nil {return nil ,_gcc ,_fg ;};if !_gcc &&_cfd ._fccd !=nil &&!_cfd ._fccd .isDecrypted (_gbd ){_fef :=_cfd ._fccd .Decrypt (_gbd ,0,0);if _fef !=nil {return nil ,_gcc ,_fef ;};};return _gbd ,_gcc ,nil ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_egaa *PdfObjectName ,_daec bool ){_egaa ,_daec =TraceToDirectObject (obj ).(*PdfObjectName );return _egaa ,_daec ;};

// UpdateParams updates the parameter values of the encoder.
func (_acf *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _deca :=obj .(type ){case *PdfObjectFloat :_egd .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_deca ),nil ;case *PdfObjectInteger :return int64 (*_deca ),nil ;};return 0,ErrNotANumber ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// GetXrefTable returns the PDFs xref table.
func (_geef *PdfParser )GetXrefTable ()XrefTable {return _geef ._cggf };func (_egge *PdfParser )parsePdfVersion ()(int ,int ,error ){var _daed int64 =20;_daee :=make ([]byte ,_daed );_egge ._ecgc .Seek (0,_dg .SeekStart );_egge ._ecgc .Read (_daee );var _fdfdg error ;var _ffgdb ,_efac int ;if _dbac :=_ffga .FindStringSubmatch (string (_daee ));len (_dbac )< 3{if _ffgdb ,_efac ,_fdfdg =_egge .seekPdfVersionTopDown ();_fdfdg !=nil {_egd .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_fdfdg ;};_egge ._ecgc ,_fdfdg =_eda (_egge ._ecgc ,_egge .GetFileOffset ()-8);if _fdfdg !=nil {return 0,0,_fdfdg ;};}else {if _ffgdb ,_fdfdg =_bf .Atoi (_dbac [1]);_fdfdg !=nil {return 0,0,_fdfdg ;};if _efac ,_fdfdg =_bf .Atoi (_dbac [2]);_fdfdg !=nil {return 0,0,_fdfdg ;};_egge .SetFileOffset (0);};_egge ._degc =_de .NewReader (_egge ._ecgc );_egd .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_ffgdb ,_efac );return _ffgdb ,_efac ,nil ;};var _eacb =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_c .Model ;Bounds ()_dc .Rectangle ;At (_dbdb ,_afb int )_c .Color ;Set (_ecee ,_fegc int ,_gacg _c .Color );};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_fabe *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};func (_cge *PdfCrypt )makeKey (_bbf string ,_fccc ,_cac uint32 ,_dgd []byte )([]byte ,error ){_bee ,_gagg :=_cge ._bfce [_bbf ];if !_gagg {return nil ,_gb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bbf );};return _bee .MakeKey (_fccc ,_cac ,_dgd );};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_edb :=&PdfCrypt {_eaf :false ,_bad :make (map[PdfObject ]bool ),_bec :make (map[PdfObject ]bool ),_gag :make (map[int ]struct{}),_gdg :parser };_gdcg ,_afg :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_afg {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _edb ,_b .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gdcg !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_egd .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gdcg );return _edb ,_b .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_edb ._bcb .Filter =string (*_gdcg );if _aag ,_gbe :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_gbe {_edb ._bcb .SubFilter =_aag .Str ();_egd .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_aag );};if L ,_edcc :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_edcc {if (*L %8)!=0{_egd .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _edb ,_b .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_edb ._bcb .Length =int (*L );}else {_edb ._bcb .Length =40;};_edb ._bcb .V =0;if _age ,_efge :=ed .Get ("\u0056").(*PdfObjectInteger );_efge {V :=int (*_age );_edb ._bcb .V =V ;if V >=1&&V <=2{_edb ._bfce =_dagb (_edb ._bcb .Length );}else if V >=4&&V <=5{if _fabg :=_edb .loadCryptFilters (ed );_fabg !=nil {return _edb ,_fabg ;};}else {_egd .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _edb ,_b .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _agb :=_eca (&_edb ._adg ,ed );_agb !=nil {return _edb ,_agb ;};_badb :="";if _agca ,_gdca :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_gdca &&_agca .Len ()>=1{_eff ,_ccf :=GetString (_agca .Get (0));if !_ccf {return _edb ,_b .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_badb =_eff .Str ();}else {_egd .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_edb ._cdfd =_badb ;return _edb ,nil ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_dcegb *PdfObjectString ,_dgcf bool ){_dcegb ,_dgcf =TraceToDirectObject (obj ).(*PdfObjectString );return _dcegb ,_dgcf ;};func (_ebfa *PdfParser )rebuildXrefTable ()error {_bfdc :=XrefTable {};_bfdc .ObjectMap =map[int ]XrefObject {};_bcdec :=make ([]int ,0,len (_ebfa ._cggf .ObjectMap ));for _dede :=range _ebfa ._cggf .ObjectMap {_bcdec =append (_bcdec ,_dede );};_ed .Ints (_bcdec );for _ ,_aaff :=range _bcdec {_gccab :=_ebfa ._cggf .ObjectMap [_aaff ];_efbd ,_ ,_acfce :=_ebfa .lookupByNumberWrapper (_aaff ,false );if _acfce !=nil {_egd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_acfce );_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_ecde ,_face :=_ebfa .repairRebuildXrefsTopDown ();if _face !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_face );return _face ;};_ebfa ._cggf =*_ecde ;_egd .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_aegff ,_bffg ,_acfce :=_dde (_efbd );if _acfce !=nil {return _acfce ;};_gccab .ObjectNumber =int (_aegff );_gccab .Generation =int (_bffg );_bfdc .ObjectMap [int (_aegff )]=_gccab ;};_ebfa ._cggf =_bfdc ;_egd .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_fdd (_ebfa ._cggf );return nil ;};func (_gaf *PdfParser )parseHexString ()(*PdfObjectString ,error ){_gaf ._degc .ReadByte ();var _gebe _eg .Buffer ;for {_bcce ,_cgaf :=_gaf ._degc .Peek (1);if _cgaf !=nil {return MakeString (""),_cgaf ;};if _bcce [0]=='>'{_gaf ._degc .ReadByte ();break ;};_daag ,_ :=_gaf ._degc .ReadByte ();if !IsWhiteSpace (_daag ){_gebe .WriteByte (_daag );};};if _gebe .Len ()%2==1{_gebe .WriteRune ('0');};_afab ,_ :=_gg .DecodeString (_gebe .String ());return MakeHexString (string (_afab )),nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_ceg *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_faa ,_ga :=obj .(*PdfObjectReference );if !_ga {return obj ,nil ;};_aee :=_ceg .GetFileOffset ();defer func (){_ceg .SetFileOffset (_aee )}();_bd ,_adbe :=_ceg .LookupByReference (*_faa );if _adbe !=nil {return nil ,_adbe ;};_fgg ,_bac :=_bd .(*PdfIndirectObject );if !_bac {return _bd ,nil ;};_bd =_fgg .PdfObject ;_ ,_ga =_bd .(*PdfObjectReference );if _ga {return _fgg ,_b .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _bd ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_efbb *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };func _bbbc (_dgag ,_gecgd PdfObject ,_affc int )bool {if _affc > _fdce {_egd .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_fdce );return false ;};if _dgag ==nil &&_gecgd ==nil {return true ;}else if _dgag ==nil ||_gecgd ==nil {return false ;};if _f .TypeOf (_dgag )!=_f .TypeOf (_gecgd ){return false ;};switch _ecbe :=_dgag .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_ecbe ==*(_gecgd .(*PdfObjectName ));case *PdfObjectString :return *_ecbe ==*(_gecgd .(*PdfObjectString ));case *PdfObjectInteger :return *_ecbe ==*(_gecgd .(*PdfObjectInteger ));case *PdfObjectBool :return *_ecbe ==*(_gecgd .(*PdfObjectBool ));case *PdfObjectFloat :return *_ecbe ==*(_gecgd .(*PdfObjectFloat ));case *PdfIndirectObject :return _bbbc (TraceToDirectObject (_dgag ),TraceToDirectObject (_gecgd ),_affc +1);case *PdfObjectArray :_bbdg :=_gecgd .(*PdfObjectArray );if len ((*_ecbe )._afda )!=len ((*_bbdg )._afda ){return false ;};for _gfefe ,_faec :=range (*_ecbe )._afda {if !_bbbc (_faec ,(*_bbdg )._afda [_gfefe ],_affc +1){return false ;};};return true ;case *PdfObjectDictionary :_bcba :=_gecgd .(*PdfObjectDictionary );_dedg ,_aacef :=(*_ecbe )._ffeb ,(*_bcba )._ffeb ;if len (_dedg )!=len (_aacef ){return false ;};for _acbef ,_ceccg :=range _dedg {_bbdb ,_bdebg :=_aacef [_acbef ];if !_bdebg ||!_bbbc (_ceccg ,_bbdb ,_affc +1){return false ;};};return true ;case *PdfObjectStream :_fbgc :=_gecgd .(*PdfObjectStream );return _bbbc ((*_ecbe ).PdfObjectDictionary ,(*_fbgc ).PdfObjectDictionary ,_affc +1);default:_egd .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_dgag );};return false ;};func (_dfce *PdfParser )inspect ()(map[string ]int ,error ){_egd .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_egd .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_ggaeg :=map[string ]int {};_feabc :=0;_fgab :=0;var _fadee []int ;for _aaedg :=range _dfce ._cggf .ObjectMap {_fadee =append (_fadee ,_aaedg );};_ed .Ints (_fadee );_dgbdg :=0;for _ ,_cgbf :=range _fadee {_gfcc :=_dfce ._cggf .ObjectMap [_cgbf ];if _gfcc .ObjectNumber ==0{continue ;};_feabc ++;_egd .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_egd .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_gfcc .ObjectNumber );_gdge ,_ggfa :=_dfce .LookupByNumber (_gfcc .ObjectNumber );if _ggfa !=nil {_egd .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_gfcc .ObjectNumber ,_ggfa );_fgab ++;continue ;};_egd .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_gdge );_gdfd ,_gafcd :=_gdge .(*PdfIndirectObject );if _gafcd {_egd .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_gfcc .ObjectNumber ,_gdfd );_aggc ,_faaa :=_gdfd .PdfObject .(*PdfObjectDictionary );if _faaa {if _gddd ,_aaebb :=_aggc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_aaebb {_cffd :=string (*_gddd );_egd .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_cffd );_ ,_cfgcc :=_ggaeg [_cffd ];if _cfgcc {_ggaeg [_cffd ]++;}else {_ggaeg [_cffd ]=1;};}else if _aagd ,_bgfcb :=_aggc .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_bgfcb {_ecfec :=string (*_aagd );_egd .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_ecfec );_ ,_gebd :=_ggaeg [_ecfec ];if _gebd {_ggaeg [_ecfec ]++;}else {_ggaeg [_ecfec ]=1;};};if _edff ,_fgge :=_aggc .Get ("\u0053").(*PdfObjectName );_fgge &&*_edff =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_cagc :=_ggaeg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _cagc {_ggaeg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_ggaeg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _bgbb ,_gace :=_gdge .(*PdfObjectStream );_gace {if _dgge ,_ffffb :=_bgbb .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ffffb {_egd .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_dgge );_efdfc :=string (*_dgge );_ggaeg [_efdfc ]++;};}else {_bceaaa ,_efffb :=_gdge .(*PdfObjectDictionary );if _efffb {_bgfbg ,_dfea :=_bceaaa .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _dfea {_gdbf :=string (*_bgfbg );_egd .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_gdbf );_ggaeg [_gdbf ]++;};};_egd .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_gfcc .ObjectNumber ,_gdge );};_dgbdg ++;};_egd .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_egd .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_egd .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_feabc );_egd .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_fgab );for _cfdd ,_bedb :=range _ggaeg {_egd .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_cfdd ,_bedb );};_egd .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_dfce ._cggf .ObjectMap )< 1{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_gb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_fcfe ,_fbeacc :=_ggaeg ["\u0046\u006f\u006e\u0074"];if !_fbeacc ||_fcfe < 2{_egd .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_egd .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _ggaeg ,nil ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_bdfa :=&PdfObjectDictionary {};_bdfa ._ffeb =map[PdfObjectName ]PdfObject {};_bdfa ._cecc =[]PdfObjectName {};return _bdfa ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_edag *PdfParser )GetTrailer ()*PdfObjectDictionary {return _edag ._fddc };func (_gddbe *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ffag :=_gddbe ._degc .Discard (4);return PdfObjectNull {},_ffag ;};func (_acb *ASCII85Encoder )base256Tobase85 (_ddae uint32 )[5]byte {_effcb :=[5]byte {0,0,0,0,0};_faf :=_ddae ;for _gacf :=0;_gacf < 5;_gacf ++{_ccga :=uint32 (1);for _dab :=0;_dab < 4-_gacf ;_dab ++{_ccga *=85;};_cbd :=_faf /_ccga ;_faf =_faf %_ccga ;_effcb [_gacf ]=byte (_cbd );};return _effcb ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_fefaa :=TraceToDirectObject (obj ).(*PdfObjectNull );return _fefaa ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_cdb *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ecff _eg .Buffer ;_gdfb :=_eg .NewReader (encoded );var _eefd _dg .ReadCloser ;if _cdb .EarlyChange ==1{_eefd =_dd .NewReader (_gdfb ,_dd .MSB ,8);}else {_eefd =_fc .NewReader (_gdfb ,_fc .MSB ,8);};defer _eefd .Close ();_ ,_dgca :=_ecff .ReadFrom (_eefd );if _dgca !=nil {return nil ,_dgca ;};return _ecff .Bytes (),nil ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_feaa *PdfObjectString )Bytes ()[]byte {return []byte (_feaa ._cdfb )};func (_bced *FlateEncoder )postDecodePredict (_fgbg []byte )([]byte ,error ){if _bced .Predictor > 1{if _bced .Predictor ==2{_egd .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_egd .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_bced .Colors );_cdgc :=_bced .Columns *_bced .Colors ;if _cdgc < 1{return []byte {},nil ;};_bca :=len (_fgbg )/_cdgc ;if len (_fgbg )%_cdgc !=0{_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fgbg ),_cdgc );};if _cdgc %_bced .Colors !=0{return nil ,_gb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_cdgc ,_bced .Colors );};if _cdgc > len (_fgbg ){_egd .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cdgc ,len (_fgbg ));return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_egd .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fgbg ),_fgbg );_ddaa :=_eg .NewBuffer (nil );for _beae :=0;_beae < _bca ;_beae ++{_cca :=_fgbg [_cdgc *_beae :_cdgc *(_beae +1)];for _cbg :=_bced .Colors ;_cbg < _cdgc ;_cbg ++{_cca [_cbg ]+=_cca [_cbg -_bced .Colors ];};_ddaa .Write (_cca );};_bdb :=_ddaa .Bytes ();_egd .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bdb ),_bdb );return _bdb ,nil ;}else if _bced .Predictor >=10&&_bced .Predictor <=15{_egd .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_dggb :=_bced .Columns *_bced .Colors +1;_gcfc :=len (_fgbg )/_dggb ;if len (_fgbg )%_dggb !=0{return nil ,_gb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fgbg ),_dggb );};if _dggb > len (_fgbg ){_egd .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dggb ,len (_fgbg ));return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fabgf :=_eg .NewBuffer (nil );_egd .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_bced .Columns );_egd .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fgbg ),_dggb ,_gcfc );_ffgc :=make ([]byte ,_dggb );for _effd :=0;_effd < _dggb ;_effd ++{_ffgc [_effd ]=0;};_geg :=_bced .Colors ;for _gcb :=0;_gcb < _gcfc ;_gcb ++{_dadd :=_fgbg [_dggb *_gcb :_dggb *(_gcb +1)];_efga :=_dadd [0];switch _efga {case _dgbb :case _defb :for _fgbf :=1+_geg ;_fgbf < _dggb ;_fgbf ++{_dadd [_fgbf ]+=_dadd [_fgbf -_geg ];};case _befd :for _gddb :=1;_gddb < _dggb ;_gddb ++{_dadd [_gddb ]+=_ffgc [_gddb ];};case _fabf :for _dfa :=1;_dfa < _geg +1;_dfa ++{_dadd [_dfa ]+=_ffgc [_dfa ]/2;};for _gbcd :=_geg +1;_gbcd < _dggb ;_gbcd ++{_dadd [_gbcd ]+=byte ((int (_dadd [_gbcd -_geg ])+int (_ffgc [_gbcd ]))/2);};case _cff :for _cfe :=1;_cfe < _dggb ;_cfe ++{var _gede ,_baf ,_beaa byte ;_baf =_ffgc [_cfe ];if _cfe >=_geg +1{_gede =_dadd [_cfe -_geg ];_beaa =_ffgc [_cfe -_geg ];};_dadd [_cfe ]+=_bdeb (_gede ,_baf ,_beaa );};default:_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_efga ,_gcb );return nil ,_gb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_efga );};copy (_ffgc ,_dadd );_fabgf .Write (_dadd [1:]);};_decdf :=_fabgf .Bytes ();return _decdf ,nil ;}else {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_bced .Predictor );return nil ,_gb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_bced .Predictor );};};return _fgbg ,nil ;};func (_cafc *PdfParser )traceStreamLength (_bbef PdfObject )(PdfObject ,error ){_agge ,_ccgfd :=_bbef .(*PdfObjectReference );if _ccgfd {_aafe ,_cgbb :=_cafc ._dffa [_agge .ObjectNumber ];if _cgbb &&_aafe {_egd .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_b .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_cafc ._dffa [_agge .ObjectNumber ]=true ;};_acaae ,_gcca :=_cafc .Resolve (_bbef );if _gcca !=nil {return nil ,_gcca ;};_egd .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_acaae );if _ccgfd {_cafc ._dffa [_agge .ObjectNumber ]=false ;};return _acaae ,nil ;};func _dagb (_edf int )cryptFilters {return cryptFilters {_gbga :_gc .NewFilterV2 (_edf )}};func _eebfd (_ecdd int )int {if _ecdd < 0{return -_ecdd ;};return _ecdd ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func (_efabc *PdfObjectFloat )String ()string {return _gb .Sprintf ("\u0025\u0066",*_efabc )};func _cafbc (_dgbe string )(PdfObjectReference ,error ){_aebc :=PdfObjectReference {};_baeg :=_cbf .FindStringSubmatch (_dgbe );if len (_baeg )< 3{_egd .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _aebc ,_b .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_ddbeg ,_ :=_bf .Atoi (_baeg [1]);_egec ,_ :=_bf .Atoi (_baeg [2]);_aebc .ObjectNumber =int64 (_ddbeg );_aebc .GenerationNumber =int64 (_egec );return _aebc ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_aadbg *PdfObjectString )WriteString ()string {var _aedc _eg .Buffer ;if _aadbg ._bfae {_daca :=_gg .EncodeToString (_aadbg .Bytes ());_aedc .WriteString ("\u003c");_aedc .WriteString (_daca );_aedc .WriteString ("\u003e");return _aedc .String ();};_cabbg :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_aedc .WriteString ("\u0028");for _egfcd :=0;_egfcd < len (_aadbg ._cdfb );_egfcd ++{_dbadd :=_aadbg ._cdfb [_egfcd ];if _fabc ,_dbacf :=_cabbg [_dbadd ];_dbacf {_aedc .WriteString (_fabc );}else {_aedc .WriteByte (_dbadd );};};_aedc .WriteString ("\u0029");return _aedc .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_cgee *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_efffe *PdfParser )GetObjectNums ()[]int {var _bafb []int ;for _ ,_gbff :=range _efffe ._cggf .ObjectMap {_bafb =append (_bafb ,_gbff .ObjectNumber );};_ed .Ints (_bafb );return _bafb ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_abea []PdfObject ;};

// String returns a string representation of the *PdfObjectString.
func (_gfefg *PdfObjectString )String ()string {return _gfefg ._cdfb };

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};type cryptFilters map[string ]_gc .Filter ;

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_ggaa *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ggaa .DecodeBytes (streamObj .Stream );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cggd *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_abef :=MakeDict ();_abef .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cggd .GetFilterName ()));return _abef ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_efgf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func _bece (_gdc *_bc .StdEncryptDict ,_begg *PdfObjectDictionary ){_begg .Set ("\u0052",MakeInteger (int64 (_gdc .R )));_begg .Set ("\u0050",MakeInteger (int64 (_gdc .P )));_begg .Set ("\u004f",MakeStringFromBytes (_gdc .O ));_begg .Set ("\u0055",MakeStringFromBytes (_gdc .U ));if _gdc .R >=5{_begg .Set ("\u004f\u0045",MakeStringFromBytes (_gdc .OE ));_begg .Set ("\u0055\u0045",MakeStringFromBytes (_gdc .UE ));_begg .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_gdc .EncryptMetadata ));if _gdc .R > 5{_begg .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_gdc .Perms ));};};};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_ccggf *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_egd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ccggf .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_cgcf *PdfObjectStreams )Elements ()[]PdfObject {if _cgcf ==nil {return nil ;};return _cgcf ._abea ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ebbd *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};var _abffd =_g .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// LookupByReference looks up a PdfObject by a reference.
func (_dad *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_egd .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _dad .LookupByNumber (int (ref .ObjectNumber ));};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_cecg bool ,_fcdeb bool ){_bdafa ,_fcdeb :=TraceToDirectObject (obj ).(*PdfObjectBool );if _fcdeb {return bool (*_bdafa ),true ;};return false ,false ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};func (_gfc *PdfCrypt )isDecrypted (_afc PdfObject )bool {_ ,_dacb :=_gfc ._bad [_afc ];if _dacb {_egd .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _acg :=_afc .(type ){case *PdfObjectStream :if _gfc ._adg .R !=5{if _adag ,_eafg :=_acg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eafg &&*_adag =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_dacb =_gfc ._gag [int (_acg .ObjectNumber )];_dacb {return true ;};switch _cdac :=_acg .PdfObject .(type ){case *PdfObjectDictionary :_fcbf :=true ;for _ ,_eccc :=range _eacb {if _cdac .Get (_eccc )==nil {_fcbf =false ;break ;};};if _fcbf {return true ;};};};_egd .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_bfa *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cdc :=MakeDict ();_cdc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_cdc .Set ("\u0056",MakeInteger (int64 (_bfa ._bcb .V )));_cdc .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bfa ._bcb .Length )));return _cdc ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_bceb *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_gee :=_bceb .GetFileOffset ();_ ,_fcfa :=_bceb ._ecgc .Seek (offset ,_dg .SeekStart );if _fcfa !=nil {return nil ,_fcfa ;};_cafb :=make ([]byte ,len );_ ,_fcfa =_dg .ReadAtLeast (_bceb ._ecgc ,_cafb ,int (len ));if _fcfa !=nil {return nil ,_fcfa ;};_bceb .SetFileOffset (_gee );return _cafb ,nil ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_gada :=&LZWEncoder {};_gada .Predictor =1;_gada .BitsPerComponent =8;_gada .Colors =1;_gada .Columns =1;_gada .EarlyChange =1;return _gada ;};func (_efa *PdfParser )lookupByNumber (_aad int ,_eef bool )(PdfObject ,bool ,error ){_edc ,_gba :=_efa .ObjCache [_aad ];if _gba {_egd .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_aad );return _edc ,false ,nil ;};if _efa ._adfe ==nil {_efa ._adfe =map[int ]bool {};};if _efa ._adfe [_aad ]{_egd .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_aad );return nil ,false ,_b .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_efa ._adfe [_aad ]=true ;defer delete (_efa ._adfe ,_aad );_cdg ,_gba :=_efa ._cggf .ObjectMap [_aad ];if !_gba {_egd .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _fd PdfObjectNull ;return &_fd ,false ,nil ;};_egd .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_aad );if _cdg .XType ==XrefTypeTableEntry {_egd .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_cdg .ObjectNumber );_egd .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_cdg .Generation );_egd .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_cdg .Offset );_efa ._ecgc .Seek (_cdg .Offset ,_dg .SeekStart );_efa ._degc =_de .NewReader (_efa ._ecgc );_egc ,_cg :=_efa .ParseIndirectObject ();if _cg !=nil {_egd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_cg );if _eef {_egd .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_ab ,_dec :=_efa .repairRebuildXrefsTopDown ();if _dec !=nil {_egd .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_dec );return nil ,false ,_dec ;};_efa ._cggf =*_ab ;return _efa .lookupByNumber (_aad ,false );};return nil ,false ,_cg ;};if _eef {_bgb ,_ ,_ :=_dde (_egc );if int (_bgb )!=_aad {_egd .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_db :=_efa .rebuildXrefTable ();if _db !=nil {return nil ,false ,_db ;};_efa .ObjCache =objectCache {};return _efa .lookupByNumberWrapper (_aad ,false );};};_egd .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_efa .ObjCache [_aad ]=_egc ;return _egc ,false ,nil ;}else if _cdg .XType ==XrefTypeObjectStream {_egd .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_egd .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_egd .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_cdg .OsObjNumber ,_cdg .OsObjIndex );if _cdg .OsObjNumber ==_aad {_egd .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_b .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_aaf :=_efa ._cggf .ObjectMap [_cdg .OsObjNumber ];_aaf {_ebc ,_cfg :=_efa .lookupObjectViaOS (_cdg .OsObjNumber ,_aad );if _cfg !=nil {_egd .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_cfg );return nil ,true ,_cfg ;};_egd .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_efa .ObjCache [_aad ]=_ebc ;if _efa ._fccd !=nil {_efa ._fccd ._bad [_ebc ]=true ;};return _ebc ,true ,nil ;};_egd .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_b .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_b .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// DecodeStream implements ASCII85 stream decoding.
func (_dbag *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dbag .DecodeBytes (streamObj .Stream );};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_aaeb []float64 ,_bgga error ){for _ ,_gfeb :=range objects {_cbffa ,_ddec :=GetNumberAsFloat (_gfeb );if _ddec !=nil {return nil ,_ddec ;};_aaeb =append (_aaeb ,_cbffa );};return _aaeb ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_bdfgb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_beaga :=MakeDict ();_beaga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bdfgb .GetFilterName ()));return _beaga ;};