//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_cf "bufio";_gc "bytes";_gd "compress/lzw";_b "compress/zlib";_ga "crypto/md5";_gag "crypto/rand";_ed "encoding/hex";_g "errors";_bb "fmt";_gcg "github.com/unidoc/unipdf/v3/common";_ab "github.com/unidoc/unipdf/v3/core/security";_ggd "github.com/unidoc/unipdf/v3/core/security/crypt";_gg "github.com/unidoc/unipdf/v3/internal/ccittfax";_ef "github.com/unidoc/unipdf/v3/internal/imageutil";_ge "github.com/unidoc/unipdf/v3/internal/jbig2";_fe "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_cg "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_d "github.com/unidoc/unipdf/v3/internal/jbig2/document";_af "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_cfd "github.com/unidoc/unipdf/v3/internal/strutils";_ag "golang.org/x/image/tiff/lzw";_bc "golang.org/x/xerrors";_fg "image";_gf "image/color";_e "image/jpeg";_fb "io";_c "reflect";_gb "regexp";_ccd "sort";_cc "strconv";_fga "strings";_a "time";);

// String returns a string describing `ref`.
func (_ebde *PdfObjectReference )String ()string {return _bb .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_ebde .ObjectNumber ,_ebde .GenerationNumber );};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_eadff *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _fcfa _gc .Buffer ;for _ ,_abccg :=range data {_fcfa .WriteString (_bb .Sprintf ("\u0025\u002e\u0032X\u0020",_abccg ));};_fcfa .WriteByte ('>');return _fcfa .Bytes (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbgg *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_abba :=MakeDict ();_abba .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_bbgg .GetFilterArray ());for _ ,_eaacg :=range _bbgg ._ceda {_ebbca :=_eaacg .MakeStreamDict ();for _ ,_adge :=range _ebbca .Keys (){_aaffb :=_ebbca .Get (_adge );if _adge !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_adge !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_abba .Set (_adge ,_aaffb );};};};_badf :=_bbgg .MakeDecodeParams ();if _badf !=nil {_abba .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_badf );};return _abba ;};var _bcge =_gb .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_fcaa *PdfCrypt )GetAccessPermissions ()_ab .Permissions {return _fcaa ._bgc .P };

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_dddf *PdfObjectArray )Get (i int )PdfObject {if _dddf ==nil ||i >=len (_dddf ._fggb )||i < 0{return nil ;};return _dddf ._fggb [i ];};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_aabce :=MakeArray ();for _ ,_dbbab :=range vals {_aabce .Append (MakeInteger (_dbbab ));};return _aabce ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_ddcg *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ecbf :=_gc .NewReader (encoded );var _fbbc []byte ;for {_cce ,_ccde :=_ecbf .ReadByte ();if _ccde !=nil {return nil ,_ccde ;};if _cce > 128{_adca ,_eff :=_ecbf .ReadByte ();if _eff !=nil {return nil ,_eff ;};for _adee :=0;_adee < 257-int (_cce );_adee ++{_fbbc =append (_fbbc ,_adca );};}else if _cce < 128{for _bcbg :=0;_bcbg < int (_cce )+1;_bcbg ++{_ebdd ,_edfg :=_ecbf .ReadByte ();if _edfg !=nil {return nil ,_edfg ;};_fbbc =append (_fbbc ,_ebdd );};}else {break ;};};return _fbbc ,nil ;};func (_bbb *PdfCrypt )checkAccessRights (_fcff []byte )(bool ,_ab .Permissions ,error ){_eded :=_bbb .securityHandler ();_acga ,_bga ,_bde :=_eded .Authenticate (&_bbb ._bgc ,_fcff );if _bde !=nil {return false ,0,_bde ;}else if _bga ==0||len (_acga )==0{return false ,0,nil ;};return true ,_bga ,nil ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_gfdga *PdfObjectString )Str ()string {return _gfdga ._agfdc };func (_dabd *PdfParser )inspect ()(map[string ]int ,error ){_gcg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_gcg .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_eaccb :=map[string ]int {};_ddae :=0;_edee :=0;var _dgfc []int ;for _ggbc :=range _dabd ._ccbg .ObjectMap {_dgfc =append (_dgfc ,_ggbc );};_ccd .Ints (_dgfc );_dbf :=0;for _ ,_ggbd :=range _dgfc {_afag :=_dabd ._ccbg .ObjectMap [_ggbd ];if _afag .ObjectNumber ==0{continue ;};_ddae ++;_gcg .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_gcg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_afag .ObjectNumber );_ccfd ,_ebbe :=_dabd .LookupByNumber (_afag .ObjectNumber );if _ebbe !=nil {_gcg .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_afag .ObjectNumber ,_ebbe );_edee ++;continue ;};_gcg .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_ccfd );_eadba ,_gcbgf :=_ccfd .(*PdfIndirectObject );if _gcbgf {_gcg .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_afag .ObjectNumber ,_eadba );_eacbe ,_egba :=_eadba .PdfObject .(*PdfObjectDictionary );if _egba {if _gagcb ,_bbgf :=_eacbe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bbgf {_gdcb :=string (*_gagcb );_gcg .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_gdcb );_ ,_fafb :=_eaccb [_gdcb ];if _fafb {_eaccb [_gdcb ]++;}else {_eaccb [_gdcb ]=1;};}else if _ecba ,_ageee :=_eacbe .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_ageee {_dcag :=string (*_ecba );_gcg .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_dcag );_ ,_feaea :=_eaccb [_dcag ];if _feaea {_eaccb [_dcag ]++;}else {_eaccb [_dcag ]=1;};};if _gdbcc ,_aadbga :=_eacbe .Get ("\u0053").(*PdfObjectName );_aadbga &&*_gdbcc =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_ddga :=_eaccb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _ddga {_eaccb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_eaccb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _gdca ,_gfec :=_ccfd .(*PdfObjectStream );_gfec {if _gefbd ,_gfebdd :=_gdca .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gfebdd {_gcg .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_gefbd );_egdgf :=string (*_gefbd );_eaccb [_egdgf ]++;};}else {_bbdeda ,_cfega :=_ccfd .(*PdfObjectDictionary );if _cfega {_fefb ,_gdbcg :=_bbdeda .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _gdbcg {_egagb :=string (*_fefb );_gcg .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_egagb );_eaccb [_egagb ]++;};};_gcg .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_afag .ObjectNumber ,_ccfd );};_dbf ++;};_gcg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_gcg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_gcg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_ddae );_gcg .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_edee );for _gabga ,_ecbde :=range _eaccb {_gcg .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_gabga ,_ecbde );};_gcg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_dabd ._ccbg .ObjectMap )< 1{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_bb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_dfdbb ,_dfag :=_eaccb ["\u0046\u006f\u006e\u0074"];if !_dfag ||_dfdbb < 2{_gcg .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_gcg .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _eaccb ,nil ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_dgfa *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dgfa .DecodeBytes (streamObj .Stream );};

// WriteString outputs the object as it is to be written to file.
func (_fccb *PdfObjectName )WriteString ()string {var _dabg _gc .Buffer ;if len (*_fccb )> 127{_gcg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_fccb );};_dabg .WriteString ("\u002f");for _acdg :=0;_acdg < len (*_fccb );_acdg ++{_egde :=(*_fccb )[_acdg ];if !IsPrintable (_egde )||_egde =='#'||IsDelimiter (_egde ){_dabg .WriteString (_bb .Sprintf ("\u0023\u0025\u002e2\u0078",_egde ));}else {_dabg .WriteByte (_egde );};};return _dabg .String ();};func (_efdca *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_efdca ._ccbg .ObjectMap =make (map[int ]XrefObject );_efdca ._gabad =make (objectStreams );_aege ,_dbac :=_efdca ._bcbad .Seek (0,_fb .SeekEnd );if _dbac !=nil {return nil ,_dbac ;};_gcg .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_aege );_efdca ._cfga =_aege ;_dbac =_efdca .seekToEOFMarker (_aege );if _dbac !=nil {_gcg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_dbac );return nil ,_dbac ;};_fcde ,_dbac :=_efdca ._bcbad .Seek (0,_fb .SeekCurrent );if _dbac !=nil {return nil ,_dbac ;};var _ggegb int64 =64;_ceaa :=_fcde -_ggegb ;if _ceaa < 0{_ceaa =0;};_ ,_dbac =_efdca ._bcbad .Seek (_ceaa ,_fb .SeekStart );if _dbac !=nil {return nil ,_dbac ;};_dddba :=make ([]byte ,_ggegb );_ ,_dbac =_efdca ._bcbad .Read (_dddba );if _dbac !=nil {_gcg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_dbac );return nil ,_dbac ;};_gfda :=_afdg .FindStringSubmatch (string (_dddba ));if len (_gfda )< 2{_gcg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_g .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_gfda )> 2{_gcg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_dddba );return nil ,_g .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_ccaf ,_ :=_cc .ParseInt (_gfda [1],10,64);_gcg .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_ccaf );if _ccaf > _aege {_gcg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_gcg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_ccaf ,_dbac =_efdca .repairLocateXref ();if _dbac !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_dbac ;};};_efdca ._bcbad .Seek (_ccaf ,_fb .SeekStart );_efdca ._cccg =_cf .NewReader (_efdca ._bcbad );_egf ,_dbac :=_efdca .parseXref ();if _dbac !=nil {return nil ,_dbac ;};_ceac :=_egf .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _ceac !=nil {_egda ,_bbfc :=_ceac .(*PdfObjectInteger );if !_bbfc {return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_dbac =_efdca .parseXrefStream (_egda );if _dbac !=nil {return nil ,_dbac ;};};var _gead []int64 ;_efdg :=func (_dfea int64 ,_dafc []int64 )bool {for _ ,_fdce :=range _dafc {if _fdce ==_dfea {return true ;};};return false ;};_ceac =_egf .Get ("\u0050\u0072\u0065\u0076");for _ceac !=nil {_adfff ,_fccdb :=_ceac .(*PdfObjectInteger );if !_fccdb {_gcg .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_ceac );return _egf ,nil ;};_aecb :=*_adfff ;_gcg .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_aecb );_efdca ._bcbad .Seek (int64 (_aecb ),_fb .SeekStart );_efdca ._cccg =_cf .NewReader (_efdca ._bcbad );_gefd ,_fafg :=_efdca .parseXref ();if _fafg !=nil {_gcg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_gcg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_ceac =_gefd .Get ("\u0050\u0072\u0065\u0076");if _ceac !=nil {_adfge :=*(_ceac .(*PdfObjectInteger ));if _efdg (int64 (_adfge ),_gead ){_gcg .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_gead =append (_gead ,int64 (_adfge ));};};return _egf ,nil ;};

// Append appends PdfObject(s) to the streams.
func (_gadee *PdfObjectStreams )Append (objects ...PdfObject ){if _gadee ==nil {_gcg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_gadee ._gccd =append (_gadee ._gccd ,objects ...);};

// UpdateParams updates the parameter values of the encoder.
func (_baff *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_dccf ,_aadg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _aadg ==nil {_baff .ColorComponents =int (_dccf );};_daff ,_aadg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _aadg ==nil {_baff .BitsPerComponent =int (_daff );};_aadf ,_aadg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _aadg ==nil {_baff .Width =int (_aadf );};_agbf ,_aadg :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _aadg ==nil {_baff .Height =int (_agbf );};_cbcde ,_aadg :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _aadg ==nil {_baff .Quality =int (_cbcde );};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_adbaf *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };func _gdec (_dgaef *PdfObjectStream )(*MultiEncoder ,error ){_edbg :=NewMultiEncoder ();_dfdd :=_dgaef .PdfObjectDictionary ;if _dfdd ==nil {return _edbg ,nil ;};var _gdb *PdfObjectDictionary ;var _ebaba []PdfObject ;_gbeg :=_dfdd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gbeg !=nil {_efed ,_efecb :=_gbeg .(*PdfObjectDictionary );if _efecb {_gdb =_efed ;};_cadb ,_gbg :=_gbeg .(*PdfObjectArray );if _gbg {for _ ,_dbeg :=range _cadb .Elements (){_dbeg =TraceToDirectObject (_dbeg );if _gfbd ,_afcc :=_dbeg .(*PdfObjectDictionary );_afcc {_ebaba =append (_ebaba ,_gfbd );}else {_ebaba =append (_ebaba ,MakeDict ());};};};};_gbeg =_dfdd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _gbeg ==nil {return nil ,_bb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_agec ,_fee :=_gbeg .(*PdfObjectArray );if !_fee {return nil ,_bb .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _ecbff ,_gafae :=range _agec .Elements (){_ffd ,_ebagg :=_gafae .(*PdfObjectName );if !_ebagg {return nil ,_bb .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _bgcd PdfObject ;if _gdb !=nil {_bgcd =_gdb ;}else {if len (_ebaba )> 0{if _ecbff >=len (_ebaba ){return nil ,_bb .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_bgcd =_ebaba [_ecbff ];};};var _beea *PdfObjectDictionary ;if _bbded ,_dab :=_bgcd .(*PdfObjectDictionary );_dab {_beea =_bbded ;};_gcg .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_ffd ,_bgcd ,_beea );if *_ffd ==StreamEncodingFilterNameFlate {_gbde ,_abbe :=_ffe (_dgaef ,_beea );if _abbe !=nil {return nil ,_abbe ;};_edbg .AddEncoder (_gbde );}else if *_ffd ==StreamEncodingFilterNameLZW {_efbg ,_bccf :=_ddgcg (_dgaef ,_beea );if _bccf !=nil {return nil ,_bccf ;};_edbg .AddEncoder (_efbg );}else if *_ffd ==StreamEncodingFilterNameASCIIHex {_edd :=NewASCIIHexEncoder ();_edbg .AddEncoder (_edd );}else if *_ffd ==StreamEncodingFilterNameASCII85 {_ccdg :=NewASCII85Encoder ();_edbg .AddEncoder (_ccdg );}else if *_ffd ==StreamEncodingFilterNameDCT {_dfgb ,_bbef :=_cda (_dgaef ,_edbg );if _bbef !=nil {return nil ,_bbef ;};_edbg .AddEncoder (_dfgb );_gcg .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_gcg .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_edbg );}else {_gcg .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_ffd );return nil ,_bb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _edbg ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_aebf *PdfObjectBool ,_gcf bool ){_aebf ,_gcf =TraceToDirectObject (obj ).(*PdfObjectBool );return _aebf ,_gcf ;};func _ffe (_gaba *PdfObjectStream ,_bceg *PdfObjectDictionary )(*FlateEncoder ,error ){_gff :=NewFlateEncoder ();_gbae :=_gaba .PdfObjectDictionary ;if _gbae ==nil {return _gff ,nil ;};_gff ._cee =_egab (_gbae );if _bceg ==nil {_bdeb :=TraceToDirectObject (_gbae .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _bdba :=_bdeb .(type ){case *PdfObjectArray :if _bdba .Len ()!=1{_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_bdba .Len ());return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _dgae ,_adc :=GetDict (_bdba .Get (0));_adc {_bceg =_dgae ;};case *PdfObjectDictionary :_bceg =_bdba ;case *PdfObjectNull ,nil :default:_gcg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_bdeb );return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bceg ==nil {return _gff ,nil ;};_gcg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bceg .String ());_aage :=_bceg .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _aage ==nil {_gcg .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_efeb ,_fbba :=_aage .(*PdfObjectInteger );if !_fbba {_gcg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_aage );return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gff .Predictor =int (*_efeb );};_aage =_bceg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _aage !=nil {_abg ,_aded :=_aage .(*PdfObjectInteger );if !_aded {_gcg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_bb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gff .BitsPerComponent =int (*_abg );};if _gff .Predictor > 1{_gff .Columns =1;_aage =_bceg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _aage !=nil {_bdea ,_afge :=_aage .(*PdfObjectInteger );if !_afge {return nil ,_bb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gff .Columns =int (*_bdea );};_gff .Colors =1;_aage =_bceg .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _aage !=nil {_aefb ,_efg :=_aage .(*PdfObjectInteger );if !_efg {return nil ,_bb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_gff .Colors =int (*_aefb );};};return _gff ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_ecaf JBIG2EncoderSettings )Validate ()error {const _addc ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _ecaf .Threshold < 0||_ecaf .Threshold > 1.0{return _af .Errorf (_addc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_ecaf .Threshold );};if _ecaf .ResolutionX < 0{return _af .Errorf (_addc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_ecaf .ResolutionX );};if _ecaf .ResolutionY < 0{return _af .Errorf (_addc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_ecaf .ResolutionY );};if _ecaf .DefaultPixelValue !=0&&_ecaf .DefaultPixelValue !=1{return _af .Errorf (_addc ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_ecaf .DefaultPixelValue );};if _ecaf .Compression !=JB2Generic {return _af .Errorf (_addc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};func _dbd (_gec *_ab .StdEncryptDict ,_dgg *PdfObjectDictionary ){_dgg .Set ("\u0052",MakeInteger (int64 (_gec .R )));_dgg .Set ("\u0050",MakeInteger (int64 (_gec .P )));_dgg .Set ("\u004f",MakeStringFromBytes (_gec .O ));_dgg .Set ("\u0055",MakeStringFromBytes (_gec .U ));if _gec .R >=5{_dgg .Set ("\u004f\u0045",MakeStringFromBytes (_gec .OE ));_dgg .Set ("\u0055\u0045",MakeStringFromBytes (_gec .UE ));_dgg .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_gec .EncryptMetadata ));if _gec .R > 5{_dgg .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_gec .Perms ));};};};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_faddf *PdfObjectInteger ,_afbg bool ){_faddf ,_afbg =TraceToDirectObject (obj ).(*PdfObjectInteger );return _faddf ,_afbg ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ebee *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_adbe :=MakeDict ();_adbe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ebee .GetFilterName ()));return _adbe ;};func _gdd (_abb int )cryptFilters {return cryptFilters {_fcd :_ggd .NewFilterV2 (_abb )}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dee *FlateEncoder )MakeDecodeParams ()PdfObject {if _dee .Predictor > 1{_aeg :=MakeDict ();_aeg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_dee .Predictor )));if _dee .BitsPerComponent !=8{_aeg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_dee .BitsPerComponent )));};if _dee .Columns !=1{_aeg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_dee .Columns )));};if _dee .Colors !=1{_aeg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_dee .Colors )));};return _aeg ;};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_adggb *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func (_ebbf *ASCII85Encoder )base256Tobase85 (_eabd uint32 )[5]byte {_dfac :=[5]byte {0,0,0,0,0};_ceee :=_eabd ;for _decf :=0;_decf < 5;_decf ++{_fcdc :=uint32 (1);for _gaca :=0;_gaca < 4-_decf ;_gaca ++{_fcdc *=85;};_bcag :=_ceee /_fcdc ;_ceee =_ceee %_fcdc ;_dfac [_decf ]=byte (_bcag );};return _dfac ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_dfeg :=&DCTEncoder {};_dfeg .ColorComponents =3;_dfeg .BitsPerComponent =8;_dfeg .Quality =DefaultJPEGQuality ;return _dfeg ;};var _gddf =_gb .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ea []XrefObject ;};func (_cea *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_fb .SeekStart {offset +=_cea ._afgea ;};_affe ,_fddb :=_cea ._bbae .Seek (offset ,whence );if _fddb !=nil {return _affe ,_fddb ;};if whence ==_fb .SeekCurrent {_affe -=_cea ._afgea ;};if _affe < 0{return 0,_g .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _affe ,nil ;};const _afabf =10;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fgdf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_efde :=&PdfCrypt {_gcc :false ,_dgc :make (map[PdfObject ]bool ),_dbb :make (map[PdfObject ]bool ),_gbd :make (map[int ]struct{}),_bbd :parser };_bgf ,_baf :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_baf {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _efde ,_g .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_bgf !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_gcg .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_bgf );return _efde ,_g .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_efde ._adf .Filter =string (*_bgf );if _bbc ,_aeae :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_aeae {_efde ._adf .SubFilter =_bbc .Str ();_gcg .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_bbc );};if L ,_fab :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_fab {if (*L %8)!=0{_gcg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _efde ,_g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_efde ._adf .Length =int (*L );}else {_efde ._adf .Length =40;};_efde ._adf .V =0;if _gae ,_ggeb :=ed .Get ("\u0056").(*PdfObjectInteger );_ggeb {V :=int (*_gae );_efde ._adf .V =V ;if V >=1&&V <=2{_efde ._ddb =_gdd (_efde ._adf .Length );}else if V >=4&&V <=5{if _affa :=_efde .loadCryptFilters (ed );_affa !=nil {return _efde ,_affa ;};}else {_gcg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _efde ,_g .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _gfg :=_geg (&_efde ._bgc ,ed );_gfg !=nil {return _efde ,_gfg ;};_dga :="";if _fbed ,_cdd :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_cdd &&_fbed .Len ()>=1{_ddda ,_dea :=GetString (_fbed .Get (0));if !_dea {return _efde ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_dga =_ddda .Str ();}else {_gcg .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_efde ._ba =_dga ;return _efde ,nil ;};const _cfbgd =32<<(^uint (0)>>63);

// Clear resets the array to an empty state.
func (_defe *PdfObjectArray )Clear (){_defe ._fggb =[]PdfObject {}};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_cdf *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gcg .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_gcg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cdf .Predictor );if _cdf .BitsPerComponent !=8{return nil ,_bb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_cdf .BitsPerComponent );};_ggdb ,_fgag :=_cdf .DecodeBytes (streamObj .Stream );if _fgag !=nil {return nil ,_fgag ;};_ggdb ,_fgag =_cdf .postDecodePredict (_ggdb );if _fgag !=nil {return nil ,_fgag ;};return _cdf .cleanImageData (_ggdb );};

// UpdateParams updates the parameter values of the encoder.
func (_fdg *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_acb ,_cbcf :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _cbcf ==nil {_fdg .Predictor =int (_acb );};_edged ,_cbcf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cbcf ==nil {_fdg .BitsPerComponent =int (_edged );};_fdab ,_cbcf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cbcf ==nil {_fdg .Columns =int (_fdab );};_bgee ,_cbcf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cbcf ==nil {_fdg .Colors =int (_bgee );};};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_dfada *PdfObjectFloat ,_abef bool ){_dfada ,_abef =TraceToDirectObject (obj ).(*PdfObjectFloat );return _dfada ,_abef ;};

// WriteString outputs the object as it is to be written to file.
func (_abdfa *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_eeac *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_agfef :=_eeac ._fgee [key ];if !_agfef {_eeac ._fdgf =append (_eeac ._fdgf ,key );};_eeac ._fgee [key ]=val ;};func (_gefg *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cebf :=MakeDict ();_cebf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_cebf .Set ("\u0056",MakeInteger (int64 (_gefg ._adf .V )));_cebf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gefg ._adf .Length )));return _cebf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eecb *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_ggdg :=MakeDict ();_ggdg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eecb .GetFilterName ()));return _ggdg ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_cdcc :=PdfObjectString {_agfdc :s };return &_cdcc };

// Bytes returns the PdfObjectString content as a []byte array.
func (_dfga *PdfObjectString )Bytes ()[]byte {return []byte (_dfga ._agfdc )};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ddac :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ddac .PdfObjectDictionary =encoder .MakeStreamDict ();_fccg ,_cead :=encoder .EncodeBytes (contents );if _cead !=nil {return nil ,_cead ;};_ddac .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fccg ))));_ddac .Stream =_fccg ;return _ddac ,nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_dbcg *PdfParser )Decrypt (password []byte )(bool ,error ){if _dbcg ._aedd ==nil {return false ,_g .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_cabf ,_cfaf :=_dbcg ._aedd .authenticate (password );if _cfaf !=nil {return false ,_cfaf ;};if !_cabf {_cabf ,_cfaf =_dbcg ._aedd .authenticate ([]byte (""));};return _cabf ,_cfaf ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};var _gfffd =_gb .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// UpdateParams updates the parameter values of the encoder.
func (_bddb *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// UpdateParams updates the parameter values of the encoder.
func (_gfeb *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _ddfb ,_cbdad :=GetNumberAsInt64 (params .Get ("\u004b"));_cbdad ==nil {_gfeb .K =int (_ddfb );};if _ceba ,_aadb :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_aadb ==nil {_gfeb .Columns =int (_ceba );}else if _ceba ,_aadb =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_aadb ==nil {_gfeb .Columns =int (_ceba );};if _cbcg ,_ggf :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ggf ==nil {_gfeb .BlackIs1 =_cbcg > 0;}else {if _ddec ,_bbed :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_bbed {_gfeb .BlackIs1 =_ddec ;}else {if _bffa ,_egdg :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_egdg {_bcbb ,_bdfg :=_bffa .ToIntegerArray ();if _bdfg ==nil {_gfeb .BlackIs1 =_bcbb [0]==1&&_bcbb [1]==0;};};};};if _eafg ,_fefd :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fefd ==nil {_gfeb .EncodedByteAlign =_eafg > 0;}else {if _ecfa ,_bffab :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bffab {_gfeb .EncodedByteAlign =_ecfa ;};};if _fdga ,_aade :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_aade ==nil {_gfeb .EndOfLine =_fdga > 0;}else {if _ebca ,_bgce :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bgce {_gfeb .EndOfLine =_ebca ;};};if _ffbe ,_gbeb :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_gbeb ==nil {_gfeb .Rows =int (_ffbe );}else if _ffbe ,_gbeb =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_gbeb ==nil {_gfeb .Rows =int (_ffbe );};if _dddb ,_ddfe :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ddfe ==nil {_gfeb .EndOfBlock =_dddb > 0;}else {if _bgcad ,_cgad :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cgad {_gfeb .EndOfBlock =_bgcad ;};};if _bfc ,_faag :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_faag !=nil {_gfeb .DamagedRowsBeforeError =int (_bfc );};};

// DecodeStream implements ASCII hex decoding.
func (_fgc *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fgc .DecodeBytes (streamObj .Stream );};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _deff :=obj .(type ){case *PdfObjectFloat :return float64 (*_deff ),nil ;case *PdfObjectInteger :return float64 (*_deff ),nil ;};return 0,ErrNotANumber ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};func _dagd (_eagfc PdfObject ,_ebbgb int )PdfObject {if _ebbgb > _afabf {_gcg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_afabf );return MakeNull ();};switch _ddaee :=_eagfc .(type ){case *PdfIndirectObject :_eagfc =_dagd ((*_ddaee ).PdfObject ,_ebbgb +1);case *PdfObjectArray :for _aaaa ,_befcc :=range (*_ddaee )._fggb {(*_ddaee )._fggb [_aaaa ]=_dagd (_befcc ,_ebbgb +1);};case *PdfObjectDictionary :for _cfcb ,_aadec :=range (*_ddaee )._fgee {(*_ddaee )._fgee [_cfcb ]=_dagd (_aadec ,_ebbgb +1);};_ccd .Slice ((*_ddaee )._fdgf ,func (_cdef ,_feffc int )bool {return (*_ddaee )._fdgf [_cdef ]< (*_ddaee )._fdgf [_feffc ]});};return _eagfc ;};func (_fcabaa *PdfParser )parsePdfVersion ()(int ,int ,error ){var _bbaec int64 =20;_agfd :=make ([]byte ,_bbaec );_fcabaa ._bcbad .Seek (0,_fb .SeekStart );_fcabaa ._bcbad .Read (_agfd );var _caaa error ;var _fcge ,_dgec int ;if _abdg :=_gbdbe .FindStringSubmatch (string (_agfd ));len (_abdg )< 3{if _fcge ,_dgec ,_caaa =_fcabaa .seekPdfVersionTopDown ();_caaa !=nil {_gcg .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_caaa ;};_fcabaa ._bcbad ,_caaa =_bgde (_fcabaa ._bcbad ,_fcabaa .GetFileOffset ()-8);if _caaa !=nil {return 0,0,_caaa ;};}else {if _fcge ,_caaa =_cc .Atoi (_abdg [1]);_caaa !=nil {return 0,0,_caaa ;};if _dgec ,_caaa =_cc .Atoi (_abdg [2]);_caaa !=nil {return 0,0,_caaa ;};_fcabaa .SetFileOffset (0);};_fcabaa ._cccg =_cf .NewReader (_fcabaa ._bcbad );_gcg .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_fcge ,_dgec );return _fcge ,_dgec ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fcad *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_aeaa ,_bcbcb :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bcbcb ==nil {_fcad .Predictor =int (_aeaa );};_cdb ,_bcbcb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bcbcb ==nil {_fcad .BitsPerComponent =int (_cdb );};_efegc ,_bcbcb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bcbcb ==nil {_fcad .Columns =int (_efegc );};_egd ,_bcbcb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bcbcb ==nil {_fcad .Colors =int (_egd );};_dad ,_bcbcb :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _bcbcb ==nil {_fcad .EarlyChange =int (_dad );};};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dccdf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_adad *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_acd :=_gc .NewReader (encoded );var _agfc []byte ;for {_bac ,_bbbe :=_acd .ReadByte ();if _bbbe !=nil {return nil ,_bbbe ;};if _bac =='>'{break ;};if IsWhiteSpace (_bac ){continue ;};if (_bac >='a'&&_bac <='f')||(_bac >='A'&&_bac <='F')||(_bac >='0'&&_bac <='9'){_agfc =append (_agfc ,_bac );}else {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_bac );return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_bac );};};if len (_agfc )%2==1{_agfc =append (_agfc ,'0');};_gcg .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_agfc );_eabf :=make ([]byte ,_ed .DecodedLen (len (_agfc )));_ ,_fef :=_ed .Decode (_eabf ,_agfc );if _fef !=nil {return nil ,_fef ;};return _eabf ,nil ;};func (_gddb *JBIG2Image )toBitmap ()(_bceff *_fe .Bitmap ,_bgbda error ){const _ddecd ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _gddb .Data ==nil {return nil ,_af .Error (_ddecd ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _gddb .Width ==0||_gddb .Height ==0{return nil ,_af .Error (_ddecd ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _gddb .HasPadding {_bceff ,_bgbda =_fe .NewWithData (_gddb .Width ,_gddb .Height ,_gddb .Data );}else {_bceff ,_bgbda =_fe .NewWithUnpaddedData (_gddb .Width ,_gddb .Height ,_gddb .Data );};if _bgbda !=nil {return nil ,_af .Wrap (_bgbda ,_ddecd ,"");};return _bceff ,nil ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _fg .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _bcdb ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_af .Error (_bcdb ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_baed uint8 ;_dfbe _ef .Image ;_afdb error ;);if bwThreshold ==JB2ImageAutoThreshold {_dfbe ,_afdb =_ef .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_af .Error (_bcdb ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_baed =uint8 (255*bwThreshold );_dfbe ,_afdb =_ef .MonochromeThresholdConverter (_baed ).Convert (i );};if _afdb !=nil {return nil ,_afdb ;};return _cgdc (_dfbe ),nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_aacgd *JBIG2Encoder )Encode ()(_gdfbf []byte ,_bdcc error ){const _ffbg ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _aacgd ._ccfg ==nil {return nil ,_af .Errorf (_ffbg ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_aacgd ._ccfg .FullHeaders =_aacgd .DefaultPageSettings .FileMode ;_gdfbf ,_bdcc =_aacgd ._ccfg .Encode ();if _bdcc !=nil {return nil ,_af .Wrap (_bdcc ,_ffbg ,"");};return _gdfbf ,nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ggd .Filter ,userPass ,ownerPass []byte ,perm _ab .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_ead :=&PdfCrypt {_dbb :make (map[PdfObject ]bool ),_ddb :make (cryptFilters ),_bgc :_ab .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _df Version ;if cf !=nil {_cfgc :=cf .PDFVersion ();_df .Major ,_df .Minor =_cfgc [0],_cfgc [1];V ,R :=cf .HandlerVersion ();_ead ._adf .V =V ;_ead ._bgc .R =R ;_ead ._adf .Length =cf .KeyLength ()*8;};const (_dde =_fcd ;);_ead ._ddb [_dde ]=cf ;if _ead ._adf .V >=4{_ead ._aa =_dde ;_ead ._ada =_dde ;};_ede :=_ead .newEncryptDict ();_db :=_ga .Sum ([]byte (_a .Now ().Format (_a .RFC850 )));_gbb :=string (_db [:]);_ec :=make ([]byte ,100);_gag .Read (_ec );_db =_ga .Sum (_ec );_bdb :=string (_db [:]);_gcg .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_ec );_gcg .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_gbb );_ead ._ba =_gbb ;_bed :=_ead .generateParams (userPass ,ownerPass );if _bed !=nil {return nil ,nil ,_bed ;};_dbd (&_ead ._bgc ,_ede );if _ead ._adf .V >=4{if _dg :=_ead .saveCryptFilters (_ede );_dg !=nil {return nil ,nil ,_dg ;};};return _ead ,&EncryptInfo {Version :_df ,Encrypt :_ede ,ID0 :_gbb ,ID1 :_bdb },nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_eacb *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_begba ,_ecac :=_eacb ._fgee [key ];if !_ecac {return nil ;};return _begba ;};func _dcfg (_caaf ,_aedef ,_dacd uint8 )uint8 {_bdfb :=int (_dacd );_aabd :=int (_aedef )-_bdfb ;_feee :=int (_caaf )-_bdfb ;_bdfb =_cae (_aabd +_feee );_aabd =_cae (_aabd );_feee =_cae (_feee );if _aabd <=_feee &&_aabd <=_bdfb {return _caaf ;}else if _feee <=_bdfb {return _aedef ;};return _dacd ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_bee *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bee .DecodeBytes (streamObj .Stream );};

// WriteString outputs the object as it is to be written to file.
func (_fece *PdfIndirectObject )WriteString ()string {var _agef _fga .Builder ;_agef .WriteString (_cc .FormatInt (_fece .ObjectNumber ,10));_agef .WriteString ("\u0020\u0030\u0020\u0052");return _agef .String ();};type objectStreams map[int ]objectStream ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_faed *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func (_cca *PdfParser )lookupByNumberWrapper (_fd int ,_cfe bool )(PdfObject ,bool ,error ){_efb ,_cbg ,_beb :=_cca .lookupByNumber (_fd ,_cfe );if _beb !=nil {return nil ,_cbg ,_beb ;};if !_cbg &&_cca ._aedd !=nil &&!_cca ._aedd .isDecrypted (_efb ){_efd :=_cca ._aedd .Decrypt (_efb ,0,0);if _efd !=nil {return nil ,_cbg ,_efd ;};};return _efb ,_cbg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_faeb *PdfObjectStreams )WriteString ()string {var _feca _fga .Builder ;_feca .WriteString (_cc .FormatInt (_faeb .ObjectNumber ,10));_feca .WriteString ("\u0020\u0030\u0020\u0052");return _feca .String ();};func (_fced *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fcaba :=MakeArray ();_fced ._cccg .ReadByte ();for {_fced .skipSpaces ();_acca ,_gadc :=_fced ._cccg .Peek (1);if _gadc !=nil {return _fcaba ,_gadc ;};if _acca [0]==']'{_fced ._cccg .ReadByte ();break ;};_gfdg ,_gadc :=_fced .parseObject ();if _gadc !=nil {return _fcaba ,_gadc ;};_fcaba .Append (_gfdg );};return _fcaba ,nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_cag *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _cag .isEncrypted (obj ){return nil ;};switch _eee :=obj .(type ){case *PdfIndirectObject :_cag ._dbb [_eee ]=true ;_gcg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_eee .ObjectNumber ,_eee .GenerationNumber );_dfb :=_eee .ObjectNumber ;_adgg :=_eee .GenerationNumber ;_fdfg :=_cag .Encrypt (_eee .PdfObject ,_dfb ,_adgg );if _fdfg !=nil {return _fdfg ;};return nil ;case *PdfObjectStream :_cag ._dbb [_eee ]=true ;_gagc :=_eee .PdfObjectDictionary ;if _ggcg ,_ffb :=_gagc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ffb &&*_ggcg =="\u0058\u0052\u0065\u0066"{return nil ;};_fba :=_eee .ObjectNumber ;_dafe :=_eee .GenerationNumber ;_gcg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fba ,_dafe );_gega :=_fcd ;if _cag ._adf .V >=4{_gega =_cag ._aa ;_gcg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_cag ._aa );if _cbdf ,_fgf :=_gagc .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_fgf {if _fda ,_cfa :=GetName (_cbdf .Get (0));_cfa {if *_fda =="\u0043\u0072\u0079p\u0074"{_gega ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cfcg ,_dba :=_gagc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_dba {if _cgd ,_efc :=_cfcg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_efc {if _ ,_ccac :=_cag ._ddb [string (*_cgd )];_ccac {_gcg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cgd );_gega =string (*_cgd );};};};};};};_gcg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gega );if _gega =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ceg :=_cag .Encrypt (_eee .PdfObjectDictionary ,_fba ,_dafe );if _ceg !=nil {return _ceg ;};_gcb ,_ceg :=_cag .makeKey (_gega ,uint32 (_fba ),uint32 (_dafe ),_cag ._ade );if _ceg !=nil {return _ceg ;};_eee .Stream ,_ceg =_cag .encryptBytes (_eee .Stream ,_gega ,_gcb );if _ceg !=nil {return _ceg ;};_gagc .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eee .Stream ))));return nil ;case *PdfObjectString :_gcg .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cfba :=_fcd ;if _cag ._adf .V >=4{_gcg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cag ._ada );if _cag ._ada =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cfba =_cag ._ada ;};_bgcg ,_dgd :=_cag .makeKey (_cfba ,uint32 (parentObjNum ),uint32 (parentGenNum ),_cag ._ade );if _dgd !=nil {return _dgd ;};_fgb :=_eee .Str ();_ebc :=make ([]byte ,len (_fgb ));for _ebe :=0;_ebe < len (_fgb );_ebe ++{_ebc [_ebe ]=_fgb [_ebe ];};_gcg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ebc ,_ebc );_ebc ,_dgd =_cag .encryptBytes (_ebc ,_cfba ,_bgcg );if _dgd !=nil {return _dgd ;};_eee ._agfdc =string (_ebc );return nil ;case *PdfObjectArray :for _ ,_agab :=range _eee .Elements (){_cab :=_cag .Encrypt (_agab ,parentObjNum ,parentGenNum );if _cab !=nil {return _cab ;};};return nil ;case *PdfObjectDictionary :_bfa :=false ;if _cgea :=_eee .Get ("\u0054\u0079\u0070\u0065");_cgea !=nil {_agc ,_bgbd :=_cgea .(*PdfObjectName );if _bgbd &&*_agc =="\u0053\u0069\u0067"{_bfa =true ;};};for _ ,_eeab :=range _eee .Keys (){_fabc :=_eee .Get (_eeab );if _bfa &&string (_eeab )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_eeab )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_eeab )!="\u0050\u0072\u0065\u0076"&&string (_eeab )!="\u004c\u0061\u0073\u0074"{_fggg :=_cag .Encrypt (_fabc ,parentObjNum ,parentGenNum );if _fggg !=nil {return _fggg ;};};};return nil ;};return nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_dcda *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_fgcf :=n ;_bgbb :=0;_ffcd :=0;for _fgcf > 0{_edda ,_afgc :=_dcda ._cccg .Read (p [_bgbb :]);if _afgc !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_edda ,_ffcd ,_afgc .Error ());return _bgbb ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_ffcd ++;_bgbb +=_edda ;_fgcf -=_edda ;};return _bgbb ,nil ;};func (_gga *PdfParser )parseXrefStream (_gfbe *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _gfbe !=nil {_gcg .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_gfbe );_gga ._bcbad .Seek (int64 (*_gfbe ),_fb .SeekStart );_gga ._cccg =_cf .NewReader (_gga ._bcbad );};_dbee :=_gga .GetFileOffset ();_cadbb ,_gacb :=_gga .ParseIndirectObject ();if _gacb !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_gcg .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_cadbb );_gegaa ,_adgc :=_cadbb .(*PdfObjectStream );if !_adgc {_gcg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_cgce :=_gegaa .PdfObjectDictionary ;_fdde ,_adgc :=_gegaa .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_adgc {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_g .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_fdde )> 8388607{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_fdde );return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eeag :=_gegaa .PdfObjectDictionary .Get ("\u0057");_bddfa ,_adgc :=_eeag .(*PdfObjectArray );if !_adgc {return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_eede :=_bddfa .Len ();if _eede !=3{_gcg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_eede );return nil ,_g .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _cced []int64 ;for _bcad :=0;_bcad < 3;_bcad ++{_fdb ,_efdf :=GetInt (_bddfa .Get (_bcad ));if !_efdf {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_cced =append (_cced ,int64 (*_fdb ));};_fgbb ,_gacb :=DecodeStream (_gegaa );if _gacb !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_gacb );return nil ,_gacb ;};_ffda :=int (_cced [0]);_ebcae :=int (_cced [0]+_cced [1]);_aeaae :=int (_cced [0]+_cced [1]+_cced [2]);_ecca :=int (_cced [0]+_cced [1]+_cced [2]);if _ffda < 0||_ebcae < 0||_aeaae < 0{_gcg .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_ffda ,_ebcae ,_aeaae );return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ecca ==0{_gcg .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _cgce ,nil ;};_ffdb :=len (_fgbb )/_ecca ;_dgab :=0;_cfda :=_gegaa .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _cgbf []int ;if _cfda !=nil {_gcg .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_cfda );_cdga ,_gaae :=_cfda .(*PdfObjectArray );if !_gaae {_gcg .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_g .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _cdga .Len ()%2!=0{_gcg .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dgab =0;_gddc ,_dgag :=_cdga .ToIntegerArray ();if _dgag !=nil {_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_dgag );return nil ,_dgag ;};for _gcab :=0;_gcab < len (_gddc );_gcab +=2{_bcbef :=_gddc [_gcab ];_cebce :=_gddc [_gcab +1];for _gafb :=0;_gafb < _cebce ;_gafb ++{_cgbf =append (_cgbf ,_bcbef +_gafb );};_dgab +=_cebce ;};}else {for _gagdb :=0;_gagdb < int (*_fdde );_gagdb ++{_cgbf =append (_cgbf ,_gagdb );};_dgab =int (*_fdde );};if _ffdb ==_dgab +1{_gcg .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_gdfbe :=_dgab -1;for _ ,_gagcc :=range _cgbf {if _gagcc > _gdfbe {_gdfbe =_gagcc ;};};_cgbf =append (_cgbf ,_gdfbe +1);_dgab ++;};if _ffdb !=len (_cgbf ){_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_ffdb ,len (_cgbf ));return nil ,_g .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_gcg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_dgab );_gcg .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_cgbf );_bcce :=func (_gebc []byte )int64 {var _cbcfa int64 ;for _bedc :=0;_bedc < len (_gebc );_bedc ++{_cbcfa +=int64 (_gebc [_bedc ])*(1<<uint (8*(len (_gebc )-_bedc -1)));};return _cbcfa ;};_gcg .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_fgbb ));_cbgf :=0;for _aedc :=0;_aedc < len (_fgbb );_aedc +=_ecca {_cdceb :=_bcabc (len (_fgbb ),_aedc ,_aedc +_ffda );if _cdceb !=nil {_gcg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cdceb );return nil ,_cdceb ;};_bdfd :=_fgbb [_aedc :_aedc +_ffda ];_cdceb =_bcabc (len (_fgbb ),_aedc +_ffda ,_aedc +_ebcae );if _cdceb !=nil {_gcg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cdceb );return nil ,_cdceb ;};_abbb :=_fgbb [_aedc +_ffda :_aedc +_ebcae ];_cdceb =_bcabc (len (_fgbb ),_aedc +_ebcae ,_aedc +_aeaae );if _cdceb !=nil {_gcg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_cdceb );return nil ,_cdceb ;};_gea :=_fgbb [_aedc +_ebcae :_aedc +_aeaae ];_fafa :=_bcce (_bdfd );_egeb :=_bcce (_abbb );_fdff :=_bcce (_gea );if _cced [0]==0{_fafa =1;};if _cbgf >=len (_cgbf ){_gcg .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_gabg :=_cgbf [_cbgf ];_cbgf ++;_gcg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_gabg ,_bdfd );_gcg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_gabg ,_abbb );_gcg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_gabg ,_gea );_gcg .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_gabg ,_fafa ,_egeb ,_fdff );if _fafa ==0{_gcg .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _fafa ==1{_gcg .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_abbb );if _egeb ==_dbee {_gcg .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_gabg ,_gegaa .ObjectNumber );_gabg =int (_gegaa .ObjectNumber );};if _cfbb ,_bfbce :=_gga ._ccbg .ObjectMap [_gabg ];!_bfbce ||int (_fdff )> _cfbb .Generation {_cfdb :=XrefObject {ObjectNumber :_gabg ,XType :XrefTypeTableEntry ,Offset :_egeb ,Generation :int (_fdff )};_gga ._ccbg .ObjectMap [_gabg ]=_cfdb ;};}else if _fafa ==2{_gcg .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_agce :=_gga ._ccbg .ObjectMap [_gabg ];!_agce {_edgg :=XrefObject {ObjectNumber :_gabg ,XType :XrefTypeObjectStream ,OsObjNumber :int (_egeb ),OsObjIndex :int (_fdff )};_gga ._ccbg .ObjectMap [_gabg ]=_edgg ;_gcg .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_edgg );};}else {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _gga ._ecgg ==nil {_gdae :=XrefTypeObjectStream ;_gga ._ecgg =&_gdae ;};return _cgce ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_daaa *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _daaa .Predictor !=1&&_daaa .Predictor !=11{_gcg .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _daaa .Predictor ==11{_dgf :=_daaa .Columns ;_baeb :=len (data )/_dgf ;if len (data )%_dgf !=0{_gcg .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_cbb :=_gc .NewBuffer (nil );_cgeag :=make ([]byte ,_dgf );for _ebab :=0;_ebab < _baeb ;_ebab ++{_abe :=data [_dgf *_ebab :_dgf *(_ebab +1)];_cgeag [0]=_abe [0];for _ecad :=1;_ecad < _dgf ;_ecad ++{_cgeag [_ecad ]=byte (int (_abe [_ecad ]-_abe [_ecad -1])%256);};_cbb .WriteByte (1);_cbb .Write (_cgeag );};data =_cbb .Bytes ();};var _efgf _gc .Buffer ;_fadd :=_b .NewWriter (&_efgf );_fadd .Write (data );_fadd .Close ();return _efgf .Bytes (),nil ;};func (_ecf *FlateEncoder )cleanImageData (_daef []byte )([]byte ,error ){if _ecf ._cee ==nil {return _daef ,nil ;};if _ecf ._cee .BitsPerComponent >=8{return _daef ,nil ;};_ebed :=_ecf ._cee .BitsPerComponent *_ecf ._cee .Width *_ecf ._cee .ColorComponents *_ecf ._cee .Height /8;_daef =_daef [:_ebed ];var _gdf error ;_daef ,_gdf =_ef .AddDataPadding (_ecf ._cee .Width ,_ecf ._cee .Height ,_ecf ._cee .BitsPerComponent ,_ecf ._cee .ColorComponents ,_daef );if _gdf !=nil {return nil ,_gdf ;};return _daef ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fccd *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };func _cae (_bbfag int )int {_feb :=_bbfag >>(_cfbgd -1);return (_bbfag ^_feb )-_feb };type offsetReader struct{_bbae _fb .ReadSeeker ;_afgea int64 ;};

// GetFilterName returns the name of the encoding filter.
func (_gedc *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_fbc *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_fcg :=MakeDict ();_fcg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fbc .GetFilterName ()));_dfd :=_fbc .MakeDecodeParams ();if _dfd !=nil {_fcg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dfd );};return _fcg ;};func (_feeg *PdfParser )readComment ()(string ,error ){var _agee _gc .Buffer ;_ ,_fgab :=_feeg .skipSpaces ();if _fgab !=nil {return _agee .String (),_fgab ;};_adbge :=true ;for {_fbdc ,_gecf :=_feeg ._cccg .Peek (1);if _gecf !=nil {_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gecf .Error ());return _agee .String (),_gecf ;};if _adbge &&_fbdc [0]!='%'{return _agee .String (),_g .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_adbge =false ;if (_fbdc [0]!='\r')&&(_fbdc [0]!='\n'){_baag ,_ :=_feeg ._cccg .ReadByte ();_agee .WriteByte (_baag );}else {break ;};};return _agee .String (),nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_eagc *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_ecg :=_gc .NewReader (data );var _dfec []byte ;var _cgg []byte ;_fagc ,_aacg :=_ecg .ReadByte ();if _aacg ==_fb .EOF {return []byte {},nil ;}else if _aacg !=nil {return nil ,_aacg ;};_agfb :=1;for {_gagd ,_dbdea :=_ecg .ReadByte ();if _dbdea ==_fb .EOF {break ;}else if _dbdea !=nil {return nil ,_dbdea ;};if _gagd ==_fagc {if len (_cgg )> 0{_cgg =_cgg [:len (_cgg )-1];if len (_cgg )> 0{_dfec =append (_dfec ,byte (len (_cgg )-1));_dfec =append (_dfec ,_cgg ...);};_agfb =1;_cgg =[]byte {};};_agfb ++;if _agfb >=127{_dfec =append (_dfec ,byte (257-_agfb ),_fagc );_agfb =0;};}else {if _agfb > 0{if _agfb ==1{_cgg =[]byte {_fagc };}else {_dfec =append (_dfec ,byte (257-_agfb ),_fagc );};_agfb =0;};_cgg =append (_cgg ,_gagd );if len (_cgg )>=127{_dfec =append (_dfec ,byte (len (_cgg )-1));_dfec =append (_dfec ,_cgg ...);_cgg =[]byte {};};};_fagc =_gagd ;};if len (_cgg )> 0{_dfec =append (_dfec ,byte (len (_cgg )-1));_dfec =append (_dfec ,_cgg ...);}else if _agfb > 0{_dfec =append (_dfec ,byte (257-_agfb ),_fagc );};_dfec =append (_dfec ,128);return _dfec ,nil ;};func _ddgcg (_fag *PdfObjectStream ,_egb *PdfObjectDictionary )(*LZWEncoder ,error ){_eab :=NewLZWEncoder ();_ebcd :=_fag .PdfObjectDictionary ;if _ebcd ==nil {return _eab ,nil ;};if _egb ==nil {_feg :=TraceToDirectObject (_ebcd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _feg !=nil {if _bbde ,_eecf :=_feg .(*PdfObjectDictionary );_eecf {_egb =_bbde ;}else if _ege ,_gfcb :=_feg .(*PdfObjectArray );_gfcb {if _ege .Len ()==1{if _edef ,_cafd :=GetDict (_ege .Get (0));_cafd {_egb =_edef ;};};};if _egb ==nil {_gcg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_feg );return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_eac :=_ebcd .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _eac !=nil {_bdf ,_eae :=_eac .(*PdfObjectInteger );if !_eae {_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_eac );return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_bdf !=0&&*_bdf !=1{return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_eab .EarlyChange =int (*_bdf );}else {_eab .EarlyChange =1;};if _egb ==nil {return _eab ,nil ;};_eac =_egb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _eac !=nil {_baa ,_dbda :=_eac .(*PdfObjectInteger );if !_dbda {_gcg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_eac );return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_eab .Predictor =int (*_baa );};_eac =_egb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _eac !=nil {_aca ,_bafge :=_eac .(*PdfObjectInteger );if !_bafge {_gcg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_bb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_eab .BitsPerComponent =int (*_aca );};if _eab .Predictor > 1{_eab .Columns =1;_eac =_egb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _eac !=nil {_efad ,_eeb :=_eac .(*PdfObjectInteger );if !_eeb {return nil ,_bb .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_eab .Columns =int (*_efad );};_eab .Colors =1;_eac =_egb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _eac !=nil {_bbfa ,_fecd :=_eac .(*PdfObjectInteger );if !_fecd {return nil ,_bb .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_eab .Colors =int (*_bbfa );};};_gcg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_egb .String ());return _eab ,nil ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_dagc bool ,_adgb bool ){_baeaa ,_adgb :=TraceToDirectObject (obj ).(*PdfObjectBool );if _adgb {return bool (*_baeaa ),true ;};return false ,false ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_bbdc *PdfObjectStream ,_bbgc bool ){obj =ResolveReference (obj );_bbdc ,_bbgc =obj .(*PdfObjectStream );return _bbdc ,_bbgc ;};func (_bgd *PdfCrypt )saveCryptFilters (_fcf *PdfObjectDictionary )error {if _bgd ._adf .V < 4{return _g .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_ddbg :=MakeDict ();_fcf .Set ("\u0043\u0046",_ddbg );for _dac ,_de :=range _bgd ._ddb {if _dac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_eeg :=_ebd (_de ,"");_ddbg .Set (PdfObjectName (_dac ),_eeg );};_fcf .Set ("\u0053\u0074\u0072\u0046",MakeName (_bgd ._ada ));_fcf .Set ("\u0053\u0074\u006d\u0046",MakeName (_bgd ._aa ));return nil ;};func (_cd *PdfParser )lookupObjectViaOS (_ca int ,_be int )(PdfObject ,error ){var _aga *_gc .Reader ;var _fec objectStream ;var _dce bool ;_fec ,_dce =_cd ._gabad [_ca ];if !_dce {_dd ,_fge :=_cd .LookupByNumber (_ca );if _fge !=nil {_gcg .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ca );return nil ,_fge ;};_gce ,_dcg :=_dd .(*PdfObjectStream );if !_dcg {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _cd ._aedd !=nil &&!_cd ._aedd .isDecrypted (_gce ){return nil ,_g .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_eg :=_gce .PdfObjectDictionary ;_gcg .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_eg .String ());_cb ,_dcg :=_eg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_dcg {_gcg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _fga .ToLower (string (*_cb ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_g .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_dcg :=_eg .Get ("\u004e").(*PdfObjectInteger );if !_dcg {return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_egg ,_dcg :=_eg .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_dcg {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gcg .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cb ,*N );_bce ,_fge :=DecodeStream (_gce );if _fge !=nil {return nil ,_fge ;};_gcg .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_bce );_bcef :=_cd .GetFileOffset ();defer func (){_cd .SetFileOffset (_bcef )}();_aga =_gc .NewReader (_bce );_cd ._cccg =_cf .NewReader (_aga );_gcg .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_caf :=map[int ]int64 {};for _ff :=0;_ff < int (*N );_ff ++{_cd .skipSpaces ();_ad ,_ee :=_cd .parseNumber ();if _ee !=nil {return nil ,_ee ;};_fc ,_cfdc :=_ad .(*PdfObjectInteger );if !_cfdc {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_cd .skipSpaces ();_ad ,_ee =_cd .parseNumber ();if _ee !=nil {return nil ,_ee ;};_agd ,_cfdc :=_ad .(*PdfObjectInteger );if !_cfdc {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_gcg .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_fc ,*_agd );_caf [int (*_fc )]=int64 (*_egg +*_agd );};_fec =objectStream {N :int (*N ),_gcd :_bce ,_dc :_caf };_cd ._gabad [_ca ]=_fec ;}else {_da :=_cd .GetFileOffset ();defer func (){_cd .SetFileOffset (_da )}();_aga =_gc .NewReader (_fec ._gcd );_cd ._cccg =_cf .NewReader (_aga );};_gef :=_fec ._dc [_be ];_gcg .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_be ,_gef );_aga .Seek (_gef ,_fb .SeekStart );_cd ._cccg =_cf .NewReader (_aga );_fgg ,_ :=_cd ._cccg .Peek (100);_gcg .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_fgg ));_edb ,_ggc :=_cd .parseObject ();if _ggc !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_ggc );return nil ,_ggc ;};if _edb ==nil {return nil ,_g .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_fa :=PdfIndirectObject {};_fa .ObjectNumber =int64 (_be );_fa .PdfObject =_edb ;return &_fa ,nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ebf *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// String returns a string describing `stream`.
func (_ggad *PdfObjectStream )String ()string {return _bb .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_ggad .ObjectNumber ,_ggad .PdfObjectDictionary );};func _cggc ()string {return _gcg .Version };

// String returns a string describing `streams`.
func (_cbdc *PdfObjectStreams )String ()string {return _bb .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_cbdc .ObjectNumber );};var _ccgf =_gb .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");var (ErrUnsupportedEncodingParameters =_g .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_g .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_g .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_g .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_bc .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_g .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// Len returns the number of elements in the streams.
func (_bfbf *PdfObjectStreams )Len ()int {if _bfbf ==nil {return 0;};return len (_bfbf ._gccd );};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_ccfg :_d .InitEncodeDocument (false )}};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _abda (o ,0,traversed );};const (_edeb =0;_adac =1;_abd =2;_gcaa =3;_cbcd =4;);

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_gccd :objects };};

// GetFilterName returns the name of the encoding filter.
func (_agcd *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bdag *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func (_bdca *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _bdca ._bgab {return nil ,_bb .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_bdca ._bgab =true ;_bdca ._bcbad .Seek (0,_fb .SeekStart );_bdca ._cccg =_cf .NewReader (_bdca ._bcbad );_bbfgc :=20;_caeg :=make ([]byte ,_bbfgc );_fcaae :=XrefTable {};_fcaae .ObjectMap =make (map[int ]XrefObject );for {_daca ,_cbfef :=_bdca ._cccg .ReadByte ();if _cbfef !=nil {if _cbfef ==_fb .EOF {break ;}else {return nil ,_cbfef ;};};if _daca =='j'&&_caeg [_bbfgc -1]=='b'&&_caeg [_bbfgc -2]=='o'&&IsWhiteSpace (_caeg [_bbfgc -3]){_ebdc :=_bbfgc -4;for IsWhiteSpace (_caeg [_ebdc ])&&_ebdc > 0{_ebdc --;};if _ebdc ==0||!IsDecimalDigit (_caeg [_ebdc ]){continue ;};for IsDecimalDigit (_caeg [_ebdc ])&&_ebdc > 0{_ebdc --;};if _ebdc ==0||!IsWhiteSpace (_caeg [_ebdc ]){continue ;};for IsWhiteSpace (_caeg [_ebdc ])&&_ebdc > 0{_ebdc --;};if _ebdc ==0||!IsDecimalDigit (_caeg [_ebdc ]){continue ;};for IsDecimalDigit (_caeg [_ebdc ])&&_ebdc > 0{_ebdc --;};if _ebdc ==0{continue ;};_aegg :=_bdca .GetFileOffset ()-int64 (_bbfgc -_ebdc );_bgefb :=append (_caeg [_ebdc +1:],_daca );_agaa ,_cegbg ,_gggd :=_fbbac (string (_bgefb ));if _gggd !=nil {_gcg .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_gggd );return nil ,_gggd ;};if _cfdad ,_ecdb :=_fcaae .ObjectMap [_agaa ];!_ecdb ||_cfdad .Generation < _cegbg {_efff :=XrefObject {};_efff .XType =XrefTypeTableEntry ;_efff .ObjectNumber =_agaa ;_efff .Generation =_cegbg ;_efff .Offset =_aegg ;_fcaae .ObjectMap [_agaa ]=_efff ;};};_caeg =append (_caeg [1:_bbfgc ],_daca );};return &_fcaae ,nil ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_fgba *FlateEncoder )SetPredictor (columns int ){_fgba .Predictor =11;_fgba .Columns =columns };

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bdd *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bdd .isDecrypted (obj ){return nil ;};switch _eba :=obj .(type ){case *PdfIndirectObject :_bdd ._dgc [_eba ]=true ;_gcg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_eba .ObjectNumber ,_eba .GenerationNumber );_ddge :=_eba .ObjectNumber ;_bcbc :=_eba .GenerationNumber ;_ccf :=_bdd .Decrypt (_eba .PdfObject ,_ddge ,_bcbc );if _ccf !=nil {return _ccf ;};return nil ;case *PdfObjectStream :_bdd ._dgc [_eba ]=true ;_dceg :=_eba .PdfObjectDictionary ;if _bdd ._bgc .R !=5{if _faec ,_eaf :=_dceg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eaf &&*_faec =="\u0058\u0052\u0065\u0066"{return nil ;};};_gcce :=_eba .ObjectNumber ;_dacb :=_eba .GenerationNumber ;_gcg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gcce ,_dacb );_edg :=_fcd ;if _bdd ._adf .V >=4{_edg =_bdd ._aa ;_gcg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bdd ._aa );if _ebbg ,_dda :=_dceg .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_dda {if _bae ,_aef :=GetName (_ebbg .Get (0));_aef {if *_bae =="\u0043\u0072\u0079p\u0074"{_edg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _agac ,_dgbb :=_dceg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_dgbb {if _bfef ,_ccg :=_agac .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_ccg {if _ ,_ced :=_bdd ._ddb [string (*_bfef )];_ced {_gcg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_bfef );_edg =string (*_bfef );};};};};};};_gcg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_edg );if _edg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_fbda :=_bdd .Decrypt (_dceg ,_gcce ,_dacb );if _fbda !=nil {return _fbda ;};_aag ,_fbda :=_bdd .makeKey (_edg ,uint32 (_gcce ),uint32 (_dacb ),_bdd ._ade );if _fbda !=nil {return _fbda ;};_eba .Stream ,_fbda =_bdd .decryptBytes (_eba .Stream ,_edg ,_aag );if _fbda !=nil {return _fbda ;};_dceg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eba .Stream ))));return nil ;case *PdfObjectString :_gcg .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_edbd :=_fcd ;if _bdd ._adf .V >=4{_gcg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bdd ._ada );if _bdd ._ada =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_edbd =_bdd ._ada ;};_ggdf ,_efeg :=_bdd .makeKey (_edbd ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bdd ._ade );if _efeg !=nil {return _efeg ;};_ffff :=_eba .Str ();_bcd :=make ([]byte ,len (_ffff ));for _bbg :=0;_bbg < len (_ffff );_bbg ++{_bcd [_bbg ]=_ffff [_bbg ];};_gcg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bcd ,_bcd );_bcd ,_efeg =_bdd .decryptBytes (_bcd ,_edbd ,_ggdf );if _efeg !=nil {return _efeg ;};_eba ._agfdc =string (_bcd );return nil ;case *PdfObjectArray :for _ ,_bec :=range _eba .Elements (){_aede :=_bdd .Decrypt (_bec ,parentObjNum ,parentGenNum );if _aede !=nil {return _aede ;};};return nil ;case *PdfObjectDictionary :_bccgg :=false ;if _eagb :=_eba .Get ("\u0054\u0079\u0070\u0065");_eagb !=nil {_ddaa ,_bcab :=_eagb .(*PdfObjectName );if _bcab &&*_ddaa =="\u0053\u0069\u0067"{_bccgg =true ;};};for _ ,_agb :=range _eba .Keys (){_dcd :=_eba .Get (_agb );if _bccgg &&string (_agb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_agb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_agb )!="\u0050\u0072\u0065\u0076"&&string (_agb )!="\u004c\u0061\u0073\u0074"{_bbe :=_bdd .Decrypt (_dcd ,parentObjNum ,parentGenNum );if _bbe !=nil {return _bbe ;};};};return nil ;};return nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_caca *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_ddgea :=range another .Keys (){_efdfc :=another .Get (_ddgea );_caca .Set (_ddgea ,_efdfc );};};return _caca ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_cgbeg int ,_egcg bool ){_ded ,_egcg :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _egcg &&_ded !=nil {return int (*_ded ),true ;};return 0,false ;};

// Append appends PdfObject(s) to the array.
func (_gccde *PdfObjectArray )Append (objects ...PdfObject ){if _gccde ==nil {_gcg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_gccde ._fggb =append (_gccde ._fggb ,objects ...);};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_faff *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _faff .DecodeBytes (streamObj .Stream );};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _fb .ReadSeeker )(*PdfParser ,error ){_bbeaa :=&PdfParser {_bcbad :rs ,ObjCache :make (objectCache ),_ecde :map[int64 ]bool {}};_ddbeb ,_efebf ,_dbad :=_bbeaa .parsePdfVersion ();if _dbad !=nil {_gcg .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_dbad );return nil ,_dbad ;};_bbeaa ._gaec .Major =_ddbeb ;_bbeaa ._gaec .Minor =_efebf ;if _bbeaa ._fbeed ,_dbad =_bbeaa .loadXrefs ();_dbad !=nil {_gcg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_dbad );return nil ,_dbad ;};_gcg .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_bbeaa ._fbeed );if len (_bbeaa ._ccbg .ObjectMap )==0{return nil ,_bb .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _bbeaa ,nil ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_ffce *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_agfe ,_cad :=_ef .NewImage (_ffce .Width ,_ffce .Height ,_ffce .BitsPerComponent ,_ffce .ColorComponents ,data ,nil ,nil );if _cad !=nil {return nil ,_cad ;};_eed :=_e .Options {};_eed .Quality =_ffce .Quality ;var _debc _gc .Buffer ;if _cad =_e .Encode (&_debc ,_agfe ,&_eed );_cad !=nil {return nil ,_cad ;};return _debc .Bytes (),nil ;};func (_dbded *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _bffg =20;_bdfc ,_ :=_dbded ._cccg .Peek (_bffg );for _deae :=0;_deae < 2;_deae ++{if _dbded ._gcba ==0{_dbded ._gcba =_dbded .GetFileOffset ();};if _gddf .Match (_bdfc ){_gcg .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_gcg .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_bdfc ));return _dbded .parseXrefStream (nil );};if _gfffd .Match (_bdfc ){_gcg .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _dbded .parseXrefTable ();};_eacc :=_dbded .GetFileOffset ();if _dbded ._gcba ==0{_dbded ._gcba =_eacc ;};_dbded .SetFileOffset (_eacc -_bffg );defer _dbded .SetFileOffset (_eacc );_cbee ,_ :=_dbded ._cccg .Peek (_bffg );_bdfc =append (_cbee ,_bdfc ...);};_gcg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _gcagd :=_dbded .repairSeekXrefMarker ();_gcagd !=nil {_gcg .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_gcagd );return nil ,_gcagd ;};return _dbded .parseXrefTable ();};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_ddgf *PdfObjectReference )Resolve ()PdfObject {if _ddgf ._eacef ==nil {return MakeNull ();};_aead ,_ ,_bcga :=_ddgf ._eacef .resolveReference (_ddgf );if _bcga !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_bcga );return MakeNull ();};if _aead ==nil {_gcg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _aead ;};func (_aec *PdfCrypt )decryptBytes (_dgbg []byte ,_dcc string ,_ddeb []byte )([]byte ,error ){_gcg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cbff ,_aece :=_aec ._ddb [_dcc ];if !_aece {return nil ,_bb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dcc );};return _cbff .DecryptBytes (_dgbg ,_ddeb );};func (_ddee *PdfParser )readTextLine ()(string ,error ){var _cdbf _gc .Buffer ;for {_dcb ,_bddg :=_ddee ._cccg .Peek (1);if _bddg !=nil {_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bddg .Error ());return _cdbf .String (),_bddg ;};if (_dcb [0]!='\r')&&(_dcb [0]!='\n'){_bgdd ,_ :=_ddee ._cccg .ReadByte ();_cdbf .WriteByte (_bgdd );}else {break ;};};return _cdbf .String (),nil ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gcg .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_bfge ,_eadgf :=NewEncoderFromStream (streamObj );if _eadgf !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_eadgf );return nil ,_eadgf ;};_gcg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_bfge );_cfdbe ,_eadgf :=_bfge .DecodeStream (streamObj );if _eadgf !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_eadgf );return nil ,_eadgf ;};return _cfdbe ,nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func _bcabc (_gfdd ,_bccc ,_bfca int )error {if _bccc < 0||_bccc > _gfdd {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _bfca < _bccc {return _g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _bfca > _gfdd {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// String returns the state of the bool as "true" or "false".
func (_fcgd *PdfObjectBool )String ()string {if *_fcgd {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_dbbe *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _gfgd []byte ;_gcg .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_afe :=0;_aaf :=false ;for _afe < len (encoded )&&!_aaf {_ebafa :=[5]byte {0,0,0,0,0};_gebg :=0;_gcec :=0;_aab :=4;for _gcec < 5+_gebg {if _afe +_gcec ==len (encoded ){break ;};_daab :=encoded [_afe +_gcec ];if IsWhiteSpace (_daab ){_gebg ++;_gcec ++;continue ;}else if _daab =='~'&&_afe +_gcec +1< len (encoded )&&encoded [_afe +_gcec +1]=='>'{_aab =(_gcec -_gebg )-1;if _aab < 0{_aab =0;};_aaf =true ;break ;}else if _daab >='!'&&_daab <='u'{_daab -='!';}else if _daab =='z'&&_gcec -_gebg ==0{_aab =4;_gcec ++;break ;}else {_gcg .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_ebafa [_gcec -_gebg ]=_daab ;_gcec ++;};_afe +=_gcec ;for _ebbc :=_aab +1;_ebbc < 5;_ebbc ++{_ebafa [_ebbc ]=84;};_cbac :=uint32 (_ebafa [0])*85*85*85*85+uint32 (_ebafa [1])*85*85*85+uint32 (_ebafa [2])*85*85+uint32 (_ebafa [3])*85+uint32 (_ebafa [4]);_affg :=[]byte {byte ((_cbac >>24)&0xff),byte ((_cbac >>16)&0xff),byte ((_cbac >>8)&0xff),byte (_cbac &0xff)};_gfgd =append (_gfgd ,_affg [:_aab ]...);};_gcg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_gcg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_gfgd );return _gfgd ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cefe *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_cefe ._ceda )==0{return nil ;};if len (_cefe ._ceda )==1{return _cefe ._ceda [0].MakeDecodeParams ();};_dgef :=MakeArray ();for _ ,_dfcg :=range _cefe ._ceda {_cbad :=_dfcg .MakeDecodeParams ();if _cbad ==nil {_dgef .Append (MakeNull ());}else {_dgef .Append (_cbad );};};return _dgef ;};func (_cga *PdfCrypt )isDecrypted (_gbad PdfObject )bool {_ ,_gfd :=_cga ._dgc [_gbad ];if _gfd {_gcg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _fbd :=_gbad .(type ){case *PdfObjectStream :if _cga ._bgc .R !=5{if _cde ,_gca :=_fbd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gca &&*_cde =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_gfd =_cga ._gbd [int (_fbd .ObjectNumber )];_gfd {return true ;};switch _aee :=_fbd .PdfObject .(type ){case *PdfObjectDictionary :_fdc :=true ;for _ ,_daea :=range _afgb {if _aee .Get (_daea )==nil {_fdc =false ;break ;};};if _fdc {return true ;};};};_gcg .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// Remove removes an element specified by key.
func (_cbfbf *PdfObjectDictionary )Remove (key PdfObjectName ){_ebaa :=-1;for _febf ,_bgcc :=range _cbfbf ._fdgf {if _bgcc ==key {_ebaa =_febf ;break ;};};if _ebaa >=0{_cbfbf ._fdgf =append (_cbfbf ._fdgf [:_ebaa ],_cbfbf ._fdgf [_ebaa +1:]...);delete (_cbfbf ._fgee ,key );};};func (_acaf *PdfParser )xrefNextObjectOffset (_cgbd int64 )int64 {_caea :=int64 (0);if len (_acaf ._ccbg .ObjectMap )==0{return 0;};if len (_acaf ._ccbg ._ea )==0{_ggbad :=0;for _ ,_abga :=range _acaf ._ccbg .ObjectMap {if _abga .Offset > 0{_ggbad ++;};};if _ggbad ==0{return 0;};_acaf ._ccbg ._ea =make ([]XrefObject ,_ggbad );_ggfa :=0;for _ ,_dfcgc :=range _acaf ._ccbg .ObjectMap {if _dfcgc .Offset > 0{_acaf ._ccbg ._ea [_ggfa ]=_dfcgc ;_ggfa ++;};};_ccd .Slice (_acaf ._ccbg ._ea ,func (_cgfcc ,_fea int )bool {return _acaf ._ccbg ._ea [_cgfcc ].Offset < _acaf ._ccbg ._ea [_fea ].Offset });};_gbdf :=_ccd .Search (len (_acaf ._ccbg ._ea ),func (_ecfc int )bool {return _acaf ._ccbg ._ea [_ecfc ].Offset >=_cgbd });if _gbdf < len (_acaf ._ccbg ._ea ){_caea =_acaf ._ccbg ._ea [_gbdf ].Offset ;};return _caea ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_eacef *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_fggb []PdfObject };const (DefaultJPEGQuality =75;);const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// DecodeBytes decodes the CCITTFax encoded image data.
func (_ggeg *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dbbd :=&_gg .Encoder {K :_ggeg .K ,Columns :_ggeg .Columns ,EndOfLine :_ggeg .EndOfLine ,EndOfBlock :_ggeg .EndOfBlock ,BlackIs1 :_ggeg .BlackIs1 ,DamagedRowsBeforeError :_ggeg .DamagedRowsBeforeError ,Rows :_ggeg .Rows ,EncodedByteAlign :_ggeg .EncodedByteAlign };_adaf ,_cdbg :=_dbbd .Decode (encoded );if _cdbg !=nil {return nil ,_cdbg ;};var _edgee []byte ;_ebbd :=0;var _cfdd byte ;var _ffaea byte ;for _eacd :=range _adaf {if _cfdd !=0{_edgee =append (_edgee ,_ffaea );_ffaea =0;_ebbd ++;_cfdd =0;};for _dcde :=range _adaf [_eacd ]{_ffaea |=_adaf [_eacd ][_dcde ]<<(7-_cfdd );_cfdd ++;if _cfdd ==8{_edgee =append (_edgee ,_ffaea );_ffaea =0;_ebbd ++;_cfdd =0;};};};if _cfdd > 0{_edgee =append (_edgee ,_ffaea );};return _edgee ,nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _gbda _gc .Buffer ;_gbda .Write ([]byte {0xFE,0xFF});_gbda .WriteString (_cfd .StringToUTF16 (s ));return &PdfObjectString {_agfdc :_gbda .String (),_gcef :true };};return &PdfObjectString {_agfdc :string (_cfd .StringToPDFDocEncoding (s )),_gcef :false };};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ggd .FilterDict ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_ebag *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bdbf :=_gc .NewReader (encoded );_cbfb ,_cgaf :=_e .Decode (_bdbf );if _cgaf !=nil {_gcg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cgaf );return nil ,_cgaf ;};_aefbe :=_cbfb .Bounds ();var _ffbf =make ([]byte ,_aefbe .Dx ()*_aefbe .Dy ()*_ebag .ColorComponents *_ebag .BitsPerComponent /8);_dfa :=0;for _ggea :=_aefbe .Min .Y ;_ggea < _aefbe .Max .Y ;_ggea ++{for _adacg :=_aefbe .Min .X ;_adacg < _aefbe .Max .X ;_adacg ++{_dada :=_cbfb .At (_adacg ,_ggea );if _ebag .ColorComponents ==1{if _ebag .BitsPerComponent ==16{_egca ,_bba :=_dada .(_gf .Gray16 );if !_bba {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffbf [_dfa ]=byte ((_egca .Y >>8)&0xff);_dfa ++;_ffbf [_dfa ]=byte (_egca .Y &0xff);_dfa ++;}else {_fafd ,_bbbd :=_dada .(_gf .Gray );if !_bbbd {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffbf [_dfa ]=_fafd .Y &0xff;_dfa ++;};}else if _ebag .ColorComponents ==3{if _ebag .BitsPerComponent ==16{_dff ,_gfb :=_dada .(_gf .RGBA64 );if !_gfb {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffbf [_dfa ]=byte ((_dff .R >>8)&0xff);_dfa ++;_ffbf [_dfa ]=byte (_dff .R &0xff);_dfa ++;_ffbf [_dfa ]=byte ((_dff .G >>8)&0xff);_dfa ++;_ffbf [_dfa ]=byte (_dff .G &0xff);_dfa ++;_ffbf [_dfa ]=byte ((_dff .B >>8)&0xff);_dfa ++;_ffbf [_dfa ]=byte (_dff .B &0xff);_dfa ++;}else {_deb ,_aac :=_dada .(_gf .RGBA );if _aac {_ffbf [_dfa ]=_deb .R &0xff;_dfa ++;_ffbf [_dfa ]=_deb .G &0xff;_dfa ++;_ffbf [_dfa ]=_deb .B &0xff;_dfa ++;}else {_cdea ,_gdeg :=_dada .(_gf .YCbCr );if !_gdeg {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cebg ,_gada ,_agcfd ,_ :=_cdea .RGBA ();_ffbf [_dfa ]=byte (_cebg >>8);_dfa ++;_ffbf [_dfa ]=byte (_gada >>8);_dfa ++;_ffbf [_dfa ]=byte (_agcfd >>8);_dfa ++;};};}else if _ebag .ColorComponents ==4{_ccga ,_aace :=_dada .(_gf .CMYK );if !_aace {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffbf [_dfa ]=255-_ccga .C &0xff;_dfa ++;_ffbf [_dfa ]=255-_ccga .M &0xff;_dfa ++;_ffbf [_dfa ]=255-_ccga .Y &0xff;_dfa ++;_ffbf [_dfa ]=255-_ccga .K &0xff;_dfa ++;};};};return _ffbf ,nil ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_adf encryptDict ;_bgc _ab .StdEncryptDict ;_ba string ;_ade []byte ;_dgc map[PdfObject ]bool ;_dbb map[PdfObject ]bool ;_gcc bool ;_ddb cryptFilters ;_aa string ;_ada string ;_bbd *PdfParser ;_gbd map[int ]struct{};};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_dceca *PdfParser )IsEncrypted ()(bool ,error ){if _dceca ._aedd !=nil {return true ,nil ;}else if _dceca ._fbeed ==nil {return false ,nil ;};_gcg .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_cgbe :=_dceca ._fbeed .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _cgbe ==nil {return false ,nil ;};_gcg .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_ccda *PdfObjectDictionary ;);switch _fcaf :=_cgbe .(type ){case *PdfObjectDictionary :_ccda =_fcaf ;case *PdfObjectReference :_gcg .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_fcaf );_accfe ,_egdgd :=_dceca .LookupByReference (*_fcaf );_gcg .Log .Trace ("\u0031\u003a\u0020%\u0071",_accfe );if _egdgd !=nil {return false ,_egdgd ;};_edc ,_eedg :=_accfe .(*PdfIndirectObject );if !_eedg {_gcg .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_dfde ,_eedg :=_edc .PdfObject .(*PdfObjectDictionary );_gcg .Log .Trace ("\u0032\u003a\u0020%\u0071",_dfde );if !_eedg {return false ,_g .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_ccda =_dfde ;case *PdfObjectNull :_gcg .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_bb .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_fcaf );};_dffc ,_dcgg :=PdfCryptNewDecrypt (_dceca ,_ccda ,_dceca ._fbeed );if _dcgg !=nil {return false ,_dcgg ;};for _ ,_ecbc :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_ggdfb :=_dceca ._fbeed .Get (PdfObjectName (_ecbc ));if _ggdfb ==nil {continue ;};switch _ebbae :=_ggdfb .(type ){case *PdfObjectReference :_dffc ._gbd [int (_ebbae .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_dffc ._dgc [_ebbae ]=true ;_dffc ._gbd [int (_ebbae .ObjectNumber )]=struct{}{};};};_dceca ._aedd =_dffc ;_gcg .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_dffc );return true ,nil ;};func (_dbbea *PdfParser )repairLocateXref ()(int64 ,error ){_efgc :=int64 (1000);_dbbea ._bcbad .Seek (-_efgc ,_fb .SeekCurrent );_cdde ,_gcae :=_dbbea ._bcbad .Seek (0,_fb .SeekCurrent );if _gcae !=nil {return 0,_gcae ;};_gdgaa :=make ([]byte ,_efgc );_dbbea ._bcbad .Read (_gdgaa );_aadfd :=_dece .FindAllStringIndex (string (_gdgaa ),-1);if len (_aadfd )< 1{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_g .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_ddcd :=int64 (_aadfd [len (_aadfd )-1][0]);_eaffg :=_cdde +_ddcd ;return _eaffg ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_ecfec *PdfObjectStreams )Elements ()[]PdfObject {if _ecfec ==nil {return nil ;};return _ecfec ._gccd ;};func (_fgfg *PdfParser )rebuildXrefTable ()error {_aeed :=XrefTable {};_aeed .ObjectMap =map[int ]XrefObject {};_eagd :=make ([]int ,0,len (_fgfg ._ccbg .ObjectMap ));for _ebeca :=range _fgfg ._ccbg .ObjectMap {_eagd =append (_eagd ,_ebeca );};_ccd .Ints (_eagd );for _ ,_abcb :=range _eagd {_cdgc :=_fgfg ._ccbg .ObjectMap [_abcb ];_ddde ,_ ,_eebac :=_fgfg .lookupByNumberWrapper (_abcb ,false );if _eebac !=nil {_gcg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_eebac );_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_ebbaa ,_bfce :=_fgfg .repairRebuildXrefsTopDown ();if _bfce !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_bfce );return _bfce ;};_fgfg ._ccbg =*_ebbaa ;_gcg .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_bgcb ,_ggcce ,_eebac :=_ggg (_ddde );if _eebac !=nil {return _eebac ;};_cdgc .ObjectNumber =int (_bgcb );_cdgc .Generation =int (_ggcce );_aeed .ObjectMap [int (_bgcb )]=_cdgc ;};_fgfg ._ccbg =_aeed ;_gcg .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_eag (_fgfg ._ccbg );return nil ;};

// String returns a string describing `d`.
func (_ddce *PdfObjectDictionary )String ()string {var _eccg _fga .Builder ;_eccg .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_cbgda :=range _ddce ._fdgf {_ddea :=_ddce ._fgee [_cbgda ];_eccg .WriteString ("\u0022"+_cbgda .String ()+"\u0022\u003a\u0020");_eccg .WriteString (_ddea .String ());_eccg .WriteString ("\u002c\u0020");};_eccg .WriteString ("\u0029");return _eccg .String ();};var _faee =_gb .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_bffe *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gadf :=MakeDict ();_gadf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bffe .GetFilterName ()));return _gadf ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_afba :=&PdfIndirectObject {};_afba .PdfObject =obj ;return _afba ;};func (_adff *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_adff ._cccg )};func (_ffcda *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_febc :=_ffcda ._cccg .Discard (4);return PdfObjectNull {},_febc ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dddg *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _cefd []int ;for _ ,_adcdf :=range _dddg .Elements (){if _dbbb ,_gbbc :=_adcdf .(*PdfObjectInteger );_gbbc {_cefd =append (_cefd ,int (*_dbbb ));}else {return nil ,ErrTypeError ;};};return _cefd ,nil ;};func (_cbdd *PdfCrypt )encryptBytes (_dbg []byte ,_bcbag string ,_dfe []byte )([]byte ,error ){_gcg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_bafg ,_eec :=_cbdd ._ddb [_bcbag ];if !_eec {return nil ,_bb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bcbag );};return _bafg .EncryptBytes (_dbg ,_dfe );};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_ccag :=PdfObjectNull {};return &_ccag };

// GetXrefType returns the type of the first xref object (table or stream).
func (_agaed *PdfParser )GetXrefType ()*xrefType {return _agaed ._ecgg };

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_gfde *PdfParser )IsAuthenticated ()bool {return _gfde ._aedd ._gcc };

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_fbg *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_ecade :=data ;var _bgea error ;for _bgba :=len (_fbg ._ceda )-1;_bgba >=0;_bgba --{_gbf :=_fbg ._ceda [_bgba ];_ecade ,_bgea =_gbf .EncodeBytes (_ecade );if _bgea !=nil {return nil ,_bgea ;};};return _ecade ,nil ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_cgac *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _eccgg :=val .(type ){case *PdfObjectName :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectDictionary :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectStream :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectString :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectNull :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectInteger :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectArray :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectBool :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectFloat :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfObjectReference :if _eccgg !=nil {_cgac .Set (key ,val );};case *PdfIndirectObject :if _eccgg !=nil {_cgac .Set (key ,val );};default:_gcg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_cdce *PdfParser )GetCrypter ()*PdfCrypt {return _cdce ._aedd };

// String returns a string describing `array`.
func (_gbfd *PdfObjectArray )String ()string {_afgee :="\u005b";for _edbdb ,_dgage :=range _gbfd .Elements (){_afgee +=_dgage .String ();if _edbdb < (_gbfd .Len ()-1){_afgee +="\u002c\u0020";};};_afgee +="\u005d";return _afgee ;};

// GetFilterName returns the name of the encoding filter.
func (_fed *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_fcae *MultiEncoder )GetFilterArray ()*PdfObjectArray {_bece :=make ([]PdfObject ,len (_fcae ._ceda ));for _afgf ,_ebgf :=range _fcae ._ceda {_bece [_afgf ]=MakeName (_ebgf .GetFilterName ());};return MakeArray (_bece ...);};

// String returns a string representation of the *PdfObjectString.
func (_aacb *PdfObjectString )String ()string {return _aacb ._agfdc };func (_ebcf *PdfParser )skipSpaces ()(int ,error ){_bgabc :=0;for {_egbd ,_fbbf :=_ebcf ._cccg .ReadByte ();if _fbbf !=nil {return 0,_fbbf ;};if IsWhiteSpace (_egbd ){_bgabc ++;}else {_ebcf ._cccg .UnreadByte ();break ;};};return _bgabc ,nil ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_fggga *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _aefd []float64 ;for _ ,_cdbb :=range _fggga .Elements (){_gabcf ,_bcec :=GetNumberAsFloat (TraceToDirectObject (_cdbb ));if _bcec !=nil {return nil ,_bb .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_aefd =append (_aefd ,_gabcf );};return _aefd ,nil ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_edcf *PdfParser )GetObjectNums ()[]int {var _gbfb []int ;for _ ,_eccb :=range _edcf ._ccbg .ObjectMap {_gbfb =append (_gbfb ,_eccb .ObjectNumber );};_ccd .Ints (_gbfb );return _gbfb ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_agfeg *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_gcg .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_fcbc :=MakeDict ();_fcbc ._cadf =_agfeg ;_ebbb ,_ :=_agfeg ._cccg .ReadByte ();if _ebbb !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_ebbb ,_ =_agfeg ._cccg .ReadByte ();if _ebbb !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_agfeg .skipSpaces ();_agfeg .skipComments ();_fgadf ,_gfed :=_agfeg ._cccg .Peek (2);if _gfed !=nil {return nil ,_gfed ;};_gcg .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fgadf ),string (_fgadf ));if (_fgadf [0]=='>')&&(_fgadf [1]=='>'){_gcg .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_agfeg ._cccg .ReadByte ();_agfeg ._cccg .ReadByte ();break ;};_gcg .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_adfg ,_gfed :=_agfeg .parseName ();_gcg .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_adfg );if _gfed !=nil {_gcg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_gfed );return nil ,_gfed ;};if len (_adfg )> 4&&_adfg [len (_adfg )-4:]=="\u006e\u0075\u006c\u006c"{_fdaa :=_adfg [0:len (_adfg )-4];_gcg .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_adfg );_gcg .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_fdaa );_agfeg .skipSpaces ();_efdeb ,_ :=_agfeg ._cccg .Peek (1);if _efdeb [0]=='/'{_fcbc .Set (_fdaa ,MakeNull ());continue ;};};_agfeg .skipSpaces ();_bgg ,_gfed :=_agfeg .parseObject ();if _gfed !=nil {return nil ,_gfed ;};_fcbc .Set (_adfg ,_bgg );if _gcg .Log .IsLogLevel (_gcg .LogLevelTrace ){_gcg .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_adfg ,_bgg .String ());};};_gcg .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _fcbc ,nil ;};func (_ebcc *PdfParser )parseObject ()(PdfObject ,error ){_gcg .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_ebcc .skipSpaces ();for {_gdga ,_acgf :=_ebcc ._cccg .Peek (2);if _acgf !=nil {if _acgf !=_fb .EOF ||len (_gdga )==0{return nil ,_acgf ;};if len (_gdga )==1{_gdga =append (_gdga ,' ');};};_gcg .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_gdga ));if _gdga [0]=='/'{_gacg ,_fefe :=_ebcc .parseName ();_gcg .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_gacg );return &_gacg ,_fefe ;}else if _gdga [0]=='('{_gcg .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_cdaa ,_dace :=_ebcc .parseString ();return _cdaa ,_dace ;}else if _gdga [0]=='['{_gcg .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_geeg ,_aebc :=_ebcc .parseArray ();return _geeg ,_aebc ;}else if (_gdga [0]=='<')&&(_gdga [1]=='<'){_gcg .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_dcea ,_abdf :=_ebcc .ParseDict ();return _dcea ,_abdf ;}else if _gdga [0]=='<'{_gcg .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_aaeee ,_dabe :=_ebcc .parseHexString ();return _aaeee ,_dabe ;}else if _gdga [0]=='%'{_ebcc .readComment ();_ebcc .skipSpaces ();}else {_gcg .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_gdga ,_ =_ebcc ._cccg .Peek (15);_bgef :=string (_gdga );_gcg .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_bgef );if (len (_bgef )> 3)&&(_bgef [:4]=="\u006e\u0075\u006c\u006c"){_ceed ,_cfcf :=_ebcc .parseNull ();return &_ceed ,_cfcf ;}else if (len (_bgef )> 4)&&(_bgef [:5]=="\u0066\u0061\u006cs\u0065"){_bbcb ,_fdee :=_ebcc .parseBool ();return &_bbcb ,_fdee ;}else if (len (_bgef )> 3)&&(_bgef [:4]=="\u0074\u0072\u0075\u0065"){_bbdeb ,_dacdg :=_ebcc .parseBool ();return &_bbdeb ,_dacdg ;};_defd :=_faee .FindStringSubmatch (_bgef );if len (_defd )> 1{_gdga ,_ =_ebcc ._cccg .ReadBytes ('R');_gcg .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_gdga [:]));_fabf ,_abbeg :=_abbd (string (_gdga ));_fabf ._eacef =_ebcc ;return &_fabf ,_abbeg ;};_dfaf :=_ccgf .FindStringSubmatch (_bgef );if len (_dfaf )> 1{_gcg .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_addd ,_defg :=_ebcc .parseNumber ();return _addd ,_defg ;};_dfaf =_dgdf .FindStringSubmatch (_bgef );if len (_dfaf )> 1{_gcg .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_gcg .Log .Trace ("\u0025\u0020\u0073",_dfaf );_cfee ,_acda :=_ebcc .parseNumber ();return _cfee ,_acda ;};_gcg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_bgef );return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// WriteString outputs the object as it is to be written to file.
func (_geac *PdfObjectDictionary )WriteString ()string {var _cbgc _fga .Builder ;_cbgc .WriteString ("\u003c\u003c");for _ ,_acba :=range _geac ._fdgf {_begb :=_geac ._fgee [_acba ];_cbgc .WriteString (_acba .WriteString ());_cbgc .WriteString ("\u0020");_cbgc .WriteString (_begb .WriteString ());};_cbgc .WriteString ("\u003e\u003e");return _cbgc .String ();};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_ggcc *PdfParser )GetTrailer ()*PdfObjectDictionary {return _ggcc ._fbeed };var _afgb =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_agdf *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_agdf ._bcbad .Seek (offset ,_fb .SeekStart );_agdf ._cccg =_cf .NewReader (_agdf ._bcbad );};func (_gecd *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_gecd ._bcbad .Seek (0,_fb .SeekStart );_gecd ._cccg =_cf .NewReader (_gecd ._bcbad );_dedf :=20;_fefc :=make ([]byte ,_dedf );for {_bdfcb ,_dbafa :=_gecd ._cccg .ReadByte ();if _dbafa !=nil {if _dbafa ==_fb .EOF {break ;}else {return 0,0,_dbafa ;};};if IsDecimalDigit (_bdfcb )&&_fefc [_dedf -1]=='.'&&IsDecimalDigit (_fefc [_dedf -2])&&_fefc [_dedf -3]=='-'&&_fefc [_dedf -4]=='F'&&_fefc [_dedf -5]=='D'&&_fefc [_dedf -6]=='P'{_agbfb :=int (_fefc [_dedf -2]-'0');_dfee :=int (_bdfcb -'0');return _agbfb ,_dfee ,nil ;};_fefc =append (_fefc [1:_dedf ],_bdfcb );};return 0,0,_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};func _cgdc (_ebgd _ef .Image )*JBIG2Image {_gdaaa :=_ebgd .Base ();return &JBIG2Image {Data :_gdaaa .Data ,Width :_gdaaa .Width ,Height :_gdaaa .Height ,HasPadding :true };};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_fafcd :=PdfObjectFloat (val );return &_fafcd };

// GetFilterName returns the name of the encoding filter.
func (_ddbgb *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_egbc *PdfObjectDictionary )Keys ()[]PdfObjectName {if _egbc ==nil {return nil ;};return _egbc ._fdgf ;};type objectStream struct{N int ;_gcd []byte ;_dc map[int ]int64 ;};func (_dgcd *PdfCrypt )makeKey (_cbd string ,_gbbe ,_abcg uint32 ,_efa []byte )([]byte ,error ){_bcba ,_dage :=_dgcd ._ddb [_cbd ];if !_dage {return nil ,_bb .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cbd );};return _bcba .MakeKey (_gbbe ,_abcg ,_efa );};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_bab *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ge .Globals ,error ){return _ge .DecodeGlobals (encoded );};var _dgdf =_gb .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// GetFilterName returns the name of the encoding filter.
func (_ggb *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_efdeg *PdfParser )CheckAccessRights (password []byte )(bool ,_ab .Permissions ,error ){if _efdeg ._aedd ==nil {return true ,_ab .PermOwner ,nil ;};return _efdeg ._aedd .checkAccessRights (password );};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_ccfg *_d .Document ;

// Globals are the JBIG2 global segments.
Globals _ge .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_bgac string ,_bdec bool ){_bbce ,_bdec :=TraceToDirectObject (obj ).(*PdfObjectString );if _bdec {return _bbce .Str (),true ;};return ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_cdeg :=MakeArray ();for _ ,_bfg :=range vals {_cdeg .Append (MakeInteger (int64 (_bfg )));};return _cdeg ;};func (_badc *offsetReader )Read (p []byte )(_bceb int ,_aeab error ){return _badc ._bbae .Read (p )};func _ebd (_efba _ggd .Filter ,_bea _ab .AuthEvent )*PdfObjectDictionary {if _bea ==""{_bea =_ab .EventDocOpen ;};_fca :=MakeDict ();_fca .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_fca .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_bea )));_fca .Set ("\u0043\u0046\u004d",MakeName (_efba .Name ()));_fca .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_efba .KeyLength ())));return _fca ;};func _cdfb (_dffb *PdfObjectStream ,_geca *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _bcff ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_bcac :=&JBIG2Encoder {};_adbd :=_dffb .PdfObjectDictionary ;if _adbd ==nil {return _bcac ,nil ;};if _geca ==nil {_cbe :=_adbd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cbe !=nil {switch _ceeb :=_cbe .(type ){case *PdfObjectDictionary :_geca =_ceeb ;case *PdfObjectArray :if _ceeb .Len ()==1{if _gcbb ,_dbca :=GetDict (_ceeb .Get (0));_dbca {_geca =_gcbb ;};};default:_gcg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_cbe );return nil ,_af .Errorf (_bcff ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_ceeb );};};};if _geca ==nil {return _bcac ,nil ;};_bcac .UpdateParams (_geca );_bdagd :=_geca .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _bdagd ==nil {return _bcac ,nil ;};var _dgccf error ;_effg ,_bcbcbd :=_bdagd .(*PdfObjectStream );if !_bcbcbd {_dgccf =_af .Error (_bcff ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_gcg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dgccf );return nil ,_dgccf ;};_bcac .Globals ,_dgccf =_ge .DecodeGlobals (_effg .Stream );if _dgccf !=nil {_dgccf =_af .Wrap (_dgccf ,_bcff ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_gcg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dgccf );return nil ,_dgccf ;};return _bcac ,nil ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func (_aaca *PdfParser )parseBool ()(PdfObjectBool ,error ){_bgagb ,_dfgd :=_aaca ._cccg .Peek (4);if _dfgd !=nil {return PdfObjectBool (false ),_dfgd ;};if (len (_bgagb )>=4)&&(string (_bgagb [:4])=="\u0074\u0072\u0075\u0065"){_aaca ._cccg .Discard (4);return PdfObjectBool (true ),nil ;};_bgagb ,_dfgd =_aaca ._cccg .Peek (5);if _dfgd !=nil {return PdfObjectBool (false ),_dfgd ;};if (len (_bgagb )>=5)&&(string (_bgagb [:5])=="\u0066\u0061\u006cs\u0065"){_aaca ._cccg .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_g .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_abbg *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbag :=MakeDict ();_gbag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_abbg .GetFilterName ()));_gbe :=_abbg .MakeDecodeParams ();if _gbe !=nil {_gbag .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gbe );};_gbag .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_abbg .EarlyChange )));return _gbag ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bdac *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_afc :=MakeDict ();_afc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bdac .GetFilterName ()));_agg :=_bdac .MakeDecodeParams ();if _agg !=nil {_afc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_agg );};return _afc ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_dgbgc *PdfObjectString ,_cefdb bool ){_dgbgc ,_cefdb =TraceToDirectObject (obj ).(*PdfObjectString );return _dgbgc ,_cefdb ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_fgge :=PdfObjectName (s );return &_fgge };

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_afdd *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_afdd .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};func (_fdf *PdfCrypt )isEncrypted (_afae PdfObject )bool {_ ,_aaee :=_fdf ._dbb [_afae ];if _aaee {_gcg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_gcg .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_edeae Version )String ()string {return _bb .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_edeae .Major ,_edeae .Minor );};func _eag (_cba XrefTable ){_gcg .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_gcg .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_aed :=0;for _ ,_efdb :=range _cba .ObjectMap {_gcg .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_aed +1,_efdb .ObjectNumber ,_efdb .Generation ,_efdb .Offset );_aed ++;};};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_dcfe *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dcfe .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_ffa :=&FlateEncoder {};_ffa .Predictor =1;_ffa .BitsPerComponent =8;_ffa .Colors =1;_ffa .Columns =1;return _ffa ;};func _ggg (_bcea PdfObject )(int64 ,int64 ,error ){if _cge ,_ac :=_bcea .(*PdfIndirectObject );_ac {return _cge .ObjectNumber ,_cge .GenerationNumber ,nil ;};if _cbf ,_ddd :=_bcea .(*PdfObjectStream );_ddd {return _cbf .ObjectNumber ,_cbf .GenerationNumber ,nil ;};return 0,0,_g .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};func _cda (_cac *PdfObjectStream ,_gagf *MultiEncoder )(*DCTEncoder ,error ){_ffg :=NewDCTEncoder ();_caa :=_cac .PdfObjectDictionary ;if _caa ==nil {return _ffg ,nil ;};_faf :=_cac .Stream ;if _gagf !=nil {_ebba ,_aaea :=_gagf .DecodeBytes (_faf );if _aaea !=nil {return nil ,_aaea ;};_faf =_ebba ;};_gedf :=_gc .NewReader (_faf );_ddfdg ,_dca :=_e .DecodeConfig (_gedf );if _dca !=nil {_gcg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dca );return nil ,_dca ;};switch _ddfdg .ColorModel {case _gf .RGBAModel :_ffg .BitsPerComponent =8;_ffg .ColorComponents =3;case _gf .RGBA64Model :_ffg .BitsPerComponent =16;_ffg .ColorComponents =3;case _gf .GrayModel :_ffg .BitsPerComponent =8;_ffg .ColorComponents =1;case _gf .Gray16Model :_ffg .BitsPerComponent =16;_ffg .ColorComponents =1;case _gf .CMYKModel :_ffg .BitsPerComponent =8;_ffg .ColorComponents =4;case _gf .YCbCrModel :_ffg .BitsPerComponent =8;_ffg .ColorComponents =3;default:return nil ,_g .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_ffg .Width =_ddfdg .Width ;_ffg .Height =_ddfdg .Height ;_gcg .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_ffg );_ffg .Quality =DefaultJPEGQuality ;return _ffg ,nil ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ebeea *JBIG2Encoder )EncodeImage (img _fg .Image )([]byte ,error ){return _ebeea .encodeImage (img );};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_gccd []PdfObject ;};

// UpdateParams updates the parameter values of the encoder.
func (_cdfd *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};func (_egagg *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _aadbb *PdfObjectDictionary ;_fcgc ,_fgga :=_egagg .readTextLine ();if _fgga !=nil {return nil ,_fgga ;};_gcg .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fcgc );_agddb :=-1;_befc :=0;_faagf :=false ;_febg :="";for {_egagg .skipSpaces ();_ ,_cgfc :=_egagg ._cccg .Peek (1);if _cgfc !=nil {return nil ,_cgfc ;};_fcgc ,_cgfc =_egagg .readTextLine ();if _cgfc !=nil {return nil ,_cgfc ;};_dgad :=_egcae .FindStringSubmatch (_fcgc );if len (_dgad )==0{_cafa :=len (_febg )> 0;_febg +=_fcgc +"\u000a";if _cafa {_dgad =_egcae .FindStringSubmatch (_febg );};};if len (_dgad )==3{_babc ,_ :=_cc .Atoi (_dgad [1]);_efebb ,_ :=_cc .Atoi (_dgad [2]);_agddb =_babc ;_befc =_efebb ;_faagf =true ;_febg ="";_gcg .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_agddb ,_befc );continue ;};_fbgf :=_gfea .FindStringSubmatch (_fcgc );if len (_fbgf )==4{if !_faagf {_gcg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_g .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_dgbbf ,_ :=_cc .ParseInt (_fbgf [1],10,64);_aadbg ,_ :=_cc .Atoi (_fbgf [2]);_cecf :=_fbgf [3];_febg ="";if _fga .ToLower (_cecf )=="\u006e"&&_dgbbf > 1{_ccad ,_dgcca :=_egagg ._ccbg .ObjectMap [_agddb ];if !_dgcca ||_aadbg > _ccad .Generation {_caac :=XrefObject {ObjectNumber :_agddb ,XType :XrefTypeTableEntry ,Offset :_dgbbf ,Generation :_aadbg };_egagg ._ccbg .ObjectMap [_agddb ]=_caac ;};};_agddb ++;continue ;};if (len (_fcgc )> 6)&&(_fcgc [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_gcg .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_fcgc );if len (_fcgc )> 9{_bdgf :=_egagg .GetFileOffset ();_egagg .SetFileOffset (_bdgf -int64 (len (_fcgc ))+7);};_egagg .skipSpaces ();_egagg .skipComments ();_gcg .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_gcg .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_fcgc );_aadbb ,_cgfc =_egagg .ParseDict ();_gcg .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _cgfc !=nil {_gcg .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cgfc );return nil ,_cgfc ;};break ;};if _fcgc =="\u0025\u0025\u0045O\u0046"{_gcg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_g .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_gcg .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_fcgc );};_gcg .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _egagg ._ecgg ==nil {_gaa :=XrefTypeTableEntry ;_egagg ._ecgg =&_gaa ;};return _aadbb ,nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_cf .Reader )(PdfObject ,error ){_gcbba :=false ;_aebcd :=true ;var _bffbg _gc .Buffer ;for {if _gcg .Log .IsLogLevel (_gcg .LogLevelTrace ){_gcg .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_bffbg .String ());};_fegd ,_agfa :=buf .Peek (1);if _agfa ==_fb .EOF {break ;};if _agfa !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_agfa );return nil ,_agfa ;};if _aebcd &&(_fegd [0]=='-'||_fegd [0]=='+'){_aedb ,_ :=buf .ReadByte ();_bffbg .WriteByte (_aedb );_aebcd =false ;}else if IsDecimalDigit (_fegd [0]){_fceff ,_ :=buf .ReadByte ();_bffbg .WriteByte (_fceff );}else if _fegd [0]=='.'{_cfacd ,_ :=buf .ReadByte ();_bffbg .WriteByte (_cfacd );_gcbba =true ;}else if _fegd [0]=='e'||_fegd [0]=='E'{_gced ,_ :=buf .ReadByte ();_bffbg .WriteByte (_gced );_gcbba =true ;_aebcd =true ;}else {break ;};};var _gfefe PdfObject ;if _gcbba {_egage ,_ebeg :=_cc .ParseFloat (_bffbg .String (),64);if _ebeg !=nil {_gcg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_bffbg .String (),_ebeg );_egage =0.0;};_aggf :=PdfObjectFloat (_egage );_gfefe =&_aggf ;}else {_bafa ,_eddf :=_cc .ParseInt (_bffbg .String (),10,64);if _eddf !=nil {_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_bffbg .String (),_eddf );_bafa =0;};_adaa :=PdfObjectInteger (_bafa );_gfefe =&_adaa ;};return _gfefe ,nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _dagd (obj ,0)};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_egbb *MultiEncoder )GetFilterName ()string {_gdaa :="";for _agcb ,_faffg :=range _egbb ._ceda {_gdaa +=_faffg .GetFilterName ();if _agcb < len (_egbb ._ceda )-1{_gdaa +="\u0020";};};return _gdaa ;};

// String returns a string describing `null`.
func (_acfaf *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func (_ebb *PdfCrypt )loadCryptFilters (_adg *PdfObjectDictionary )error {_ebb ._ddb =cryptFilters {};_bgb :=_adg .Get ("\u0043\u0046");_bgb =TraceToDirectObject (_bgb );if _abc ,_fff :=_bgb .(*PdfObjectReference );_fff {_fcb ,_fdd :=_ebb ._bbd .LookupByReference (*_abc );if _fdd !=nil {_gcg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _fdd ;};_bgb =TraceToDirectObject (_fcb );};_cbgd ,_cfb :=_bgb .(*PdfObjectDictionary );if !_cfb {_gcg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_bgb );return _g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_cebc :=range _cbgd .Keys (){_eea :=_cbgd .Get (_cebc );if _cef ,_eaa :=_eea .(*PdfObjectReference );_eaa {_ddgc ,_cbgb :=_ebb ._bbd .LookupByReference (*_cef );if _cbgb !=nil {_gcg .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _cbgb ;};_eea =TraceToDirectObject (_ddgc );};_cec ,_ecc :=_eea .(*PdfObjectDictionary );if !_ecc {return _bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cebc ,_eea );};if _cebc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _ega _ggd .FilterDict ;if _acce :=_ebg (&_ega ,_cec );_acce !=nil {return _acce ;};_ecb ,_fbe :=_ggd .NewFilter (_ega );if _fbe !=nil {return _fbe ;};_ebb ._ddb [string (_cebc )]=_ecb ;};_ebb ._ddb ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ggd .NewIdentity ();_ebb ._ada ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cfbe ,_ddfd :=_adg .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ddfd {if _ ,_dfg :=_ebb ._ddb [string (*_cfbe )];!_dfg {return _bb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_cfbe );};_ebb ._ada =string (*_cfbe );};_ebb ._aa ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fad ,_cfeg :=_adg .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_cfeg {if _ ,_gfc :=_ebb ._ddb [string (*_fad )];!_gfc {return _bb .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fad );};_ebb ._aa =string (*_fad );};return nil ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};func _abbd (_gceb string )(PdfObjectReference ,error ){_gegc :=PdfObjectReference {};_dbgf :=_faee .FindStringSubmatch (_gceb );if len (_dbgf )< 3{_gcg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _gegc ,_g .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_cfeab ,_ :=_cc .Atoi (_dbgf [1]);_ebfcf ,_ :=_cc .Atoi (_dbgf [2]);_gegc .ObjectNumber =int64 (_cfeab );_gegc .GenerationNumber =int64 (_ebfcf );return _gegc ,nil ;};

// String returns a string describing `ind`.
func (_ccgc *PdfIndirectObject )String ()string {return _bb .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_ccgc ).ObjectNumber );};

// Elements returns a slice of the PdfObject elements in the array.
func (_fdaf *PdfObjectArray )Elements ()[]PdfObject {if _fdaf ==nil {return nil ;};return _fdaf ._fggb ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};var _gfea =_gb .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");func (_fbb *PdfCrypt )securityHandler ()_ab .StdHandler {if _fbb ._bgc .R >=5{return _ab .NewHandlerR6 ();};return _ab .NewHandlerR4 (_fbb ._ba ,_fbb ._adf .Length );};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_ecfg *PdfIndirectObject ,_aegfa bool ){obj =ResolveReference (obj );_ecfg ,_aegfa =obj .(*PdfIndirectObject );return _ecfg ,_aegfa ;};var _dece =_gb .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_baae :=MakeArray ();for _ ,_gedg :=range vals {_baae .Append (MakeFloat (_gedg ));};return _baae ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_gcbd *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_gcbd ._gccd ){return _g .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_gcbd ._gccd [i ]=obj ;return nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_eegg *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eegg .DecodeBytes (streamObj .Stream );};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_cdda []float64 ,_aafg error ){for _ ,_gbdac :=range objects {_bggg ,_gcge :=GetNumberAsFloat (_gbdac );if _gcge !=nil {return nil ,_gcge ;};_cdda =append (_cdda ,_bggg );};return _cdda ,nil ;};func _cfbg (_gfgf *PdfObjectStream ,_gacd *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_aaff :=NewCCITTFaxEncoder ();_bbgd :=_gfgf .PdfObjectDictionary ;if _bbgd ==nil {return _aaff ,nil ;};if _gacd ==nil {_agfg :=TraceToDirectObject (_bbgd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _agfg !=nil {switch _dccbc :=_agfg .(type ){case *PdfObjectDictionary :_gacd =_dccbc ;case *PdfObjectArray :if _dccbc .Len ()==1{if _eace ,_fbcd :=GetDict (_dccbc .Get (0));_fbcd {_gacd =_eace ;};};default:_gcg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_agfg );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gacd ==nil {_gcg .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_agfg );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _becg ,_fbee :=GetNumberAsInt64 (_gacd .Get ("\u004b"));_fbee ==nil {_aaff .K =int (_becg );};if _bdbb ,_ceec :=GetNumberAsInt64 (_gacd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_ceec ==nil {_aaff .Columns =int (_bdbb );}else {_aaff .Columns =1728;};if _aafc ,_deeb :=GetNumberAsInt64 (_gacd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_deeb ==nil {_aaff .BlackIs1 =_aafc > 0;}else {if _cgb ,_eeee :=GetBoolVal (_gacd .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eeee {_aaff .BlackIs1 =_cgb ;}else {if _gbdb ,_cdc :=GetArray (_gacd .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_cdc {_ccb ,_cgc :=_gbdb .ToIntegerArray ();if _cgc ==nil {_aaff .BlackIs1 =_ccb [0]==1&&_ccb [1]==0;};};};};if _cged ,_acad :=GetNumberAsInt64 (_gacd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_acad ==nil {_aaff .EncodedByteAlign =_cged > 0;}else {if _fgbc ,_bged :=GetBoolVal (_gacd .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bged {_aaff .EncodedByteAlign =_fgbc ;};};if _bceac ,_bcee :=GetNumberAsInt64 (_gacd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bcee ==nil {_aaff .EndOfLine =_bceac > 0;}else {if _accb ,_bgaf :=GetBoolVal (_gacd .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bgaf {_aaff .EndOfLine =_accb ;};};if _gcaf ,_gdea :=GetNumberAsInt64 (_gacd .Get ("\u0052\u006f\u0077\u0073"));_gdea ==nil {_aaff .Rows =int (_gcaf );};_aaff .EndOfBlock =true ;if _ccdeb ,_fbdb :=GetNumberAsInt64 (_gacd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fbdb ==nil {_aaff .EndOfBlock =_ccdeb > 0;}else {if _edff ,_geef :=GetBoolVal (_gacd .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_geef {_aaff .EndOfBlock =_edff ;};};if _adggd ,_dbgc :=GetNumberAsInt64 (_gacd .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_dbgc !=nil {_aaff .DamagedRowsBeforeError =int (_adggd );};_gcg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gacd .String ());return _aaff ,nil ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_fbeb *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ge .DecodeBytes (encoded ,_cg .Parameters {},_fbeb .Globals );};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_cdcb *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _dbc ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _cdcb .ColorComponents !=1||_cdcb .BitsPerComponent !=1{return nil ,_af .Errorf (_dbc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_dddc *_fe .Bitmap ;_bgbg error ;);_bffb :=(_cdcb .Width *_cdcb .Height )==len (data );if _bffb {_dddc ,_bgbg =_fe .NewWithUnpaddedData (_cdcb .Width ,_cdcb .Height ,data );}else {_dddc ,_bgbg =_fe .NewWithData (_cdcb .Width ,_cdcb .Height ,data );};if _bgbg !=nil {return nil ,_bgbg ;};_bgbc :=_cdcb .DefaultPageSettings ;if _bgbg =_bgbc .Validate ();_bgbg !=nil {return nil ,_af .Wrap (_bgbg ,_dbc ,"");};switch _bgbc .Compression {case JB2Generic :if _bgbg =_cdcb ._ccfg .AddGenericPage (_dddc ,_bgbc .DuplicatedLinesRemoval );_bgbg !=nil {return nil ,_af .Wrap (_bgbg ,_dbc ,"");};case JB2SymbolCorrelation :return nil ,_af .Error (_dbc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_af .Error (_dbc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_af .Error (_dbc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _cdcb .Encode ();};var _afdg =_gb .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// UpdateParams updates the parameter values of the encoder.
func (_fgggc *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_aabc :=range _fgggc ._ceda {_aabc .UpdateParams (params );};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_afd *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// EncodeBytes encodes data into ASCII85 encoded format.
func (_gda *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _fafff _gc .Buffer ;for _dgcc :=0;_dgcc < len (data );_dgcc +=4{_deaf :=data [_dgcc ];_cddb :=1;_dgde :=byte (0);if _dgcc +1< len (data ){_dgde =data [_dgcc +1];_cddb ++;};_faede :=byte (0);if _dgcc +2< len (data ){_faede =data [_dgcc +2];_cddb ++;};_afgg :=byte (0);if _dgcc +3< len (data ){_afgg =data [_dgcc +3];_cddb ++;};_bcbe :=(uint32 (_deaf )<<24)|(uint32 (_dgde )<<16)|(uint32 (_faede )<<8)|uint32 (_afgg );if _bcbe ==0{_fafff .WriteByte ('z');}else {_fcec :=_gda .base256Tobase85 (_bcbe );for _ ,_adced :=range _fcec [:_cddb +1]{_fafff .WriteByte (_adced +'!');};};};_fafff .WriteString ("\u007e\u003e");return _fafff .Bytes (),nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_gaec Version ;_bcbad _fb .ReadSeeker ;_cccg *_cf .Reader ;_cfga int64 ;_ccbg XrefTable ;_gcba int64 ;_ecgg *xrefType ;_gabad objectStreams ;_fbeed *PdfObjectDictionary ;_aedd *PdfCrypt ;_bgab bool ;ObjCache objectCache ;_ecde map[int64 ]bool ;};

// UpdateParams updates the parameter values of the encoder.
func (_edfc *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_efgd *PdfObjectArray ,_eedb bool ){_efgd ,_eedb =TraceToDirectObject (obj ).(*PdfObjectArray );return _efgd ,_eedb ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};func (_gefgd *PdfObjectInteger )String ()string {return _bb .Sprintf ("\u0025\u0064",*_gefgd )};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// GetFilterName returns the name of the encoding filter.
func (_baec *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_adce *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _adce .DecodeBytes (streamObj .Stream );};

// SetImage sets the image base for given flate encoder.
func (_bfd *FlateEncoder )SetImage (img *_ef .ImageBase ){_bfd ._cee =img };func (_aaad *PdfParser )seekToEOFMarker (_dgba int64 )error {var _abge int64 ;var _dfgc int64 =2048;for _abge < _dgba -4{if _dgba <=(_dfgc +_abge ){_dfgc =_dgba -_abge ;};_ ,_bcffd :=_aaad ._bcbad .Seek (-_abge -_dfgc ,_fb .SeekEnd );if _bcffd !=nil {return _bcffd ;};_gfaa :=make ([]byte ,_dfgc );_aaad ._bcbad .Read (_gfaa );_gcg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_gfaa ));_gefc :=_bcge .FindAllStringIndex (string (_gfaa ),-1);if _gefc !=nil {_eda :=_gefc [len (_gefc )-1];_gcg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gefc );_aaad ._bcbad .Seek (-_abge -_dfgc +int64 (_eda [0]),_fb .SeekEnd );return nil ;};_gcg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_abge +=_dfgc -4;};_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _g .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_ebec *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _cbda _gc .Buffer ;_eaac :=_gc .NewReader (encoded );var _efdc _fb .ReadCloser ;if _ebec .EarlyChange ==1{_efdc =_ag .NewReader (_eaac ,_ag .MSB ,8);}else {_efdc =_gd .NewReader (_eaac ,_gd .MSB ,8);};defer _efdc .Close ();_ ,_gac :=_cbda .ReadFrom (_efdc );if _gac !=nil {return nil ,_gac ;};return _cbda .Bytes (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fbbb *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_daee *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_ace :=MakeDict ();_ace .Set ("\u004b",MakeInteger (int64 (_daee .K )));_ace .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_daee .Columns )));if _daee .BlackIs1 {_ace .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_daee .BlackIs1 ));};if _daee .EncodedByteAlign {_ace .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_daee .EncodedByteAlign ));};if _daee .EndOfLine &&_daee .K >=0{_ace .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_daee .EndOfLine ));};if _daee .Rows !=0&&!_daee .EndOfBlock {_ace .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_daee .Rows )));};if !_daee .EndOfBlock {_ace .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_daee .EndOfBlock ));};if _daee .DamagedRowsBeforeError !=0{_ace .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_daee .DamagedRowsBeforeError )));};return _ace ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_afff :=PdfObjectBool (val );return &_afff };func _abda (_dfdef PdfObject ,_fgcfe int ,_bgae map[PdfObject ]struct{})error {_gcg .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_fgcfe );if _ ,_gfedf :=_bgae [_dfdef ];_gfedf {_gcg .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_bgae [_dfdef ]=struct{}{};switch _fdfc :=_dfdef .(type ){case *PdfIndirectObject :_fgde :=_fdfc ;_gcg .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_fgde );_gcg .Log .Trace ("\u002d\u0020\u0025\u0073",_fgde .PdfObject );return _abda (_fgde .PdfObject ,_fgcfe +1,_bgae );case *PdfObjectStream :_fafe :=_fdfc ;return _abda (_fafe .PdfObjectDictionary ,_fgcfe +1,_bgae );case *PdfObjectDictionary :_aaadc :=_fdfc ;_gcg .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_aaadc );for _ ,_fbae :=range _aaadc .Keys (){_ecfb :=_aaadc .Get (_fbae );if _fgcg ,_eggg :=_ecfb .(*PdfObjectReference );_eggg {_fade :=_fgcg .Resolve ();_aaadc .Set (_fbae ,_fade );_cbaf :=_abda (_fade ,_fgcfe +1,_bgae );if _cbaf !=nil {return _cbaf ;};}else {_ecfbb :=_abda (_ecfb ,_fgcfe +1,_bgae );if _ecfbb !=nil {return _ecfbb ;};};};return nil ;case *PdfObjectArray :_bbfgd :=_fdfc ;_gcg .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_bbfgd );for _cfcc ,_dgdc :=range _bbfgd .Elements (){if _cceg ,_fcgdb :=_dgdc .(*PdfObjectReference );_fcgdb {_agdb :=_cceg .Resolve ();_bbfgd .Set (_cfcc ,_agdb );_egac :=_abda (_agdb ,_fgcfe +1,_bgae );if _egac !=nil {return _egac ;};}else {_fadc :=_abda (_dgdc ,_fgcfe +1,_bgae );if _fadc !=nil {return _fadc ;};};};return nil ;case *PdfObjectReference :_gcg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _g .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_feff *RawEncoder )MakeDecodeParams ()PdfObject {return nil };func _fgef (_gdab ,_bgbdb PdfObject ,_aedaf int )bool {if _aedaf > _afabf {_gcg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_afabf );return false ;};if _gdab ==nil &&_bgbdb ==nil {return true ;}else if _gdab ==nil ||_bgbdb ==nil {return false ;};if _c .TypeOf (_gdab )!=_c .TypeOf (_bgbdb ){return false ;};switch _ffbef :=_gdab .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_ffbef ==*(_bgbdb .(*PdfObjectName ));case *PdfObjectString :return *_ffbef ==*(_bgbdb .(*PdfObjectString ));case *PdfObjectInteger :return *_ffbef ==*(_bgbdb .(*PdfObjectInteger ));case *PdfObjectBool :return *_ffbef ==*(_bgbdb .(*PdfObjectBool ));case *PdfObjectFloat :return *_ffbef ==*(_bgbdb .(*PdfObjectFloat ));case *PdfIndirectObject :return _fgef (TraceToDirectObject (_gdab ),TraceToDirectObject (_bgbdb ),_aedaf +1);case *PdfObjectArray :_dabeb :=_bgbdb .(*PdfObjectArray );if len ((*_ffbef )._fggb )!=len ((*_dabeb )._fggb ){return false ;};for _cgbb ,_agbfc :=range (*_ffbef )._fggb {if !_fgef (_agbfc ,(*_dabeb )._fggb [_cgbb ],_aedaf +1){return false ;};};return true ;case *PdfObjectDictionary :_ggca :=_bgbdb .(*PdfObjectDictionary );_gadfb ,_bgeg :=(*_ffbef )._fgee ,(*_ggca )._fgee ;if len (_gadfb )!=len (_bgeg ){return false ;};for _gege ,_ebagf :=range _gadfb {_ffca ,_aagf :=_bgeg [_gege ];if !_aagf ||!_fgef (_ebagf ,_ffca ,_aedaf +1){return false ;};};return true ;case *PdfObjectStream :_bedg :=_bgbdb .(*PdfObjectStream );return _fgef ((*_ffbef ).PdfObjectDictionary ,(*_bedg ).PdfObjectDictionary ,_aedaf +1);default:_gcg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_gdab );};return false ;};

// GetXrefOffset returns the offset of the xref table.
func (_ddad *PdfParser )GetXrefOffset ()int64 {return _ddad ._gcba };func _fgd (_eaaa *PdfObjectStream ,_cddg *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_cgdb []byte ,_geea bool ){_dfeb ,_geea :=TraceToDirectObject (obj ).(*PdfObjectString );if _geea {return _dfeb .Bytes (),true ;};return ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// WriteString outputs the object as it is to be written to file.
func (_ffcc *PdfObjectString )WriteString ()string {var _cbbe _gc .Buffer ;if _ffcc ._gcef {_gefgf :=_ed .EncodeToString (_ffcc .Bytes ());_cbbe .WriteString ("\u003c");_cbbe .WriteString (_gefgf );_cbbe .WriteString ("\u003e");return _cbbe .String ();};_dfdb :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_cbbe .WriteString ("\u0028");for _gfebd :=0;_gfebd < len (_ffcc ._agfdc );_gfebd ++{_adagf :=_ffcc ._agfdc [_gfebd ];if _dfbc ,_dcaf :=_dfdb [_adagf ];_dcaf {_cbbe .WriteString (_dfbc );}else {_cbbe .WriteByte (_adagf );};};_cbbe .WriteString ("\u0029");return _cbbe .String ();};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_cccgb :=_gc .NewReader ([]byte (txt ));_edbdd :=&PdfParser {ObjCache :objectCache {},_bcbad :_cccgb ,_cccg :_cf .NewReader (_cccgb ),_cfga :int64 (len (txt )),_ecde :map[int64 ]bool {}};_edbdd ._ccbg .ObjectMap =make (map[int ]XrefObject );return _edbdd ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_dfad :=&ASCIIHexEncoder {};return _dfad };

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_eadc *JBIG2Encoder )DecodeImages (encoded []byte )([]_fg .Image ,error ){const _eedf ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_afggb ,_fgeg :=_cg .Decode (encoded ,_cg .Parameters {},_eadc .Globals .ToDocumentGlobals ());if _fgeg !=nil {return nil ,_af .Wrap (_fgeg ,_eedf ,"");};_beaa ,_fgeg :=_afggb .PageNumber ();if _fgeg !=nil {return nil ,_af .Wrap (_fgeg ,_eedf ,"");};_baad :=[]_fg .Image {};var _caae _fg .Image ;for _add :=1;_add <=_beaa ;_add ++{_caae ,_fgeg =_afggb .DecodePageImage (_add );if _fgeg !=nil {return nil ,_af .Wrapf (_fgeg ,_eedf ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_add );};_baad =append (_baad ,_caae );};return _baad ,nil ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _fgef (obj1 ,obj2 ,0)};func (_cccd *PdfParser )traceStreamLength (_feae PdfObject )(PdfObject ,error ){_abgcc ,_defa :=_feae .(*PdfObjectReference );if _defa {_eadb ,_ffdc :=_cccd ._ecde [_abgcc .ObjectNumber ];if _ffdc &&_eadb {_gcg .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_g .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_cccd ._ecde [_abgcc .ObjectNumber ]=true ;};_cdbe ,_fecc :=_cccd .Resolve (_feae );if _fecc !=nil {return nil ,_fecc ;};_gcg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cdbe );if _defa {_cccd ._ecde [_abgcc .ObjectNumber ]=false ;};return _cdbe ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_cegb *PdfObjectFloat )WriteString ()string {return _cc .FormatFloat (float64 (*_cegb ),'f',-1,64);};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ccdea *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// UpdateParams updates the parameter values of the encoder.
func (_cafdf *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// LookupByReference looks up a PdfObject by a reference.
func (_ceb *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_gcg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _ceb .LookupByNumber (int (ref .ObjectNumber ));};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _cdfe ,_aacc :=obj .(*PdfObjectReference );_aacc {obj =_cdfe .Resolve ();};_bbaed ,_bega :=obj .(*PdfIndirectObject );_fcef :=0;for _bega {obj =_bbaed .PdfObject ;_bbaed ,_bega =GetIndirect (obj );_fcef ++;if _fcef > _afabf {_gcg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_afabf );return nil ;};};return obj ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;func (_bcda *PdfParser )parseString ()(*PdfObjectString ,error ){_bcda ._cccg .ReadByte ();var _bddf _gc .Buffer ;_fgec :=1;for {_acfg ,_cfacg :=_bcda ._cccg .Peek (1);if _cfacg !=nil {return MakeString (_bddf .String ()),_cfacg ;};if _acfg [0]=='\\'{_bcda ._cccg .ReadByte ();_caeb ,_edgf :=_bcda ._cccg .ReadByte ();if _edgf !=nil {return MakeString (_bddf .String ()),_edgf ;};if IsOctalDigit (_caeb ){_afeg ,_gged :=_bcda ._cccg .Peek (2);if _gged !=nil {return MakeString (_bddf .String ()),_gged ;};var _deca []byte ;_deca =append (_deca ,_caeb );for _ ,_fedc :=range _afeg {if IsOctalDigit (_fedc ){_deca =append (_deca ,_fedc );}else {break ;};};_bcda ._cccg .Discard (len (_deca )-1);_gcg .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_deca );_fde ,_gged :=_cc .ParseUint (string (_deca ),8,32);if _gged !=nil {return MakeString (_bddf .String ()),_gged ;};_bddf .WriteByte (byte (_fde ));continue ;};switch _caeb {case 'n':_bddf .WriteRune ('\n');case 'r':_bddf .WriteRune ('\r');case 't':_bddf .WriteRune ('\t');case 'b':_bddf .WriteRune ('\b');case 'f':_bddf .WriteRune ('\f');case '(':_bddf .WriteRune ('(');case ')':_bddf .WriteRune (')');case '\\':_bddf .WriteRune ('\\');};continue ;}else if _acfg [0]=='('{_fgec ++;}else if _acfg [0]==')'{_fgec --;if _fgec ==0{_bcda ._cccg .ReadByte ();break ;};};_eggc ,_ :=_bcda ._cccg .ReadByte ();_bddf .WriteByte (_eggc );};return MakeString (_bddf .String ()),nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_cgaa *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_ggge error ){const _beda ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _cgaa ==nil {return _af .Error (_beda ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_cgaa .DefaultPageSettings ;};if _cgaa ._ccfg ==nil {_cgaa ._ccfg =_d .InitEncodeDocument (settings .FileMode );};if _ggge =settings .Validate ();_ggge !=nil {return _af .Wrap (_ggge ,_beda ,"");};_fagf ,_ggge :=img .toBitmap ();if _ggge !=nil {return _af .Wrap (_ggge ,_beda ,"");};switch settings .Compression {case JB2Generic :if _ggge =_cgaa ._ccfg .AddGenericPage (_fagf ,settings .DuplicatedLinesRemoval );_ggge !=nil {return _af .Wrap (_ggge ,_beda ,"");};case JB2SymbolCorrelation :return _af .Error (_beda ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _af .Error (_beda ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _af .Error (_beda ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_dfegg *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_bdef :=MakeDict ();_bdef .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dfegg .GetFilterName ()));return _bdef ;};func (_gccg *PdfCrypt )authenticate (_bca []byte )(bool ,error ){_gccg ._gcc =false ;_abcc :=_gccg .securityHandler ();_aae ,_gadb ,_bccg :=_abcc .Authenticate (&_gccg ._bgc ,_bca );if _bccg !=nil {return false ,_bccg ;}else if _gadb ==0||len (_aae )==0{return false ,nil ;};_gccg ._gcc =true ;_gccg ._ade =_aae ;return true ,nil ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_ebge :=PdfObjectInteger (val );return &_ebge };func (_edbf *PdfParser )parseHexString ()(*PdfObjectString ,error ){_edbf ._cccg .ReadByte ();var _dfcd _gc .Buffer ;for {_fgad ,_bccff :=_edbf ._cccg .Peek (1);if _bccff !=nil {return MakeString (""),_bccff ;};if _fgad [0]=='>'{_edbf ._cccg .ReadByte ();break ;};_cebca ,_ :=_edbf ._cccg .ReadByte ();if !IsWhiteSpace (_cebca ){_dfcd .WriteByte (_cebca );};};if _dfcd .Len ()%2==1{_dfcd .WriteRune ('0');};_dgdea ,_ :=_ed .DecodeString (_dfcd .String ());return MakeHexString (string (_dgdea )),nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_gcbg :=&ASCII85Encoder {};return _gcbg };

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_gccb *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_bbbdc *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_efcf ,_fgfa :=_bbbdc ._fgee [key ].(*PdfObjectString );if !_fgfa {return "",false ;};return _efcf .Str (),true ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);func _bgde (_dfegc _fb .ReadSeeker ,_ggfe int64 )(*offsetReader ,error ){_eaee :=&offsetReader {_bbae :_dfegc ,_afgea :_ggfe };_ ,_gcbf :=_eaee .Seek (0,_fb .SeekStart );return _eaee ,_gcbf ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dccb *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};var _gbdbe =_gb .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_gf .Model ;Bounds ()_fg .Rectangle ;At (_abed ,_dfc int )_gf .Color ;Set (_gfe ,_faaa int ,_dccd _gf .Color );};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_ggba *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _dbed ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _agdd :=_ggba .AddPageImage (img ,&_ggba .DefaultPageSettings );_agdd !=nil {return nil ,_af .Wrap (_agdd ,_dbed ,"");};return _ggba .Encode ();};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_baffc float64 ,_ffage bool ){_dacg ,_ffage :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _ffage {return float64 (*_dacg ),true ;};return 0,false ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_agcbc *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_cgfd :=_agcbc .GetFileOffset ();_ ,_gade :=_agcbc ._bcbad .Seek (offset ,_fb .SeekStart );if _gade !=nil {return nil ,_gade ;};_efbc :=make ([]byte ,len );_ ,_gade =_fb .ReadAtLeast (_agcbc ._bcbad ,_efbc ,int (len ));if _gade !=nil {return nil ,_gade ;};_agcbc .SetFileOffset (_cgfd );return _efbc ,nil ;};const JB2ImageAutoThreshold =-1.0;

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_dcge *JBIG2Image )ToGoImage ()(_fg .Image ,error ){const _aeegc ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _dcge .Data ==nil {return nil ,_af .Error (_aeegc ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _dcge .Width ==0||_dcge .Height ==0{return nil ,_af .Error (_aeegc ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_dcgff ,_adbc :=_ef .NewImage (_dcge .Width ,_dcge .Height ,1,1,_dcge .Data ,nil ,nil );if _adbc !=nil {return nil ,_adbc ;};return _dcgff ,nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_cee *_ef .ImageBase ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_cfea *MultiEncoder )AddEncoder (encoder StreamEncoder ){_cfea ._ceda =append (_cfea ._ceda ,encoder );};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_agfdc string ;_gcef bool ;};func (_baea *PdfParser )resolveReference (_dbdag *PdfObjectReference )(PdfObject ,bool ,error ){_baeba ,_efbf :=_baea .ObjCache [int (_dbdag .ObjectNumber )];if _efbf {return _baeba ,true ,nil ;};_fgbg ,_cffe :=_baea .LookupByReference (*_dbdag );if _cffe !=nil {return nil ,false ,_cffe ;};_baea .ObjCache [int (_dbdag .ObjectNumber )]=_fgbg ;return _fgbg ,false ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func _eddb (_bada int )int {if _bada < 0{return -_bada ;};return _bada ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bgeaf ,_dfbd :=obj .(*PdfObjectReference );_dfbd {return _bgeaf .Resolve ();};return obj ;};func _egab (_dfbb *PdfObjectDictionary )(_daeef *_ef .ImageBase ){var (_aedf *PdfObjectInteger ;_eeba bool ;);if _aedf ,_eeba =_dfbb .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_eeba {_daeef =&_ef .ImageBase {Width :int (*_aedf )};}else {return nil ;};if _aedf ,_eeba =_dfbb .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_eeba {_daeef .Height =int (*_aedf );};if _aedf ,_eeba =_dfbb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_eeba {_daeef .BitsPerComponent =int (*_aedf );};if _aedf ,_eeba =_dfbb .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_eeba {_daeef .ColorComponents =int (*_aedf );};return _daeef ;};func (_dbba *PdfCrypt )generateParams (_edge ,_ddbc []byte )error {_aebb :=_dbba .securityHandler ();_fddd ,_dbe :=_aebb .GenerateParams (&_dbba ._bgc ,_ddbc ,_edge );if _dbe !=nil {return _dbe ;};_dbba ._ade =_fddd ;return nil ;};func (_cbdaf *PdfParser )skipComments ()error {if _ ,_gabc :=_cbdaf .skipSpaces ();_gabc !=nil {return _gabc ;};_dbab :=true ;for {_fcab ,_cffa :=_cbdaf ._cccg .Peek (1);if _cffa !=nil {_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cffa .Error ());return _cffa ;};if _dbab &&_fcab [0]!='%'{return nil ;};_dbab =false ;if (_fcab [0]!='\r')&&(_fcab [0]!='\n'){_cbdaf ._cccg .ReadByte ();}else {break ;};};return _cbdaf .skipComments ();};func _fbbac (_bfec string )(int ,int ,error ){_gecg :=_gddf .FindStringSubmatch (_bfec );if len (_gecg )< 3{return 0,0,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dagec ,_ :=_cc .Atoi (_gecg [1]);_dfbcc ,_ :=_cc .Atoi (_gecg [2]);return _dagec ,_dfbcc ,nil ;};func (_bgag *PdfParser )parseName ()(PdfObjectName ,error ){var _aaed _gc .Buffer ;_dcec :=false ;for {_becb ,_dfcf :=_bgag ._cccg .Peek (1);if _dfcf ==_fb .EOF {break ;};if _dfcf !=nil {return PdfObjectName (_aaed .String ()),_dfcf ;};if !_dcec {if _becb [0]=='/'{_dcec =true ;_bgag ._cccg .ReadByte ();}else if _becb [0]=='%'{_bgag .readComment ();_bgag .skipSpaces ();}else {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_becb ,_becb );return PdfObjectName (_aaed .String ()),_bb .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_becb [0]);};}else {if IsWhiteSpace (_becb [0]){break ;}else if (_becb [0]=='/')||(_becb [0]=='[')||(_becb [0]=='(')||(_becb [0]==']')||(_becb [0]=='<')||(_becb [0]=='>'){break ;}else if _becb [0]=='#'{_ebfc ,_fffc :=_bgag ._cccg .Peek (3);if _fffc !=nil {return PdfObjectName (_aaed .String ()),_fffc ;};_gdbc ,_fffc :=_ed .DecodeString (string (_ebfc [1:3]));if _fffc !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_aaed .WriteByte ('#');_bgag ._cccg .Discard (1);continue ;};_bgag ._cccg .Discard (3);_aaed .Write (_gdbc );}else {_ccef ,_ :=_bgag ._cccg .ReadByte ();_aaed .WriteByte (_ccef );};};};return PdfObjectName (_aaed .String ()),nil ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_dgga *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bbea [][]byte ;for _gfcg :=0;_gfcg < len (data );_gfcg +=_dgga .Columns {_gdgc :=make ([]byte ,_dgga .Columns );_dbaf :=0;for _fac :=0;_fac < _dgga .Columns ;_fac ++{if data [_gfcg +_fac ]==255{_gdgc [_dbaf ]=1;}else {_gdgc [_dbaf ]=0;};_dbaf ++;};_bbea =append (_bbea ,_gdgc );};_cgdd :=&_gg .Encoder {K :_dgga .K ,Columns :_dgga .Columns ,EndOfLine :_dgga .EndOfLine ,EndOfBlock :_dgga .EndOfBlock ,BlackIs1 :_dgga .BlackIs1 ,DamagedRowsBeforeError :_dgga .DamagedRowsBeforeError ,Rows :_dgga .Rows ,EncodedByteAlign :_dgga .EncodedByteAlign };return _cgdd .Encode (_bbea ),nil ;};func _ffcf (_abee PdfObject )(*float64 ,error ){switch _ccacd :=_abee .(type ){case *PdfObjectFloat :_ccfe :=float64 (*_ccacd );return &_ccfe ,nil ;case *PdfObjectInteger :_cdad :=float64 (*_ccacd );return &_cdad ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_gaf *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gcg .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_dcgf :=_gc .NewReader (encoded );_dageb ,_adcd :=_b .NewReader (_dcgf );if _adcd !=nil {_gcg .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_adcd );_gcg .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_adcd ;};defer _dageb .Close ();var _eagf _gc .Buffer ;_eagf .ReadFrom (_dageb );return _eagf .Bytes (),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_edefa *PdfObjectStream )WriteString ()string {var _abec _fga .Builder ;_abec .WriteString (_cc .FormatInt (_edefa .ObjectNumber ,10));_abec .WriteString ("\u0020\u0030\u0020\u0052");return _abec .String ();};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_cadfe :=&PdfObjectDictionary {};_cadfe ._fgee =map[PdfObjectName ]PdfObject {};_cadfe ._fdgf =[]PdfObjectName {};return _cadfe ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_cgcc string ,_bcbeg bool ){_gagccf ,_bcbeg :=TraceToDirectObject (obj ).(*PdfObjectName );if _bcbeg {return string (*_gagccf ),true ;};return ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_gcg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_accd ,_bcecc :=NewEncoderFromStream (streamObj );if _bcecc !=nil {_gcg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_bcecc );return _bcecc ;};if _fddf ,_ddbef :=_accd .(*LZWEncoder );_ddbef {_fddf .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_gcg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_accd );_egfd ,_bcecc :=_accd .EncodeBytes (streamObj .Stream );if _bcecc !=nil {_gcg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_bcecc );return _bcecc ;};streamObj .Stream =_egfd ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_egfd ))));return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fbbcb *PdfObjectReference )WriteString ()string {var _gfeg _fga .Builder ;_gfeg .WriteString (_cc .FormatInt (_fbbcb .ObjectNumber ,10));_gfeg .WriteString ("\u0020");_gfeg .WriteString (_cc .FormatInt (_fbbcb .GenerationNumber ,10));_gfeg .WriteString ("\u0020\u0052");return _gfeg .String ();};

// GetXrefTable returns the PDFs xref table.
func (_acf *PdfParser )GetXrefTable ()XrefTable {return _acf ._ccbg };

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_gdgg *PdfParser )GetFileOffset ()int64 {_cdg ,_ :=_gdgg ._bcbad .Seek (0,_fb .SeekCurrent );_cdg -=int64 (_gdgg ._cccg .Buffered ());return _cdg ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ecae *LZWEncoder )MakeDecodeParams ()PdfObject {if _ecae .Predictor > 1{_abce :=MakeDict ();_abce .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ecae .Predictor )));if _ecae .BitsPerComponent !=8{_abce .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ecae .BitsPerComponent )));};if _ecae .Columns !=1{_abce .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ecae .Columns )));};if _ecae .Colors !=1{_abce .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ecae .Colors )));};return _abce ;};return nil ;};

// Clear resets the dictionary to an empty state.
func (_ddgeb *PdfObjectDictionary )Clear (){_ddgeb ._fdgf =[]PdfObjectName {};_ddgeb ._fgee =map[PdfObjectName ]PdfObject {};};

// GetParser returns the parser for lazy-loading or compare references.
func (_bdgg *PdfObjectReference )GetParser ()*PdfParser {return _bdgg ._eacef };func (_cbge *JBIG2Encoder )encodeImage (_cgf _fg .Image )([]byte ,error ){const _cfac ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_fgcb ,_ebae :=GoImageToJBIG2 (_cgf ,JB2ImageAutoThreshold );if _ebae !=nil {return nil ,_af .Wrap (_ebae ,_cfac ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _ebae =_cbge .AddPageImage (_fgcb ,&_cbge .DefaultPageSettings );_ebae !=nil {return nil ,_af .Wrap (_ebae ,_cfac ,"");};return _cbge .Encode ();};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_cgcd *PdfParser )Inspect ()(map[string ]int ,error ){return _cgcd .inspect ()};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// WriteString outputs the object as it is to be written to file.
func (_aeag *PdfObjectArray )WriteString ()string {var _feega _fga .Builder ;_feega .WriteString ("\u005b");for _fdeef ,_ecce :=range _aeag .Elements (){_feega .WriteString (_ecce .WriteString ());if _fdeef < (_aeag .Len ()-1){_feega .WriteString ("\u0020");};};_feega .WriteString ("\u005d");return _feega .String ();};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// DecodeStream implements ASCII85 stream decoding.
func (_beg *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _beg .DecodeBytes (streamObj .Stream );};

// WriteString outputs the object as it is to be written to file.
func (_afbaf *PdfObjectBool )WriteString ()string {if *_afbaf {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_edbge *PdfObjectDictionary ,_dafeb bool ){_edbge ,_dafeb =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _edbge ,_dafeb ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_agacc *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _agacc .Predictor !=1{return nil ,_bb .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _agacc .EarlyChange ==1{return nil ,_bb .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _gfff _gc .Buffer ;_bbcd :=_gd .NewWriter (&_gfff ,_gd .MSB ,8);_bbcd .Write (data );_bbcd .Close ();return _gfff .Bytes (),nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_aba *PdfObjectName ,_feceb bool ){_aba ,_feceb =TraceToDirectObject (obj ).(*PdfObjectName );return _aba ,_feceb ;};

// GetFilterName returns the name of the encoding filter.
func (_gdc *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ceebd *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _ggebb []int64 ;for _ ,_acfa :=range _ceebd .Elements (){if _dbcgg ,_cbfbc :=_acfa .(*PdfObjectInteger );_cbfbc {_ggebb =append (_ggebb ,int64 (*_dbcgg ));}else {return nil ,ErrTypeError ;};};return _ggebb ,nil ;};

// String returns a string representation of `name`.
func (_aefc *PdfObjectName )String ()string {return string (*_aefc )};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_accf *PdfObjectDictionary );EncodeBytes (_bbf []byte )([]byte ,error );DecodeBytes (_def []byte )([]byte ,error );DecodeStream (_ecbd *PdfObjectStream )([]byte ,error );};func (_ddeac *PdfParser )repairSeekXrefMarker ()error {_acde ,_defbb :=_ddeac ._bcbad .Seek (0,_fb .SeekEnd );if _defbb !=nil {return _defbb ;};_gceg :=_gb .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _bcbgf int64 ;var _aafb int64 =1000;for _bcbgf < _acde {if _acde <=(_aafb +_bcbgf ){_aafb =_acde -_bcbgf ;};_ ,_eggf :=_ddeac ._bcbad .Seek (-_bcbgf -_aafb ,_fb .SeekEnd );if _eggf !=nil {return _eggf ;};_adfd :=make ([]byte ,_aafb );_ddeac ._bcbad .Read (_adfd );_gcg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_adfd ));_dbdca :=_gceg .FindAllStringIndex (string (_adfd ),-1);if _dbdca !=nil {_bdaa :=_dbdca [len (_dbdca )-1];_gcg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dbdca );_ddeac ._bcbad .Seek (-_bcbgf -_aafb +int64 (_bdaa [0]),_fb .SeekEnd );_ddeac ._cccg =_cf .NewReader (_ddeac ._bcbad );for {_gfaf ,_gecfg :=_ddeac ._cccg .Peek (1);if _gecfg !=nil {return _gecfg ;};_gcg .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_gfaf [0],_gfaf [0]);if !IsWhiteSpace (_gfaf [0]){break ;};_ddeac ._cccg .Discard (1);};return nil ;};_gcg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_bcbgf +=_aafb ;};_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _g .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// PdfVersion returns version of the PDF file.
func (_cfgcd *PdfParser )PdfVersion ()Version {return _cfgcd ._gaec };

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_fdcb :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _fdcb ==nil {return NewRawEncoder (),nil ;};if _ ,_dbbbd :=_fdcb .(*PdfObjectNull );_dbbbd {return NewRawEncoder (),nil ;};_bgbe ,_ccdfg :=_fdcb .(*PdfObjectName );if !_ccdfg {_gfef ,_gegf :=_fdcb .(*PdfObjectArray );if !_gegf {return nil ,_bb .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _gfef .Len ()==0{return NewRawEncoder (),nil ;};if _gfef .Len ()!=1{_daac ,_bgeff :=_gdec (streamObj );if _bgeff !=nil {_gcg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bgeff );return nil ,_bgeff ;};_gcg .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_daac );return _daac ,nil ;};_fdcb =_gfef .Get (0);_bgbe ,_gegf =_fdcb .(*PdfObjectName );if !_gegf {return nil ,_bb .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_bgbe {case StreamEncodingFilterNameFlate :return _ffe (streamObj ,nil );case StreamEncodingFilterNameLZW :return _ddgcg (streamObj ,nil );case StreamEncodingFilterNameDCT :return _cda (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _fgd (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _cfbg (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _cdfb (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_gcg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_bb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bgbe );};func _ebg (_aaa *_ggd .FilterDict ,_aff *PdfObjectDictionary )error {if _bad ,_acg :=_aff .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_acg {if _acc :=string (*_bad );_acc !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_gcg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_acc );};};_ddca ,_dbdc :=_aff .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_dbdc {return _bb .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_aaa .CFM =string (*_ddca );if _daa ,_dag :=_aff .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_dag {_aaa .AuthEvent =_ab .AuthEvent (*_daa );}else {_aaa .AuthEvent =_ab .EventDocOpen ;};if _afg ,_bfbe :=_aff .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_bfbe {_aaa .Length =int (*_afg );};return nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_agae *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_bf ,_ ,_age :=_agae .lookupByNumberWrapper (objNumber ,true );return _bf ,_age ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _efgg :=obj .(type ){case *PdfObjectFloat :_gcg .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_efgg ),nil ;case *PdfObjectInteger :return int64 (*_efgg ),nil ;};return 0,ErrNotANumber ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// WriteString outputs the object as it is to be written to file.
func (_gcabe *PdfObjectInteger )WriteString ()string {return _cc .FormatInt (int64 (*_gcabe ),10)};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_gcgg *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_afb ,_adfb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _adfb ==nil {_gcgg .BitsPerComponent =int (_afb );};_fbgd ,_adfb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _adfb ==nil {_gcgg .Width =int (_fbgd );};_aaba ,_adfb :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _adfb ==nil {_gcgg .Height =int (_aaba );};_gggg ,_adfb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _adfb ==nil {_gcgg .ColorComponents =int (_gggg );};};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_bedf :=PdfObjectString {_agfdc :s ,_gcef :true };return &_bedf ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_gbdc :=TraceToDirectObject (obj ).(*PdfObjectNull );return _gbdc ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_dfbg :=&LZWEncoder {};_dfbg .Predictor =1;_dfbg .BitsPerComponent =8;_dfbg .Colors =1;_dfbg .Columns =1;_dfbg .EarlyChange =1;return _dfbg ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_aeeg *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_fbdaa *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bgdf :=encoded ;var _gdge error ;for _ ,_fgcc :=range _fbdaa ._ceda {_gcg .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_fgcc ,_fgcc );_bgdf ,_gdge =_fgcc .DecodeBytes (_bgdf );if _gdge !=nil {return nil ,_gdge ;};};return _bgdf ,nil ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_fgee map[PdfObjectName ]PdfObject ;_fdgf []PdfObjectName ;_cadf *PdfParser ;};const _fcd ="\u0053\u0074\u0064C\u0046";

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_ggaf *PdfObjectString )Decoded ()string {if _ggaf ==nil {return "";};_fabe :=[]byte (_ggaf ._agfdc );if len (_fabe )>=2&&_fabe [0]==0xFE&&_fabe [1]==0xFF{return _cfd .UTF16ToString (_fabe [2:]);};return _cfd .PDFDocEncodingToString (_fabe );};

// String returns a descriptive information string about the encryption method used.
func (_bef *PdfCrypt )String ()string {if _bef ==nil {return "";};_dcgc :=_bef ._adf .Filter +"\u0020\u002d\u0020";if _bef ._adf .V ==0{_dcgc +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _bef ._adf .V ==1{_dcgc +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _bef ._adf .V ==2{_dcgc +=_bb .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_bef ._adf .Length );}else if _bef ._adf .V ==3{_dcgc +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _bef ._adf .V >=4{_dcgc +=_bb .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_bef ._aa ,_bef ._ada );_dcgc +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _bfe ,_eagg :=range _bef ._ddb {_dcgc +=_bb .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_bfe ,_eagg .Name (),_eagg .KeyLength ());};};_gad :=_bef .GetAccessPermissions ();_dcgc +=_bb .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_gad );return _dcgc ;};

// GetFilterName returns the name of the encoding filter.
func (_bdbe *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_fggb :objects }};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_gefb *PdfObjectStreams ,_aafde bool ){_gefb ,_aafde =obj .(*PdfObjectStreams );return _gefb ,_aafde ;};type cryptFilters map[string ]_ggd .Filter ;func (_bdg *FlateEncoder )postDecodePredict (_dbde []byte )([]byte ,error ){if _bdg .Predictor > 1{if _bdg .Predictor ==2{_gcg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gcg .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_bdg .Colors );_ebaf :=_bdg .Columns *_bdg .Colors ;if _ebaf < 1{return []byte {},nil ;};_geb :=len (_dbde )/_ebaf ;if len (_dbde )%_ebaf !=0{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dbde ),_ebaf );};if _ebaf %_bdg .Colors !=0{return nil ,_bb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ebaf ,_bdg .Colors );};if _ebaf > len (_dbde ){_gcg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ebaf ,len (_dbde ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gcg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dbde ),_dbde );_aeba :=_gc .NewBuffer (nil );for _bgca :=0;_bgca < _geb ;_bgca ++{_cfgd :=_dbde [_ebaf *_bgca :_ebaf *(_bgca +1)];for _ebdb :=_bdg .Colors ;_ebdb < _ebaf ;_ebdb ++{_cfgd [_ebdb ]+=_cfgd [_ebdb -_bdg .Colors ];};_aeba .Write (_cfgd );};_aefe :=_aeba .Bytes ();_gcg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_aefe ),_aefe );return _aefe ,nil ;}else if _bdg .Predictor >=10&&_bdg .Predictor <=15{_gcg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bbfe :=_bdg .Columns *_bdg .Colors +1;_ffae :=len (_dbde )/_bbfe ;if len (_dbde )%_bbfe !=0{return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dbde ),_bbfe );};if _bbfe > len (_dbde ){_gcg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bbfe ,len (_dbde ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fcc :=_gc .NewBuffer (nil );_gcg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_bdg .Columns );_gcg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dbde ),_bbfe ,_ffae );_bda :=make ([]byte ,_bbfe );for _ffffa :=0;_ffffa < _bbfe ;_ffffa ++{_bda [_ffffa ]=0;};_agf :=_bdg .Colors ;for _ggcgc :=0;_ggcgc < _ffae ;_ggcgc ++{_ged :=_dbde [_bbfe *_ggcgc :_bbfe *(_ggcgc +1)];_eca :=_ged [0];switch _eca {case _edeb :case _adac :for _bbfg :=1+_agf ;_bbfg < _bbfe ;_bbfg ++{_ged [_bbfg ]+=_ged [_bbfg -_agf ];};case _abd :for _bgfc :=1;_bgfc < _bbfe ;_bgfc ++{_ged [_bgfc ]+=_bda [_bgfc ];};case _gcaa :for _cbaa :=1;_cbaa < _agf +1;_cbaa ++{_ged [_cbaa ]+=_bda [_cbaa ]/2;};for _gde :=_agf +1;_gde < _bbfe ;_gde ++{_ged [_gde ]+=byte ((int (_ged [_gde -_agf ])+int (_bda [_gde ]))/2);};case _cbcd :for _deg :=1;_deg < _bbfe ;_deg ++{var _afab ,_gafa ,_gcgf byte ;_gafa =_bda [_deg ];if _deg >=_agf +1{_afab =_ged [_deg -_agf ];_gcgf =_bda [_deg -_agf ];};_ged [_deg ]+=_dcfg (_afab ,_gafa ,_gcgf );};default:_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_eca ,_ggcgc );return nil ,_bb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_eca );};copy (_bda ,_ged );_fcc .Write (_ged [1:]);};_egag :=_fcc .Bytes ();return _egag ,nil ;}else {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_bdg .Predictor );return nil ,_bb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_bdg .Predictor );};};return _dbde ,nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_gee *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gcg .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_gcg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gee .Predictor );_gabe ,_cfef :=_gee .DecodeBytes (streamObj .Stream );if _cfef !=nil {return nil ,_cfef ;};_gcg .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_gcg .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_gabe ),_gabe );if _gee .Predictor > 1{if _gee .Predictor ==2{_gcg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bff :=_gee .Columns *_gee .Colors ;if _bff < 1{return []byte {},nil ;};_gcag :=len (_gabe )/_bff ;if len (_gabe )%_bff !=0{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gabe ),_bff );};if _bff %_gee .Colors !=0{return nil ,_bb .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_bff ,_gee .Colors );};if _bff > len (_gabe ){_gcg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bff ,len (_gabe ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gcg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_gabe ),_gabe );_eadg :=_gc .NewBuffer (nil );for _eadf :=0;_eadf < _gcag ;_eadf ++{_acgaa :=_gabe [_bff *_eadf :_bff *(_eadf +1)];for _gdg :=_gee .Colors ;_gdg < _bff ;_gdg ++{_acgaa [_gdg ]=byte (int (_acgaa [_gdg ]+_acgaa [_gdg -_gee .Colors ])%256);};_eadg .Write (_acgaa );};_dec :=_eadg .Bytes ();_gcg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_dec ),_dec );return _dec ,nil ;}else if _gee .Predictor >=10&&_gee .Predictor <=15{_gcg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_adbg :=_gee .Columns *_gee .Colors +1;if _adbg < 1{return []byte {},nil ;};_acaa :=len (_gabe )/_adbg ;if len (_gabe )%_adbg !=0{return nil ,_bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gabe ),_adbg );};if _adbg > len (_gabe ){_gcg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_adbg ,len (_gabe ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_adba :=_gc .NewBuffer (nil );_gcg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_gee .Columns );_gcg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_gabe ),_adbg ,_acaa );_eaed :=make ([]byte ,_adbg );for _gfa :=0;_gfa < _adbg ;_gfa ++{_eaed [_gfa ]=0;};for _acgd :=0;_acgd < _acaa ;_acgd ++{_ffc :=_gabe [_adbg *_acgd :_adbg *(_acgd +1)];_bgff :=_ffc [0];switch _bgff {case 0:case 1:for _gcde :=2;_gcde < _adbg ;_gcde ++{_ffc [_gcde ]=byte (int (_ffc [_gcde ]+_ffc [_gcde -1])%256);};case 2:for _agcf :=1;_agcf < _adbg ;_agcf ++{_ffc [_agcf ]=byte (int (_ffc [_agcf ]+_eaed [_agcf ])%256);};default:_gcg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bgff );return nil ,_bb .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bgff );};for _fdgb :=0;_fdgb < _adbg ;_fdgb ++{_eaed [_fdgb ]=_ffc [_fdgb ];};_adba .Write (_ffc [1:]);};_bgdc :=_adba .Bytes ();return _bgdc ,nil ;}else {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_gee .Predictor );return nil ,_bb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_gee .Predictor );};};return _gabe ,nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_ceda []StreamEncoder };type xrefType int ;

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_agbb :=MultiEncoder {};_agbb ._ceda =[]StreamEncoder {};return &_agbb ;};func _geg (_dcf *_ab .StdEncryptDict ,_eb *PdfObjectDictionary )error {R ,_dae :=_eb .Get ("\u0052").(*PdfObjectInteger );if !_dae {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _bb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_dcf .R =int (*R );O ,_dae :=_eb .GetString ("\u004f");if !_dae {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _dcf .R ==5||_dcf .R ==6{if len (O )< 48{return _bb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _bb .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_dcf .O =[]byte (O );U ,_dae :=_eb .GetString ("\u0055");if !_dae {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _dcf .R ==5||_dcf .R ==6{if len (U )< 48{return _bb .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_gcg .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_dcf .U =[]byte (U );if _dcf .R >=5{OE ,_egc :=_eb .GetString ("\u004f\u0045");if !_egc {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _bb .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_dcf .OE =[]byte (OE );UE ,_egc :=_eb .GetString ("\u0055\u0045");if !_egc {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _bb .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_dcf .UE =[]byte (UE );};P ,_dae :=_eb .Get ("\u0050").(*PdfObjectInteger );if !_dae {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_dcf .P =_ab .Permissions (*P );if _dcf .R ==6{Perms ,_aea :=_eb .GetString ("\u0050\u0065\u0072m\u0073");if !_aea {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _bb .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_dcf .Perms =[]byte (Perms );};if _cbc ,_cffc :=_eb .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_cffc {_dcf .EncryptMetadata =bool (*_cbc );}else {_dcf .EncryptMetadata =true ;};return nil ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_ggcgb *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ggcgb ._fggb ){return _g .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ggcgb ._fggb [i ]=obj ;return nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_deebc *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_gcg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_deebc .GetFilterName ());return data ,ErrNoJPXDecode ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fefg *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _eef []float64 ;for _ ,_beca :=range _fefg .Elements (){switch _fcbg :=_beca .(type ){case *PdfObjectInteger :_eef =append (_eef ,float64 (*_fcbg ));case *PdfObjectFloat :_eef =append (_eef ,float64 (*_fcbg ));default:return nil ,ErrTypeError ;};};return _eef ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gdfb *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_ecd :=MakeDict ();_ecd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gdfb .GetFilterName ()));return _ecd ;};func (_gefa *PdfObjectFloat )String ()string {return _bb .Sprintf ("\u0025\u0066",*_gefa )};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_cfg *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_faa ,_efe :=obj .(*PdfObjectReference );if !_efe {return obj ,nil ;};_cbfe :=_cfg .GetFileOffset ();defer func (){_cfg .SetFileOffset (_cbfe )}();_afa ,_efec :=_cfg .LookupByReference (*_faa );if _efec !=nil {return nil ,_efec ;};_cfde ,_bge :=_afa .(*PdfIndirectObject );if !_bge {return _afa ,nil ;};_afa =_cfde .PdfObject ;_ ,_efe =_afa .(*PdfObjectReference );if _efe {return _cfde ,_g .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _afa ,nil ;};type objectCache map[int ]PdfObject ;

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;var _egcae =_gb .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// Len returns the number of elements in the array.
func (_bbeg *PdfObjectArray )Len ()int {if _bbeg ==nil {return 0;};return len (_bbeg ._fggb );};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func (_bcb *PdfParser )lookupByNumber (_bcg int ,_ae bool )(PdfObject ,bool ,error ){_aged ,_edf :=_bcb .ObjCache [_bcg ];if _edf {_gcg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_bcg );return _aged ,false ,nil ;};_ddg ,_edf :=_bcb ._ccbg .ObjectMap [_bcg ];if !_edf {_gcg .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _bfb PdfObjectNull ;return &_bfb ,false ,nil ;};_gcg .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_bcg );if _ddg .XType ==XrefTypeTableEntry {_gcg .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_ddg .ObjectNumber );_gcg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_ddg .Generation );_gcg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_ddg .Offset );_bcb ._bcbad .Seek (_ddg .Offset ,_fb .SeekStart );_bcb ._cccg =_cf .NewReader (_bcb ._bcbad );_fae ,_aeb :=_bcb .ParseIndirectObject ();if _aeb !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_aeb );if _ae {_gcg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_daf ,_bg :=_bcb .repairRebuildXrefsTopDown ();if _bg !=nil {_gcg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_bg );return nil ,false ,_bg ;};_bcb ._ccbg =*_daf ;return _bcb .lookupByNumber (_bcg ,false );};return nil ,false ,_aeb ;};if _ae {_ce ,_ ,_ :=_ggg (_fae );if int (_ce )!=_bcg {_gcg .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_fce :=_bcb .rebuildXrefTable ();if _fce !=nil {return nil ,false ,_fce ;};_bcb .ObjCache =objectCache {};return _bcb .lookupByNumberWrapper (_bcg ,false );};};_gcg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_bcb .ObjCache [_bcg ]=_fae ;return _fae ,false ,nil ;}else if _ddg .XType ==XrefTypeObjectStream {_gcg .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_gcg .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_gcg .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_ddg .OsObjNumber ,_ddg .OsObjIndex );if _ddg .OsObjNumber ==_bcg {_gcg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_g .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_cff :=_bcb ._ccbg .ObjectMap [_ddg .OsObjNumber ];_cff {_gge ,_gab :=_bcb .lookupObjectViaOS (_ddg .OsObjNumber ,_bcg );if _gab !=nil {_gcg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_gab );return nil ,true ,_gab ;};_gcg .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_bcb .ObjCache [_bcg ]=_gge ;if _bcb ._aedd !=nil {_bcb ._aedd ._dgc [_gge ]=true ;};return _gge ,true ,nil ;};_gcg .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_g .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_g .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_cacd *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_fgae :=PdfIndirectObject {};_fgae ._eacef =_cacd ;_gcg .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_dddcd ,_ggfeg :=_cacd ._cccg .Peek (20);if _ggfeg !=nil {if _ggfeg !=_fb .EOF {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_fgae ,_ggfeg ;};};_gcg .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_dddcd ));_ddeca :=_gddf .FindStringSubmatchIndex (string (_dddcd ));if len (_ddeca )< 6{if _ggfeg ==_fb .EOF {return nil ,_ggfeg ;};_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_dddcd ));return &_fgae ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_cacd ._cccg .Discard (_ddeca [0]);_gcg .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_ddeca );_efbcg :=_ddeca [1]-_ddeca [0];_fbec :=make ([]byte ,_efbcg );_ ,_ggfeg =_cacd .ReadAtLeast (_fbec ,_efbcg );if _ggfeg !=nil {_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_ggfeg );return nil ,_ggfeg ;};_gcg .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fbec );_egdc :=_gddf .FindStringSubmatch (string (_fbec ));if len (_egdc )< 3{_gcg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fbec ));return &_fgae ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dfgf ,_ :=_cc .Atoi (_egdc [1]);_fceb ,_ :=_cc .Atoi (_egdc [2]);_fgae .ObjectNumber =int64 (_dfgf );_fgae .GenerationNumber =int64 (_fceb );for {_agdc ,_fecb :=_cacd ._cccg .Peek (2);if _fecb !=nil {return &_fgae ,_fecb ;};_gcg .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_agdc ),string (_agdc ));if IsWhiteSpace (_agdc [0]){_cacd .skipSpaces ();}else if _agdc [0]=='%'{_cacd .skipComments ();}else if (_agdc [0]=='<')&&(_agdc [1]=='<'){_gcg .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_fgae .PdfObject ,_fecb =_cacd .ParseDict ();_gcg .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_fecb );if _fecb !=nil {return &_fgae ,_fecb ;};_gcg .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_agdc [0]=='/')||(_agdc [0]=='(')||(_agdc [0]=='[')||(_agdc [0]=='<'){_fgae .PdfObject ,_fecb =_cacd .parseObject ();if _fecb !=nil {return &_fgae ,_fecb ;};_gcg .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _agdc [0]==']'{_gcg .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_cacd ._cccg .Discard (1);}else {if _agdc [0]=='e'{_dcdb ,_eaff :=_cacd .readTextLine ();if _eaff !=nil {return nil ,_eaff ;};if len (_dcdb )>=6&&_dcdb [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _agdc [0]=='s'{_agdc ,_ =_cacd ._cccg .Peek (10);if string (_agdc [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_aceg :=6;if len (_agdc )> 6{if IsWhiteSpace (_agdc [_aceg ])&&_agdc [_aceg ]!='\r'&&_agdc [_aceg ]!='\n'{_gcg .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_aceg ++;};if _agdc [_aceg ]=='\r'{_aceg ++;if _agdc [_aceg ]=='\n'{_aceg ++;};}else if _agdc [_aceg ]=='\n'{_aceg ++;};};_cacd ._cccg .Discard (_aceg );_afgeg ,_dfce :=_fgae .PdfObject .(*PdfObjectDictionary );if !_dfce {return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gcg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_afgeg );_fafc ,_ddbe :=_cacd .traceStreamLength (_afgeg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _ddbe !=nil {_gcg .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_ddbe );return nil ,_ddbe ;};_gcg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fafc );_beae ,_dagf :=_fafc .(*PdfObjectInteger );if !_dagf {return nil ,_g .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_defb :=*_beae ;if _defb < 0{return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_ffef :=_cacd .GetFileOffset ();_abfa :=_cacd .xrefNextObjectOffset (_ffef );if _ffef +int64 (_defb )> _abfa &&_abfa > _ffef {_gcg .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_ffef +int64 (_defb ));_gcg .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_abfa );_gdecg :=_abfa -_ffef -17;if _gdecg < 0{return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_gcg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_gdecg );_defb =PdfObjectInteger (_gdecg );_afgeg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_gdecg ));};if int64 (_defb )> _cacd ._cfga {_gcg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_afcf :=make ([]byte ,_defb );_ ,_ddbe =_cacd .ReadAtLeast (_afcf ,int (_defb ));if _ddbe !=nil {_gcg .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_afcf ),_afcf );_gcg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ddbe );return nil ,_ddbe ;};_cgeb :=PdfObjectStream {};_cgeb .Stream =_afcf ;_cgeb .PdfObjectDictionary =_fgae .PdfObject .(*PdfObjectDictionary );_cgeb .ObjectNumber =_fgae .ObjectNumber ;_cgeb .GenerationNumber =_fgae .GenerationNumber ;_cgeb .PdfObjectReference ._eacef =_cacd ;_cacd .skipSpaces ();_cacd ._cccg .Discard (9);_cacd .skipSpaces ();return &_cgeb ,nil ;};};_fgae .PdfObject ,_fecb =_cacd .parseObject ();if _fgae .PdfObject ==nil {_gcg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_fgae .PdfObject =MakeNull ();};return &_fgae ,_fecb ;};};if _fgae .PdfObject ==nil {_gcg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_fgae .PdfObject =MakeNull ();};_gcg .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_fgae ,nil ;};