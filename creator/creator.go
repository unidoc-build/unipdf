//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_d "bytes";_f "errors";_bb "fmt";_bg "github.com/unidoc/unichart/render";_gd "github.com/unidoc/unipdf/v3/common";_dc "github.com/unidoc/unipdf/v3/contentstream";_ee "github.com/unidoc/unipdf/v3/contentstream/draw";_abe "github.com/unidoc/unipdf/v3/core";
_cf "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_gg "github.com/unidoc/unipdf/v3/internal/license";_fc "github.com/unidoc/unipdf/v3/internal/transform";_ab "github.com/unidoc/unipdf/v3/model";_c "image";_e "io";_de "math";_g "os";_bd "sort";
_a "strconv";_fg "strings";_ae "unicode";);

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_ebbf *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gaac :=_ebbf ;if _ebbf ._dafa {_gaac =_ebbf .clone ();};return _bgdc (_gaac ,ctx );};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_ddfa *Creator )PageFinalize (pageFinalizeFunc func (_deed PageFinalizeFunctionArgs )error ){_ddfa ._fegc =pageFinalizeFunc ;};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_fada *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _ebcc (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Notes returns the notes section of the invoice as a title-content pair.
func (_gadga *Invoice )Notes ()(string ,string ){return _gadga ._degd [0],_gadga ._degd [1]};

// GeneratePageBlocks implements drawable interface.
func (_fdb *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bge :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cdc :=_fdb ._fagb ;_afeb :=ctx .PageHeight -_fdb ._dga ;if _fdb ._aggf !=nil {_gegd :=_ee .Rectangle {Opacity :1.0,X :_fdb ._fagb ,Y :ctx .PageHeight -_fdb ._dga -_fdb ._cgeb ,Height :_fdb ._cgeb ,Width :_fdb ._dag };
_gegd .FillEnabled =true ;_gegd .FillColor =_fad (_fdb ._aggf );_gegd .BorderEnabled =false ;_eebf ,_ ,_fdca :=_gegd .Draw ("");if _fdca !=nil {return nil ,ctx ,_fdca ;};_fdca =_bge .addContentsByString (string (_eebf ));if _fdca !=nil {return nil ,ctx ,_fdca ;
};};_cegg :=_fdb ._adf ;_eac :=_fdb ._bgcd ;_ccbf :=_fdb ._ggea ;_egb :=_fdb ._eeb ;_fgcg :=_fdb ._adf ;if _fdb ._cceb ==CellBorderStyleDouble {_fgcg +=2*_cegg ;};_gfe :=_fdb ._bgcd ;if _fdb ._ecfa ==CellBorderStyleDouble {_gfe +=2*_eac ;};_afbe :=_fdb ._ggea ;
if _fdb ._cgf ==CellBorderStyleDouble {_afbe +=2*_ccbf ;};_bbfee :=_fdb ._eeb ;if _fdb ._ecf ==CellBorderStyleDouble {_bbfee +=2*_egb ;};_dde :=(_fgcg -_afbe )/2;_dfbg :=(_fgcg -_bbfee )/2;_fba :=(_gfe -_afbe )/2;_eed :=(_gfe -_bbfee )/2;if _fdb ._adf !=0{_feb :=_cdc ;
_eda :=_afeb ;if _fdb ._cceb ==CellBorderStyleDouble {_eda -=_cegg ;_eafb :=_ee .BasicLine {LineColor :_fad (_fdb ._ecd ),Opacity :1.0,LineWidth :_fdb ._adf ,LineStyle :_fdb .LineStyle ,X1 :_feb -_fgcg /2+_dde ,Y1 :_eda +2*_cegg ,X2 :_feb +_fgcg /2-_dfbg +_fdb ._dag ,Y2 :_eda +2*_cegg };
_cbd ,_ ,_cde :=_eafb .Draw ("");if _cde !=nil {return nil ,ctx ,_cde ;};_cde =_bge .addContentsByString (string (_cbd ));if _cde !=nil {return nil ,ctx ,_cde ;};};_eccf :=_ee .BasicLine {LineWidth :_fdb ._adf ,Opacity :1.0,LineColor :_fad (_fdb ._ecd ),LineStyle :_fdb .LineStyle ,X1 :_feb -_fgcg /2+_dde +(_afbe -_fdb ._ggea ),Y1 :_eda ,X2 :_feb +_fgcg /2-_dfbg +_fdb ._dag -(_bbfee -_fdb ._eeb ),Y2 :_eda };
_gbb ,_ ,_fgbg :=_eccf .Draw ("");if _fgbg !=nil {return nil ,ctx ,_fgbg ;};_fgbg =_bge .addContentsByString (string (_gbb ));if _fgbg !=nil {return nil ,ctx ,_fgbg ;};};if _fdb ._bgcd !=0{_fde :=_cdc ;_adce :=_afeb -_fdb ._cgeb ;if _fdb ._ecfa ==CellBorderStyleDouble {_adce +=_eac ;
_fbbb :=_ee .BasicLine {LineWidth :_fdb ._bgcd ,Opacity :1.0,LineColor :_fad (_fdb ._ggbc ),LineStyle :_fdb .LineStyle ,X1 :_fde -_gfe /2+_fba ,Y1 :_adce -2*_eac ,X2 :_fde +_gfe /2-_eed +_fdb ._dag ,Y2 :_adce -2*_eac };_gcf ,_ ,_eefa :=_fbbb .Draw ("");
if _eefa !=nil {return nil ,ctx ,_eefa ;};_eefa =_bge .addContentsByString (string (_gcf ));if _eefa !=nil {return nil ,ctx ,_eefa ;};};_cgcb :=_ee .BasicLine {LineWidth :_fdb ._bgcd ,Opacity :1.0,LineColor :_fad (_fdb ._ggbc ),LineStyle :_fdb .LineStyle ,X1 :_fde -_gfe /2+_fba +(_afbe -_fdb ._ggea ),Y1 :_adce ,X2 :_fde +_gfe /2-_eed +_fdb ._dag -(_bbfee -_fdb ._eeb ),Y2 :_adce };
_fab ,_ ,_efd :=_cgcb .Draw ("");if _efd !=nil {return nil ,ctx ,_efd ;};_efd =_bge .addContentsByString (string (_fab ));if _efd !=nil {return nil ,ctx ,_efd ;};};if _fdb ._ggea !=0{_fgbgb :=_cdc ;_edcef :=_afeb ;if _fdb ._cgf ==CellBorderStyleDouble {_fgbgb +=_ccbf ;
_efa :=_ee .BasicLine {LineWidth :_fdb ._ggea ,Opacity :1.0,LineColor :_fad (_fdb ._ada ),LineStyle :_fdb .LineStyle ,X1 :_fgbgb -2*_ccbf ,Y1 :_edcef +_afbe /2+_dde ,X2 :_fgbgb -2*_ccbf ,Y2 :_edcef -_afbe /2-_fba -_fdb ._cgeb };_bdd ,_ ,_bcc :=_efa .Draw ("");
if _bcc !=nil {return nil ,ctx ,_bcc ;};_bcc =_bge .addContentsByString (string (_bdd ));if _bcc !=nil {return nil ,ctx ,_bcc ;};};_bec :=_ee .BasicLine {LineWidth :_fdb ._ggea ,Opacity :1.0,LineColor :_fad (_fdb ._ada ),LineStyle :_fdb .LineStyle ,X1 :_fgbgb ,Y1 :_edcef +_afbe /2+_dde -(_fgcg -_fdb ._adf ),X2 :_fgbgb ,Y2 :_edcef -_afbe /2-_fba -_fdb ._cgeb +(_gfe -_fdb ._bgcd )};
_gadg ,_ ,_facc :=_bec .Draw ("");if _facc !=nil {return nil ,ctx ,_facc ;};_facc =_bge .addContentsByString (string (_gadg ));if _facc !=nil {return nil ,ctx ,_facc ;};};if _fdb ._eeb !=0{_fdcb :=_cdc +_fdb ._dag ;_dffa :=_afeb ;if _fdb ._ecf ==CellBorderStyleDouble {_fdcb -=_egb ;
_gdf :=_ee .BasicLine {LineWidth :_fdb ._eeb ,Opacity :1.0,LineColor :_fad (_fdb ._cccb ),LineStyle :_fdb .LineStyle ,X1 :_fdcb +2*_egb ,Y1 :_dffa +_bbfee /2+_dfbg ,X2 :_fdcb +2*_egb ,Y2 :_dffa -_bbfee /2-_eed -_fdb ._cgeb };_daf ,_ ,_aed :=_gdf .Draw ("");
if _aed !=nil {return nil ,ctx ,_aed ;};_aed =_bge .addContentsByString (string (_daf ));if _aed !=nil {return nil ,ctx ,_aed ;};};_gcd :=_ee .BasicLine {LineWidth :_fdb ._eeb ,Opacity :1.0,LineColor :_fad (_fdb ._cccb ),LineStyle :_fdb .LineStyle ,X1 :_fdcb ,Y1 :_dffa +_bbfee /2+_dfbg -(_fgcg -_fdb ._adf ),X2 :_fdcb ,Y2 :_dffa -_bbfee /2-_eed -_fdb ._cgeb +(_gfe -_fdb ._bgcd )};
_dgd ,_ ,_ffce :=_gcd .Draw ("");if _ffce !=nil {return nil ,ctx ,_ffce ;};_ffce =_bge .addContentsByString (string (_dgd ));if _ffce !=nil {return nil ,ctx ,_ffce ;};};return []*Block {_bge },ctx ,nil ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_beg *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcf :=_dc .NewContentCreator ();_geg ,_cb :=_beg .Width (),_beg .Height ();if _beg ._afe .IsRelative (){_dcf .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_cb );}else {_dcf .Translate (_beg ._dg ,ctx .PageHeight -_beg ._fe -_cb );
};_ed :=_cb ;if _beg ._fa !=0{_dcf .Translate (_geg /2,_cb /2);_dcf .RotateDeg (_beg ._fa );_dcf .Translate (-_geg /2,-_cb /2);_ ,_ed =_beg .RotatedSize ();};if _beg ._afe .IsRelative (){ctx .Y +=_ed ;};_fbb :=_beg .duplicate ();_cge :=append (*_dcf .Operations (),*_fbb ._db ...);
_cge .WrapIfNeeded ();_fbb ._db =&_cge ;return []*Block {_fbb },ctx ,nil ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_gcef *StyledParagraph )SetWidth (width float64 ){_gcef ._dfgd =width ;_gcef .wrapText ()};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_fdgb _bg .ChartRenderable ;_abfb Positioning ;_cef float64 ;_fbd float64 ;_fggf Margins ;};

// SetWidthBottom sets border width for bottom.
func (_fbec *border )SetWidthBottom (bw float64 ){_fbec ._bgcd =bw };

// SetSubtotal sets the subtotal of the invoice.
func (_begb *Invoice )SetSubtotal (value string ){_begb ._cdcb [1].Value =value };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_ddaf *Chapter )SetIncludeInTOC (includeInTOC bool ){_ddaf ._gea =includeInTOC };

// SetNotes sets the notes section of the invoice.
func (_aecb *Invoice )SetNotes (title ,content string ){_aecb ._degd =[2]string {title ,content }};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_bed :float64 (r )/255.0,_afbf :float64 (g )/255.0,_eebd :float64 (b )/255.0};};func _fffa (_fcgf [][]_ee .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_fea :&_ee .CurvePolygon {Rings :_fcgf },_deff :1.0,_ddeb :1.0};
};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_gbee *Image )ConvertToBinary ()error {return _gbee ._cbad .ConvertToBinary ()};

// SetSideBorderColor sets the cell's side border color.
func (_fdaaa *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_fdaaa ._aacdg =col ;case CellBorderSideBottom :_fdaaa ._bfcg =col ;case CellBorderSideLeft :_fdaaa ._bggec =col ;case CellBorderSideRight :_fdaaa ._efgb =col ;
};};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_dcca *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cabce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cbcd ,_cdgd :=_cabce .setOpacity (_dcca ._bbdgb ,_dcca ._afef );if _cdgd !=nil {return nil ,ctx ,_cdgd ;};_bfb :=_dcca ._ebccd ;
_bfb .FillEnabled =_bfb .FillColor !=nil ;_bfb .BorderEnabled =_bfb .BorderColor !=nil &&_bfb .BorderWidth > 0;_fbbaa :=_bfb .Points ;for _aecc :=range _fbbaa {for _ffbea :=range _fbbaa [_aecc ]{_eebc :=&_fbbaa [_aecc ][_ffbea ];_eebc .Y =ctx .PageHeight -_eebc .Y ;
};};_ccea ,_ ,_cdgd :=_bfb .Draw (_cbcd );if _cdgd !=nil {return nil ,ctx ,_cdgd ;};if _cdgd =_cabce .addContentsByString (string (_ccea ));_cdgd !=nil {return nil ,ctx ,_cdgd ;};return []*Block {_cabce },ctx ,nil ;};

// NewColumn returns a new column for the line items invoice table.
func (_gcbb *Invoice )NewColumn (description string )*InvoiceCell {return _gcbb .newColumn (description ,CellHorizontalAlignmentLeft );};func (_gdfb *Invoice )drawInformation ()*Table {_edbace :=_bcfe (2);_dbdb :=append ([][2]*InvoiceCell {_gdfb ._cdeab ,_gdfb ._ede ,_gdfb ._aefg },_gdfb ._afbd ...);
for _ ,_agba :=range _dbdb {_efcg ,_egef :=_agba [0],_agba [1];if _egef .Value ==""{continue ;};_effb :=_edbace .NewCell ();_effb .SetBackgroundColor (_efcg .BackgroundColor );_gdfb .setCellBorder (_effb ,_efcg );_agcg :=_abga (_efcg .TextStyle );_agcg .Append (_efcg .Value );
_agcg .SetMargins (0,0,2,1);_effb .SetContent (_agcg );_effb =_edbace .NewCell ();_effb .SetBackgroundColor (_egef .BackgroundColor );_gdfb .setCellBorder (_effb ,_egef );_agcg =_abga (_egef .TextStyle );_agcg .Append (_egef .Value );_agcg .SetMargins (0,0,2,1);
_effb .SetContent (_agcg );};return _edbace ;};

// SetBorderOpacity sets the border opacity.
func (_fbfde *Rectangle )SetBorderOpacity (opacity float64 ){_fbfde ._fbdf =opacity };

// GetOptimizer returns current PDF optimizer.
func (_edbb *Creator )GetOptimizer ()_ab .Optimizer {return _edbb ._faggg };

// SetLineWidth sets the line width.
func (_ddfda *Line )SetLineWidth (lw float64 ){_ddfda ._eea =lw };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_acgf *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _acgf ._aefg [0],_acgf ._aefg [1]};

// SetMargins sets the margins of the chart component.
func (_faeb *Chart )SetMargins (left ,right ,top ,bottom float64 ){_faeb ._fggf .Left =left ;_faeb ._fggf .Right =right ;_faeb ._fggf .Top =top ;_faeb ._fggf .Bottom =bottom ;};func (_fcf *Block )duplicate ()*Block {_faa :=&Block {};*_faa =*_fcf ;_fb :=_dc .ContentStreamOperations {};
_fb =append (_fb ,*_fcf ._db ...);_faa ._db =&_fb ;return _faa ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// Scale block by specified factors in the x and y directions.
func (_edba *Block )Scale (sx ,sy float64 ){_bdbc :=_dc .NewContentCreator ().Scale (sx ,sy ).Operations ();*_edba ._db =append (*_bdbc ,*_edba ._db ...);_edba ._db .WrapIfNeeded ();_edba ._cc *=sx ;_edba ._bf *=sy ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_bdec *Chapter )NewSubchapter (title string )*Chapter {_gccf :=_deggb (_bdec ._bgfbf ._dccg );_gccf .FontSize =14;_bdec ._bgac ++;_aegf :=_ggc (_bdec ,_bdec ._bde ,_bdec ._bda ,title ,_bdec ._bgac ,_gccf );_bdec .Add (_aegf );return _aegf ;};

// NewImageFromFile creates an Image from a file.
func (_dbgcf *Creator )NewImageFromFile (path string )(*Image ,error ){return _cfde (path )};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;
TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);func (_gcbbg *StyledParagraph )getMaxLineWidth ()float64 {if _gcbbg ._cdec ==nil ||len (_gcbbg ._cdec )==0{_gcbbg .wrapText ();};var _gddc float64 ;for _ ,_gggdb :=range _gcbbg ._cdec {_aaacd :=_gcbbg .getTextLineWidth (_gggdb );
if _aaacd > _gddc {_gddc =_aaacd ;};};return _gddc ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_cfda *StyledParagraph ;_adec []*TOCLine ;_afeeg TextStyle ;_gagf TextStyle ;_dgffe TextStyle ;_ceeae TextStyle ;_cceea string ;_bgbf float64 ;_decf Margins ;_fagea Positioning ;_ageb TextStyle ;_bfbf bool ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_dcga *FilledCurve )AppendCurve (curve _ee .CubicBezierCurve )*FilledCurve {_dcga ._cgbg =append (_dcga ._cgbg ,curve );return _dcga ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_agcd *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cgge :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gcg :=_dc .NewContentCreator ();_gcg .Add_q ().Add_w (_agcd ._bdgaa ).SetStrokingColor (_fad (_agcd ._aega )).Add_m (_agcd ._dagc ,ctx .PageHeight -_agcd ._fadb ).Add_v (_agcd ._ggcf ,ctx .PageHeight -_agcd ._bbbg ,_agcd ._afcc ,ctx .PageHeight -_agcd ._ebfa ).Add_S ().Add_Q ();
_accd :=_cgge .addContentsByString (_gcg .String ());if _accd !=nil {return nil ,ctx ,_accd ;};return []*Block {_cgge },ctx ,nil ;};

// NewCell returns a new invoice table cell.
func (_cgcad *Invoice )NewCell (value string )*InvoiceCell {return _cgcad .newCell (value ,_cgcad .NewCellProps ());};

// Height returns the Block's height.
func (_ccd *Block )Height ()float64 {return _ccd ._bf };

// Text sets the text content of the Paragraph.
func (_gdgfd *Paragraph )Text ()string {return _gdgfd ._adfge };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_cfef *Creator )MoveRight (dx float64 ){_cfef ._aea .X +=dx };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_dgf *Block )SetMargins (left ,right ,top ,bottom float64 ){_dgf ._ff .Left =left ;_dgf ._ff .Right =right ;_dgf ._ff .Top =top ;_dgf ._ff .Bottom =bottom ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_bagaa *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_bagaa ._adec =append (_bagaa ._adec ,line );return line ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_beba *Invoice )TotalLines ()[][2]*InvoiceCell {_dedcg :=[][2]*InvoiceCell {_beba ._cdcb };_dedcg =append (_dedcg ,_beba ._dbfd ...);return append (_dedcg ,_beba ._fagd );};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_gfge *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_gccgf :=range subtable ._ddgb {_ebde :=&TableCell {};*_ebde =*_gccgf ;_ebde ._efea =_gfge ;_ebde ._gfdbd +=col -1;if _afgb :=_gfge ._egcbg -(_ebde ._gfdbd -1);_afgb < _ebde ._fbagf {_gfge ._egcbg +=_ebde ._fbagf -_afgb ;
_gfge .resetColumnWidths ();_gd .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_gfge ._egcbg );
};_ebde ._edeaa +=row -1;_afeg :=subtable ._aace [_gccgf ._edeaa -1];if _ebde ._edeaa > _gfge ._badc {for _ebde ._edeaa > _gfge ._badc {_gfge ._badc ++;_gfge ._aace =append (_gfge ._aace ,_gfge ._cced );};_gfge ._aace [_ebde ._edeaa -1]=_afeg ;}else {_gfge ._aace [_ebde ._edeaa -1]=_de .Max (_gfge ._aace [_ebde ._edeaa -1],_afeg );
};_gfge ._ddgb =append (_gfge ._ddgb ,_ebde );};_bd .Slice (_gfge ._ddgb ,func (_bcegf ,_defb int )bool {_dcfb :=_gfge ._ddgb [_bcegf ]._edeaa ;_dfbgd :=_gfge ._ddgb [_defb ]._edeaa ;if _dcfb < _dfbgd {return true ;};if _dcfb > _dfbgd {return false ;};
return _gfge ._ddgb [_bcegf ]._gfdbd < _gfge ._ddgb [_defb ]._gfdbd ;});};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_debg *Chapter )SetShowNumbering (show bool ){_debg ._acaa =show ;_debg ._bgfbf .SetText (_debg .headingText ());};func (_fdae *Image )rotatedSize ()(float64 ,float64 ){_cabc :=_fdae ._adef ;_ccgf :=_fdae ._gag ;_efga :=_fdae ._caceg ;if _efga ==0{return _cabc ,_ccgf ;
};_gbca :=_ee .Path {Points :[]_ee .Point {_ee .NewPoint (0,0).Rotate (_efga ),_ee .NewPoint (_cabc ,0).Rotate (_efga ),_ee .NewPoint (0,_ccgf ).Rotate (_efga ),_ee .NewPoint (_cabc ,_ccgf ).Rotate (_efga )}}.GetBoundingBox ();return _gbca .Width ,_gbca .Height ;
};

// Angle returns the block rotation angle in degrees.
func (_ded *Block )Angle ()float64 {return _ded ._fa };const (PositionRelative Positioning =iota ;PositionAbsolute ;);func (_bfaf *Invoice )newColumn (_bccd string ,_egba CellHorizontalAlignment )*InvoiceCell {_cfba :=&InvoiceCell {_bfaf ._ggfe ,_bccd };
_cfba .Alignment =_egba ;return _cfba ;};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;func (_gce *Chapter )headingText ()string {_ace :=_gce ._caa ;if _cfc :=_gce .headingNumber ();_cfc !=""{_ace =_bb .Sprintf ("\u0025\u0073\u0020%\u0073",_cfc ,_ace );};return _ace ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_aegb *Creator )NewPage ()*_ab .PdfPage {_cggg :=_aegb .newPage ();_aegb ._dbgc =append (_aegb ._dbgc ,_cggg );_aegb ._aea .Page ++;return _cggg ;};func (_ead *Creator )initContext (){_ead ._aea .X =_ead ._gffb .Left ;_ead ._aea .Y =_ead ._gffb .Top ;
_ead ._aea .Width =_ead ._gede -_ead ._gffb .Right -_ead ._gffb .Left ;_ead ._aea .Height =_ead ._acea -_ead ._gffb .Bottom -_ead ._gffb .Top ;_ead ._aea .PageHeight =_ead ._acea ;_ead ._aea .PageWidth =_ead ._gede ;_ead ._aea .Margins =_ead ._gffb ;_ead ._aea ._dgda =_ead .UnsupportedCharacterReplacement ;
};

// Invoice represents a configurable invoice template.
type Invoice struct{_dccb string ;_daadc *Image ;_aba *InvoiceAddress ;_ddaef *InvoiceAddress ;_beb string ;_cdeab [2]*InvoiceCell ;_ede [2]*InvoiceCell ;_aefg [2]*InvoiceCell ;_afbd [][2]*InvoiceCell ;_cbee []*InvoiceCell ;_dfcd [][]*InvoiceCell ;_cdcb [2]*InvoiceCell ;
_fagd [2]*InvoiceCell ;_dbfd [][2]*InvoiceCell ;_degd [2]string ;_aegfa [2]string ;_acaab [][2]string ;_dedbc TextStyle ;_dfgf TextStyle ;_fdcf TextStyle ;_afcaf TextStyle ;_decc TextStyle ;_acgb TextStyle ;_ceggg TextStyle ;_gfgf InvoiceCellProps ;_ggfe InvoiceCellProps ;
_ggbcb InvoiceCellProps ;_eecff InvoiceCellProps ;_cdgg Positioning ;};

// WriteToFile writes the Creator output to file specified by path.
func (_gbg *Creator )WriteToFile (outputPath string )error {_egca ,_cfdb :=_g .Create (outputPath );if _cfdb !=nil {return _cfdb ;};defer _egca .Close ();return _gbg .Write (_egca );};

// SetLogo sets the logo of the invoice.
func (_dcagd *Invoice )SetLogo (logo *Image ){_dcagd ._daadc =logo };

// SetOpacity sets opacity for Image.
func (_fdadg *Image )SetOpacity (opacity float64 ){_fdadg ._bcb =opacity };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_gege *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_gege ._bfaba =textOverflow };

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_cgbg []_ee .CubicBezierCurve ;FillEnabled bool ;_cbec Color ;BorderEnabled bool ;BorderWidth float64 ;_eafg Color ;};func (_egea *pageTransformations )applyFlip (_fdba *_ab .PdfPage )error {_agc ,_egee :=_egea ._fdad ,_egea ._dcgf ;
if !_agc &&!_egee {return nil ;};if _fdba ==nil {return _f .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_bdga ,_fdaa :=_fdba .GetMediaBox ();if _fdaa !=nil {return _fdaa ;};_dcd ,_cecf :=_bdga .Width (),_bdga .Height ();
_dddc ,_fdaa :=_fdba .GetRotate ();if _fdaa !=nil {_gd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_fdaa .Error ());
};if _adg :=_dddc %360!=0&&_dddc %90==0;_adg {if _eff :=(360+_dddc %360)%360;_eff ==90||_eff ==270{_agc ,_egee =_egee ,_agc ;};};_abff ,_dgff :=1.0,0.0;if _agc {_abff ,_dgff =-1.0,-_dcd ;};_eecg ,_fegb :=1.0,0.0;if _egee {_eecg ,_fegb =-1.0,-_cecf ;};_aac :=_dc .NewContentCreator ().Scale (_abff ,_eecg ).Translate (_dgff ,_fegb );
_aec ,_fdaa :=_abe .MakeStream (_aac .Bytes (),_abe .NewFlateEncoder ());if _fdaa !=nil {return _fdaa ;};_aacc :=_abe .MakeArray (_aec );_aacc .Append (_fdba .GetContentStreamObjs ()...);_fdba .Contents =_aacc ;return nil ;};

// SetEncoder sets the encoding/compression mechanism for the image.
func (_dce *Image )SetEncoder (encoder _abe .StreamEncoder ){_dce ._gafd =encoder };

// SetMargins sets the Paragraph's margins.
func (_acgd *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_acgd ._cagec .Left =left ;_acgd ._cagec .Right =right ;_acgd ._cagec .Top =top ;_acgd ._cagec .Bottom =bottom ;};

// Title returns the title of the invoice.
func (_fgcd *Invoice )Title ()string {return _fgcd ._dccb };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;func (_bffcd *StyledParagraph )getTextHeight ()float64 {var _gaba float64 ;for _ ,_bbfdg :=range _bffcd ._dcgfc {_ccba :=_bbfdg .Style .FontSize *_bffcd ._aaffc ;if _ccba > _gaba {_gaba =_ccba ;};};return _gaba ;};func (_gfba *List )tableHeight (_dfgb float64 )float64 {var _fadg float64 ;
for _ ,_bdea :=range _gfba ._egcb {switch _aacd :=_bdea ._gfcf .(type ){case *Paragraph :_egfa :=_aacd ;if _egfa ._ccff {_egfa .SetWidth (_dfgb );};_fadg +=_egfa .Height ()+_egfa ._cagec .Bottom +_egfa ._cagec .Bottom ;_fadg +=0.5*_egfa ._bffa *_egfa ._ebaad ;
case *StyledParagraph :_gaee :=_aacd ;if _gaee ._egcgf {_gaee .SetWidth (_dfgb );};_fadg +=_gaee .Height ()+_gaee ._dfaeg .Top +_gaee ._dfaeg .Bottom ;_fadg +=0.5*_gaee .getTextHeight ();default:_fadg +=_bdea ._gfcf .Height ();};};return _fadg ;};

// SetFillColor sets the fill color.
func (_ecfg *Polygon )SetFillColor (color Color ){_ecfg ._ebccd .FillColor =_fad (color )};func (_agde *Block )transform (_fd _fc .Matrix ){_fdd :=_dc .NewContentCreator ().Add_cm (_fd [0],_fd [1],_fd [3],_fd [4],_fd [6],_fd [7]).Operations ();*_agde ._db =append (*_fdd ,*_agde ._db ...);
_agde ._db .WrapIfNeeded ();};

// AddSection adds a new content section at the end of the invoice.
func (_gfcc *Invoice )AddSection (title ,content string ){_gfcc ._acaab =append (_gfcc ._acaab ,[2]string {title ,content });};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_acade *List )Width ()float64 {return 0};func _aacb (_aebbd int64 ,_begc ,_fafa ,_ebdf float64 )*_ab .PdfAnnotation {_eeeff :=_ab .NewPdfAnnotationLink ();_dgbd :=_ab .NewBorderStyle ();_dgbd .SetBorderWidth (0);_eeeff .BS =_dgbd .ToPdfObject ();
if _aebbd < 0{_aebbd =0;};_eeeff .Dest =_abe .MakeArray (_abe .MakeInteger (_aebbd ),_abe .MakeName ("\u0058\u0059\u005a"),_abe .MakeFloat (_begc ),_abe .MakeFloat (_fafa ),_abe .MakeFloat (_ebdf ));return _eeeff .PdfAnnotation ;};type marginDrawable interface{VectorDrawable ;
GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_eedce *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcfb :=_ee .Line {LineWidth :_eedce ._eea ,Opacity :1.0,LineColor :_fad (_eedce ._aafdc ),LineEndingStyle1 :_ee .LineEndingStyleNone ,LineEndingStyle2 :_ee .LineEndingStyleNone ,X1 :_eedce ._beacc ,Y1 :ctx .PageHeight -_eedce ._bceg ,X2 :_eedce ._aaff ,Y2 :ctx .PageHeight -_eedce ._gdeg };
_eccae ,_ ,_ega :=_bcfb .Draw ("");if _ega !=nil {return nil ,ctx ,_ega ;};_ega =_gcce .addContentsByString (string (_eccae ));if _ega !=nil {return nil ,ctx ,_ega ;};return []*Block {_gcce },ctx ,nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ggccc *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfae :=ctx ;_eafbe ,ctx ,_dacf :=_ggccc ._cfda .GeneratePageBlocks (ctx );if _dacf !=nil {return _eafbe ,ctx ,_dacf ;};for _ ,_adga :=range _ggccc ._adec {_egeb :=_adga ._ccdg ;
if !_ggccc ._bfbf {_adga ._ccdg =0;};_bgddd ,_dggd ,_bdge :=_adga .GeneratePageBlocks (ctx );_adga ._ccdg =_egeb ;if _bdge !=nil {return _eafbe ,ctx ,_bdge ;};if len (_bgddd )< 1{continue ;};_eafbe [len (_eafbe )-1].mergeBlocks (_bgddd [0]);_eafbe =append (_eafbe ,_bgddd [1:]...);
ctx =_dggd ;};if _ggccc ._fagea .IsRelative (){ctx .X =_cfae .X ;};if _ggccc ._fagea .IsAbsolute (){return _eafbe ,_cfae ,nil ;};return _eafbe ,ctx ,nil ;};

// NewDivision returns a new Division container component.
func (_bffg *Creator )NewDivision ()*Division {return _gdfa ()};func _dfac (_fgca []_ee .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_fbef :&_ee .PolyBezierCurve {Curves :_fgca ,BorderColor :_ab .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_dbfe :1.0,_gggd :1.0};
};func (_ffec *Invoice )drawSection (_gdedb ,_fdada string )[]*StyledParagraph {var _gaeg []*StyledParagraph ;if _gdedb !=""{_dgc :=_abga (_ffec ._ceggg );_dgc .SetMargins (0,0,0,5);_dgc .Append (_gdedb );_gaeg =append (_gaeg ,_dgc );};if _fdada !=""{_cefad :=_abga (_ffec ._acgb );
_cefad .Append (_fdada );_gaeg =append (_gaeg ,_cefad );};return _gaeg ;};

// Height returns the total height of all rows.
func (_bcdf *Table )Height ()float64 {_ddfbd :=float64 (0.0);for _ ,_cgfc :=range _bcdf ._aace {_ddfbd +=_cgfc ;};return _ddfbd ;};func (_bece *Table )moveToNextAvailableCell ()int {_cgcbg :=(_bece ._aaae -1)%(_bece ._egcbg )+1;for {if _cgcbg -1>=len (_bece ._gec ){return _cgcbg ;
}else if _bece ._gec [_cgcbg -1]==0{return _cgcbg ;}else {_bece ._aaae ++;_bece ._gec [_cgcbg -1]--;};_cgcbg ++;};};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_bcg *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_feec ,_ ,_dbcab :=_bcg .draw ("");if _dbcab !=nil {return nil ,ctx ,_dbcab ;};_dbcab =_afbb .addContentsByString (string (_feec ));
if _dbcab !=nil {return nil ,ctx ,_dbcab ;};return []*Block {_afbb },ctx ,nil ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_fadda *Creator )DrawFooter (drawFooterFunc func (_gaa *Block ,_bfdd FooterFunctionArgs )){_fadda ._cfag =drawFooterFunc ;};func _gagc (_gddd _c .Image )(*Image ,error ){_caega ,_deaeg :=_ab .ImageHandling .NewImageFromGoImage (_gddd );if _deaeg !=nil {return nil ,_deaeg ;
};return _ggf (_caega );};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_db *_dc .ContentStreamOperations ;_af *_ab .PdfPageResources ;_afe Positioning ;_dg ,_fe float64 ;_cc float64 ;_bf float64 ;_fa float64 ;_ff Margins ;_fcg []*_ab .PdfAnnotation ;};type pageTransformations struct{_gfee *_fc .Matrix ;_fdad bool ;
_dcgf bool ;};func _baff (_geeg ,_fged ,_efdc ,_cgd float64 )*Rectangle {return &Rectangle {_efgca :_geeg ,_gdgd :_fged ,_aceg :_efdc ,_afcf :_cgd ,_gfdb :ColorBlack ,_acgbg :1.0,_daeb :1.0,_fbdf :1.0};};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_edbaf *Image )ScaleToHeight (h float64 ){_fefg :=_edbaf ._adef /_edbaf ._gag ;_edbaf ._gag =h ;_edbaf ._adef =h *_fefg ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_eba *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eba ._fggf .Left ,_eba ._fggf .Right ,_eba ._fggf .Top ,_eba ._fggf .Bottom ;};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_acgg *Line )SetColor (col Color ){_acgg ._aafdc =col };

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_gac *Creator )SetPageLabels (pageLabels _abe .PdfObject ){_gac ._daaa =pageLabels };

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_cefa *Division )EnablePageWrap (enable bool ){_cefa ._acef =enable };

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_dbgb *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_bbec *_ab .PdfWriter )error ){_dbgb ._bae =pdfWriterAccessFunc ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_cdg *Creator )DrawHeader (drawHeaderFunc func (_deda *Block ,_efgf HeaderFunctionArgs )){_cdg ._cdba =drawHeaderFunc ;};func _fad (_abc Color )_ab .PdfColor {if _abc ==nil {_abc =ColorBlack ;};switch _gfbe :=_abc .(type ){case cmykColor :return _ab .NewPdfColorDeviceCMYK (_gfbe ._gfd ,_gfbe ._gbd ,_gfbe ._bbfd ,_gfbe ._ggbe );
};return _ab .NewPdfColorDeviceRGB (_abc .ToRGB ());};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_becb *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_becb ._egcbg {_gd .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_becb ._dbce =widths ;return nil ;};

// SetTitle sets the title of the invoice.
func (_ffae *Invoice )SetTitle (title string ){_ffae ._dccb =title };

// SetBorderOpacity sets the border opacity.
func (_aefc *CurvePolygon )SetBorderOpacity (opacity float64 ){_aefc ._ddeb =opacity };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ecca *Invoice )InfoLines ()[][2]*InvoiceCell {_eabb :=[][2]*InvoiceCell {_ecca ._cdeab ,_ecca ._ede ,_ecca ._aefg };return append (_eabb ,_ecca ._afbd ...);};

// Height returns the current page height.
func (_ffb *Creator )Height ()float64 {return _ffb ._acea };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_ggbb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _ccdf (number ,title ,page ,level ,style );};

// Width returns the Block's width.
func (_fff *Block )Width ()float64 {return _fff ._cc };func (_afab *Paragraph )getTextLineWidth (_ceea string )float64 {var _gfae float64 ;for _ ,_ddfac :=range _ceea {if _ddfac =='\u000A'{continue ;};_ffecg ,_bdce :=_afab ._dccg .GetRuneMetrics (_ddfac );
if !_bdce {_gd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_ddfac ,_ddfac );
return -1;};_gfae +=_afab ._bffa *_ffecg .Wx ;};return _gfae ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_eddg *Invoice )NoteHeadingStyle ()TextStyle {return _eddg ._ceggg };

// GetCoords returns coordinates of border.
func (_fdc *border )GetCoords ()(float64 ,float64 ){return _fdc ._fagb ,_fdc ._dga };

// NewTOC creates a new table of contents.
func (_adfa *Creator )NewTOC (title string )*TOC {_gacc :=_adfa .NewTextStyle ();_gacc .Font =_adfa ._bdcc ;return _bfeg (title ,_adfa .NewTextStyle (),_gacc );};func _dbba (_edab []byte )(*Image ,error ){_cfbda :=_d .NewReader (_edab );_cbf ,_gdaf :=_ab .ImageHandling .Read (_cfbda );
if _gdaf !=nil {_gd .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gdaf );return nil ,_gdaf ;};return _ggf (_cbf );};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_febg *Table )EnablePageWrap (enable bool ){_febg ._gebbc =enable };

// SetAngle sets the rotation angle of the text.
func (_gdgcd *StyledParagraph )SetAngle (angle float64 ){_gdgcd ._fgaa =angle };

// SetColorLeft sets border color for left.
func (_gff *border )SetColorLeft (col Color ){_gff ._ada =col };

// IsAbsolute checks if the positioning is absolute.
func (_bcee Positioning )IsAbsolute ()bool {return _bcee ==PositionAbsolute };func _ggf (_efca *_ab .Image )(*Image ,error ){_ceag :=float64 (_efca .Width );_acae :=float64 (_efca .Height );return &Image {_cbad :_efca ,_gaed :_ceag ,_caeg :_acae ,_adef :_ceag ,_gag :_acae ,_caceg :0,_bcb :1.0,_fadad :PositionRelative },nil ;
};

// SetFillOpacity sets the fill opacity.
func (_aeca *PolyBezierCurve )SetFillOpacity (opacity float64 ){_aeca ._dbfe =opacity };

// NewPageBreak create a new page break.
func (_eedc *Creator )NewPageBreak ()*PageBreak {return _fdgdg ()};

// SetText sets the text content of the Paragraph.
func (_gbaca *Paragraph )SetText (text string ){_gbaca ._adfge =text };

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_ebccd *_ee .Polygon ;_bbdgb float64 ;_afef float64 ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gggbc *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aebd :=ctx ;_bfg :=[]func (_efgac DrawContext )([]*Block ,DrawContext ,error ){_gggbc .generateHeaderBlocks ,_gggbc .generateInformationBlocks ,_gggbc .generateLineBlocks ,_gggbc .generateTotalBlocks ,_gggbc .generateNoteBlocks };
var _ecff []*Block ;for _ ,_gacf :=range _bfg {_edea ,_ebcf ,_adccc :=_gacf (ctx );if _adccc !=nil {return _ecff ,ctx ,_adccc ;};if len (_ecff )==0{_ecff =_edea ;}else if len (_edea )> 0{_ecff [len (_ecff )-1].mergeBlocks (_edea [0]);_ecff =append (_ecff ,_edea [1:]...);
};ctx =_ebcf ;};if _gggbc ._cdgg .IsRelative (){ctx .X =_aebd .X ;};if _gggbc ._cdgg .IsAbsolute (){return _ecff ,_aebd ,nil ;};return _ecff ,ctx ,nil ;};func (_ccde *Paragraph )getTextWidth ()float64 {_ggabc :=0.0;for _ ,_bfdb :=range _ccde ._adfge {if _bfdb =='\u000A'{continue ;
};_bfecc ,_efffde :=_ccde ._dccg .GetRuneMetrics (_bfdb );if !_efffde {_gd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bfdb ,_bfdb );
return -1;};_ggabc +=_ccde ._bffa *_bfecc .Wx ;};return _ggabc ;};

// Inline returns whether the inline mode of the division is active.
func (_ggab *Division )Inline ()bool {return _ggab ._fdgdd };func _cecb (_bgdb *Block ,_gedg *Paragraph ,_gdaeg DrawContext )(DrawContext ,error ){_ddg :=1;_fdce :=_abe .PdfObjectName ("\u0046\u006f\u006e\u0074"+_a .Itoa (_ddg ));for _bgdb ._af .HasFontByName (_fdce ){_ddg ++;
_fdce =_abe .PdfObjectName ("\u0046\u006f\u006e\u0074"+_a .Itoa (_ddg ));};_fabbf :=_bgdb ._af .SetFontByName (_fdce ,_gedg ._dccg .ToPdfObject ());if _fabbf !=nil {return _gdaeg ,_fabbf ;};_gedg .wrapText ();_eeed :=_dc .NewContentCreator ();_eeed .Add_q ();
_eecb :=_gdaeg .PageHeight -_gdaeg .Y -_gedg ._bffa *_gedg ._ebaad ;_eeed .Translate (_gdaeg .X ,_eecb );if _gedg ._fbga !=0{_eeed .RotateDeg (_gedg ._fbga );};_eeed .Add_BT ().SetNonStrokingColor (_fad (_gedg ._adfd )).Add_Tf (_fdce ,_gedg ._bffa ).Add_TL (_gedg ._bffa *_gedg ._ebaad );
for _dfcg ,_bbdb :=range _gedg ._eeff {if _dfcg !=0{_eeed .Add_Tstar ();};_bdaee :=[]rune (_bbdb );_gbaf :=0.0;_fdgdb :=0;for _cfefd ,_gccga :=range _bdaee {if _gccga ==' '{_fdgdb ++;continue ;};if _gccga =='\u000A'{continue ;};_cbbc ,_debf :=_gedg ._dccg .GetRuneMetrics (_gccga );
if !_debf {_gd .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_cfefd ,_gccga ,_gccga ,_gedg ._dccg .BaseFont (),_gedg ._dccg .Subtype ());
return _gdaeg ,_f .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_gbaf +=_gedg ._bffa *_cbbc .Wx ;};var _bfdee []_abe .PdfObject ;_baagc ,_caebe :=_gedg ._dccg .GetRuneMetrics (' ');
if !_caebe {return _gdaeg ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_daff :=_baagc .Wx ;switch _gedg ._dfdd {case TextAlignmentJustify :if _fdgdb > 0&&_dfcg < len (_gedg ._eeff )-1{_daff =(_gedg ._defgc *1000.0-_gbaf )/float64 (_fdgdb )/_gedg ._bffa ;
};case TextAlignmentCenter :_fdgba :=_gbaf +float64 (_fdgdb )*_daff *_gedg ._bffa ;_fegbd :=(_gedg ._defgc *1000.0-_fdgba )/2/_gedg ._bffa ;_bfdee =append (_bfdee ,_abe .MakeFloat (-_fegbd ));case TextAlignmentRight :_fgff :=_gbaf +float64 (_fdgdb )*_daff *_gedg ._bffa ;
_dbagb :=(_gedg ._defgc *1000.0-_fgff )/_gedg ._bffa ;_bfdee =append (_bfdee ,_abe .MakeFloat (-_dbagb ));};_faaa :=_gedg ._dccg .Encoder ();var _cbaa []byte ;for _ ,_ddaeg :=range _bdaee {if _ddaeg =='\u000A'{continue ;};if _ddaeg ==' '{if len (_cbaa )> 0{_bfdee =append (_bfdee ,_abe .MakeStringFromBytes (_cbaa ));
_cbaa =nil ;};_bfdee =append (_bfdee ,_abe .MakeFloat (-_daff ));}else {if _ ,_edeb :=_faaa .RuneToCharcode (_ddaeg );!_edeb {_fabbf =UnsupportedRuneError {Message :_bb .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ddaeg ,_ddaeg ),Rune :_ddaeg };
_gdaeg ._abd =append (_gdaeg ._abd ,_fabbf );_gd .Log .Debug (_fabbf .Error ());if _gdaeg ._dgda <=0{continue ;};_ddaeg =_gdaeg ._dgda ;};_cbaa =append (_cbaa ,_faaa .Encode (string (_ddaeg ))...);};};if len (_cbaa )> 0{_bfdee =append (_bfdee ,_abe .MakeStringFromBytes (_cbaa ));
};_eeed .Add_TJ (_bfdee ...);};_eeed .Add_ET ();_eeed .Add_Q ();_afded :=_eeed .Operations ();_afded .WrapIfNeeded ();_bgdb .addContents (_afded );if _gedg ._cbecc .IsRelative (){_caged :=_gedg .Height ();_gdaeg .Y +=_caged ;_gdaeg .Height -=_caged ;if _gdaeg .Inline {_gdaeg .X +=_gedg .Width ()+_gedg ._cagec .Right ;
};};return _gdaeg ,nil ;};

// GeneratePageBlocks draws the chart onto a block.
func (_cgeg *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcce :=ctx ;_cfbe :=_cgeg ._abfb .IsRelative ();var _bdc []*Block ;if _cfbe {_baa :=1.0;_cgg :=_cgeg ._fggf .Top ;if float64 (_cgeg ._fdgb .Height ())> ctx .Height -_cgeg ._fggf .Top {_bdc =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _agb error ;if _ ,ctx ,_agb =_fdgdg ().GeneratePageBlocks (ctx );_agb !=nil {return nil ,ctx ,_agb ;};_cgg =0;};ctx .X +=_cgeg ._fggf .Left +_baa ;ctx .Y +=_cgg ;ctx .Width -=_cgeg ._fggf .Left +_cgeg ._fggf .Right +2*_baa ;ctx .Height -=_cgg ;_cgeg ._fdgb .SetWidth (int (ctx .Width ));
}else {ctx .X =_cgeg ._cef ;ctx .Y =_cgeg ._fbd ;};_efef :=_dc .NewContentCreator ();_efef .Translate (0,ctx .PageHeight );_efef .Scale (1,-1);_efef .Translate (ctx .X ,ctx .Y );_fggge :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cgeg ._fdgb .Render (_cf .NewRenderer (_efef ,_fggge ._af ),nil );
if _aga :=_fggge .addContentsByString (_efef .String ());_aga !=nil {return nil ,ctx ,_aga ;};if _cfbe {_abb :=_cgeg .Height ()+_cgeg ._fggf .Bottom ;ctx .Y +=_abb ;ctx .Height -=_abb ;}else {ctx =_bcce ;};_bdc =append (_bdc ,_fggge );return _bdc ,ctx ,nil ;
};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_effad Drawable )(Drawable ,error );};

// SetBorderOpacity sets the border opacity.
func (_aaeg *Polygon )SetBorderOpacity (opacity float64 ){_aaeg ._afef =opacity };

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_fbcf *Ellipse )GetCoords ()(float64 ,float64 ){return _fbcf ._gcgd ,_fbcf ._bggd };

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_cabe *Invoice )SetColumns (cols []*InvoiceCell ){_cabe ._cbee =cols };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_dcdad *TOC )SetLineNumberStyle (style TextStyle ){_dcdad ._afeeg =style };var PPMM =float64 (72*1.0/25.4);

// SetDate sets the date of the invoice.
func (_bcge *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_bcge ._ede [1].Value =date ;return _bcge ._ede [0],_bcge ._ede [1];};

// InsertColumn inserts a column in the line items table at the specified index.
func (_gggc *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_ffcf :=uint (len (_gggc ._cbee ));if index > _ffcf {index =_ffcf ;};_bade :=_gggc .NewColumn (description );_gggc ._cbee =append (_gggc ._cbee [:index ],append ([]*InvoiceCell {_bade },_gggc ._cbee [index :]...)...);
return _bade ;};func (_eaee *StyledParagraph )wrapText ()error {return _eaee .wrapChunks (true )};func (_dad *Creator )newPage ()*_ab .PdfPage {_babf :=_ab .NewPdfPage ();_abce :=_dad ._dffe [0];_ecaa :=_dad ._dffe [1];_fade :=_ab .PdfRectangle {Llx :0,Lly :0,Urx :_abce ,Ury :_ecaa };
_babf .MediaBox =&_fade ;_dad ._gede =_abce ;_dad ._acea =_ecaa ;_dad .initContext ();return _babf ;};

// SetFontSize sets the font size in document units (points).
func (_egaa *Paragraph )SetFontSize (fontSize float64 ){_egaa ._bffa =fontSize };func (_fee *Block )mergeBlocks (_eg *Block )error {_afc :=_eb (_fee ._db ,_fee ._af ,_eg ._db ,_eg ._af );if _afc !=nil {return _afc ;};for _ ,_aa :=range _eg ._fcg {_fee .AddAnnotation (_aa );
};return nil ;};

// NewTable create a new Table with a specified number of columns.
func (_geae *Creator )NewTable (cols int )*Table {return _bcfe (cols )};

// Append adds a new text chunk to the paragraph.
func (_dfggb *StyledParagraph )Append (text string )*TextChunk {_dfbff :=NewTextChunk (text ,_dfggb ._babe );return _dfggb .appendChunk (_dfbff );};func (_gddg *Invoice )generateTotalBlocks (_dbcf DrawContext )([]*Block ,DrawContext ,error ){_ggga :=_bcfe (4);
_ggga .SetMargins (0,0,10,10);_baag :=[][2]*InvoiceCell {_gddg ._cdcb };_baag =append (_baag ,_gddg ._dbfd ...);_baag =append (_baag ,_gddg ._fagd );for _ ,_beac :=range _baag {_efcc ,_ceff :=_beac [0],_beac [1];if _ceff .Value ==""{continue ;};_ggga .SkipCells (2);
_geff :=_ggga .NewCell ();_geff .SetBackgroundColor (_efcc .BackgroundColor );_geff .SetHorizontalAlignment (_ceff .Alignment );_gddg .setCellBorder (_geff ,_efcc );_gggea :=_abga (_efcc .TextStyle );_gggea .SetMargins (0,0,2,1);_gggea .Append (_efcc .Value );
_geff .SetContent (_gggea );_geff =_ggga .NewCell ();_geff .SetBackgroundColor (_ceff .BackgroundColor );_geff .SetHorizontalAlignment (_ceff .Alignment );_gddg .setCellBorder (_geff ,_efcc );_gggea =_abga (_ceff .TextStyle );_gggea .SetMargins (0,0,2,1);
_gggea .Append (_ceff .Value );_geff .SetContent (_gggea );};return _ggga .GeneratePageBlocks (_dbcf );};func (_bgdbc *Table )wrapRow (_aedgd int ,_afdb DrawContext ,_agdb float64 )(bool ,error ){if !_bgdbc ._dafa {return false ,nil ;};var (_gafag =_bgdbc ._ddgb [_aedgd ];
_eafe =-1;_abcab []*TableCell ;_fagee float64 ;_efed bool ;_cgdde =make ([]float64 ,0,len (_bgdbc ._dbce )););_ffbfa :=func (_ffggd *TableCell ,_fffge VectorDrawable ,_cdbe bool )*TableCell {_eeebdd :=*_ffggd ;_eeebdd ._ggcge =_fffge ;if _cdbe {_eeebdd ._edeaa ++;
};return &_eeebdd ;};_degf :=func (_bbcb int ,_cagf VectorDrawable ){var _dbdfc float64 =-1;if _cagf ==nil {if _cfefg :=_cgdde [_bbcb -_aedgd ];_cfefg > _afdb .Height {_cagf =_bgdbc ._ddgb [_bbcb ]._ggcge ;_bgdbc ._ddgb [_bbcb ]._ggcge =nil ;_cgdde [_bbcb -_aedgd ]=0;
_dbdfc =_cfefg ;};};_efadd :=_ffbfa (_bgdbc ._ddgb [_bbcb ],_cagf ,true );_abcab =append (_abcab ,_efadd );if _dbdfc < 0{_dbdfc =_efadd .height (_afdb .Width );};if _dbdfc > _fagee {_fagee =_dbdfc ;};};for _efaea :=_aedgd ;_efaea < len (_bgdbc ._ddgb );
_efaea ++{_bdf :=_bgdbc ._ddgb [_efaea ];if _gafag ._edeaa !=_bdf ._edeaa {_eafe =_efaea ;break ;};_afdb .Width =_bdf .width (_bgdbc ._dbce ,_agdb );var _egeac VectorDrawable ;switch _bbcf :=_bdf ._ggcge .(type ){case *StyledParagraph :if _egcab :=_bdf .height (_afdb .Width );
_egcab > _afdb .Height {_fefgd :=_afdb ;_fefgd .Height =_de .Floor (_afdb .Height -_bbcf ._dfaeg .Top -_bbcf ._dfaeg .Bottom -0.5*_bbcf .getTextHeight ());_dded ,_cbgf ,_edebf :=_bbcf .split (_fefgd );if _edebf !=nil {return false ,_edebf ;};if _dded !=nil &&_cbgf !=nil {_bbcf =_dded ;
_bdf =_ffbfa (_bdf ,_dded ,false );_bgdbc ._ddgb [_efaea ]=_bdf ;_egeac =_cbgf ;_efed =true ;};};case *Division :if _ecgd :=_bdf .height (_afdb .Width );_ecgd > _afdb .Height {_daeag :=_afdb ;_daeag .Height =_de .Floor (_afdb .Height -_bbcf ._ebaaa .Top -_bbcf ._ebaaa .Bottom );
_bffdb ,_cda :=_bbcf .split (_daeag );if _bffdb !=nil &&_cda !=nil {_bbcf =_bffdb ;_bdf =_ffbfa (_bdf ,_bffdb ,false );_bgdbc ._ddgb [_efaea ]=_bdf ;_egeac =_cda ;_efed =true ;};};};_cgdde =append (_cgdde ,_bdf .height (_afdb .Width ));if _efed {if _abcab ==nil {_abcab =make ([]*TableCell ,0,len (_bgdbc ._dbce ));
for _fcgfc :=_aedgd ;_fcgfc < _efaea ;_fcgfc ++{_degf (_fcgfc ,nil );};};_degf (_efaea ,_egeac );};};var _decde float64 ;for _ ,_dbbc :=range _cgdde {if _dbbc > _decde {_decde =_dbbc ;};};if _efed &&_decde < _afdb .Height {if _eafe < 0{_eafe =len (_bgdbc ._ddgb );
};_bbfeg :=_bgdbc ._ddgb [_eafe -1]._edeaa +_bgdbc ._ddgb [_eafe -1]._efbb -1;for _edaea :=_eafe ;_edaea < len (_bgdbc ._ddgb );_edaea ++{_bgdbc ._ddgb [_edaea ]._edeaa ++;};_bgdbc ._ddgb =append (_bgdbc ._ddgb [:_eafe ],append (_abcab ,_bgdbc ._ddgb [_eafe :]...)...);
_bgdbc ._aace =append (_bgdbc ._aace [:_bbfeg ],append ([]float64 {_fagee },_bgdbc ._aace [_bbfeg :]...)...);_bgdbc ._aace [_gafag ._edeaa +_gafag ._efbb -2]=_decde ;};return _efed ,nil ;};

// SetInline sets the inline mode of the division.
func (_dadb *Division )SetInline (inline bool ){_dadb ._fdgdd =inline };

// Height returns Image's document height.
func (_bgd *Image )Height ()float64 {return _bgd ._gag };func (_fffe *StyledParagraph )appendChunk (_cebc *TextChunk )*TextChunk {_fffe ._dcgfc =append (_fffe ._dcgfc ,_cebc );_fffe .wrapText ();return _cebc ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_edde *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _edde ._dfaeg .Left ,_edde ._dfaeg .Right ,_edde ._dfaeg .Top ,_edde ._dfaeg .Bottom ;};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_ccge *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _f .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _f .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _f .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_ccge ._debe =true ;_ccge ._aadbb =startRow ;_ccge ._fgdfd =endRow ;return nil ;};

// SetBorderWidth sets the border width.
func (_fdgdgb *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_fdgdgb ._fbef .BorderWidth =borderWidth ;};

// Scale scales Image by a constant factor, both width and height.
func (_ffcd *Image )Scale (xFactor ,yFactor float64 ){_ffcd ._adef =xFactor *_ffcd ._adef ;_ffcd ._gag =yFactor *_ffcd ._gag ;};func (_afd *Block )addContents (_dac *_dc .ContentStreamOperations ){_afd ._db .WrapIfNeeded ();_dac .WrapIfNeeded ();*_afd ._db =append (*_afd ._db ,*_dac ...);
};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_dcc *Creator )Draw (d Drawable )error {if _dcc .getActivePage ()==nil {_dcc .NewPage ();};_babg ,_bbdg ,_feed :=d .GeneratePageBlocks (_dcc ._aea );if _feed !=nil {return _feed ;};if len (_bbdg ._abd )> 0{_dcc .Errors =append (_dcc .Errors ,_bbdg ._abd ...);
};for _eecf ,_bafg :=range _babg {if _eecf > 0{_dcc .NewPage ();};_afbed :=_dcc .getActivePage ();if _bag ,_dfg :=_dcc ._bccb [_afbed ];_dfg {if _gaf :=_bag .mergeBlocks (_bafg );_gaf !=nil {return _gaf ;};if _dfbc :=_dfa (_bafg ._af ,_bag ._af );_dfbc !=nil {return _dfbc ;
};}else {_dcc ._bccb [_afbed ]=_bafg ;};};_dcc ._aea .X =_bbdg .X ;_dcc ._aea .Y =_bbdg .Y ;_dcc ._aea .Height =_bbdg .PageHeight -_bbdg .Y -_bbdg .Margins .Bottom ;return nil ;};func (_cafb *TableCell )height (_bdcea float64 )float64 {var _fageg float64 ;
switch _caedb :=_cafb ._ggcge .(type ){case *Paragraph :if _caedb ._ccff {_caedb .SetWidth (_bdcea -_cafb ._eaea -_caedb ._cagec .Left -_caedb ._cagec .Right );};_fageg =_caedb .Height ()+_caedb ._cagec .Top +_caedb ._cagec .Bottom +0.5*_caedb ._bffa *_caedb ._ebaad ;
case *StyledParagraph :if _caedb ._egcgf {_caedb .SetWidth (_bdcea -_cafb ._eaea -_caedb ._dfaeg .Left -_caedb ._dfaeg .Right );};_fageg =_caedb .Height ()+_caedb ._dfaeg .Top +_caedb ._dfaeg .Bottom +0.5*_caedb .getTextHeight ();case *Image :_fageg =_caedb .Height ()+_caedb ._dcbb .Top +_caedb ._dcbb .Bottom ;
case *Table :_caedb .updateRowHeights (_bdcea -_cafb ._eaea -_caedb ._abca .Left -_caedb ._abca .Right );_fageg =_caedb .Height ()+_caedb ._abca .Top +_caedb ._abca .Bottom ;case *List :_fageg =_caedb .tableHeight (_bdcea -_cafb ._eaea )+_caedb ._gegg .Top +_caedb ._gegg .Bottom ;
case *Division :_fageg =_caedb .ctxHeight (_bdcea -_cafb ._eaea )+_caedb ._ebaaa .Top +_caedb ._ebaaa .Bottom ;case *Chart :_fageg =_caedb .Height ()+_caedb ._fggf .Top +_caedb ._fggf .Bottom ;};return _fageg ;};

// Add adds a new line with the default style to the table of contents.
func (_ffgadc *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_egcef :=_ffgadc .AddLine (_ccdf (TextChunk {Text :number ,Style :_ffgadc ._afeeg },TextChunk {Text :title ,Style :_ffgadc ._gagf },TextChunk {Text :page ,Style :_ffgadc ._ceeae },level ,_ffgadc ._ageb ));
if _egcef ==nil {return nil ;};_cabd :=&_ffgadc ._decf ;_egcef .SetMargins (_cabd .Left ,_cabd .Right ,_cabd .Top ,_cabd .Bottom );_egcef .SetLevelOffset (_ffgadc ._bgbf );_egcef .Separator .Text =_ffgadc ._cceea ;_egcef .Separator .Style =_ffgadc ._dgffe ;
return _egcef ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_eaac *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_eaac .Text },nil ;};var _dccc []string ;var _dddf []rune ;var _fefc float64 ;var _aggc []float64 ;_cgcc :=_eaac .Style ;for _ ,_dceb :=range _eaac .Text {if _dceb =='\u000A'{_dccc =append (_dccc ,_fg .TrimRightFunc (string (_dddf ),_ae .IsSpace )+string (_dceb ));
_dddf =nil ;_fefc =0;_aggc =nil ;continue ;};_gdeb :=_dceb ==' ';_cegbf ,_bdgg :=_cgcc .Font .GetRuneMetrics (_dceb );if !_bdgg {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_dceb ,_dceb ,_cgcc .Font .BaseFont (),_cgcc .Font .Subtype ());
_gd .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_cgcc .Font );_gd .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_cgcc .Font .Encoder ());return nil ,_f .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_afbbg :=_cgcc .FontSize *_cegbf .Wx ;_fafeb :=_afbbg ;if !_gdeb {_fafeb =_afbbg +_cgcc .CharSpacing *1000.0;};if _fefc +_afbbg > width *1000.0{_gdcc :=-1;if !_gdeb {for _beed :=len (_dddf )-1;_beed >=0;_beed --{if _dddf [_beed ]==' '{_gdcc =_beed ;break ;
};};};_gdfc :=string (_dddf );if _gdcc > 0{_gdfc =string (_dddf [0:_gdcc +1]);_dddf =append (_dddf [_gdcc +1:],_dceb );_aggc =append (_aggc [_gdcc +1:],_fafeb );_fefc =0;for _ ,_ebad :=range _aggc {_fefc +=_ebad ;};}else {if _gdeb {_dddf =[]rune {};_aggc =[]float64 {};
_fefc =0;}else {_dddf =[]rune {_dceb };_aggc =[]float64 {_fafeb };_fefc =_fafeb ;};};_dccc =append (_dccc ,_fg .TrimRightFunc (_gdfc ,_ae .IsSpace ));}else {_dddf =append (_dddf ,_dceb );_fefc +=_fafeb ;_aggc =append (_aggc ,_fafeb );};};if len (_dddf )> 0{_dccc =append (_dccc ,string (_dddf ));
};return _dccc ,nil ;};func (_dd *Block )translate (_bgg ,_bggc float64 ){_ec :=_dc .NewContentCreator ().Translate (_bgg ,-_bggc ).Operations ();*_dd ._db =append (*_ec ,*_dd ._db ...);_dd ._db .WrapIfNeeded ();};const (DefaultHorizontalScaling =100;);


// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_gfde *Creator )MoveTo (x ,y float64 ){_gfde ._aea .X =x ;_gfde ._aea .Y =y };const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// SetMargins sets the Table's left, right, top, bottom margins.
func (_feea *Table )SetMargins (left ,right ,top ,bottom float64 ){_feea ._abca .Left =left ;_feea ._abca .Right =right ;_feea ._abca .Top =top ;_feea ._abca .Bottom =bottom ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ceeb *Creator )MoveDown (dy float64 ){_ceeb ._aea .Y +=dy };

// NewList creates a new list.
func (_egg *Creator )NewList ()*List {return _faef (_egg .NewTextStyle ())};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_ebgd *StyledParagraph )Insert (index uint ,text string )*TextChunk {_efgg :=uint (len (_ebgd ._dcgfc ));if index > _efgg {index =_efgg ;};_dfdf :=NewTextChunk (text ,_ebgd ._babe );_ebgd ._dcgfc =append (_ebgd ._dcgfc [:index ],append ([]*TextChunk {_dfdf },_ebgd ._dcgfc [index :]...)...);
_ebgd .wrapText ();return _dfdf ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_gfbfe *Invoice )AddressHeadingStyle ()TextStyle {return _gfbfe ._dfgf };

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_aacdd *TOC )SetLineStyle (style TextStyle ){_aacdd .SetLineNumberStyle (style );_aacdd .SetLineTitleStyle (style );_aacdd .SetLineSeparatorStyle (style );_aacdd .SetLinePageStyle (style );};

// SetColorBottom sets border color for bottom.
func (_cccd *border )SetColorBottom (col Color ){_cccd ._ggbc =col };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_geba *Creator )SetOutlineTree (outlineTree *_ab .PdfOutlineTreeNode ){_geba ._bgb =outlineTree };

// GetRowHeight returns the height of the specified row.
func (_gbed *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_gbed ._aace ){return 0,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _gbed ._aace [row -1],nil ;
};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_cfdee *Invoice )Sections ()[][2]string {return _cfdee ._acaab };

// SetBorder sets the cell's border style.
func (_dcge *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_dcge ._edaed =CellBorderStyleSingle ;_dcge ._dbgf =width ;_dcge ._cadd =CellBorderStyleSingle ;
_dcge ._ffedc =width ;_dcge ._cbefa =CellBorderStyleSingle ;_dcge ._ccdc =width ;_dcge ._ggfd =CellBorderStyleSingle ;_dcge ._ggeed =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_dcge ._edaed =CellBorderStyleDouble ;_dcge ._dbgf =width ;
_dcge ._cadd =CellBorderStyleDouble ;_dcge ._ffedc =width ;_dcge ._cbefa =CellBorderStyleDouble ;_dcge ._ccdc =width ;_dcge ._ggfd =CellBorderStyleDouble ;_dcge ._ggeed =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_dcge ._edaed =style ;
_dcge ._dbgf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_dcge ._cadd =style ;_dcge ._ffedc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_dcge ._cbefa =style ;
_dcge ._ccdc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_dcge ._ggfd =style ;_dcge ._ggeed =width ;};};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
func (_faga *Division )Add (d VectorDrawable )error {switch _gcb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart :case containerDrawable :_deae ,_bfff :=_gcb .ContainerComponent (_faga );if _bfff !=nil {return _bfff ;};_fgd ,_cdfdb :=_deae .(VectorDrawable );
if !_cdfdb {return _bb .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_deae );
};d =_fgd ;default:return _f .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_faga ._bfad =append (_faga ._bfad ,d );return nil ;};func _aeac (_fcaa [][]_ee .Point )*Polygon {return &Polygon {_ebccd :&_ee .Polygon {Points :_fcaa },_bbdgb :1.0,_afef :1.0};
};

// NewPolyline creates a new polyline.
func (_babfc *Creator )NewPolyline (points []_ee .Point )*Polyline {return _abeb (points )};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_aacce *Image )GetHorizontalAlignment ()HorizontalAlignment {return _aacce ._bdeca };

// SkipCells skips over a specified number of cells in the table.
func (_fgad *Table )SkipCells (num int ){if num < 0{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_fgad ._aaae +=num ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_dfaef *Invoice )SetNoteStyle (style TextStyle ){_dfaef ._acgb =style };

// SetWidthTop sets border width for top.
func (_fffg *border )SetWidthTop (bw float64 ){_fffg ._adf =bw };func _aada (_aadae ,_bgbb TextStyle )*Invoice {_gegcff :=&Invoice {_dccb :"\u0049N\u0056\u004f\u0049\u0043\u0045",_beb :"\u002c\u0020",_dedbc :_aadae ,_dfgf :_bgbb };_gegcff ._ddaef =&InvoiceAddress {Separator :_gegcff ._beb };
_gegcff ._aba =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_gegcff ._beb };_bdaa :=ColorRGBFrom8bit (245,245,245);_gfc :=ColorRGBFrom8bit (155,155,155);_gegcff ._fdcf =_bgbb ;_gegcff ._fdcf .Color =_gfc ;_gegcff ._fdcf .FontSize =20;
_gegcff ._afcaf =_aadae ;_gegcff ._decc =_bgbb ;_gegcff ._acgb =_aadae ;_gegcff ._ceggg =_bgbb ;_gegcff ._gfgf =_gegcff .NewCellProps ();_gegcff ._gfgf .BackgroundColor =_bdaa ;_gegcff ._gfgf .TextStyle =_bgbb ;_gegcff ._ggfe =_gegcff .NewCellProps ();
_gegcff ._ggfe .TextStyle =_bgbb ;_gegcff ._ggfe .BackgroundColor =_bdaa ;_gegcff ._ggfe .BorderColor =_bdaa ;_gegcff ._ggbcb =_gegcff .NewCellProps ();_gegcff ._ggbcb .BorderColor =_bdaa ;_gegcff ._ggbcb .BorderSides =[]CellBorderSide {CellBorderSideBottom };
_gegcff ._ggbcb .Alignment =CellHorizontalAlignmentRight ;_gegcff ._eecff =_gegcff .NewCellProps ();_gegcff ._eecff .Alignment =CellHorizontalAlignmentRight ;_gegcff ._cdeab =[2]*InvoiceCell {_gegcff .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_gegcff ._gfgf ),_gegcff .newCell ("",_gegcff ._gfgf )};
_gegcff ._ede =[2]*InvoiceCell {_gegcff .newCell ("\u0044\u0061\u0074\u0065",_gegcff ._gfgf ),_gegcff .newCell ("",_gegcff ._gfgf )};_gegcff ._aefg =[2]*InvoiceCell {_gegcff .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_gegcff ._gfgf ),_gegcff .newCell ("",_gegcff ._gfgf )};
_gegcff ._cdcb =[2]*InvoiceCell {_gegcff .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_gegcff ._eecff ),_gegcff .newCell ("",_gegcff ._eecff )};_egbb :=_gegcff ._eecff ;_egbb .TextStyle =_bgbb ;_egbb .BackgroundColor =_bdaa ;_egbb .BorderColor =_bdaa ;
_gegcff ._fagd =[2]*InvoiceCell {_gegcff .newCell ("\u0054\u006f\u0074a\u006c",_egbb ),_gegcff .newCell ("",_egbb )};_gegcff ._degd =[2]string {"\u004e\u006f\u0074e\u0073",""};_gegcff ._aegfa =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_gegcff ._cbee =[]*InvoiceCell {_gegcff .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_gegcff .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_gegcff .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_gegcff .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _gegcff ;};

// MoveX moves the drawing context to absolute position x.
func (_baegc *Creator )MoveX (x float64 ){_baegc ._aea .X =x };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_dedbe *Table )MultiColCell (colspan int )*TableCell {return _dedbe .MultiCell (1,colspan )};

// SetAngle sets Image rotation angle in degrees.
func (_gdde *Image )SetAngle (angle float64 ){_gdde ._caceg =angle };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_bded *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bded ._cagec .Left ,_bded ._cagec .Right ,_bded ._cagec .Top ,_bded ._cagec .Bottom ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_fgf *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bdad :=_ee .Circle {X :_fgf ._gcgd -_fgf ._caeb /2,Y :ctx .PageHeight -_fgf ._bggd -_fgf ._babdg /2,Width :_fgf ._caeb ,Height :_fgf ._babdg ,Opacity :1.0,BorderWidth :_fgf ._fce };
if _fgf ._fcff !=nil {_bdad .FillEnabled =true ;_bdad .FillColor =_fad (_fgf ._fcff );};if _fgf ._edbac !=nil {_bdad .BorderEnabled =true ;_bdad .BorderColor =_fad (_fgf ._edbac );_bdad .BorderWidth =_fgf ._fce ;};_faac ,_ ,_agae :=_bdad .Draw ("");if _agae !=nil {return nil ,ctx ,_agae ;
};_agae =_edd .addContentsByString (string (_faac ));if _agae !=nil {return nil ,ctx ,_agae ;};return []*Block {_edd },ctx ,nil ;};func (_bbff *TOCLine )getLineLink ()*_ab .PdfAnnotation {if _bbff ._ccdg <=0{return nil ;};return _aacb (_bbff ._ccdg -1,_bbff ._cabb ,_bbff ._gabb ,0);
};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_geaaf *TOCLine )SetStyle (style TextStyle ){_geaaf .Number .Style =style ;_geaaf .Title .Style =style ;_geaaf .Separator .Style =style ;_geaaf .Page .Style =style ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;
HorizontalAlignmentRight ;);

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_edbbg *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _baff (x ,y ,width ,height );};

// SetBorderColor sets the border color for the path.
func (_dcag *FilledCurve )SetBorderColor (color Color ){_dcag ._eafg =color };

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_eace *Invoice )SetAddressStyle (style TextStyle ){_eace ._afcaf =style };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_gcab *Table )SetPos (x ,y float64 ){_gcab ._ecbga =PositionAbsolute ;_gcab ._abged =x ;_gcab ._bfbe =y ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_aaaf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _aaaf ._cdcb [0],_aaaf ._cdcb [1]};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _aegc ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_cff :=&Creator {};_cff ._dbgc =[]*_ab .PdfPage {};_cff ._bccb =map[*_ab .PdfPage ]*Block {};_cff ._bbee =map[*_ab .PdfPage ]*pageTransformations {};_cff .SetPageSize (PageSizeLetter );
_dfad :=0.1*_cff ._gede ;_cff ._gffb .Left =_dfad ;_cff ._gffb .Right =_dfad ;_cff ._gffb .Top =_dfad ;_cff ._gffb .Bottom =_dfad ;var _dcac error ;_cff ._ebd ,_dcac =_ab .NewStandard14Font (_ab .HelveticaName );if _dcac !=nil {_cff ._ebd =_ab .DefaultFont ();
};_cff ._bdcc ,_dcac =_ab .NewStandard14Font (_ab .HelveticaBoldName );if _dcac !=nil {_cff ._ebd =_ab .DefaultFont ();};_cff ._efab =_cff .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_cff .AddOutlines =true ;
_cff ._aeag =_ab .NewOutline ();_gg .TrackUse (_aegc );return _cff ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetBackgroundColor sets the cell's background color.
func (_ebgg *TableCell )SetBackgroundColor (col Color ){_ebgg ._fgbd =col };func (_ggfc *Paragraph )getMaxLineWidth ()float64 {if _ggfc ._eeff ==nil ||len (_ggfc ._eeff )==0{_ggfc .wrapText ();};var _abaa float64 ;for _ ,_dbaa :=range _ggfc ._eeff {_cfacg :=_ggfc .getTextLineWidth (_dbaa );
if _cfacg > _abaa {_abaa =_cfacg ;};};return _abaa ;};

// Width returns Image's document width.
func (_decdb *Image )Width ()float64 {return _decdb ._adef };func (_ggg *Chapter )headingNumber ()string {var _ebe string ;if _ggg ._acaa {if _ggg ._cdcc !=0{_ebe =_a .Itoa (_ggg ._cdcc )+"\u002e";};if _ggg ._ecfb !=nil {_ade :=_ggg ._ecfb .headingNumber ();
if _ade !=""{_ebe =_ade +_ebe ;};};};return _ebe ;};

// Width returns the width of the Paragraph.
func (_daea *Paragraph )Width ()float64 {if _daea ._ccff &&int (_daea ._defgc )> 0{return _daea ._defgc ;};return _daea .getTextWidth ()/1000.0;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_fabf *_ee .Polyline ;_afbeb float64 ;};

// RotatedSize returns the width and height of the rotated block.
func (_gdg *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_fec ,_afg :=_ebcb (_gdg ._cc ,_gdg ._bf ,_gdg ._fa );return _fec ,_afg ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_bffd *Creator )NewChapter (title string )*Chapter {_bffd ._gcdd ++;_bcag :=_bffd .NewTextStyle ();_bcag .FontSize =16;return _ggc (nil ,_bffd ._efab ,_bffd ._aeag ,title ,_bffd ._gcdd ,_bcag );};

// NewImage create a new image from a unidoc image (model.Image).
func (_cbba *Creator )NewImage (img *_ab .Image )(*Image ,error ){return _ggf (img )};

// AddTotalLine adds a new line in the invoice totals table.
func (_cgbe *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_faca :=&InvoiceCell {_cgbe ._eecff ,desc };_dced :=&InvoiceCell {_cgbe ._eecff ,value };_cgbe ._dbfd =append (_cgbe ._dbfd ,[2]*InvoiceCell {_faca ,_dced });return _faca ,_dced ;
};

// SetMargins sets the Paragraph's margins.
func (_ebga *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_ebga ._dfaeg .Left =left ;_ebga ._dfaeg .Right =right ;_ebga ._dfaeg .Top =top ;_ebga ._dfaeg .Bottom =bottom ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ab .PdfPage )(*Block ,error ){_bdb :=&Block {};_deg ,_ag :=page .GetAllContentStreams ();if _ag !=nil {return nil ,_ag ;};_cd :=_dc .NewContentStreamParser (_deg );_bc ,_ag :=_cd .Parse ();if _ag !=nil {return nil ,_ag ;};
_bc .WrapIfNeeded ();_bdb ._db =_bc ;if page .Resources !=nil {_bdb ._af =page .Resources ;}else {_bdb ._af =_ab .NewPdfPageResources ();};_bca ,_ag :=page .GetMediaBox ();if _ag !=nil {return nil ,_ag ;};if _bca .Llx !=0||_bca .Lly !=0{_bdb .translate (-_bca .Llx ,_bca .Lly );
};_bdb ._cc =_bca .Urx -_bca .Llx ;_bdb ._bf =_bca .Ury -_bca .Lly ;if page .Rotate !=nil {_bdb ._fa =-float64 (*page .Rotate );};return _bdb ,nil ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_fceb *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffade :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_faba ,_gagdg :=_ffade .setOpacity (_fceb ._dbfe ,_fceb ._gggd );if _gagdg !=nil {return nil ,ctx ,_gagdg ;
};_gaad :=_fceb ._fbef ;_gaad .FillEnabled =_gaad .FillColor !=nil ;var (_egge =ctx .PageHeight ;_fefb =_gaad .Curves ;_cgfbe =make ([]_ee .CubicBezierCurve ,0,len (_gaad .Curves )););for _bgee :=range _gaad .Curves {_gadgc :=_fefb [_bgee ];_gadgc .P0 .Y =_egge -_gadgc .P0 .Y ;
_gadgc .P1 .Y =_egge -_gadgc .P1 .Y ;_gadgc .P2 .Y =_egge -_gadgc .P2 .Y ;_gadgc .P3 .Y =_egge -_gadgc .P3 .Y ;_cgfbe =append (_cgfbe ,_gadgc );};_gaad .Curves =_cgfbe ;defer func (){_gaad .Curves =_fefb }();_cbge ,_ ,_gagdg :=_gaad .Draw (_faba );if _gagdg !=nil {return nil ,ctx ,_gagdg ;
};if _gagdg =_ffade .addContentsByString (string (_cbge ));_gagdg !=nil {return nil ,ctx ,_gagdg ;};return []*Block {_ffade },ctx ,nil ;};func _deggb (_afcafd *_ab .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_afcafd ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func _ebcb (_abcd ,_ccbcb ,_gaaf float64 )(_bfacd ,_ddfaf ,_adccf ,_dfdab float64 ){if _gaaf ==0{return 0,0,_abcd ,_ccbcb ;};_ggagf :=_ee .Path {Points :[]_ee .Point {_ee .NewPoint (0,0).Rotate (_gaaf ),_ee .NewPoint (_abcd ,0).Rotate (_gaaf ),_ee .NewPoint (0,_ccbcb ).Rotate (_gaaf ),_ee .NewPoint (_abcd ,_ccbcb ).Rotate (_gaaf )}}.GetBoundingBox ();
return _ggagf .X ,_ggagf .Y ,_ggagf .Width ,_ggagf .Height ;};

// SetBorderWidth sets the border width.
func (_edgf *Rectangle )SetBorderWidth (bw float64 ){_edgf ._acgbg =bw };

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _bg .ChartRenderable )*Chart {return _fccb (chart )};

// Columns returns all the columns in the invoice line items table.
func (_bdbdc *Invoice )Columns ()[]*InvoiceCell {return _bdbdc ._cbee };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_ffed *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _ffed ._cdeab [0],_ffed ._cdeab [1]};

// SetLevel sets the indentation level of the TOC line.
func (_cfbbg *TOCLine )SetLevel (level uint ){_cfbbg ._fcecd =level ;_cfbbg ._agaae ._dfaeg .Left =_cfbbg ._aacdb +float64 (_cfbbg ._fcecd -1)*_cfbbg ._abfc ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_debb *Image )SetMargins (left ,right ,top ,bottom float64 ){_debb ._dcbb .Left =left ;_debb ._dcbb .Right =right ;_debb ._dcbb .Top =top ;_debb ._dcbb .Bottom =bottom ;};func _bcfe (_bgeb int )*Table {_efde :=&Table {_egcbg :_bgeb ,_cced :10.0,_dbce :[]float64 {},_aace :[]float64 {},_ddgb :[]*TableCell {},_gec :make ([]int ,_bgeb ),_gebbc :true };
_efde .resetColumnWidths ();return _efde ;};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_feef *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_beae :=ctx ;var _fagf []*Block ;_cfbb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _feef ._cbecc .IsRelative (){ctx .X +=_feef ._cagec .Left ;ctx .Y +=_feef ._cagec .Top ;
ctx .Width -=_feef ._cagec .Left +_feef ._cagec .Right ;ctx .Height -=_feef ._cagec .Top ;_feef .SetWidth (ctx .Width );if _feef .Height ()> ctx .Height {_fagf =append (_fagf ,_cfbb );_cfbb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_acd :=ctx ;
_acd .Y =ctx .Margins .Top ;_acd .X =ctx .Margins .Left +_feef ._cagec .Left ;_acd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_acd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_feef ._cagec .Left -_feef ._cagec .Right ;
ctx =_acd ;};}else {if int (_feef ._defgc )<=0{_feef .SetWidth (_feef .getTextWidth ());};ctx .X =_feef ._bgba ;ctx .Y =_feef ._fcda ;};ctx ,_fcfce :=_cecb (_cfbb ,_feef ,ctx );if _fcfce !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcfce );
return nil ,ctx ,_fcfce ;};_fagf =append (_fagf ,_cfbb );if _feef ._cbecc .IsRelative (){ctx .Y +=_feef ._cagec .Bottom ;ctx .Height -=_feef ._cagec .Bottom ;if !ctx .Inline {ctx .X =_beae .X ;ctx .Width =_beae .Width ;};return _fagf ,ctx ,nil ;};return _fagf ,_beae ,nil ;
};

// SetBorderColor sets the border color.
func (_ggdee *Polygon )SetBorderColor (color Color ){_ggdee ._ebccd .BorderColor =_fad (color )};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_bbb *Chapter )GetHeading ()*Paragraph {return _bbb ._bgfbf };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_adda *TOC )SetLinePageStyle (style TextStyle ){_adda ._ceeae =style };

// SetFillOpacity sets the fill opacity.
func (_eecd *Rectangle )SetFillOpacity (opacity float64 ){_eecd ._daeb =opacity };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_bgdd *TOC )SetLineSeparatorStyle (style TextStyle ){_bgdd ._dgffe =style };

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_dgaf *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_gbde :=_abga (_dgaf ._egga );_gbde .Append (text );_gfcca ,_gbggd :=_dgaf .Add (_gbde );return _gbde ,_gfcca ,_gbggd ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_eegc *Invoice )SetTitleStyle (style TextStyle ){_eegc ._fdcf =style };

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_aeb *Block )ScaleToHeight (h float64 ){_gda :=h /_aeb ._bf ;_aeb .Scale (_gda ,_gda )};func (_dafg *InvoiceAddress )fmtLine (_badb ,_aedee string ,_geaa bool )string {if _geaa {_aedee ="";};return _bb .Sprintf ("\u0025\u0073\u0025s\u000a",_aedee ,_badb );
};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_bbfg *Image )SetPos (x ,y float64 ){_bbfg ._fadad =PositionAbsolute ;_bbfg ._bfec =x ;_bbfg ._gbbeb =y ;};func (_bcfg rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _bcfg ._bed ,_bcfg ._afbf ,_bcfg ._eebd ;};func (_fadd cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_fgab :=_fadd ._ggbe ;
return 1-(_fadd ._gfd *(1-_fgab )+_fgab ),1-(_fadd ._gbd *(1-_fgab )+_fgab ),1-(_fadd ._bbfd *(1-_fgab )+_fgab );};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func (_fbbc *FilledCurve )draw (_dfaa string )([]byte ,*_ab .PdfRectangle ,error ){_cbab :=_ee .NewCubicBezierPath ();for _ ,_ffgg :=range _fbbc ._cgbg {_cbab =_cbab .AppendCurve (_ffgg );};
creator :=_dc .NewContentCreator ();creator .Add_q ();if _fbbc .FillEnabled &&_fbbc ._cbec !=nil {creator .SetNonStrokingColor (_fad (_fbbc ._cbec ));};if _fbbc .BorderEnabled {if _fbbc ._eafg !=nil {creator .SetStrokingColor (_fad (_fbbc ._eafg ));};creator .Add_w (_fbbc .BorderWidth );
};if len (_dfaa )> 1{creator .Add_gs (_abe .PdfObjectName (_dfaa ));};_ee .DrawBezierPathWithCreator (_cbab ,creator );creator .Add_h ();if _fbbc .FillEnabled &&_fbbc .BorderEnabled {creator .Add_B ();}else if _fbbc .FillEnabled {creator .Add_f ();}else if _fbbc .BorderEnabled {creator .Add_S ();
};creator .Add_Q ();_dece :=_cbab .GetBoundingBox ();if _fbbc .BorderEnabled {_dece .Height +=_fbbc .BorderWidth ;_dece .Width +=_fbbc .BorderWidth ;_dece .X -=_fbbc .BorderWidth /2;_dece .Y -=_fbbc .BorderWidth /2;};_ceaf :=&_ab .PdfRectangle {};_ceaf .Llx =_dece .X ;
_ceaf .Lly =_dece .Y ;_ceaf .Urx =_dece .X +_dece .Width ;_ceaf .Ury =_dece .Y +_dece .Height ;return creator .Bytes (),_ceaf ,nil ;};func _abga (_cdga TextStyle )*StyledParagraph {return &StyledParagraph {_dcgfc :[]*TextChunk {},_babe :_cdga ,_dbac :_faaed (_cdga .Font ),_aaffc :1.0,_bfcfg :TextAlignmentLeft ,_egcgf :true ,_gbdba :true ,_fgaa :0,_gagca :1,_bfac :1,_gcedb :PositionRelative };
};

// SetSellerAddress sets the seller address of the invoice.
func (_caed *Invoice )SetSellerAddress (address *InvoiceAddress ){_caed ._ddaef =address };

// CreateTableOfContents sets a function to generate table of contents.
func (_cdbf *Creator )CreateTableOfContents (genTOCFunc func (_afde *TOC )error ){_cdbf ._cbdg =genTOCFunc ;};func (_eeg *Block )drawToPage (_bgc *_ab .PdfPage )error {_cce :=&_dc .ContentStreamOperations {};if _bgc .Resources ==nil {_bgc .Resources =_ab .NewPdfPageResources ();
};_abf :=_eb (_cce ,_bgc .Resources ,_eeg ._db ,_eeg ._af );if _abf !=nil {return _abf ;};if _abf =_dfa (_eeg ._af ,_bgc .Resources );_abf !=nil {return _abf ;};if _abf =_bgc .AppendContentBytes (_cce .Bytes (),true );_abf !=nil {return _abf ;};for _ ,_bggf :=range _eeg ._fcg {_bgc .AddAnnotation (_bggf );
};return nil ;};

// Width returns the width of the Paragraph.
func (_adeg *StyledParagraph )Width ()float64 {if _adeg ._egcgf &&int (_adeg ._dfgd )> 0{return _adeg ._dfgd ;};return _adeg .getTextWidth ()/1000.0;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_efae *Invoice )AddressStyle ()TextStyle {return _efae ._afcaf };

// SetBorderWidth sets the border width.
func (_dgae *CurvePolygon )SetBorderWidth (borderWidth float64 ){_dgae ._fea .BorderWidth =borderWidth };

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_cbcda *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_cbcda ._dgac =align ;};func (_eeba *Invoice )newCell (_faff string ,_bfef InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_bfef ,_faff };};func (_edfa *StyledParagraph )getLineMetrics (_ggbgd int )(_bcffg ,_fgdf ,_afgd float64 ){if _edfa ._cdec ==nil ||len (_edfa ._cdec )==0{_edfa .wrapText ();
};if _ggbgd < 0||_ggbgd > len (_edfa ._cdec )-1{_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_ggbgd );
return 0,0,0;};_gcfgd :=_edfa ._cdec [_ggbgd ];for _ ,_bcaaf :=range _gcfgd {_gdgcda ,_ffbeaf :=_bcaaf .Style .Font .GetFontDescriptor ();if _ffbeaf !=nil {_gd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _ddafd ,_gdac float64 ;if _gdgcda !=nil {if _ddafd ,_ffbeaf =_gdgcda .GetCapHeight ();_ffbeaf !=nil {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_ffbeaf );
};if _gdac ,_ffbeaf =_gdgcda .GetDescent ();_ffbeaf !=nil {_gd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_ffbeaf );
};};if int (_ddafd )<=0{_gd .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_ddafd =1000;};if _gadde :=_ddafd /1000.0*_bcaaf .Style .FontSize ;_gadde > _bcffg {_bcffg =_gadde ;};if _bfag :=_bcaaf .Style .FontSize ;_bfag > _fgdf {_fgdf =_bfag ;};if _gbcf :=_gdac /1000.0*_bcaaf .Style .FontSize ;_gbcf < _afgd {_afgd =_gbcf ;};};
return _bcffg ,_fgdf ,_afgd ;};func _bgdc (_gegee *Table ,_agbf DrawContext )([]*Block ,DrawContext ,error ){var _cgeed []*Block ;_ccec :=NewBlock (_agbf .PageWidth ,_agbf .PageHeight );_gegee .updateRowHeights (_agbf .Width -_gegee ._abca .Left -_gegee ._abca .Right );
_daeea :=_gegee ._abca .Top ;if _gegee ._ecbga .IsRelative ()&&!_gegee ._gebbc {_fggb :=_gegee .Height ();if _fggb > _agbf .Height -_gegee ._abca .Top &&_fggb <=_agbf .PageHeight -_agbf .Margins .Top -_agbf .Margins .Bottom {_cgeed =[]*Block {NewBlock (_agbf .PageWidth ,_agbf .PageHeight -_agbf .Y )};
var _eaceb error ;if _ ,_agbf ,_eaceb =_fdgdg ().GeneratePageBlocks (_agbf );_eaceb !=nil {return nil ,_agbf ,_eaceb ;};_daeea =0;};};_fddfgg :=_agbf ;if _gegee ._ecbga .IsAbsolute (){_agbf .X =_gegee ._abged ;_agbf .Y =_gegee ._bfbe ;}else {_agbf .X +=_gegee ._abca .Left ;
_agbf .Y +=_daeea ;_agbf .Width -=_gegee ._abca .Left +_gegee ._abca .Right ;_agbf .Height -=_daeea ;};_afge :=_agbf .Width ;_fgfb :=_agbf .X ;_agbfb :=_agbf .Y ;_dafgd :=_agbf .Height ;_acbb :=0;_eabf ,_cgcg :=-1,-1;if _gegee ._debe {for _gcedbe ,_gabc :=range _gegee ._ddgb {if _gabc ._edeaa < _gegee ._aadbb {continue ;
};if _gabc ._edeaa > _gegee ._fgdfd {break ;};if _eabf < 0{_eabf =_gcedbe ;};_cgcg =_gcedbe ;};};var (_gead bool ;_ffccc int ;_bcbg int ;_dfaac bool ;_edff int ;_abgd error ;);for _cbag :=0;_cbag < len (_gegee ._ddgb );_cbag ++{_gffg :=_gegee ._ddgb [_cbag ];
_bgdg :=_gffg .width (_gegee ._dbce ,_afge );_bedb :=float64 (0.0);for _abad :=0;_abad < _gffg ._gfdbd -1;_abad ++{_bedb +=_gegee ._dbce [_abad ]*_afge ;};_dfdg :=float64 (0.0);for _dfab :=_acbb ;_dfab < _gffg ._edeaa -1;_dfab ++{_dfdg +=_gegee ._aace [_dfab ];
};_agbf .Height =_dafgd -_dfdg ;_dcgc :=float64 (0.0);for _bfcc :=0;_bfcc < _gffg ._efbb ;_bfcc ++{_dcgc +=_gegee ._aace [_gffg ._edeaa +_bfcc -1];};_abebb :=_dfaac &&_gffg ._edeaa !=_edff ;_edff =_gffg ._edeaa ;if _abebb ||_dcgc > _agbf .Height {if _gegee ._dafa &&!_dfaac {_dfaac ,_abgd =_gegee .wrapRow (_cbag ,_agbf ,_afge );
if _abgd !=nil {return nil ,_agbf ,_abgd ;};if _dfaac {_cbag --;continue ;};};_cgeed =append (_cgeed ,_ccec );_ccec =NewBlock (_agbf .PageWidth ,_agbf .PageHeight );_fgfb =_agbf .Margins .Left +_gegee ._abca .Left ;_agbfb =_agbf .Margins .Top ;_agbf .Height =_agbf .PageHeight -_agbf .Margins .Top -_agbf .Margins .Bottom ;
_agbf .Page ++;_dafgd =_agbf .Height ;_acbb =_gffg ._edeaa -1;_dfdg =0;_dfaac =false ;if _gegee ._debe &&_eabf >=0{_ffccc =_cbag ;_cbag =_eabf -1;_bcbg =_acbb ;_acbb =_gegee ._aadbb -1;_gead =true ;continue ;};if _abebb {_cbag --;continue ;};};_agbf .Width =_bgdg ;
_agbf .X =_fgfb +_bedb ;_agbf .Y =_agbfb +_dfdg ;_cabee :=_eaf (_agbf .X ,_agbf .Y ,_bgdg ,_dcgc );if _gffg ._fgbd !=nil {_cabee .SetFillColor (_gffg ._fgbd );};_cabee .LineStyle =_gffg ._bbgf ;_cabee ._cgf =_gffg ._edaed ;_cabee ._ecf =_gffg ._cbefa ;
_cabee ._cceb =_gffg ._ggfd ;_cabee ._ecfa =_gffg ._cadd ;if _gffg ._bggec !=nil {_cabee .SetColorLeft (_gffg ._bggec );};if _gffg ._bfcg !=nil {_cabee .SetColorBottom (_gffg ._bfcg );};if _gffg ._efgb !=nil {_cabee .SetColorRight (_gffg ._efgb );};if _gffg ._aacdg !=nil {_cabee .SetColorTop (_gffg ._aacdg );
};_cabee .SetWidthBottom (_gffg ._ffedc );_cabee .SetWidthLeft (_gffg ._dbgf );_cabee .SetWidthRight (_gffg ._ccdc );_cabee .SetWidthTop (_gffg ._ggeed );_bgeff :=_ccec .Draw (_cabee );if _bgeff !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgeff );
};if _gffg ._ggcge !=nil {_gegfa :=_gffg ._ggcge .Width ();_ebcd :=_gffg ._ggcge .Height ();_degbb :=0.0;switch _ccbgf :=_gffg ._ggcge .(type ){case *Paragraph :if _ccbgf ._ccff {_gegfa =_ccbgf .getMaxLineWidth ()/1000.0;};_gegfa +=_ccbgf ._cagec .Left +_ccbgf ._cagec .Right ;
_ebcd +=_ccbgf ._cagec .Top +_ccbgf ._cagec .Bottom ;case *StyledParagraph :if _ccbgf ._egcgf {_gegfa =_ccbgf .getMaxLineWidth ()/1000.0;};_gfac ,_cdeb ,_fgcf :=_ccbgf .getLineMetrics (0);_aebg ,_egeca :=_gfac *_ccbgf ._aaffc ,_cdeb *_ccbgf ._aaffc ;if _ccbgf ._dgac ==TextVerticalAlignmentCenter {_degbb =_egeca -(_cdeb +(_gfac +_fgcf -_cdeb )/2+(_egeca -_cdeb )/2);
};if len (_ccbgf ._cdec )==1{_ebcd =_aebg ;}else {_ebcd =_ebcd -_egeca +_aebg ;};_degbb +=_aebg -_egeca ;switch _gffg ._fcga {case CellVerticalAlignmentTop :_degbb +=_aebg *0.5;case CellVerticalAlignmentBottom :_degbb -=_aebg *0.5;};_gegfa +=_ccbgf ._dfaeg .Left +_ccbgf ._dfaeg .Right ;
_ebcd +=_ccbgf ._dfaeg .Top +_ccbgf ._dfaeg .Bottom ;case *Table :_gegfa =_bgdg ;case *List :_gegfa =_bgdg ;case *Division :_gegfa =_bgdg ;case *Chart :_gegfa =_bgdg ;};switch _gffg ._ffeg {case CellHorizontalAlignmentLeft :_agbf .X +=_gffg ._eaea ;_agbf .Width -=_gffg ._eaea ;
case CellHorizontalAlignmentCenter :if _bcbf :=_bgdg -_gegfa ;_bcbf > 0{_agbf .X +=_bcbf /2;_agbf .Width -=_bcbf /2;};case CellHorizontalAlignmentRight :if _bgdg > _gegfa {_agbf .X =_agbf .X +_bgdg -_gegfa -_gffg ._eaea ;_agbf .Width -=_gffg ._eaea ;};
};_agbf .Y +=_degbb ;switch _gffg ._fcga {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _abeag :=_dcgc -_ebcd ;_abeag > 0{_agbf .Y +=_abeag /2;_agbf .Height -=_abeag /2;};case CellVerticalAlignmentBottom :if _dcgc > _ebcd {_agbf .Y =_agbf .Y +_dcgc -_ebcd ;
_agbf .Height =_dcgc ;};};_cgbb :=_ccec .DrawWithContext (_gffg ._ggcge ,_agbf );if _cgbb !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cgbb );};_agbf .Y -=_degbb ;};_agbf .Y +=_dcgc ;_agbf .Height -=_dcgc ;if _gead &&_cbag +1> _cgcg {_agbfb +=_dfdg +_dcgc ;
_dafgd -=_dcgc +_dfdg ;_acbb =_bcbg ;_cbag =_ffccc -1;_gead =false ;};};_cgeed =append (_cgeed ,_ccec );if _gegee ._ecbga .IsAbsolute (){return _cgeed ,_fddfgg ,nil ;};_agbf .X =_fddfgg .X ;_agbf .Width =_fddfgg .Width ;_agbf .Y +=_gegee ._abca .Bottom ;
_agbf .Height -=_gegee ._abca .Bottom ;return _cgeed ,_agbf ,nil ;};

// NewInvoice returns an instance of an empty invoice.
func (_bggcg *Creator )NewInvoice ()*Invoice {_aefb :=_bggcg .NewTextStyle ();_aefb .Font =_bggcg ._bdcc ;return _aada (_bggcg .NewTextStyle (),_aefb );};

// SetEnableWrap sets the line wrapping enabled flag.
func (_bffc *Paragraph )SetEnableWrap (enableWrap bool ){_bffc ._ccff =enableWrap ;_bffc ._caeef =false ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_fbag *Image )SetWidth (w float64 ){_fbag ._adef =w };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_acde *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egcg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ecce ,_fbbbf :=_egcg .setOpacity (_acde ._afbeb ,_acde ._afbeb );if _fbbbf !=nil {return nil ,ctx ,_fbbbf ;
};_gggeg :=_acde ._fabf .Points ;for _dfbf :=range _gggeg {_gegaf :=&_gggeg [_dfbf ];_gegaf .Y =ctx .PageHeight -_gegaf .Y ;};_ebbg ,_ ,_fbbbf :=_acde ._fabf .Draw (_ecce );if _fbbbf !=nil {return nil ,ctx ,_fbbbf ;};if _fbbbf =_egcg .addContentsByString (string (_ebbg ));
_fbbbf !=nil {return nil ,ctx ,_fbbbf ;};return []*Block {_egcg },ctx ,nil ;};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_edb *Block )SetPos (x ,y float64 ){_edb ._afe =PositionAbsolute ;_edb ._dg =x ;_edb ._fe =y };

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_cdeg *Creator )Flip (flipH ,flipV bool )error {_gfgc :=_cdeg .getActivePage ();if _gfgc ==nil {return _f .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_gdb ,_begf :=_cdeg ._bbee [_gfgc ];if !_begf {_gdb =&pageTransformations {};
_cdeg ._bbee [_gfgc ]=_gdb ;};_gdb ._fdad =flipH ;_gdb ._dcgf =flipV ;return nil ;};

// SetMargins sets the margins of the paragraph.
func (_bage *List )SetMargins (left ,right ,top ,bottom float64 ){_bage ._gegg .Left =left ;_bage ._gegg .Right =right ;_bage ._gegg .Top =top ;_bage ._gegg .Bottom =bottom ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_deee *StyledParagraph )SetEnableWrap (enableWrap bool ){_deee ._egcgf =enableWrap ;_deee ._gbdba =false ;};func (_agbb *Table )resetColumnWidths (){_agbb ._dbce =[]float64 {};_ecegd :=float64 (1.0)/float64 (_agbb ._egcbg );for _fcec :=0;_fcec < _agbb ._egcbg ;
_fcec ++{_agbb ._dbce =append (_agbb ._dbce ,_ecegd );};};

// NewCellProps returns the default properties of an invoice cell.
func (_affa *Invoice )NewCellProps ()InvoiceCellProps {_bacf :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_affa ._dedbc ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_bacf ,BorderColor :_bacf ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};func _bddg (_ceae *Block ,_agcf *StyledParagraph ,_fgda [][]*TextChunk ,_eeebd DrawContext )(DrawContext ,[][]*TextChunk ,error ){_bbfdga :=1;_acege :=_abe .PdfObjectName (_bb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bbfdga ));for _ceae ._af .HasFontByName (_acege ){_bbfdga ++;
_acege =_abe .PdfObjectName (_bb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bbfdga ));};_cbef :=_ceae ._af .SetFontByName (_acege ,_agcf ._babe .Font .ToPdfObject ());if _cbef !=nil {return _eeebd ,nil ,_cbef ;};_bbfdga ++;_fffeg :=_acege ;_gbce :=_agcf ._babe .FontSize ;
_edeab :=_agcf ._gcedb .IsRelative ();var _fccbf [][]_abe .PdfObjectName ;var _dbe [][]*TextChunk ;var _gcdb float64 ;for _adgde ,_agdc :=range _fgda {var _fcgfd []_abe .PdfObjectName ;var _adgded float64 ;if len (_agdc )> 0{_adgded =_agdc [0].Style .FontSize ;
};for _ ,_dbfa :=range _agdc {_ffaf :=_dbfa .Style ;if _dbfa .Text !=""&&_ffaf .FontSize > _adgded {_adgded =_ffaf .FontSize ;};_acege =_abe .PdfObjectName (_bb .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bbfdga ));_egaf :=_ceae ._af .SetFontByName (_acege ,_ffaf .Font .ToPdfObject ());
if _egaf !=nil {return _eeebd ,nil ,_egaf ;};_fcgfd =append (_fcgfd ,_acege );_bbfdga ++;};_adgded *=_agcf ._aaffc ;if _edeab &&_gcdb +_adgded > _eeebd .Height {_dbe =_fgda [_adgde :];_fgda =_fgda [:_adgde ];break ;};_gcdb +=_adgded ;_fccbf =append (_fccbf ,_fcgfd );
};_eddgb ,_ggbd ,_dfdc :=_agcf .getLineMetrics (0);_ffdd ,_fdbb :=_eddgb *_agcf ._aaffc ,_ggbd *_agcf ._aaffc ;_bcaea :=_dc .NewContentCreator ();_bcaea .Add_q ();_fadbe :=_fdbb ;if _agcf ._dgac ==TextVerticalAlignmentCenter {_fadbe =_ggbd +(_eddgb +_dfdc -_ggbd )/2+(_fdbb -_ggbd )/2;
};_gedbd :=_eeebd .PageHeight -_eeebd .Y -_fadbe ;_bcaea .Translate (_eeebd .X ,_gedbd );_aabc :=_gedbd ;if _agcf ._fgaa !=0{_bcaea .RotateDeg (_agcf ._fgaa );};if _agcf ._bfaba ==TextOverflowHidden {_bcaea .Add_re (0,-_gcdb +_ffdd +1,_agcf ._dfgd ,_gcdb ).Add_W ().Add_n ();
};_bcaea .Add_BT ();var _fbae []*_ee .BasicLine ;for _edgd ,_aeff :=range _fgda {_gegge :=_eeebd .X ;var _bbfge float64 ;if len (_aeff )> 0{_bbfge =_aeff [0].Style .FontSize ;};for _ ,_ddgf :=range _aeff {_cefg :=&_ddgf .Style ;if _ddgf .Text !=""&&_cefg .FontSize > _bbfge {_bbfge =_cefg .FontSize ;
};};if _edgd !=0{_bcaea .Add_TD (0,-_bbfge *_agcf ._aaffc );_aabc -=_bbfge *_agcf ._aaffc ;};_eeef :=_edgd ==len (_fgda )-1;var (_ffgad float64 ;_dbgcb float64 ;_cceeb float64 ;_eggb uint ;);var _edbd []float64 ;for _ ,_cdfe :=range _aeff {_ccbg :=&_cdfe .Style ;
if _ccbg .FontSize > _dbgcb {_dbgcb =_ccbg .FontSize ;};_ddbb ,_fbcd :=_ccbg .Font .GetRuneMetrics (' ');if !_fbcd {return _eeebd ,nil ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _gbbc uint ;var _gdcd float64 ;_bbcd :=len (_cdfe .Text );for _ceee ,_ebccda :=range _cdfe .Text {if _ebccda ==' '{_gbbc ++;continue ;};if _ebccda =='\u000A'{continue ;};_ggbbf ,_daead :=_ccbg .Font .GetRuneMetrics (_ebccda );if !_daead {_gd .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_ebccda );
return _eeebd ,nil ,_f .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_gdcd +=_ccbg .FontSize *_ggbbf .Wx *_ccbg .horizontalScale ();if _ceee !=_bbcd -1{_gdcd +=_ccbg .CharSpacing *1000.0;
};};_edbd =append (_edbd ,_gdcd );_ffgad +=_gdcd ;_cceeb +=float64 (_gbbc )*_ddbb .Wx *_ccbg .FontSize *_ccbg .horizontalScale ();_eggb +=_gbbc ;};_dbgcb *=_agcf ._aaffc ;var _adegg []_abe .PdfObject ;_ffbf :=_agcf ._dfgd *1000.0;if _agcf ._bfcfg ==TextAlignmentJustify {if _eggb > 0&&!_eeef {_cceeb =(_ffbf -_ffgad )/float64 (_eggb )/_gbce ;
};}else if _agcf ._bfcfg ==TextAlignmentCenter {_cacf :=(_ffbf -_ffgad -_cceeb )/2;_ggbcc :=_cacf /_gbce ;_adegg =append (_adegg ,_abe .MakeFloat (-_ggbcc ));_gegge +=_cacf /1000.0;}else if _agcf ._bfcfg ==TextAlignmentRight {_dffb :=(_ffbf -_ffgad -_cceeb );
_ffef :=_dffb /_gbce ;_adegg =append (_adegg ,_abe .MakeFloat (-_ffef ));_gegge +=_dffb /1000.0;};if len (_adegg )> 0{_bcaea .Add_Tf (_fffeg ,_gbce ).Add_TL (_gbce *_agcf ._aaffc ).Add_TJ (_adegg ...);};for _cbfcc ,_bbecd :=range _aeff {_agda :=&_bbecd .Style ;
_fgfg :=_fffeg ;_dgcf :=_gbce ;_eddd :=_agda .OutlineColor !=nil ;_fgdg :=_agda .HorizontalScaling !=DefaultHorizontalScaling ;_dbab :=_agda .OutlineSize !=1;if _dbab {_bcaea .Add_w (_agda .OutlineSize );};_dabb :=_agda .RenderingMode !=TextRenderingModeFill ;
if _dabb {_bcaea .Add_Tr (int64 (_agda .RenderingMode ));};_acggb :=_agda .CharSpacing !=0;if _acggb {_bcaea .Add_Tc (_agda .CharSpacing );};_afdd :=_agda .TextRise !=0;if _afdd {_bcaea .Add_Ts (_agda .TextRise );};if _agcf ._bfcfg !=TextAlignmentJustify ||_eeef {_bcab ,_gagb :=_agda .Font .GetRuneMetrics (' ');
if !_gagb {return _eeebd ,nil ,_f .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_fgfg =_fccbf [_edgd ][_cbfcc ];_dgcf =_agda .FontSize ;
_cceeb =_bcab .Wx *_agda .horizontalScale ();};_bdgf :=_agda .Font .Encoder ();var _aafb []byte ;for _ ,_gdca :=range _bbecd .Text {if _gdca =='\u000A'{continue ;};if _gdca ==' '{if len (_aafb )> 0{if _eddd {_bcaea .SetStrokingColor (_fad (_agda .OutlineColor ));
};if _fgdg {_bcaea .Add_Tz (_agda .HorizontalScaling );};_bcaea .SetNonStrokingColor (_fad (_agda .Color )).Add_Tf (_fccbf [_edgd ][_cbfcc ],_agda .FontSize ).Add_TJ ([]_abe .PdfObject {_abe .MakeStringFromBytes (_aafb )}...);_aafb =nil ;};if _fgdg {_bcaea .Add_Tz (DefaultHorizontalScaling );
};_bcaea .Add_Tf (_fgfg ,_dgcf ).Add_TJ ([]_abe .PdfObject {_abe .MakeFloat (-_cceeb )}...);_edbd [_cbfcc ]+=_cceeb *_dgcf ;}else {if _ ,_cbdb :=_bdgf .RuneToCharcode (_gdca );!_cbdb {_cbef =UnsupportedRuneError {Message :_bb .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_gdca ,_gdca ),Rune :_gdca };
_eeebd ._abd =append (_eeebd ._abd ,_cbef );_gd .Log .Debug (_cbef .Error ());if _eeebd ._dgda <=0{continue ;};_gdca =_eeebd ._dgda ;};_aafb =append (_aafb ,_bdgf .Encode (string (_gdca ))...);};};if len (_aafb )> 0{if _eddd {_bcaea .SetStrokingColor (_fad (_agda .OutlineColor ));
};if _fgdg {_bcaea .Add_Tz (_agda .HorizontalScaling );};_bcaea .SetNonStrokingColor (_fad (_agda .Color )).Add_Tf (_fccbf [_edgd ][_cbfcc ],_agda .FontSize ).Add_TJ ([]_abe .PdfObject {_abe .MakeStringFromBytes (_aafb )}...);};_adbd :=_edbd [_cbfcc ]/1000.0;
if _agda .Underline {_fabd :=_agda .UnderlineStyle .Color ;if _fabd ==nil {_fabd =_bbecd .Style .Color ;};_dbbge ,_effcf ,_debc :=_fabd .ToRGB ();_ecdab :=_gegge -_eeebd .X ;_agge :=_aabc -_gedbd +_agda .TextRise -_agda .UnderlineStyle .Offset ;_fbae =append (_fbae ,&_ee .BasicLine {X1 :_ecdab ,Y1 :_agge ,X2 :_ecdab +_adbd ,Y2 :_agge ,LineWidth :_bbecd .Style .UnderlineStyle .Thickness ,LineColor :_ab .NewPdfColorDeviceRGB (_dbbge ,_effcf ,_debc )});
};if _bbecd ._ffcff !=nil {var _aaaca *_abe .PdfObjectArray ;if !_bbecd ._dbed {switch _fabbg :=_bbecd ._ffcff .GetContext ().(type ){case *_ab .PdfAnnotationLink :_aaaca =_abe .MakeArray ();_fabbg .Rect =_aaaca ;_edgb ,_ebfae :=_fabbg .Dest .(*_abe .PdfObjectArray );
if _ebfae &&_edgb .Len ()==5{_bdgd ,_eefc :=_edgb .Get (1).(*_abe .PdfObjectName );if _eefc &&_bdgd .String ()=="\u0058\u0059\u005a"{_faaf ,_dbcad :=_abe .GetNumberAsFloat (_edgb .Get (3));if _dbcad ==nil {_edgb .Set (3,_abe .MakeFloat (_eeebd .PageHeight -_faaf ));
};};};};_bbecd ._dbed =true ;};if _aaaca !=nil {_dffc :=_ee .NewPoint (_gegge -_eeebd .X ,_aabc +_agda .TextRise -_gedbd ).Rotate (_agcf ._fgaa );_dffc .X +=_eeebd .X ;_dffc .Y +=_gedbd ;_bcgd ,_cgggc ,_gcdg ,_edabf :=_ebcb (_adbd ,_dbgcb ,_agcf ._fgaa );
_dffc .X +=_bcgd ;_dffc .Y +=_cgggc ;_aaaca .Clear ();_aaaca .Append (_abe .MakeFloat (_dffc .X ));_aaaca .Append (_abe .MakeFloat (_dffc .Y ));_aaaca .Append (_abe .MakeFloat (_dffc .X +_gcdg ));_aaaca .Append (_abe .MakeFloat (_dffc .Y +_edabf ));};_ceae .AddAnnotation (_bbecd ._ffcff );
};_gegge +=_adbd ;if _dbab {_bcaea .Add_w (1.0);};if _eddd {_bcaea .Add_RG (0.0,0.0,0.0);};if _dabb {_bcaea .Add_Tr (int64 (TextRenderingModeFill ));};if _acggb {_bcaea .Add_Tc (0);};if _afdd {_bcaea .Add_Ts (0);};if _fgdg {_bcaea .Add_Tz (DefaultHorizontalScaling );
};};};_bcaea .Add_ET ();for _ ,_afcfg :=range _fbae {_bcaea .SetStrokingColor (_afcfg .LineColor ).Add_w (_afcfg .LineWidth ).Add_m (_afcfg .X1 ,_afcfg .Y1 ).Add_l (_afcfg .X2 ,_afcfg .Y2 ).Add_s ();};_bcaea .Add_Q ();_bageb :=_bcaea .Operations ();_bageb .WrapIfNeeded ();
_ceae .addContents (_bageb );if _edeab {_fcbg :=_gcdb ;_eeebd .Y +=_fcbg ;_eeebd .Height -=_fcbg ;if _eeebd .Inline {_eeebd .X +=_agcf .Width ()+_agcf ._dfaeg .Right ;};};return _eeebd ,_dbe ,nil ;};

// SetLineOpacity sets the line opacity.
func (_cdgdd *Polyline )SetLineOpacity (opacity float64 ){_cdgdd ._afbeb =opacity };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:         This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_egcb []*listItem ;_gegg Margins ;_gbac TextChunk ;_bgge float64 ;_cca bool ;_gfa Positioning ;_egga TextStyle ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_cgdd *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efeed :=ctx ;var _fbfg []*Block ;_baec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _cgdd ._gcedb .IsRelative (){ctx .X +=_cgdd ._dfaeg .Left ;ctx .Y +=_cgdd ._dfaeg .Top ;
ctx .Width -=_cgdd ._dfaeg .Left +_cgdd ._dfaeg .Right ;ctx .Height -=_cgdd ._dfaeg .Top ;_cgdd .SetWidth (ctx .Width );}else {if int (_cgdd ._dfgd )<=0{_cgdd .SetWidth (_cgdd .getTextWidth ()/1000.0);};ctx .X =_cgdd ._cbaf ;ctx .Y =_cgdd ._egfe ;};if _cgdd ._acda !=nil {_cgdd ._acda (_cgdd ,ctx );
};if _faad :=_cgdd .wrapText ();_faad !=nil {return nil ,ctx ,_faad ;};_efdf :=_cgdd ._cdec ;for {_abebe ,_eafd ,_bggcd :=_bddg (_baec ,_cgdd ,_efdf ,ctx );if _bggcd !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bggcd );return nil ,ctx ,_bggcd ;
};ctx =_abebe ;_fbfg =append (_fbfg ,_baec );if _efdf =_eafd ;len (_eafd )==0{break ;};_baec =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_abebe =ctx ;_abebe .Y =ctx .Margins .Top ;_abebe .X =ctx .Margins .Left +_cgdd ._dfaeg .Left ;_abebe .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
_abebe .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_cgdd ._dfaeg .Left -_cgdd ._dfaeg .Right ;ctx =_abebe ;};if _cgdd ._gcedb .IsRelative (){ctx .Y +=_cgdd ._dfaeg .Bottom ;ctx .Height -=_cgdd ._dfaeg .Bottom ;if !ctx .Inline {ctx .X =_efeed .X ;
ctx .Width =_efeed .Width ;};return _fbfg ,ctx ,nil ;};return _fbfg ,_efeed ,nil ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_eeeed *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_fgea :=&_eeeed ._decf ;_fgea .Left =left ;_fgea .Right =right ;_fgea .Top =top ;_fgea .Bottom =bottom ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_bagg *Paragraph )Height ()float64 {_bagg .wrapText ();return float64 (len (_bagg ._eeff ))*_bagg ._ebaad *_bagg ._bffa ;};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_bbgb *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfbcc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bcaa :=_ee .Rectangle {Opacity :1.0,X :_bbgb ._efgca ,Y :ctx .PageHeight -_bbgb ._gdgd -_bbgb ._afcf ,Height :_bbgb ._afcf ,Width :_bbgb ._aceg };
if _bbgb ._cecg !=nil {_bcaa .FillEnabled =true ;_bcaa .FillColor =_fad (_bbgb ._cecg );};if _bbgb ._gfdb !=nil &&_bbgb ._acgbg > 0{_bcaa .BorderEnabled =true ;_bcaa .BorderColor =_fad (_bbgb ._gfdb );_bcaa .BorderWidth =_bbgb ._acgbg ;};_cfgd ,_ebgc :=_dfbcc .setOpacity (_bbgb ._daeb ,_bbgb ._fbdf );
if _ebgc !=nil {return nil ,ctx ,_ebgc ;};_agac ,_ ,_ebgc :=_bcaa .Draw (_cfgd );if _ebgc !=nil {return nil ,ctx ,_ebgc ;};if _ebgc =_dfbcc .addContentsByString (string (_agac ));_ebgc !=nil {return nil ,ctx ,_ebgc ;};return []*Block {_dfbcc },ctx ,nil ;
};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_edg *Creator )SetForms (form *_ab .PdfAcroForm )error {_edg ._cfbg =form ;return nil };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_gcda *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gcda ._dfed .Left ,_gcda ._dfed .Right ,_gcda ._dfed .Top ,_gcda ._dfed .Bottom ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};func _dcce (_gfbb *Block ,_ffga *Image ,_feff DrawContext )(DrawContext ,error ){_acfe :=_feff ;
_aaefb :=1;_aedg :=_abe .PdfObjectName (_bb .Sprintf ("\u0049\u006d\u0067%\u0064",_aaefb ));for _gfbb ._af .HasXObjectByName (_aedg ){_aaefb ++;_aedg =_abe .PdfObjectName (_bb .Sprintf ("\u0049\u006d\u0067%\u0064",_aaefb ));};_gefb :=_gfbb ._af .SetXObjectImageByName (_aedg ,_ffga ._dbdf );
if _gefb !=nil {return _feff ,_gefb ;};_cdea :=0;_gbbd :=_abe .PdfObjectName (_bb .Sprintf ("\u0047\u0053\u0025\u0064",_cdea ));for _gfbb ._af .HasExtGState (_gbbd ){_cdea ++;_gbbd =_abe .PdfObjectName (_bb .Sprintf ("\u0047\u0053\u0025\u0064",_cdea ));
};_cdbgc :=_abe .MakeDict ();_cdbgc .Set ("\u0042\u004d",_abe .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _ffga ._bcb < 1.0{_cdbgc .Set ("\u0043\u0041",_abe .MakeFloat (_ffga ._bcb ));_cdbgc .Set ("\u0063\u0061",_abe .MakeFloat (_ffga ._bcb ));
};_gefb =_gfbb ._af .AddExtGState (_gbbd ,_abe .MakeIndirectObject (_cdbgc ));if _gefb !=nil {return _feff ,_gefb ;};_aaacc :=_ffga .Width ();_dbfb :=_ffga .Height ();_ ,_agbd :=_ffga .rotatedSize ();_ddcd :=_feff .X ;_gade :=_feff .PageHeight -_feff .Y -_dbfb ;
if _ffga ._fadad .IsRelative (){_gade -=(_agbd -_dbfb )/2;switch _ffga ._bdeca {case HorizontalAlignmentCenter :_ddcd +=(_feff .Width -_aaacc )/2;case HorizontalAlignmentRight :_ddcd =_feff .PageWidth -_feff .Margins .Right -_ffga ._dcbb .Right -_aaacc ;
};};_ggcc :=_ffga ._caceg ;_adaa :=_dc .NewContentCreator ();_adaa .Add_gs (_gbbd );_adaa .Translate (_ddcd ,_gade );if _ggcc !=0{_adaa .Translate (_aaacc /2,_dbfb /2);_adaa .RotateDeg (_ggcc );_adaa .Translate (-_aaacc /2,-_dbfb /2);};_adaa .Scale (_aaacc ,_dbfb ).Add_Do (_aedg );
_daae :=_adaa .Operations ();_daae .WrapIfNeeded ();_gfbb .addContents (_daae );if _ffga ._fadad .IsRelative (){_feff .Y +=_agbd ;_feff .Height -=_agbd ;return _feff ,nil ;};return _acfe ,nil ;};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_aaf *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eebb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bafe ,_adgb :=_eebb .setOpacity (_aaf ._deff ,_aaf ._ddeb );if _adgb !=nil {return nil ,ctx ,_adgb ;};_ffe :=_aaf ._fea ;
_ffe .FillEnabled =_ffe .FillColor !=nil ;_ffe .BorderEnabled =_ffe .BorderColor !=nil &&_ffe .BorderWidth > 0;var (_dbgge =ctx .PageHeight ;_bggg =_ffe .Rings ;_ecef =make ([][]_ee .CubicBezierCurve ,0,len (_ffe .Rings )););for _ ,_gfbf :=range _bggg {_cace :=make ([]_ee .CubicBezierCurve ,0,len (_gfbf ));
for _ ,_gga :=range _gfbf {_gdae :=_gga ;_gdae .P0 .Y =_dbgge -_gdae .P0 .Y ;_gdae .P1 .Y =_dbgge -_gdae .P1 .Y ;_gdae .P2 .Y =_dbgge -_gdae .P2 .Y ;_gdae .P3 .Y =_dbgge -_gdae .P3 .Y ;_cace =append (_cace ,_gdae );};_ecef =append (_ecef ,_cace );};_ffe .Rings =_ecef ;
defer func (){_ffe .Rings =_bggg }();_cfcf ,_ ,_adgb :=_ffe .Draw (_bafe );if _adgb !=nil {return nil ,ctx ,_adgb ;};if _adgb =_eebb .addContentsByString (string (_cfcf ));_adgb !=nil {return nil ,ctx ,_adgb ;};return []*Block {_eebb },ctx ,nil ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_bege *Paragraph )SetMaxLines (maxLines int ){_bege ._dcad =maxLines ;_bege .wrapText ()};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_fea *_ee .CurvePolygon ;_deff float64 ;_ddeb float64 ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_ccef *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _ccef ._dbdf ==nil {if _gagd :=_ccef .makeXObject ();_gagd !=nil {return nil ,ctx ,_gagd ;};};var _eccb []*Block ;_ebaac :=ctx ;_cgfb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _ccef ._fadad .IsRelative (){ctx .X +=_ccef ._dcbb .Left ;ctx .Y +=_ccef ._dcbb .Top ;ctx .Width -=_ccef ._dcbb .Left +_ccef ._dcbb .Right ;ctx .Height -=_ccef ._dcbb .Top +_ccef ._dcbb .Bottom ;if _ccef ._gag > ctx .Height {_eccb =append (_eccb ,_cgfb );
_cgfb =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_ggeb :=ctx ;_ggeb .Y =ctx .Margins .Top +_ccef ._dcbb .Top ;_ggeb .X =ctx .Margins .Left +_ccef ._dcbb .Left ;_ggeb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ccef ._dcbb .Top -_ccef ._dcbb .Bottom ;
_ggeb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ccef ._dcbb .Left -_ccef ._dcbb .Right ;ctx =_ggeb ;_ebaac .X =ctx .Margins .Left ;_ebaac .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_ccef ._bfec ;
ctx .Y =_ccef ._gbbeb ;};ctx ,_ccgg :=_dcce (_cgfb ,_ccef ,ctx );if _ccgg !=nil {return nil ,ctx ,_ccgg ;};_eccb =append (_eccb ,_cgfb );if _ccef ._fadad .IsAbsolute (){ctx =_ebaac ;}else {ctx .X =_ebaac .X ;ctx .Y +=_ccef ._dcbb .Bottom ;ctx .Width =_ebaac .Width ;
};return _eccb ,ctx ,nil ;};

// CurRow returns the currently active cell's row number.
func (_dbbf *Table )CurRow ()int {_deaa :=(_dbbf ._aaae -1)/_dbbf ._egcbg +1;return _deaa };var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };
PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_fegg *Creator )NewStyledParagraph ()*StyledParagraph {return _abga (_fegg .NewTextStyle ())};

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_bfad []VectorDrawable ;_cbe Positioning ;_ebaaa Margins ;_fdgdd bool ;_acef bool ;};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_bedd *Creator )AddPage (page *_ab .PdfPage )error {_fbba ,_cab :=page .GetMediaBox ();if _cab !=nil {_gd .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_cab );
return _cab ;};_fbba .Normalize ();_fgge ,_baba :=_fbba .Llx ,_fbba .Lly ;_gbfb :=_fc .IdentityMatrix ();_bbg ,_cab :=page .GetRotate ();if _cab !=nil {_gd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_cab .Error ());
};_beag :=_bbg %360!=0&&_bbg %90==0;if _beag {_abgc :=float64 ((360+_bbg %360)%360);if _abgc ==90{_gbfb =_gbfb .Translate (_fbba .Width (),0);}else if _abgc ==180{_gbfb =_gbfb .Translate (_fbba .Width (),_fbba .Height ());}else if _abgc ==270{_gbfb =_gbfb .Translate (0,_fbba .Height ());
};_gbfb =_gbfb .Mult (_fc .RotationMatrix (_abgc *_de .Pi /180));_gbfb =_gbfb .Round (0.000001);_abfa :=_cdbag (_fbba ,_gbfb );_fbba =_abfa ;_fbba .Normalize ();};if _fgge !=0||_baba !=0{_gbfb =_fc .TranslationMatrix (_fgge ,_baba ).Mult (_gbfb );};if !_gbfb .Identity (){_gbfb =_gbfb .Round (0.000001);
_bedd ._bbee [page ]=&pageTransformations {_gfee :&_gbfb };};_bedd ._gede =_fbba .Width ();_bedd ._acea =_fbba .Height ();_bedd .initContext ();_bedd ._dbgc =append (_bedd ._dbgc ,page );_bedd ._aea .Page ++;return nil ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_egbf *Division )Height ()float64 {var _cdbg float64 ;for _ ,_dagb :=range _egbf ._bfad {switch _efeg :=_dagb .(type ){case marginDrawable :_ ,_ ,_dadd ,_adaf :=_efeg .GetMargins ();_cdbg +=_efeg .Height ()+_dadd +_adaf ;default:_cdbg +=_efeg .Height ();
};};return _cdbg ;};

// Reset removes all the text chunks the paragraph contains.
func (_aegad *StyledParagraph )Reset (){_aegad ._dcgfc =[]*TextChunk {}};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_dadbd *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dadbd ._dcbb .Left ,_dadbd ._dcbb .Right ,_dadbd ._dcbb .Top ,_dadbd ._dcbb .Bottom ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_facd *TOC )SetLineTitleStyle (style TextStyle ){_facd ._gagf =style };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_dbcg *Table )NewCell ()*TableCell {return _dbcg .MultiCell (1,1)};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fgcc *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _fgcc ._fagd [0],_fgcc ._fagd [1]};

// SetBorderWidth sets the border width.
func (_bfca *Ellipse )SetBorderWidth (bw float64 ){_bfca ._fce =bw };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_gcgd float64 ;_bggd float64 ;_caeb float64 ;_babdg float64 ;_fcff Color ;_edbac Color ;_fce float64 ;};func _gdfa ()*Division {return &Division {_acef :true }};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_egcaf *Creator )NewTextStyle ()TextStyle {return _deggb (_egcaf ._ebd )};

// AddLine appends a new line to the invoice line items table.
func (_gded *Invoice )AddLine (values ...string )[]*InvoiceCell {_accbe :=len (_gded ._cbee );var _eagf []*InvoiceCell ;for _aedd ,_efb :=range values {_afbag :=_gded .newCell (_efb ,_gded ._ggbcb );if _aedd < _accbe {_afbag .Alignment =_gded ._cbee [_aedd ].Alignment ;
};_eagf =append (_eagf ,_afbag );};_gded ._dfcd =append (_gded ._dfcd ,_eagf );return _eagf ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_dcdc *List )SetIndent (indent float64 ){_dcdc ._bgge =indent ;_dcdc ._cca =false };

// SetMargins sets the margins TOC line.
func (_gcddg *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_gcddg ._aacdb =left ;_bbegd :=&_gcddg ._agaae ._dfaeg ;_bbegd .Left =_gcddg ._aacdb +float64 (_gcddg ._fcecd -1)*_gcddg ._abfc ;_bbegd .Right =right ;_bbegd .Top =top ;_bbegd .Bottom =bottom ;
};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_ddfde *List )Add (item VectorDrawable )(*TextChunk ,error ){_cbade :=&listItem {_gfcf :item ,_defe :_ddfde ._gbac };switch _effg :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _effg ._cca {_effg ._bgge =15;};default:return nil ,_f .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_ddfde ._egcb =append (_ddfde ._egcb ,_cbade );return &_cbade ._defe ,nil ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_ca *Block )AddAnnotation (annotation *_ab .PdfAnnotation ){for _ ,_cfb :=range _ca ._fcg {if _cfb ==annotation {return ;};};_ca ._fcg =append (_ca ._fcg ,annotation );};

// SetBorderColor sets the border color.
func (_bggeb *PolyBezierCurve )SetBorderColor (color Color ){_bggeb ._fbef .BorderColor =_fad (color )};

// SetWidthRight sets border width for right.
func (_aca *border )SetWidthRight (bw float64 ){_aca ._eeb =bw };

// SetFillOpacity sets the fill opacity.
func (_bad *CurvePolygon )SetFillOpacity (opacity float64 ){_bad ._deff =opacity };

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_dgda rune ;_abd []error ;};

// Width returns the cell's width based on the input draw context.
func (_efce *TableCell )Width (ctx DrawContext )float64 {_defdd :=float64 (0.0);for _edag :=0;_edag < _efce ._fbagf ;_edag ++{_defdd +=_efce ._efea ._dbce [_efce ._gfdbd +_edag -1];};_abbed :=ctx .Width *_defdd ;return _abbed ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_fdbg *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _fdbg ._gegg .Left ,_fdbg ._gegg .Right ,_fdbg ._gegg .Top ,_fdbg ._gegg .Bottom ;};

// SetNumber sets the number of the invoice.
func (_gbdb *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gbdb ._cdeab [1].Value =number ;return _gbdb ._cdeab [0],_gbdb ._cdeab [1];};func _abeb (_faec []_ee .Point )*Polyline {return &Polyline {_fabf :&_ee .Polyline {Points :_faec ,LineColor :_ab .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_afbeb :1.0};
};

// SetFillColor sets the fill color for the path.
func (_bgcc *FilledCurve )SetFillColor (color Color ){_bgcc ._cbec =color };

// SetTerms sets the terms and conditions section of the invoice.
func (_dgee *Invoice )SetTerms (title ,content string ){_dgee ._aegfa =[2]string {title ,content }};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_cggf *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_cggf ._gffb .Left =left ;_cggf ._gffb .Right =right ;_cggf ._gffb .Top =top ;_cggf ._gffb .Bottom =bottom ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_dedc DrawContext )([]*Block ,DrawContext ,error );};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_ffc *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ffc ._ff .Left ,_ffc ._ff .Right ,_ffc ._ff .Top ,_ffc ._ff .Bottom ;};

// NewCurvePolygon creates a new curve polygon.
func (_fagba *Creator )NewCurvePolygon (rings [][]_ee .CubicBezierCurve )*CurvePolygon {return _fffa (rings );};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_dge *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dee :=ctx ;if _dge ._bea .IsRelative (){ctx .X +=_dge ._dfed .Left ;ctx .Y +=_dge ._dfed .Top ;ctx .Width -=_dge ._dfed .Left +_dge ._dfed .Right ;ctx .Height -=_dge ._dfed .Top ;
};_aebb ,_cafd ,_bbed :=_dge ._bgfbf .GeneratePageBlocks (ctx );if _bbed !=nil {return _aebb ,ctx ,_bbed ;};ctx =_cafd ;_ecdc :=ctx .X ;_cfbd :=ctx .Y -_dge ._bgfbf .Height ();_faf :=int64 (ctx .Page );_ged :=_dge .headingNumber ();_cae :=_dge .headingText ();
if _dge ._gea {_efe :=_dge ._bde .Add (_ged ,_dge ._caa ,_a .FormatInt (_faf ,10),_dge ._gbbe );if _dge ._bde ._bfbf {_efe .SetLink (_faf ,_ecdc ,_cfbd );};};if _dge ._afdf ==nil {_dge ._afdf =_ab .NewOutlineItem (_cae ,_ab .NewOutlineDest (_faf -1,_ecdc ,_cfbd ));
if _dge ._ecfb !=nil {_dge ._ecfb ._afdf .Add (_dge ._afdf );}else {_dge ._bda .Add (_dge ._afdf );};}else {_cga :=&_dge ._afdf .Dest ;_cga .Page =_faf -1;_cga .X =_ecdc ;_cga .Y =_cfbd ;};for _ ,_gegf :=range _dge ._dbf {_bdg ,_baf ,_feee :=_gegf .GeneratePageBlocks (ctx );
if _feee !=nil {return _aebb ,ctx ,_feee ;};if len (_bdg )< 1{continue ;};_aebb [len (_aebb )-1].mergeBlocks (_bdg [0]);_aebb =append (_aebb ,_bdg [1:]...);ctx =_baf ;};if _dge ._bea .IsRelative (){ctx .X =_dee .X ;};if _dge ._bea .IsAbsolute (){return _aebb ,_dee ,nil ;
};return _aebb ,ctx ,nil ;};func (_ad *Block )addContentsByString (_ggbg string )error {_ef :=_dc .NewContentStreamParser (_ggbg );_bgf ,_dae :=_ef .Parse ();if _dae !=nil {return _dae ;};_ad ._db .WrapIfNeeded ();_bgf .WrapIfNeeded ();*_ad ._db =append (*_ad ._db ,*_bgf ...);
return nil ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_begfb *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _begfb ._beacc ,_begfb ._bceg ,_begfb ._aaff ,_begfb ._gdeg ;};func _ggc (_fggg *Chapter ,_cdb *TOC ,_begd *_ab .Outline ,_gfg string ,_agfa int ,_fcgg TextStyle )*Chapter {var _dbc uint =1;
if _fggg !=nil {_dbc =_fggg ._gbbe +1;};_gadd :=&Chapter {_cdcc :_agfa ,_caa :_gfg ,_acaa :true ,_gea :true ,_ecfb :_fggg ,_bde :_cdb ,_bda :_begd ,_dbf :[]Drawable {},_gbbe :_dbc };_cec :=_ecgc (_gadd .headingText (),_fcgg );_cec .SetFont (_fcgg .Font );
_cec .SetFontSize (_fcgg .FontSize );_gadd ._bgfbf =_cec ;return _gadd ;};func _fffd (_fcfff ,_gcfg ,_cbdf ,_efcd float64 )*Ellipse {_cfbgc :=&Ellipse {};_cfbgc ._gcgd =_fcfff ;_cfbgc ._bggd =_gcfg ;_cfbgc ._caeb =_cbdf ;_cfbgc ._babdg =_efcd ;_cfbgc ._edbac =ColorBlack ;
_cfbgc ._fce =1.0;return _cfbgc ;};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// CreateFrontPage sets a function to generate a front Page.
func (_aaef *Creator )CreateFrontPage (genFrontPageFunc func (_aab FrontpageFunctionArgs )){_aaef ._dgef =genFrontPageFunc ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Table
// - *List
// - *Division
// - *Chart
func (_cbbb *TableCell )SetContent (vd VectorDrawable )error {switch _cfea :=vd .(type ){case *Paragraph :if _cfea ._caeef {_cfea ._ccff =true ;};_cbbb ._ggcge =vd ;case *StyledParagraph :if _cfea ._gbdba {_cfea ._egcgf =true ;};_cbbb ._ggcge =vd ;case *Image :_cbbb ._ggcge =vd ;
case *Table :_cbbb ._ggcge =vd ;case *List :_cbbb ._ggcge =vd ;case *Division :_cbbb ._ggcge =vd ;case *Chart :_cbbb ._ggcge =vd ;default:_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _abe .ErrTypeError ;};return nil ;};

// TOC returns the table of contents component of the creator.
func (_egf *Creator )TOC ()*TOC {return _egf ._efab };

// BuyerAddress returns the buyer address used in the invoice template.
func (_cafc *Invoice )BuyerAddress ()*InvoiceAddress {return _cafc ._aba };

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_cdcd *Table )MultiCell (rowspan ,colspan int )*TableCell {_cdcd ._aaae ++;_ecdcb :=(_cdcd .moveToNextAvailableCell ()-1)%(_cdcd ._egcbg )+1;_cdaf :=(_cdcd ._aaae -1)/_cdcd ._egcbg +1;for _cdaf > _cdcd ._badc {_cdcd ._badc ++;_cdcd ._aace =append (_cdcd ._aace ,_cdcd ._cced );
};_eabd :=&TableCell {};_eabd ._edeaa =_cdaf ;_eabd ._gfdbd =_ecdcb ;_eabd ._eaea =5;_eabd ._edaed =CellBorderStyleNone ;_eabd ._bbgf =_ee .LineStyleSolid ;_eabd ._ffeg =CellHorizontalAlignmentLeft ;_eabd ._fcga =CellVerticalAlignmentTop ;_eabd ._dbgf =0;
_eabd ._ffedc =0;_eabd ._ccdc =0;_eabd ._ggeed =0;_efeeg :=ColorBlack ;_eabd ._bggec =_efeeg ;_eabd ._bfcg =_efeeg ;_eabd ._efgb =_efeeg ;_eabd ._aacdg =_efeeg ;if rowspan < 1{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_cagff :=_cdcd ._badc -(_eabd ._edeaa -1);if rowspan > _cagff {_gd .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_cagff );
_cdcd ._badc +=rowspan -1;for _cgebf :=0;_cgebf <=rowspan -_cagff ;_cgebf ++{_cdcd ._aace =append (_cdcd ._aace ,_cdcd ._cced );};};for _dffad :=0;_dffad < colspan &&_ecdcb +_dffad -1< len (_cdcd ._gec );_dffad ++{_cdcd ._gec [_ecdcb +_dffad -1]=rowspan -1;
};_eabd ._efbb =rowspan ;if colspan < 1{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_fccd :=_cdcd ._egcbg -(_eabd ._gfdbd -1);if colspan > _fccd {_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_fccd );
colspan =_fccd ;};_eabd ._fbagf =colspan ;_cdcd ._aaae +=colspan -1;_cdcd ._ddgb =append (_cdcd ._ddgb ,_eabd );_eabd ._efea =_cdcd ;return _eabd ;};

// GeneratePageBlocks generates a page break block.
func (_eedgc *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abge :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_aaefd :=ctx ;_aaefd .Y =ctx .Margins .Top ;
_aaefd .X =ctx .Margins .Left ;_aaefd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_aaefd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_aaefd ;return _abge ,ctx ,nil ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_facb *Paragraph )SetWidth (width float64 ){_facb ._defgc =width ;_facb .wrapText ()};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_ecg *Creator )SetOptimizer (optimizer _ab .Optimizer ){_ecg ._faggg =optimizer };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bbd *Block )ScaleToWidth (w float64 ){_dcb :=w /_bbd ._cc ;_bbd .Scale (_dcb ,_dcb )};func _cfde (_bafeg string )(*Image ,error ){_ffdc ,_dgdd :=_g .Open (_bafeg );if _dgdd !=nil {return nil ,_dgdd ;};defer _ffdc .Close ();_gdea ,_dgdd :=_ab .ImageHandling .Read (_ffdc );
if _dgdd !=nil {_gd .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dgdd );return nil ,_dgdd ;};return _ggf (_gdea );};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_cfbed *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_cfbed ._ffeg =halign ;};

// Lines returns all the rows of the invoice line items table.
func (_gab *Invoice )Lines ()[][]*InvoiceCell {return _gab ._dfcd };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_bbede *Creator )NewPolyBezierCurve (curves []_ee .CubicBezierCurve )*PolyBezierCurve {return _dfac (curves );};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetFillOpacity sets the fill opacity.
func (_bef *Polygon )SetFillOpacity (opacity float64 ){_bef ._bbdgb =opacity };

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_cbea *Division )Width ()float64 {return 0};

// Height returns the height of the chart.
func (_daee *Chart )Height ()float64 {return float64 (_daee ._fdgb .Height ())};

// SetLineHeight sets the line height (1.0 default).
func (_fdef *Paragraph )SetLineHeight (lineheight float64 ){_fdef ._ebaad =lineheight };func (_dec *Block )setOpacity (_ge float64 ,_dcg float64 )(string ,error ){if (_ge < 0||_ge >=1.0)&&(_dcg < 0||_dcg >=1.0){return "",nil ;};_bga :=0;_cg :=_bb .Sprintf ("\u0047\u0053\u0025\u0064",_bga );
for _dec ._af .HasExtGState (_abe .PdfObjectName (_cg )){_bga ++;_cg =_bb .Sprintf ("\u0047\u0053\u0025\u0064",_bga );};_be :=_abe .MakeDict ();if _ge >=0&&_ge < 1.0{_be .Set ("\u0063\u0061",_abe .MakeFloat (_ge ));};if _dcg >=0&&_dcg < 1.0{_be .Set ("\u0043\u0041",_abe .MakeFloat (_dcg ));
};_agd :=_dec ._af .AddExtGState (_abe .PdfObjectName (_cg ),_be );if _agd !=nil {return "",_agd ;};return _cg ,nil ;};func _bfeg (_bfdea string ,_dbacd ,_ffcab TextStyle )*TOC {_adff :=_ffcab ;_adff .FontSize =14;_efgfa :=_abga (_adff );_efgfa .SetEnableWrap (true );
_efgfa .SetTextAlignment (TextAlignmentLeft );_efgfa .SetMargins (0,0,0,5);_geaff :=_efgfa .Append (_bfdea );_geaff .Style =_adff ;return &TOC {_cfda :_efgfa ,_adec :[]*TOCLine {},_afeeg :_dbacd ,_gagf :_dbacd ,_dgffe :_dbacd ,_ceeae :_dbacd ,_cceea :"\u002e",_bgbf :10,_decf :Margins {0,0,2,2},_fagea :PositionRelative ,_ageb :_dbacd ,_bfbf :true };
};

// SkipOver skips over a specified number of rows and cols.
func (_gcdcf *Table )SkipOver (rows ,cols int ){_gbae :=rows *_gcdcf ._egcbg +cols -1;if _gbae < 0{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gcdcf ._aaae +=_gbae ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_abfe *Invoice )NoteStyle ()TextStyle {return _abfe ._acgb };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cfaca *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faggc :=ctx ;_cgfg ,ctx ,_fbea :=_cfaca ._agaae .GeneratePageBlocks (ctx );if _fbea !=nil {return _cgfg ,ctx ,_fbea ;};if _cfaca ._gcaa .IsRelative (){ctx .X =_faggc .X ;
};if _cfaca ._gcaa .IsAbsolute (){return _cgfg ,_faggc ,nil ;};return _cgfg ,ctx ,nil ;};

// Heading returns the heading component of the table of contents.
func (_cabca *TOC )Heading ()*StyledParagraph {return _cabca ._cfda };

// Width returns the current page width.
func (_aef *Creator )Width ()float64 {return _aef ._gede };func _cdbag (_gacaa *_ab .PdfRectangle ,_abcg _fc .Matrix )*_ab .PdfRectangle {var _acaeb _ab .PdfRectangle ;_acaeb .Llx ,_acaeb .Lly =_abcg .Transform (_gacaa .Llx ,_gacaa .Lly );_acaeb .Urx ,_acaeb .Ury =_abcg .Transform (_gacaa .Urx ,_gacaa .Ury );
_acaeb .Normalize ();return &_acaeb ;};

// SetBorderOpacity sets the border opacity.
func (_afee *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_afee ._gggd =opacity };

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_beacc float64 ;_bceg float64 ;_aaff float64 ;_gdeg float64 ;_aafdc Color ;_eea float64 ;};func (_ebaa *Creator )setActivePage (_agaa *_ab .PdfPage ){_ebaa ._eca =_agaa };

// SetFillColor sets the fill color.
func (_acadf *Rectangle )SetFillColor (col Color ){_acadf ._cecg =col };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ggb :=&Block {};_ggb ._db =&_dc .ContentStreamOperations {};_ggb ._af =_ab .NewPdfPageResources ();_ggb ._cc =width ;_ggb ._bf =height ;return _ggb ;};func _cbde (_eacg *_g .File )([]*_ab .PdfPage ,error ){_agga ,_gafac :=_ab .NewPdfReader (_eacg );
if _gafac !=nil {return nil ,_gafac ;};_bffe ,_gafac :=_agga .GetNumPages ();if _gafac !=nil {return nil ,_gafac ;};var _fbfb []*_ab .PdfPage ;for _caab :=0;_caab < _bffe ;_caab ++{_bbccg ,_fgcaa :=_agga .GetPage (_caab +1);if _fgcaa !=nil {return nil ,_fgcaa ;
};_fbfb =append (_fbfb ,_bbccg );};return _fbfb ,nil ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_bed :_de .Max (_de .Min (r ,1.0),0.0),_afbf :_de .Max (_de .Min (g ,1.0),0.0),_eebd :_de .Max (_de .Min (b ,1.0),0.0)};};

// SetBuyerAddress sets the buyer address of the invoice.
func (_efff *Invoice )SetBuyerAddress (address *InvoiceAddress ){_efff ._aba =address };func _fdgdg ()*PageBreak {return &PageBreak {}};

// String implements error interface.
func (_efee UnsupportedRuneError )Error ()string {return _efee .Message };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_eedd *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_bfda :=[2]*InvoiceCell {_eedd .newCell (description ,_eedd ._gfgf ),_eedd .newCell (value ,_eedd ._gfgf )};_eedd ._afbd =append (_eedd ._afbd ,_bfda );return _bfda [0],_bfda [1];
};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0);
);

// SetBorderColor sets the border color.
func (_age *Ellipse )SetBorderColor (col Color ){_age ._edbac =col };func (_fcdg *StyledParagraph )split (_gage DrawContext )(_cfcc ,_abaad *StyledParagraph ,_adeb error ){if _adeb =_fcdg .wrapChunks (false );_adeb !=nil {return nil ,nil ,_adeb ;};_addb :=func (_bgggb []*TextChunk ,_gfdf []*TextChunk )[]*TextChunk {if len (_gfdf )==0{return _bgggb ;
};_cbfd :=len (_bgggb );if _cbfd ==0{return append (_bgggb ,_gfdf ...);};_bgggb [_cbfd -1].Text +=_gfdf [0].Text ;return append (_bgggb ,_gfdf [1:]...);};_ffee :=func (_gfgcg *StyledParagraph ,_bffcde []*TextChunk )*StyledParagraph {if len (_bffcde )==0{return nil ;
};_dfda :=*_gfgcg ;_dfda ._dcgfc =_bffcde ;return &_dfda ;};var (_gedb float64 ;_fgbec []*TextChunk ;_ceaa []*TextChunk ;);for _ ,_adb :=range _fcdg ._cdec {var _fgeg float64 ;_deeec :=make ([]*TextChunk ,0,len (_adb ));for _ ,_defda :=range _adb {if _fgee :=_defda .Style .FontSize ;
_fgee > _fgeg {_fgeg =_fgee ;};_deeec =append (_deeec ,_defda .clone ());};_fgeg *=_fcdg ._aaffc ;if _fcdg ._gcedb .IsRelative (){if _gedb +_fgeg > _gage .Height {_ceaa =_addb (_ceaa ,_deeec );}else {_fgbec =_addb (_fgbec ,_deeec );};};_gedb +=_fgeg ;};
_fcdg ._cdec =nil ;if len (_ceaa )==0{return _fcdg ,nil ,nil ;};return _ffee (_fcdg ,_fgbec ),_ffee (_fcdg ,_ceaa ),nil ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_edfe *StyledParagraph )SetText (text string )*TextChunk {_edfe .Reset ();return _edfe .Append (text );};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_adfge string ;_dccg *_ab .PdfFont ;_bffa float64 ;_ebaad float64 ;_adfd Color ;_dfdd TextAlignment ;_ccff bool ;_defgc float64 ;_dcad int ;_caeef bool ;_fbga float64 ;_cagec Margins ;_cbecc Positioning ;_bgba float64 ;_fcda float64 ;
_cded ,_fdcfd float64 ;_eeff []string ;};

// SetFillColor sets the fill color.
func (_dddcb *PolyBezierCurve )SetFillColor (color Color ){_dddcb ._fbef .FillColor =_fad (color )};

// SetShowLinks sets visibility of links for the TOC lines.
func (_efacc *TOC )SetShowLinks (showLinks bool ){_efacc ._bfbf =showLinks };func _gbfbb ()*FilledCurve {_fffdc :=FilledCurve {};_fffdc ._cgbg =[]_ee .CubicBezierCurve {};return &_fffdc ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_efbc *TOCLine )SetLevelOffset (levelOffset float64 ){_efbc ._abfc =levelOffset ;_efbc ._agaae ._dfaeg .Left =_efbc ._aacdb +float64 (_efbc ._fcecd -1)*_efbc ._abfc ;};

// SetStyleBottom sets border style for bottom side.
func (_bcf *border )SetStyleBottom (style CellBorderStyle ){_bcf ._ecfa =style };

// The Image type is used to draw an image onto PDF.
type Image struct{_dbdf *_ab .XObjectImage ;_cbad *_ab .Image ;_caceg float64 ;_adef ,_gag float64 ;_gaed ,_caeg float64 ;_fadad Positioning ;_bdeca HorizontalAlignment ;_bfec float64 ;_gbbeb float64 ;_bcb float64 ;_dcbb Margins ;_dbag ,_cege float64 ;
_gafd _abe .StreamEncoder ;};func _faef (_cgef TextStyle )*List {return &List {_gbac :TextChunk {Text :"\u2022\u0020",Style :_cgef },_bgge :0,_cca :true ,_gfa :PositionRelative ,_egga :_cgef };};

// MoveY moves the drawing context to absolute position y.
func (_cfgb *Creator )MoveY (y float64 ){_cfgb ._aea .Y =y };func (_degb *StyledParagraph )wrapChunks (_fbcbe bool )error {if !_degb ._egcgf ||int (_degb ._dfgd )<=0{_degb ._cdec =[][]*TextChunk {_degb ._dcgfc };return nil ;};_degb ._cdec =[][]*TextChunk {};
var _dgfa []*TextChunk ;var _aacdc float64 ;_gdc :=_ae .IsSpace ;if !_fbcbe {_gdc =func (rune )bool {return false };};_eefd :=_dfggd (_degb ._dfgd *1000.0,0.000001);for _ ,_dceg :=range _degb ._dcgfc {_ceebb :=_dceg .Style ;_adgd :=_dceg ._ffcff ;var (_bdee []rune ;
_cgcee []float64 ;);for _ ,_ddafa :=range _dceg .Text {if _ddafa =='\u000A'{if !_fbcbe {_bdee =append (_bdee ,_ddafa );};_dgfa =append (_dgfa ,&TextChunk {Text :_fg .TrimRightFunc (string (_bdee ),_gdc ),Style :_ceebb ,_ffcff :_fefcf (_adgd )});_degb ._cdec =append (_degb ._cdec ,_dgfa );
_dgfa =nil ;_aacdc =0;_bdee =nil ;_cgcee =nil ;continue ;};_bccg :=_ddafa ==' ';_bbeg ,_befc :=_ceebb .Font .GetRuneMetrics (_ddafa );if !_befc {_gd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ddafa );
return _f .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_gebb :=_ceebb .FontSize *_bbeg .Wx *_ceebb .horizontalScale ();_gcdc :=_gebb ;if !_bccg {_gcdc =_gebb +_ceebb .CharSpacing *1000.0;
};if _aacdc +_gebb > _eefd {_dddg :=-1;if !_bccg {for _egec :=len (_bdee )-1;_egec >=0;_egec --{if _bdee [_egec ]==' '{_dddg =_egec ;break ;};};};_ebaec :=string (_bdee );if _dddg >=0{_ebaec =string (_bdee [0:_dddg +1]);_bdee =_bdee [_dddg +1:];_bdee =append (_bdee ,_ddafa );
_cgcee =_cgcee [_dddg +1:];_cgcee =append (_cgcee ,_gcdc );_aacdc =0;for _ ,_aead :=range _cgcee {_aacdc +=_aead ;};}else {if _bccg {_aacdc =0;_bdee =[]rune {};_cgcee =[]float64 {};}else {_aacdc =_gcdc ;_bdee =[]rune {_ddafa };_cgcee =[]float64 {_gcdc };
};};if !_fbcbe &&_bccg {_ebaec +="\u0020";};_dgfa =append (_dgfa ,&TextChunk {Text :_fg .TrimRightFunc (_ebaec ,_gdc ),Style :_ceebb ,_ffcff :_fefcf (_adgd )});_degb ._cdec =append (_degb ._cdec ,_dgfa );_dgfa =[]*TextChunk {};}else {_aacdc +=_gcdc ;_bdee =append (_bdee ,_ddafa );
_cgcee =append (_cgcee ,_gcdc );};};if len (_bdee )> 0{_dgfa =append (_dgfa ,&TextChunk {Text :string (_bdee ),Style :_ceebb ,_ffcff :_fefcf (_adgd )});};};if len (_dgfa )> 0{_degb ._cdec =append (_degb ._cdec ,_dgfa );};return nil ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_gae :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_gd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gae ;
};var _eec ,_bff ,_bdcg int ;if len (hexStr )==4{var _aede ,_fadf ,_gbfg int ;_adcc ,_bab :=_bb .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_aede ,&_fadf ,&_gbfg );if _bab !=nil {_gd .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_bab );
return _gae ;};if _adcc !=3{_gd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gae ;};_eec =_aede *16+_aede ;_bff =_fadf *16+_fadf ;_bdcg =_gbfg *16+_gbfg ;}else {_bgff ,_geb :=_bb .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_eec ,&_bff ,&_bdcg );
if _geb !=nil {_gd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gae ;};if _bgff !=3{_gd .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bgff );
return _gae ;};};_aae :=float64 (_eec )/255.0;_acb :=float64 (_bff )/255.0;_cgab :=float64 (_bdcg )/255.0;_gae ._bed =_aae ;_gae ._afbf =_acb ;_gae ._eebd =_cgab ;return _gae ;};

// SetFillColor sets the fill color.
func (_fdac *Ellipse )SetFillColor (col Color ){_fdac ._fcff =col };

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_efgca float64 ;_gdgd float64 ;_aceg float64 ;_afcf float64 ;_cecg Color ;_daeb float64 ;_gfdb Color ;_acgbg float64 ;_fbdf float64 ;};

// Height returns the height of the list.
func (_fbgb *List )Height ()float64 {var _gcfa float64 ;for _ ,_caag :=range _fbgb ._egcb {_gcfa +=_caag ._gfcf .Height ();};return _gcfa ;};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_gfed *Creator )EnableFontSubsetting (font *_ab .PdfFont ){_gfed ._gaddc =append (_gfed ._gaddc ,font );};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_bgce *Rectangle )GetCoords ()(float64 ,float64 ){return _bgce ._efgca ,_bgce ._gdgd };

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_ccdea *Table )EnableRowWrap (enable bool ){_ccdea ._dafa =enable };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_aege *StyledParagraph )Height ()float64 {_aege .wrapText ();var _cecfc float64 ;for _ ,_gcgf :=range _aege ._cdec {var _abea float64 ;for _ ,_eccg :=range _gcgf {_eabc :=_aege ._aaffc *_eccg .Style .FontSize ;if _eabc > _abea {_abea =_eabc ;};};
_cecfc +=_abea ;};return _cecfc ;};func _dfa (_ccb ,_agg *_ab .PdfPageResources )error {_ccg ,_ :=_ccb .GetColorspaces ();if _ccg !=nil &&len (_ccg .Colorspaces )> 0{for _gad ,_fdgd :=range _ccg .Colorspaces {_adc :=*_abe .MakeName (_gad );if _agg .HasColorspaceByName (_adc ){continue ;
};_bba :=_agg .SetColorspaceByName (_adc ,_fdgd );if _bba !=nil {return _bba ;};};};return nil ;};

// SetStyleLeft sets border style for left side.
func (_fcc *border )SetStyleLeft (style CellBorderStyle ){_fcc ._cgf =style };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_fbef *_ee .PolyBezierCurve ;_dbfe float64 ;_gggd float64 ;};func _ecgc (_gfeb string ,_egefg TextStyle )*Paragraph {_cfgg :=&Paragraph {_adfge :_gfeb ,_dccg :_egefg .Font ,_bffa :_egefg .FontSize ,_ebaad :1.0,_ccff :true ,_caeef :true ,_dfdd :TextAlignmentLeft ,_fbga :0,_cded :1,_fdcfd :1,_cbecc :PositionRelative };
_cfgg .SetColor (_egefg .Color );return _cfgg ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_aedb *Creator )RotateDeg (angleDeg int64 )error {_bdaea :=_aedb .getActivePage ();if _bdaea ==nil {_gd .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _f .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_gd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _eagc int64 ;if _bdaea .Rotate !=nil {_eagc =*(_bdaea .Rotate );};_eagc +=angleDeg ;_bdaea .Rotate =&_eagc ;return nil ;};

// SetColor sets the line color.
func (_dafe *Curve )SetColor (col Color ){_dafe ._aega =col };

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_dcgfc []*TextChunk ;_babe TextStyle ;_dbac TextStyle ;_bfcfg TextAlignment ;_dgac TextVerticalAlignment ;_aaffc float64 ;_egcgf bool ;_dfgd float64 ;_gbdba bool ;_bfaba TextOverflow ;_fgaa float64 ;_dfaeg Margins ;_gcedb Positioning ;
_cbaf float64 ;_egfe float64 ;_gagca float64 ;_bfac float64 ;_cdec [][]*TextChunk ;_acda func (_bgga *StyledParagraph ,_gfcg DrawContext );};

// SetBorderWidth sets the border width.
func (_eceg *Polygon )SetBorderWidth (borderWidth float64 ){_eceg ._ebccd .BorderWidth =borderWidth };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_bfdg *TOC )SetLineSeparator (separator string ){_bfdg ._cceea =separator };func (_cadf *Division )ctxHeight (_baga float64 )float64 {var _ccbb float64 ;for _ ,_gfga :=range _cadf ._bfad {_ccbb +=_adde (_gfga ,_baga );};return _ccbb ;};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};func _fefcf (_agged *_ab .PdfAnnotation )*_ab .PdfAnnotation {if _agged ==nil {return nil ;};var _acag *_ab .PdfAnnotation ;switch _bcgf :=_agged .GetContext ().(type ){case *_ab .PdfAnnotationLink :if _gcfbb :=_dbadb (_bcgf );
_gcfbb !=nil {_acag =_gcfbb .PdfAnnotation ;};};return _acag ;};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_ebdg *Paragraph )SetColor (col Color ){_ebdg ._adfd =col };

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// TitleStyle returns the style properties used to render the invoice title.
func (_ffge *Invoice )TitleStyle ()TextStyle {return _ffge ._fdcf };

// Write output of creator to io.Writer interface.
func (_eab *Creator )Write (ws _e .Writer )error {if _ebge :=_eab .Finalize ();_ebge !=nil {return _ebge ;};_dfae :=_ab .NewPdfWriter ();_dfae .SetOptimizer (_eab ._faggg );if _eab ._cfbg !=nil {_fafe :=_dfae .SetForms (_eab ._cfbg );if _fafe !=nil {_gd .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_fafe );
return _fafe ;};};if _eab ._bgb !=nil {_dfae .AddOutlineTree (_eab ._bgb );}else if _eab ._aeag !=nil &&_eab .AddOutlines {_dfae .AddOutlineTree (&_eab ._aeag .ToPdfOutline ().PdfOutlineTreeNode );};if _eab ._daaa !=nil {if _dba :=_dfae .SetPageLabels (_eab ._daaa );
_dba !=nil {_gd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_dba );return _dba ;};};if _eab ._gaddc !=nil {for _ ,_dea :=range _eab ._gaddc {_fgbe :=_dea .SubsetRegistered ();
if _fgbe !=nil {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_fgbe );return _fgbe ;};};};if _eab ._bae !=nil {_gffe :=_eab ._bae (&_dfae );
if _gffe !=nil {_gd .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_gffe );return _gffe ;};};for _ ,_dfaf :=range _eab ._dbgc {_edf :=_dfae .AddPage (_dfaf );if _edf !=nil {_gd .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_edf );
return _edf ;};};_ebb :=_dfae .Write (ws );if _ebb !=nil {return _ebb ;};return nil ;};

// CurCol returns the currently active cell's column number.
func (_ffac *Table )CurCol ()int {_fdde :=(_ffac ._aaae -1)%(_ffac ._egcbg )+1;return _fdde };

// SetAngle sets the rotation angle of the text.
func (_afgc *Paragraph )SetAngle (angle float64 ){_afgc ._fbga =angle };

// GetMargins returns the left, right, top, bottom Margins.
func (_gggdf *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gggdf ._abca .Left ,_gggdf ._abca .Right ,_gggdf ._abca .Top ,_gggdf ._abca .Bottom ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_cbcg *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _caec (number ,title ,page ,level ,_cbcg .NewTextStyle ());};func _geaf (_eafcd string )*_ab .PdfAnnotation {_aafe :=_ab .NewPdfAnnotationLink ();_eaaa :=_ab .NewBorderStyle ();
_eaaa .SetBorderWidth (0);_aafe .BS =_eaaa .ToPdfObject ();_edbg :=_ab .NewPdfActionURI ();_edbg .URI =_abe .MakeString (_eafcd );_aafe .SetAction (_edbg .PdfAction );return _aafe .PdfAnnotation ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_feg *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_fda ,_ ,_cgee :=d .GeneratePageBlocks (ctx );if _cgee !=nil {return _cgee ;};if len (_fda )!=1{return _f .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_cfe :=range _fda {if _bce :=_feg .mergeBlocks (_cfe );_bce !=nil {return _bce ;};};return nil ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_fecb *Creator )SetPageSize (size PageSize ){_fecb ._dffe =size ;_fecb ._gede =size [0];_fecb ._acea =size [1];_abefa :=0.1*_fecb ._gede ;_fecb ._gffb .Left =_abefa ;_fecb ._gffb .Right =_abefa ;_fecb ._gffb .Top =_abefa ;_fecb ._gffb .Bottom =_abefa ;
};func (_ebea *TableCell )width (_gdaee []float64 ,_bffca float64 )float64 {_ccac :=float64 (0.0);for _cdfc :=0;_cdfc < _ebea ._fbagf ;_cdfc ++{_ccac +=_gdaee [_ebea ._gfdbd +_cdfc -1];};return _ccac *_bffca ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;
TextVerticalAlignmentCenter ;);

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_dfgg *Invoice )Terms ()(string ,string ){return _dfgg ._aegfa [0],_dfgg ._aegfa [1]};

// NewFilledCurve returns a instance of filled curve.
func (_ddc *Creator )NewFilledCurve ()*FilledCurve {return _gbfbb ()};func (_aaccd *Paragraph )wrapText ()error {if !_aaccd ._ccff ||int (_aaccd ._defgc )<=0{_aaccd ._eeff =[]string {_aaccd ._adfge };return nil ;};_cgff :=NewTextChunk (_aaccd ._adfge ,TextStyle {Font :_aaccd ._dccg ,FontSize :_aaccd ._bffa });
_bgbg ,_abda :=_cgff .Wrap (_aaccd ._defgc );if _abda !=nil {return _abda ;};if _aaccd ._dcad > 0&&len (_bgbg )> _aaccd ._dcad {_bgbg =_bgbg [:_aaccd ._dcad ];};_aaccd ._eeff =_bgbg ;return nil ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_bdab *TOCLine )LevelOffset ()float64 {return _bdab ._abfc };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_efc *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_efc ._dfed .Left =left ;_efc ._dfed .Right =right ;_efc ._dfed .Top =top ;_efc ._dfed .Bottom =bottom ;};

// SetRowHeight sets the height for a specified row.
func (_bgef *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_bgef ._aace ){return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bgef ._aace [row -1]=h ;return nil ;
};func _ebcc (_fbfd ,_ddae ,_bac ,_bfcd ,_edae ,_eedf float64 )*Curve {_eedfg :=&Curve {};_eedfg ._dagc =_fbfd ;_eedfg ._fadb =_ddae ;_eedfg ._ggcf =_bac ;_eedfg ._bbbg =_bfcd ;_eedfg ._afcc =_edae ;_eedfg ._ebfa =_eedf ;_eedfg ._aega =ColorBlack ;_eedfg ._bdgaa =1.0;
return _eedfg ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_dffgd *TOC )SetLineLevelOffset (levelOffset float64 ){_dffgd ._bgbf =levelOffset };

// SetTotal sets the total of the invoice.
func (_decdbg *Invoice )SetTotal (value string ){_decdbg ._fagd [1].Value =value };func (_bbeee *Invoice )drawAddress (_gefe *InvoiceAddress )[]*StyledParagraph {var _ebca []*StyledParagraph ;if _gefe .Heading !=""{_dagf :=_abga (_bbeee ._decc );_dagf .SetMargins (0,0,0,7);
_dagf .Append (_gefe .Heading );_ebca =append (_ebca ,_dagf );};_dagbd :=_abga (_bbeee ._afcaf );_dagbd .SetLineHeight (1.2);_eage :=_gefe .Separator ;if _eage ==""{_eage =_bbeee ._beb ;};_gbeee :=_gefe .City ;if _gefe .State !=""{if _gbeee !=""{_gbeee +=_eage ;
};_gbeee +=_gefe .State ;};if _gefe .Zip !=""{if _gbeee !=""{_gbeee +=_eage ;};_gbeee +=_gefe .Zip ;};if _gefe .Name !=""{_dagbd .Append (_gefe .Name +"\u000a");};if _gefe .Street !=""{_dagbd .Append (_gefe .Street +"\u000a");};if _gefe .Street2 !=""{_dagbd .Append (_gefe .Street2 +"\u000a");
};if _gbeee !=""{_dagbd .Append (_gbeee +"\u000a");};if _gefe .Country !=""{_dagbd .Append (_gefe .Country +"\u000a");};_dcbff :=_abga (_bbeee ._afcaf );_dcbff .SetLineHeight (1.2);_dcbff .SetMargins (0,0,7,0);if _gefe .Phone !=""{_dcbff .Append (_gefe .fmtLine (_gefe .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_gefe .HidePhoneLabel ));
};if _gefe .Email !=""{_dcbff .Append (_gefe .fmtLine (_gefe .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_gefe .HideEmailLabel ));};_ebca =append (_ebca ,_dagbd ,_dcbff );return _ebca ;};func (_dedbg *Division )split (_fafg DrawContext )(_bfde ,_bfcf *Division ){var _caee float64 ;
var _fdbe ,_addg []VectorDrawable ;for _daed ,_fcfc :=range _dedbg ._bfad {_caee +=_adde (_fcfc ,_fafg .Width );if _caee < _fafg .Height {_fdbe =append (_fdbe ,_fcfc );}else {_addg =_dedbg ._bfad [_daed :];break ;};};if len (_fdbe )> 0{_bfde =_gdfa ();
_bfde ._bfad =_fdbe ;};if len (_addg )> 0{_bfcf =_gdfa ();_bfcf ._bfad =_addg ;};return _bfde ,_bfcf ;};func (_dabe *Creator )getActivePage ()*_ab .PdfPage {if _dabe ._eca ==nil {if len (_dabe ._dbgc )==0{return nil ;};return _dabe ._dbgc [len (_dabe ._dbgc )-1];
};return _dabe ._eca ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_ab .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetFillColor sets background color for border.
func (_gee *border )SetFillColor (col Color ){_gee ._aggf =col };func _aeg (_gega string ,_aee _abe .PdfObject ,_ggd *_ab .PdfPageResources )_abe .PdfObjectName {_cfa :=_fg .TrimRightFunc (_fg .TrimSpace (_gega ),func (_ccc rune )bool {return _ae .IsNumber (_ccc )});
if _cfa ==""{_cfa ="\u0046\u006f\u006e\u0074";};_efg :=0;_ceb :=_abe .PdfObjectName (_gega );for {_dbg ,_aaa :=_ggd .GetFontByName (_ceb );if !_aaa ||_dbg ==_aee {break ;};_efg ++;_ceb =_abe .PdfObjectName (_bb .Sprintf ("\u0025\u0073\u0025\u0064",_cfa ,_efg ));
};return _ceb ;};func (_daad *pageTransformations )transformPage (_cefe *_ab .PdfPage )error {if _bedc :=_daad .applyFlip (_cefe );_bedc !=nil {return _bedc ;};return nil ;};

// SetPos sets absolute positioning with specified coordinates.
func (_geab *StyledParagraph )SetPos (x ,y float64 ){_geab ._gcedb =PositionAbsolute ;_geab ._cbaf =x ;_geab ._egfe =y ;};type rgbColor struct{_bed ,_afbf ,_eebd float64 };

// SetDueDate sets the due date of the invoice.
func (_cebg *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_cebg ._aefg [1].Value =dueDate ;return _cebg ._aefg [0],_cebg ._aefg [1];};

// Lines returns all the lines the table of contents has.
func (_eageg *TOC )Lines ()[]*TOCLine {return _eageg ._adec };

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_gegcf *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _fffd (xc ,yc ,width ,height );};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_ffag *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_ffag ._efab =toc ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_ageg *Paragraph )SetTextAlignment (align TextAlignment ){_ageg ._dfdd =align };

// IsRelative checks if the positioning is relative.
func (_abg Positioning )IsRelative ()bool {return _abg ==PositionRelative };type cmykColor struct{_gfd ,_gbd ,_bbfd ,_ggbe float64 };type border struct{_fagb float64 ;_dga float64 ;_dag float64 ;_cgeb float64 ;_aggf Color ;_ada Color ;_ggea float64 ;_ggbc Color ;
_bgcd float64 ;_cccb Color ;_eeb float64 ;_ecd Color ;_adf float64 ;LineStyle _ee .LineStyle ;_cgf CellBorderStyle ;_ecf CellBorderStyle ;_cceb CellBorderStyle ;_ecfa CellBorderStyle ;};

// SetBorderColor sets the cell's border color.
func (_abbe *TableCell )SetBorderColor (col Color ){_abbe ._bggec =col ;_abbe ._bfcg =col ;_abbe ._efgb =col ;_abbe ._aacdg =col ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// Indent returns the left offset of the list when nested into another list.
func (_defg *List )Indent ()float64 {return _defg ._bgge };func (_dgceg *StyledParagraph )getTextLineWidth (_dcef []*TextChunk )float64 {var _gcgb float64 ;_eagfc :=len (_dcef );for _bcgc ,_ebcfe :=range _dcef {_bbdf :=&_ebcfe .Style ;_aafg :=len (_ebcfe .Text );
for _accbf ,_bdedf :=range _ebcfe .Text {if _bdedf =='\u000A'{continue ;};_cfed ,_cegb :=_bbdf .Font .GetRuneMetrics (_bdedf );if !_cegb {_gd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bdedf );
return -1;};_gcgb +=_bbdf .FontSize *_cfed .Wx *_bbdf .horizontalScale ();if _bdedf !=' '&&(_bcgc !=_eagfc -1||_accbf !=_aafg -1){_gcgb +=_bbdf .CharSpacing *1000.0;};};};return _gcgb ;};func _faaed (_cddg *_ab .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_cddg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SkipRows skips over a specified number of rows in the table.
func (_bdbg *Table )SkipRows (num int ){_gbede :=num *_bdbg ._egcbg -1;if _gbede < 0{_gd .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_bdbg ._aaae +=_gbede ;};

// SetPos sets absolute positioning with specified coordinates.
func (_dfbcg *Paragraph )SetPos (x ,y float64 ){_dfbcg ._cbecc =PositionAbsolute ;_dfbcg ._bgba =x ;_dfbcg ._fcda =y ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// Level returns the indentation level of the TOC line.
func (_aeeb *TOCLine )Level ()uint {return _aeeb ._fcecd };

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_dbgc []*_ab .PdfPage ;_bccb map[*_ab .PdfPage ]*Block ;_bbee map[*_ab .PdfPage ]*pageTransformations ;_eca *_ab .PdfPage ;_dffe PageSize ;_aea DrawContext ;_gffb Margins ;_gede ,_acea float64 ;_gcdd int ;_dgef func (_bdae FrontpageFunctionArgs );
_cbdg func (_fcfa *TOC )error ;_cdba func (_bccc *Block ,_afca HeaderFunctionArgs );_cfag func (_fagg *Block ,_bee FooterFunctionArgs );_fegc func (_cba PageFinalizeFunctionArgs )error ;_bae func (_dbcb *_ab .PdfWriter )error ;_cdd bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_efab *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_aeag *_ab .Outline ;_bgb *_ab .PdfOutlineTreeNode ;_cfbg *_ab .PdfAcroForm ;_daaa _abe .PdfObject ;_faggg _ab .Optimizer ;_gaddc []*_ab .PdfFont ;_ebd *_ab .PdfFont ;_bdcc *_ab .PdfFont ;};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_gbbdc *Table )MultiRowCell (rowspan int )*TableCell {return _gbbdc .MultiCell (rowspan ,1)};

// Rows returns the total number of rows the table has.
func (_adae *Table )Rows ()int {return _adae ._badc };

// SetStyleTop sets border style for top side.
func (_ceg *border )SetStyleTop (style CellBorderStyle ){_ceg ._cceb =style };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_eeffb *TOC )SetHeading (text string ,style TextStyle ){_ggbfb :=_eeffb .Heading ();_ggbfb .Reset ();_aeed :=_ggbfb .Append (text );_aeed .Style =style ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_dagc float64 ;_fadb float64 ;_ggcf float64 ;_bbbg float64 ;_afcc float64 ;_ebfa float64 ;_aega Color ;_bdgaa float64 ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_bcff *StyledParagraph )SetTextAlignment (align TextAlignment ){_bcff ._bfcfg =align };type listItem struct{_gfcf VectorDrawable ;_defe TextChunk ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_ebae *Invoice )SetAddressHeadingStyle (style TextStyle ){_ebae ._decc =style };

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_dbdfg *TableCell )SetBorderLineStyle (style _ee .LineStyle ){_dbdfg ._bbgf =style };func _caec (_gcfec ,_fafd ,_dfca string ,_abbg uint ,_ebgf TextStyle )*TOCLine {return _ccdf (TextChunk {Text :_gcfec ,Style :_ebgf },TextChunk {Text :_fafd ,Style :_ebgf },TextChunk {Text :_dfca ,Style :_ebgf },_abbg ,_ebgf );
};func _dbadb (_gdbb *_ab .PdfAnnotationLink )*_ab .PdfAnnotationLink {if _gdbb ==nil {return nil ;};_bbgfg :=_ab .NewPdfAnnotationLink ();_bbgfg .BS =_gdbb .BS ;_bbgfg .A =_gdbb .A ;if _gfgb ,_fegd :=_gdbb .GetAction ();_fegd ==nil &&_gfgb !=nil {_bbgfg .SetAction (_gfgb );
};if _fbdg ,_egcga :=_gdbb .Dest .(*_abe .PdfObjectArray );_egcga {_bbgfg .Dest =_abe .MakeArray (_fbdg .Elements ()...);};return _bbgfg ;};func (_bdeg *pageTransformations )transformBlock (_bdbd *Block ){if _bdeg ._gfee !=nil {_bdbd .transform (*_bdeg ._gfee );
};};func _eb (_eee *_dc .ContentStreamOperations ,_cac *_ab .PdfPageResources ,_dff *_dc .ContentStreamOperations ,_bced *_ab .PdfPageResources )error {_bbc :=map[_abe .PdfObjectName ]_abe .PdfObjectName {};_dab :=map[_abe .PdfObjectName ]_abe .PdfObjectName {};
_fddf :=map[_abe .PdfObjectName ]_abe .PdfObjectName {};_ecb :=map[_abe .PdfObjectName ]_abe .PdfObjectName {};_caf :=map[_abe .PdfObjectName ]_abe .PdfObjectName {};_cdf :=map[_abe .PdfObjectName ]_abe .PdfObjectName {};for _ ,_gc :=range *_dff {switch _gc .Operand {case "\u0044\u006f":if len (_gc .Params )==1{if _fbe ,_ddf :=_gc .Params [0].(*_abe .PdfObjectName );
_ddf {if _ ,_ffg :=_bbc [*_fbe ];!_ffg {var _dbd _abe .PdfObjectName ;_ddfb ,_ :=_bced .GetXObjectByName (*_fbe );if _ddfb !=nil {_dbd =*_fbe ;for {_fgc ,_ :=_cac .GetXObjectByName (_dbd );if _fgc ==nil ||_fgc ==_ddfb {break ;};_dbd =_dbd +"\u0030";};};
_cac .SetXObjectByName (_dbd ,_ddfb );_bbc [*_fbe ]=_dbd ;};_bcae :=_bbc [*_fbe ];_gc .Params [0]=&_bcae ;};};case "\u0054\u0066":if len (_gc .Params )==2{if _eeee ,_gge :=_gc .Params [0].(*_abe .PdfObjectName );_gge {if _ ,_fdg :=_dab [*_eeee ];!_fdg {_dggc ,_def :=_bced .GetFontByName (*_eeee );
_dda :=*_eeee ;if _def &&_dggc !=nil {_dda =_aeg (_eeee .String (),_dggc ,_cac );};_cac .SetFontByName (_dda ,_dggc );_dab [*_eeee ]=_dda ;};_dfe :=_dab [*_eeee ];_gc .Params [0]=&_dfe ;};};case "\u0043\u0053","\u0063\u0073":if len (_gc .Params )==1{if _ffd ,_fdf :=_gc .Params [0].(*_abe .PdfObjectName );
_fdf {if _ ,_deb :=_fddf [*_ffd ];!_deb {var _dcfe _abe .PdfObjectName ;_gca ,_fddfg :=_bced .GetColorspaceByName (*_ffd );if _fddfg {_dcfe =*_ffd ;for {_gdgc ,_dca :=_cac .GetColorspaceByName (_dcfe );if !_dca ||_gca ==_gdgc {break ;};_dcfe =_dcfe +"\u0030";
};_cac .SetColorspaceByName (_dcfe ,_gca );_fddf [*_ffd ]=_dcfe ;}else {_gd .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _ddaa ,_dedb :=_fddf [*_ffd ];_dedb {_gc .Params [0]=&_ddaa ;
}else {_gd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_ffd );};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_gc .Params )==1{if _cgc ,_gcc :=_gc .Params [0].(*_abe .PdfObjectName );
_gcc {if _ ,_afcb :=_ecb [*_cgc ];!_afcb {var _ac _abe .PdfObjectName ;_ege ,_bbfb :=_bced .GetPatternByName (*_cgc );if _bbfb {_ac =*_cgc ;for {_fef ,_ffa :=_cac .GetPatternByName (_ac );if !_ffa ||_fef ==_ege {break ;};_ac =_ac +"\u0030";};_gef :=_cac .SetPatternByName (_ac ,_ege .ToPdfObject ());
if _gef !=nil {return _gef ;};_ecb [*_cgc ]=_ac ;};};if _acg ,_ea :=_ecb [*_cgc ];_ea {_gc .Params [0]=&_acg ;};};};case "\u0073\u0068":if len (_gc .Params )==1{if _afb ,_cag :=_gc .Params [0].(*_abe .PdfObjectName );_cag {if _ ,_gdab :=_caf [*_afb ];!_gdab {var _fcfb _abe .PdfObjectName ;
_daa ,_bfd :=_bced .GetShadingByName (*_afb );if _bfd {_fcfb =*_afb ;for {_dfec ,_ba :=_cac .GetShadingByName (_fcfb );if !_ba ||_daa ==_dfec {break ;};_fcfb =_fcfb +"\u0030";};_ga :=_cac .SetShadingByName (_fcfb ,_daa .ToPdfObject ());if _ga !=nil {_gd .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_ga );
return _ga ;};_caf [*_afb ]=_fcfb ;}else {_gd .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _bbfe ,_bfaa :=_caf [*_afb ];_bfaa {_gc .Params [0]=&_bbfe ;}else {_gd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_afb );
};};};case "\u0067\u0073":if len (_gc .Params )==1{if _bgfb ,_ecc :=_gc .Params [0].(*_abe .PdfObjectName );_ecc {if _ ,_edc :=_cdf [*_bgfb ];!_edc {var _ebf _abe .PdfObjectName ;_dgfe ,_fae :=_bced .GetExtGState (*_bgfb );if _fae {_ebf =*_bgfb ;_aag :=1;
for {_add ,_dfc :=_cac .GetExtGState (_ebf );if !_dfc ||_dgfe ==_add {break ;};_ebf =_abe .PdfObjectName (_bb .Sprintf ("\u0047\u0053\u0025\u0064",_aag ));_aag ++;};};_cac .AddExtGState (_ebf ,_dgfe );_cdf [*_bgfb ]=_ebf ;};_fcb :=_cdf [*_bgfb ];_gc .Params [0]=&_fcb ;
};};};*_eee =append (*_eee ,_gc );};return nil ;};

// SetWidth sets line width.
func (_adfg *Curve )SetWidth (width float64 ){_adfg ._bdgaa =width };func (_gebe *Invoice )generateHeaderBlocks (_ecbd DrawContext )([]*Block ,DrawContext ,error ){_eedg :=_abga (_gebe ._fdcf );_eedg .SetEnableWrap (true );_eedg .Append (_gebe ._dccb );
_effc :=_bcfe (2);if _gebe ._daadc !=nil {_cbfe :=_effc .NewCell ();_cbfe .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_cbfe .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cbfe .SetIndent (0);_cbfe .SetContent (_gebe ._daadc );_gebe ._daadc .ScaleToHeight (_eedg .Height ()+20);
}else {_effc .SkipCells (1);};_dgce :=_effc .NewCell ();_dgce .SetHorizontalAlignment (CellHorizontalAlignmentRight );_dgce .SetVerticalAlignment (CellVerticalAlignmentMiddle );_dgce .SetContent (_eedg );return _effc .GeneratePageBlocks (_ecbd );};func _adde (_acad VectorDrawable ,_dcba float64 )float64 {switch _fgag :=_acad .(type ){case *Paragraph :if _fgag ._ccff {_fgag .SetWidth (_dcba );
};return _fgag .Height ()+_fgag ._cagec .Top +_fgag ._cagec .Bottom ;case *StyledParagraph :if _fgag ._egcgf {_fgag .SetWidth (_dcba );};return _fgag .Height ()+_fgag ._dfaeg .Top +_fgag ._dfaeg .Bottom ;case marginDrawable :_ ,_ ,_aacg ,_decd :=_fgag .GetMargins ();
return _fgag .Height ()+_aacg +_decd ;default:return _fgag .Height ();};};

// SetBorderColor sets border color.
func (_bdbe *Rectangle )SetBorderColor (col Color ){_bdbe ._gfdb =col };

// SetHeight sets the Image's document height to specified h.
func (_gfbea *Image )SetHeight (h float64 ){_gfbea ._gag =h };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_ffcff *_ab .PdfAnnotation ;_dbed bool ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_egda *Creator )NewParagraph (text string )*Paragraph {return _ecgc (text ,_egda .NewTextStyle ())};

// SetColorTop sets border color for top.
func (_fbecc *border )SetColorTop (col Color ){_fbecc ._ecd =col };

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_agaae *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_aacdb float64 ;_fcecd uint ;_abfc float64 ;_gcaa Positioning ;_cabb float64 ;_gabb float64 ;_ccdg int64 ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_gfef *Invoice )SetNoteHeadingStyle (style TextStyle ){_gfef ._ceggg =style };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_fccc *Creator )NewImageFromGoImage (goimg _c .Image )(*Image ,error ){return _gagc (goimg )};func (_ggbf *TextStyle )horizontalScale ()float64 {return _ggbf .HorizontalScaling /100};func _ccdf (_dbef ,_ccaa ,_fabc TextChunk ,_eceb uint ,_geea TextStyle )*TOCLine {_gaca :=_abga (_geea );
_gaca .SetEnableWrap (true );_gaca .SetTextAlignment (TextAlignmentLeft );_gaca .SetMargins (0,0,2,2);_bcbfd :=&TOCLine {_agaae :_gaca ,Number :_dbef ,Title :_ccaa ,Page :_fabc ,Separator :TextChunk {Text :"\u002e",Style :_geea },_aacdb :0,_fcecd :_eceb ,_abfc :10,_gcaa :PositionRelative };
_gaca ._dfaeg .Left =_bcbfd ._aacdb +float64 (_bcbfd ._fcecd -1)*_bcbfd ._abfc ;_gaca ._acda =_bcbfd .prepareParagraph ;return _bcbfd ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_fbbab *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _fbbab ._ede [0],_fbbab ._ede [1]};

// Add adds a new Drawable to the chapter.
func (_fbbe *Chapter )Add (d Drawable )error {if Drawable (_fbbe )==d {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _gbec :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_fbbe ._dbf =append (_fbbe ._dbf ,d );case containerDrawable :_cea ,_bfc :=_gbec .ContainerComponent (_fbbe );if _bfc !=nil {return _bfc ;};_fbbe ._dbf =append (_fbbe ._dbf ,_cea );
default:_gd .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};return nil ;};func (_bcd *StyledParagraph )getTextWidth ()float64 {var _ccaf float64 ;
_baea :=len (_bcd ._dcgfc );for _ccfa ,_cgae :=range _bcd ._dcgfc {_abgac :=&_cgae .Style ;_gebaa :=len (_cgae .Text );for _fgbf ,_aadb :=range _cgae .Text {if _aadb =='\u000A'{continue ;};_acbd ,_gabe :=_abgac .Font .GetRuneMetrics (_aadb );if !_gabe {_gd .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_aadb );
return -1;};_ccaf +=_abgac .FontSize *_acbd .Wx *_abgac .horizontalScale ();if _aadb !=' '&&(_ccfa !=_baea -1||_fgbf !=_gebaa -1){_ccaf +=_abgac .CharSpacing *1000.0;};};};return _ccaf ;};

// SetAngle sets the rotation angle in degrees.
func (_gf *Block )SetAngle (angleDeg float64 ){_gf ._fa =angleDeg };

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_ecbg *Chart )SetPos (x ,y float64 ){_ecbg ._abfb =PositionAbsolute ;_ecbg ._cef =x ;_ecbg ._fbd =y ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_gfd :_de .Max (_de .Min (c ,1.0),0.0),_gbd :_de .Max (_de .Min (m ,1.0),0.0),_bbfd :_de .Max (_de .Min (y ,1.0),0.0),_ggbe :_de .Max (_de .Min (k ,1.0),0.0)};};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_fage *Table )Width ()float64 {return 0};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_fgbd Color ;_bbgf _ee .LineStyle ;_edaed CellBorderStyle ;_bggec Color ;_dbgf float64 ;_cadd CellBorderStyle ;_bfcg Color ;_ffedc float64 ;_cbefa CellBorderStyle ;_efgb Color ;_ccdc float64 ;_ggfd CellBorderStyle ;_aacdg Color ;_ggeed float64 ;
_edeaa ,_gfdbd int ;_efbb int ;_fbagf int ;_ggcge VectorDrawable ;_ffeg CellHorizontalAlignment ;_fcga CellVerticalAlignment ;_eaea float64 ;_efea *Table ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_gfd :_de .Min (float64 (c ),100)/100.0,_gbd :_de .Min (float64 (m ),100)/100.0,_bbfd :_de .Min (float64 (y ),100)/100.0,_ggbe :_de .Min (float64 (k ),100)/100.0};};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_badc int ;_egcbg int ;_aaae int ;_dbce []float64 ;_aace []float64 ;_cced float64 ;_ddgb []*TableCell ;_gec []int ;_ecbga Positioning ;_abged ,_bfbe float64 ;_abca Margins ;_debe bool ;_aadbb int ;_fgdfd int ;_dafa bool ;_gebbc bool ;
};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_bfddg *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_bfddg ._fcga =valign };

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_cbb *Chart )Width ()float64 {return float64 (_cbb ._fdgb .Width ())};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetFont sets the Paragraph's font.
func (_fed *Paragraph )SetFont (font *_ab .PdfFont ){_fed ._dccg =font };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_bbe *Block )Draw (d Drawable )error {_fgb :=DrawContext {};_fgb .Width =_bbe ._cc ;_fgb .Height =_bbe ._bf ;_fgb .PageWidth =_bbe ._cc ;_fgb .PageHeight =_bbe ._bf ;_fgb .X =0;_fgb .Y =0;_gbf ,_ ,_bbf :=d .GeneratePageBlocks (_fgb );if _bbf !=nil {return _bbf ;
};if len (_gbf )!=1{return _f .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_cbg :=range _gbf {if _fbc :=_bbe .mergeBlocks (_cbg );_fbc !=nil {return _fbc ;};};return nil ;
};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_afbc *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_gfdbf :=&_afbc ._agaae ._dfaeg ;return _afbc ._aacdb ,_gfdbf .Right ,_gfdbf .Top ,_gfdbf .Bottom ;};func _fdgc (_bgaf ,_dcbba ,_cegga ,_eabbe float64 )*Line {_bbge :=&Line {};_bbge ._beacc =_bgaf ;
_bbge ._bceg =_dcbba ;_bbge ._aaff =_cegga ;_bbge ._gdeg =_eabbe ;_bbge ._aafdc =ColorBlack ;_bbge ._eea =1.0;return _bbge ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_dfdec *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_cdbfa :=NewTextChunk (text ,_dfdec ._dbac );_cdbfa ._ffcff =_geaf (url );return _dfdec .appendChunk (_cdbfa );};

// SetBorderColor sets the border color.
func (_bfcda *CurvePolygon )SetBorderColor (color Color ){_bfcda ._fea .BorderColor =_fad (color )};func _dfggd (_daba float64 ,_cgdc float64 )float64 {return _de .Round (_daba /_cgdc )*_cgdc };

// Cols returns the total number of columns the table has.
func (_caegg *Table )Cols ()int {return _caegg ._egcbg };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetLineWidth sets the line width.
func (_acfd *Polyline )SetLineWidth (lineWidth float64 ){_acfd ._fabf .LineWidth =lineWidth };

// SetStyleRight sets border style for right side.
func (_degg *border )SetStyleRight (style CellBorderStyle ){_degg ._ecf =style };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_daca *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_daca ._bdeca =alignment };

// SetLineHeight sets the line height (1.0 default).
func (_cbfc *StyledParagraph )SetLineHeight (lineheight float64 ){_cbfc ._aaffc =lineheight };func _eaf (_fga ,_ced ,_gba ,_dedf float64 )*border {_eag :=&border {};_eag ._fagb =_fga ;_eag ._dga =_ced ;_eag ._dag =_gba ;_eag ._cgeb =_dedf ;_eag ._ecd =ColorBlack ;
_eag ._ggbc =ColorBlack ;_eag ._ada =ColorBlack ;_eag ._cccb =ColorBlack ;_eag ._adf =0;_eag ._bgcd =0;_eag ._ggea =0;_eag ._eeb =0;_eag .LineStyle =_ee .LineStyleSolid ;return _eag ;};func (_cagg *Invoice )generateNoteBlocks (_gced DrawContext )([]*Block ,DrawContext ,error ){_bbga :=_gdfa ();
_gbcb :=append ([][2]string {_cagg ._degd ,_cagg ._aegfa },_cagg ._acaab ...);for _ ,_dbbg :=range _gbcb {if _dbbg [1]!=""{_bfab :=_cagg .drawSection (_dbbg [0],_dbbg [1]);for _ ,_cfdbd :=range _bfab {_bbga .Add (_cfdbd );};_cage :=_abga (_cagg ._dedbc );
_cage .SetMargins (0,0,10,0);_bbga .Add (_cage );};};return _bbga .GeneratePageBlocks (_gced );};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_bbca *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _fdgc (x1 ,y1 ,x2 ,y2 )};func (_ecae *TOCLine )prepareParagraph (_agfad *StyledParagraph ,_gcgfa DrawContext ){_dcdaa :=_ecae .Title .Text ;if _ecae .Number .Text !=""{_dcdaa ="\u0020"+_dcdaa ;
};_dcdaa +="\u0020";_effbe :=_ecae .Page .Text ;if _effbe !=""{_effbe ="\u0020"+_effbe ;};_agfad ._dcgfc =[]*TextChunk {{Text :_ecae .Number .Text ,Style :_ecae .Number .Style ,_ffcff :_ecae .getLineLink ()},{Text :_dcdaa ,Style :_ecae .Title .Style ,_ffcff :_ecae .getLineLink ()},{Text :_effbe ,Style :_ecae .Page .Style ,_ffcff :_ecae .getLineLink ()}};
_agfad .wrapText ();_baegcg :=len (_agfad ._cdec );if _baegcg ==0{return ;};_ffbd :=_gcgfa .Width *1000-_agfad .getTextLineWidth (_agfad ._cdec [_baegcg -1]);_acded :=_agfad .getTextLineWidth ([]*TextChunk {&_ecae .Separator });_dgbdd :=int (_ffbd /_acded );
_ecfd :=_fg .Repeat (_ecae .Separator .Text ,_dgbdd );_ggfb :=_ecae .Separator .Style ;_fcbf :=_agfad .Insert (2,_ecfd );_fcbf .Style =_ggfb ;_fcbf ._ffcff =_ecae .getLineLink ();_ffbd =_ffbd -float64 (_dgbdd )*_acded ;if _ffbd > 500{_fbfa ,_ddad :=_ggfb .Font .GetRuneMetrics (' ');
if _ddad &&_ffbd > _fbfa .Wx {_edfcf :=int (_ffbd /_fbfa .Wx );if _edfcf > 0{_gcfee :=_ggfb ;_gcfee .FontSize =1;_fcbf =_agfad .Insert (2,_fg .Repeat ("\u0020",_edfcf ));_fcbf .Style =_gcfee ;_fcbf ._ffcff =_ecae .getLineLink ();};};};};

// Context returns the current drawing context.
func (_fbcb *Creator )Context ()DrawContext {return _fbcb ._aea };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_dgag *Image )ScaleToWidth (w float64 ){_deea :=_dgag ._gag /_dgag ._adef ;_dgag ._adef =w ;_dgag ._gag =w *_deea ;};func (_ggee *Invoice )generateLineBlocks (_ggdaa DrawContext )([]*Block ,DrawContext ,error ){_edgc :=_bcfe (len (_ggee ._cbee ));
_edgc .SetMargins (0,0,25,0);for _ ,_ecad :=range _ggee ._cbee {_beeb :=_abga (_ecad .TextStyle );_beeb .SetMargins (0,0,1,0);_beeb .Append (_ecad .Value );_bbcc :=_edgc .NewCell ();_bbcc .SetHorizontalAlignment (_ecad .Alignment );_bbcc .SetBackgroundColor (_ecad .BackgroundColor );
_ggee .setCellBorder (_bbcc ,_ecad );_bbcc .SetContent (_beeb );};for _ ,_cddd :=range _ggee ._dfcd {for _ ,_ecdb :=range _cddd {_efffd :=_abga (_ecdb .TextStyle );_efffd .SetMargins (0,0,3,2);_efffd .Append (_ecdb .Value );_dgeg :=_edgc .NewCell ();_dgeg .SetHorizontalAlignment (_ecdb .Alignment );
_dgeg .SetBackgroundColor (_ecdb .BackgroundColor );_ggee .setCellBorder (_dgeg ,_ecdb );_dgeg .SetContent (_efffd );};};return _edgc .GeneratePageBlocks (_ggdaa );};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_aeae *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _ffbe float64 ;var _aged []*StyledParagraph ;for _ ,_ddca :=range _aeae ._egcb {_ffaa :=_abga (_aeae ._egga );_ffaa .SetEnableWrap (false );_ffaa .SetTextAlignment (TextAlignmentRight );
_ffaa .Append (_ddca ._defe .Text ).Style =_ddca ._defe .Style ;_ffbeg :=_ffaa .getTextWidth ()/1000.0/ctx .Width ;if _ffbe < _ffbeg {_ffbe =_ffbeg ;};_aged =append (_aged ,_ffaa );};_dfag :=_bcfe (2);_dfag .SetColumnWidths (_ffbe ,1-_ffbe );_dfag .SetMargins (_aeae ._bgge ,0,0,0);
for _bfffg ,_abbb :=range _aeae ._egcb {_fagdc :=_dfag .NewCell ();_fagdc .SetIndent (0);_fagdc .SetContent (_aged [_bfffg ]);_fagdc =_dfag .NewCell ();_fagdc .SetIndent (0);_fagdc .SetContent (_abbb ._gfcf );};return _dfag .GeneratePageBlocks (ctx );};


// SetIndent sets the cell's left indent.
func (_bede *TableCell )SetIndent (indent float64 ){_bede ._eaea =indent };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_fgbdae *TOCLine )SetLink (page int64 ,x ,y float64 ){_fgbdae ._cabb =x ;_fgbdae ._gabb =y ;_fgbdae ._ccdg =page ;_fcdb :=_fgbdae ._agaae ._dbac .Color ;_fgbdae .Number .Style .Color =_fcdb ;_fgbdae .Title .Style .Color =_fcdb ;_fgbdae .Separator .Style .Color =_fcdb ;
_fgbdae .Page .Style .Color =_fcdb ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_gccfg *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _bfae []*Block ;_cgb :=_gccfg ._cbe .IsRelative ();_gffa :=_gccfg ._ebaaa .Top ;if _cgb &&!_gccfg ._acef &&!_gccfg ._fdgdd {_ggag :=_gccfg .ctxHeight (ctx .Width -_gccfg ._ebaaa .Left -_gccfg ._ebaaa .Right );
if _ggag > ctx .Height -_gccfg ._ebaaa .Top &&_ggag <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {var _ecde error ;if _bfae ,ctx ,_ecde =_fdgdg ().GeneratePageBlocks (ctx );_ecde !=nil {return nil ,ctx ,_ecde ;};_gffa =0;};};_eae :=ctx ;if _cgb {ctx .X +=_gccfg ._ebaaa .Left ;
ctx .Y +=_gffa ;ctx .Width -=_gccfg ._ebaaa .Left +_gccfg ._ebaaa .Right ;ctx .Height -=_gffa +_gccfg ._ebaaa .Bottom ;};ctx .Inline =_gccfg ._fdgdd ;_eaa :=ctx ;_efgc :=ctx ;var _bfffb float64 ;for _ ,_bgcdb :=range _gccfg ._bfad {if ctx .Inline {if (ctx .X -_eaa .X )+_bgcdb .Width ()<=ctx .Width {ctx .Y =_efgc .Y ;
ctx .Height =_efgc .Height ;}else {ctx .X =_eaa .X ;ctx .Width =_eaa .Width ;_efgc .Y +=_bfffb ;_efgc .Height -=_bfffb ;_bfffb =0;};};_aff ,_agbg ,_ebbc :=_bgcdb .GeneratePageBlocks (ctx );if _ebbc !=nil {_gd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_ebbc );
return nil ,ctx ,_ebbc ;};if len (_aff )< 1{continue ;};if len (_bfae )> 0{_bfae [len (_bfae )-1].mergeBlocks (_aff [0]);_bfae =append (_bfae ,_aff [1:]...);}else {_bfae =append (_bfae ,_aff [0:]...);};if ctx .Inline {if ctx .Page !=_agbg .Page {_eaa .Y =ctx .Margins .Top ;
_eaa .Height =ctx .PageHeight -ctx .Margins .Top ;_efgc .Y =_eaa .Y ;_efgc .Height =_eaa .Height ;_bfffb =_agbg .Height -_eaa .Height ;}else {if _cedb :=ctx .Height -_agbg .Height ;_cedb > _bfffb {_bfffb =_cedb ;};};}else {_agbg .X =ctx .X ;};ctx =_agbg ;
};ctx .Inline =_eae .Inline ;if _cgb {ctx .X =_eae .X ;};if _gccfg ._cbe .IsAbsolute (){return _bfae ,_eae ,nil ;};return _bfae ,ctx ,nil ;};func (_ffcc *Table )clone ()*Table {_cgabe :=*_ffcc ;_cgabe ._aace =make ([]float64 ,len (_ffcc ._aace ));copy (_cgabe ._aace ,_ffcc ._aace );
_cgabe ._dbce =make ([]float64 ,len (_ffcc ._dbce ));copy (_cgabe ._dbce ,_ffcc ._dbce );_cgabe ._ddgb =make ([]*TableCell ,0,len (_ffcc ._ddgb ));for _ ,_cgeeb :=range _ffcc ._ddgb {_gffba :=*_cgeeb ;_gffba ._efea =&_cgabe ;_cgabe ._ddgb =append (_cgabe ._ddgb ,&_gffba );
};return &_cgabe ;};func (_cccf *Table )updateRowHeights (_ebfg float64 ){for _ ,_bdac :=range _cccf ._ddgb {_ddff :=_bdac .width (_cccf ._dbce ,_ebfg );_becc :=_cccf ._aace [_bdac ._edeaa +_bdac ._efbb -2];if _dgbg :=_bdac .height (_ddff );_dgbg > _becc {_fdfd :=_dgbg /float64 (_bdac ._efbb );
for _gedgc :=1;_gedgc <=_bdac ._efbb ;_gedgc ++{if _fdfd > _cccf ._aace [_bdac ._edeaa +_gedgc -2]{_cccf ._aace [_bdac ._edeaa +_gedgc -2]=_fdfd ;};};};};};

// SetLineColor sets the line color.
func (_edfc *Polyline )SetLineColor (color Color ){_edfc ._fabf .LineColor =_fad (color )};func (_caca *Invoice )generateInformationBlocks (_aggd DrawContext )([]*Block ,DrawContext ,error ){_fcae :=_abga (_caca ._dedbc );_fcae .SetMargins (0,0,0,20);_acbf :=_caca .drawAddress (_caca ._ddaef );
_acbf =append (_acbf ,_fcae );_acbf =append (_acbf ,_caca .drawAddress (_caca ._aba )...);_bgfa :=_gdfa ();for _ ,_gbfbf :=range _acbf {_bgfa .Add (_gbfbf );};_fcd :=_caca .drawInformation ();_ebdb :=_bcfe (2);_ebdb .SetMargins (0,0,25,0);_aafd :=_ebdb .NewCell ();
_aafd .SetIndent (0);_aafd .SetContent (_bgfa );_aafd =_ebdb .NewCell ();_aafd .SetContent (_fcd );return _ebdb .GeneratePageBlocks (_aggd );};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_dgbc *List )Marker ()*TextChunk {return &_dgbc ._gbac };

// SetFillColor sets the fill color.
func (_cdgb *CurvePolygon )SetFillColor (color Color ){_cdgb ._fea .FillColor =_fad (color )};

// NewImageFromData creates an Image from image data.
func (_ggda *Creator )NewImageFromData (data []byte )(*Image ,error ){return _dbba (data )};func (_eadf *TextChunk )clone ()*TextChunk {_gfbd :=*_eadf ;_gfbd ._ffcff =_fefcf (_eadf ._ffcff );return &_gfbd ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_fddff *Creator )Finalize ()error {if _fddff ._cdd {return nil ;};_cbc :=len (_fddff ._dbgc );_afed :=0;if _fddff ._dgef !=nil {_effa :=*_fddff ;_fddff ._dbgc =nil ;_fddff ._eca =nil ;_fddff .initContext ();_cfd :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cbc };
_fddff ._dgef (_cfd );_afed +=len (_fddff ._dbgc );_fddff ._dbgc =_effa ._dbgc ;_fddff ._eca =_effa ._eca ;};if _fddff .AddTOC {_fddff .initContext ();_fddff ._aea .Page =_afed +1;if _fddff ._cbdg !=nil {if _dcda :=_fddff ._cbdg (_fddff ._efab );_dcda !=nil {return _dcda ;
};};_dbca ,_ ,_ecda :=_fddff ._efab .GeneratePageBlocks (_fddff ._aea );if _ecda !=nil {_gd .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_ecda );
return _ecda ;};_afed +=len (_dbca );_ccee :=_fddff ._efab .Lines ();for _ ,_bdcf :=range _ccee {_ebc ,_acc :=_a .Atoi (_bdcf .Page .Text );if _acc !=nil {continue ;};_bdcf .Page .Text =_a .Itoa (_ebc +_afed );};};_ece :=false ;var _gggg []*_ab .PdfPage ;
if _fddff ._dgef !=nil {_ddfd :=*_fddff ;_fddff ._dbgc =nil ;_fddff ._eca =nil ;_gadc :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cbc };_fddff ._dgef (_gadc );_cbc +=len (_fddff ._dbgc );_gggg =_fddff ._dbgc ;_fddff ._dbgc =append (_fddff ._dbgc ,_ddfd ._dbgc ...);
_fddff ._eca =_ddfd ._eca ;_ece =true ;};var _dfde []*_ab .PdfPage ;if _fddff .AddTOC {_fddff .initContext ();if _fddff ._cbdg !=nil {if _aceb :=_fddff ._cbdg (_fddff ._efab );_aceb !=nil {_gd .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_aceb );
return _aceb ;};};_ffff :=_fddff ._efab .Lines ();for _ ,_fbg :=range _ffff {_fbg ._ccdg +=int64 (_afed );};_baeg ,_ ,_ :=_fddff ._efab .GeneratePageBlocks (_fddff ._aea );for _ ,_cgca :=range _baeg {_cgca .SetPos (0,0);_cbc ++;_gggb :=_fddff .newPage ();
_dfde =append (_dfde ,_gggb );_fddff .setActivePage (_gggb );_fddff .Draw (_cgca );};if _ece {_cee :=_gggg ;_dcgg :=_fddff ._dbgc [len (_gggg ):];_fddff ._dbgc =append ([]*_ab .PdfPage {},_cee ...);_fddff ._dbgc =append (_fddff ._dbgc ,_dfde ...);_fddff ._dbgc =append (_fddff ._dbgc ,_dcgg ...);
}else {_fddff ._dbgc =append (_dfde ,_fddff ._dbgc ...);};};if _fddff ._aeag !=nil &&_fddff .AddOutlines {var _agbc func (_deedb *_ab .OutlineItem );_agbc =func (_ebg *_ab .OutlineItem ){_ebg .Dest .Page +=int64 (_afed );if _babd :=int (_ebg .Dest .Page );
_babd >=0&&_babd < len (_fddff ._dbgc ){_ebg .Dest .PageObj =_fddff ._dbgc [_babd ].GetPageAsIndirectObject ();}else {_gd .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_babd );
};_ebg .Dest .Y =_fddff ._acea -_ebg .Dest .Y ;_dcff :=_ebg .Items ();for _ ,_cfdf :=range _dcff {_agbc (_cfdf );};};_baege :=_fddff ._aeag .Items ();for _ ,_cfg :=range _baege {_agbc (_cfg );};if _fddff .AddTOC {var _gccg int ;if _ece {_gccg =len (_gggg );
};_aggfc :=_ab .NewOutlineDest (int64 (_gccg ),0,_fddff ._acea );if _gccg >=0&&_gccg < len (_fddff ._dbgc ){_aggfc .PageObj =_fddff ._dbgc [_gccg ].GetPageAsIndirectObject ();}else {_gd .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gccg );
};_fddff ._aeag .Insert (0,_ab .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_aggfc ));};};for _adcb ,_aefe :=range _fddff ._dbgc {_fddff .setActivePage (_aefe );if _fddff ._fegc !=nil {_ffad ,_ffdf ,_gbcc :=_aefe .Size ();
if _gbcc !=nil {return _gbcc ;};_cdfa :=PageFinalizeFunctionArgs {PageNum :_adcb +1,PageWidth :_ffad ,PageHeight :_ffdf ,TOCPages :len (_dfde ),TotalPages :_cbc };if _aaac :=_fddff ._fegc (_cdfa );_aaac !=nil {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_aaac );
return _aaac ;};};if _fddff ._cdba !=nil {_agced :=NewBlock (_fddff ._gede ,_fddff ._gffb .Top );_deca :=HeaderFunctionArgs {PageNum :_adcb +1,TotalPages :_cbc };_fddff ._cdba (_agced ,_deca );_agced .SetPos (0,0);if _efad :=_fddff .Draw (_agced );_efad !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_efad );
return _efad ;};};if _fddff ._cfag !=nil {_gde :=NewBlock (_fddff ._gede ,_fddff ._gffb .Bottom );_eaff :=FooterFunctionArgs {PageNum :_adcb +1,TotalPages :_cbc };_fddff ._cfag (_gde ,_eaff );_gde .SetPos (0,_fddff ._acea -_gde ._bf );if _ggcg :=_fddff .Draw (_gde );
_ggcg !=nil {_gd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_ggcg );return _ggcg ;};};_afba ,_bbbb :=_fddff ._bbee [_aefe ];if _agdg ,_cdfdf :=_fddff ._bccb [_aefe ];
_cdfdf {if _bbbb {_afba .transformBlock (_agdg );};if _afa :=_agdg .drawToPage (_aefe );_afa !=nil {_gd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_adcb +1,_afa );
return _afa ;};};if _bbbb {if _gdd :=_afba .transformPage (_aefe );_gdd !=nil {_gd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_gdd );
return _gdd ;};};};_fddff ._cdd =true ;return nil ;};func _fccb (_fca _bg .ChartRenderable )*Chart {return &Chart {_fdgb :_fca ,_abfb :PositionRelative ,_fggf :Margins {Top :10,Bottom :10}};};

// Length calculates and returns the line length.
func (_fdabg *Line )Length ()float64 {return _de .Sqrt (_de .Pow (_fdabg ._aaff -_fdabg ._beacc ,2.0)+_de .Pow (_fdabg ._gdeg -_fdabg ._bceg ,2.0));};

// SetColorRight sets border color for right.
func (_edce *border )SetColorRight (col Color ){_edce ._cccb =col };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_cdcc int ;_caa string ;_bgfbf *Paragraph ;_dbf []Drawable ;_bgac int ;_acaa bool ;_gea bool ;_bea Positioning ;_geag ,_gbc float64 ;_dfed Margins ;_ecfb *Chapter ;_bde *TOC ;_bda *_ab .Outline ;_afdf *_ab .OutlineItem ;_gbbe uint ;
};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_adcg *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_fffb :=NewTextChunk (text ,_adcg ._dbac );_fffb ._ffcff =_aacb (page -1,x ,y ,zoom );return _adcg .appendChunk (_fffb );};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_cdgbd *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_acgbc ,_deba :=_cdgbd .Wrap (width );if _deba !=nil {return nil ,_deba ;};_fgbda :=int (height /_cdgbd .Style .FontSize );if _fgbda >=len (_acgbc ){return nil ,nil ;};_aceff :="\u000a";
_cdgbd .Text =_fg .Replace (_fg .Join (_acgbc [:_fgbda ],"\u0020"),_aceff +"\u0020",_aceff ,-1);_ccbc :=_fg .Replace (_fg .Join (_acgbc [_fgbda :],"\u0020"),_aceff +"\u0020",_aceff ,-1);return NewTextChunk (_ccbc ,_cdgbd .Style ),nil ;};

// SellerAddress returns the seller address used in the invoice template.
func (_beea *Invoice )SellerAddress ()*InvoiceAddress {return _beea ._ddaef };var PPI float64 =72;

// AppendColumn appends a column to the line items table.
func (_cdbae *Invoice )AppendColumn (description string )*InvoiceCell {_accb :=_cdbae .NewColumn (description );_cdbae ._cbee =append (_cdbae ._cbee ,_accb );return _accb ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_bbce *TextChunk )SetAnnotation (annotation *_ab .PdfAnnotation ){_bbce ._ffcff =annotation };func (_cgce *Invoice )setCellBorder (_fabb *TableCell ,_dbdg *InvoiceCell ){for _ ,_ffca :=range _dbdg .BorderSides {_fabb .SetBorder (_ffca ,CellBorderStyleSingle ,_dbdg .BorderWidth );
};_fabb .SetBorderColor (_dbdg .BorderColor );};

// NewPolygon creates a new polygon.
func (_egce *Creator )NewPolygon (points [][]_ee .Point )*Polygon {return _aeac (points )};

// SetWidthLeft sets border width for left.
func (_abef *border )SetWidthLeft (bw float64 ){_abef ._ggea =bw };

// Logo returns the logo of the invoice.
func (_dgb *Invoice )Logo ()*Image {return _dgb ._daadc };func (_bfea *Image )makeXObject ()error {_dcdb :=_bfea ._gafd ;if _dcdb ==nil {_dcdb =_abe .NewFlateEncoder ();};_gbgg ,_dbad :=_ab .NewXObjectImageFromImage (_bfea ._cbad ,nil ,_dcdb );if _dbad !=nil {_gd .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dbad );
return _dbad ;};_bfea ._dbdf =_gbgg ;return nil ;};