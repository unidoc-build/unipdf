//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_d "bytes";_a "errors";_da "fmt";_be "github.com/unidoc/unipdf/v3/common";_ag "github.com/unidoc/unipdf/v3/contentstream";_dd "github.com/unidoc/unipdf/v3/contentstream/draw";_dg "github.com/unidoc/unipdf/v3/core";_ba "github.com/unidoc/unipdf/v3/internal/license";
_eb "github.com/unidoc/unipdf/v3/internal/transform";_cbf "github.com/unidoc/unipdf/v3/model";_ec "image";_g "io";_ga "math";_f "os";_e "sort";_c "strconv";_fa "strings";_cb "unicode";);

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_eddg *Paragraph )SetMaxLines (maxLines int ){_eddg ._cbee =maxLines ;_eddg .wrapText ()};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_degac *_dd .Polygon ;_cccc float64 ;_efddd float64 ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// Text sets the text content of the Paragraph.
func (_eccfg *Paragraph )Text ()string {return _eccfg ._dcebg };

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_fgcfc *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_bbgda :=NewTextChunk (text ,_fgcfc ._bbfd );_bbgda ._bfaf =_gafe (page -1,x ,y ,zoom );return _fgcfc .appendChunk (_bbgda );};func _fdg (_abdf string ,_cbfd _dg .PdfObject ,_ggee *_cbf .PdfPageResources )_dg .PdfObjectName {_bdae :=_fa .TrimRightFunc (_fa .TrimSpace (_abdf ),func (_ffd rune )bool {return _cb .IsNumber (_ffd )});
if _bdae ==""{_bdae ="\u0046\u006f\u006e\u0074";};_gcd :=0;_ebfg :=_dg .PdfObjectName (_abdf );for {_afg ,_cee :=_ggee .GetFontByName (_ebfg );if !_cee ||_afg ==_cbfd {break ;};_gcd ++;_ebfg =_dg .PdfObjectName (_da .Sprintf ("\u0025\u0073\u0025\u0064",_bdae ,_gcd ));
};return _ebfg ;};

// SkipOver skips over a specified number of rows and cols.
func (_cefd *Table )SkipOver (rows ,cols int ){_deage :=rows *_cefd ._fcedd +cols -1;if _deage < 0{_be .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_cefd ._edcbf +=_deage ;};

// SetFillOpacity sets the fill opacity.
func (_ebfd *Rectangle )SetFillOpacity (opacity float64 ){_ebfd ._ccfe =opacity };

// SetDueDate sets the due date of the invoice.
func (_eega *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_eega ._ddf [1].Value =dueDate ;return _eega ._ddf [0],_eega ._ddf [1];};

// SetStyleTop sets border style for top side.
func (_fae *border )SetStyleTop (style CellBorderStyle ){_fae ._fgfd =style };

// SetBorderColor sets the border color.
func (_efbcg *Ellipse )SetBorderColor (col Color ){_efbcg ._bcgg =col };

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_gedb *Division )Add (d VectorDrawable )error {switch _ggfc :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image :case containerDrawable :_ggabe ,_fbdbc :=_ggfc .ContainerComponent (_gedb );if _fbdbc !=nil {return _fbdbc ;};_efdf ,_fgfg :=_ggabe .(VectorDrawable );
if !_fgfg {return _da .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_ggabe );
};d =_efdf ;default:return _a .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_gedb ._bdbcd =append (_gedb ._bdbcd ,d );return nil ;};func _fbbd (_acg [][]_dd .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_edce :&_dd .CurvePolygon {Rings :_acg },_ccgee :1.0,_fgcae :1.0};
};func _eebe (_ddde _ec .Image )(*Image ,error ){_cgge ,_aebdb :=_cbf .ImageHandling .NewImageFromGoImage (_ddde );if _aebdb !=nil {return nil ,_aebdb ;};return _ggca (_cgge );};

// SetBorderColor sets the border color.
func (_cgdb *CurvePolygon )SetBorderColor (color Color ){_cgdb ._edce .BorderColor =_egf (color )};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_efeba *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _ecaa (x ,y ,width ,height );};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_bdefg *Image )SetWidth (w float64 ){_bdefg ._abfe =w };func _ggab (_gebe ,_ggc ,_cagbg ,_eead ,_bfbg ,_ggbgb float64 )*Curve {_eed :=&Curve {};_eed ._bcdca =_gebe ;_eed ._edeb =_ggc ;_eed ._gacd =_cagbg ;_eed ._cfbb =_eead ;_eed ._eccg =_bfbg ;_eed ._gbed =_ggbgb ;
_eed ._eadb =ColorBlack ;_eed ._fcga =1.0;return _eed ;};

// SetBorderOpacity sets the border opacity.
func (_cfga *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_cfga ._dcba =opacity };

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_cbf .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_ggcg *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fced :=_dd .Line {LineWidth :_ggcg ._gdcgc ,Opacity :1.0,LineColor :_egf (_ggcg ._efab ),LineEndingStyle1 :_dd .LineEndingStyleNone ,LineEndingStyle2 :_dd .LineEndingStyleNone ,X1 :_ggcg ._dceb ,Y1 :ctx .PageHeight -_ggcg ._edfge ,X2 :_ggcg ._cffa ,Y2 :ctx .PageHeight -_ggcg ._gddf };
_fbdg ,_ ,_fade :=_fced .Draw ("");if _fade !=nil {return nil ,ctx ,_fade ;};_fade =_dgde .addContentsByString (string (_fbdg ));if _fade !=nil {return nil ,ctx ,_fade ;};return []*Block {_dgde },ctx ,nil ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_ege *Block )Draw (d Drawable )error {_caf :=DrawContext {};_caf .Width =_ege ._eaf ;_caf .Height =_ege ._bc ;_caf .PageWidth =_ege ._eaf ;_caf .PageHeight =_ege ._bc ;_caf .X =0;_caf .Y =0;_cd ,_ ,_affg :=d .GeneratePageBlocks (_caf );if _affg !=nil {return _affg ;
};if len (_cd )!=1{return _a .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_bfc :=range _cd {if _aebg :=_ege .mergeBlocks (_bfc );_aebg !=nil {return _aebg ;};};return nil ;
};func _agdgd (_afbg ,_fgba ,_adbe float64 )(_afab ,_ggcfg ,_feeb ,_cgdea float64 ){if _adbe ==0{return 0,0,_afbg ,_fgba ;};_ffbfd :=_dd .Path {Points :[]_dd .Point {_dd .NewPoint (0,0).Rotate (_adbe ),_dd .NewPoint (_afbg ,0).Rotate (_adbe ),_dd .NewPoint (0,_fgba ).Rotate (_adbe ),_dd .NewPoint (_afbg ,_fgba ).Rotate (_adbe )}}.GetBoundingBox ();
return _ffbfd .X ,_ffbfd .Y ,_ffbfd .Width ,_ffbfd .Height ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_aafb int ;_fcedd int ;_edcbf int ;_fbba []float64 ;_fdef []float64 ;_efgfd float64 ;_bdad []*TableCell ;_gacf Positioning ;_eabd ,_dbaa float64 ;_ggad Margins ;_fbdc bool ;_fdge int ;_abgg int ;_cbgdd bool ;};

// SetMargins sets the Paragraph's margins.
func (_cbff *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_cbff ._egdf .Left =left ;_cbff ._egdf .Right =right ;_cbff ._egdf .Top =top ;_cbff ._egdf .Bottom =bottom ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_efaa *TOC )SetLineSeparator (separator string ){_efaa ._bdadg =separator };

// SetAngle sets the rotation angle of the text.
func (_baef *StyledParagraph )SetAngle (angle float64 ){_baef ._bdcf =angle };

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_cfgf *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_cfgf ._bbfe =halign };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_gddc *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_ffedc :=range subtable ._bdad {_affbg :=&TableCell {};*_affbg =*_ffedc ;_affbg ._faded =_gddc ;_affbg ._cada +=col -1;if _bedfa :=_gddc ._fcedd -(_affbg ._cada -1);_bedfa < _affbg ._adcec {_gddc ._fcedd +=_affbg ._adcec -_bedfa ;
_gddc .resetColumnWidths ();_be .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_gddc ._fcedd );
};_affbg ._gfcae +=row -1;_eebbe :=subtable ._fdef [_ffedc ._gfcae -1];if _affbg ._gfcae > _gddc ._aafb {for _affbg ._gfcae > _gddc ._aafb {_gddc ._aafb ++;_gddc ._fdef =append (_gddc ._fdef ,_gddc ._efgfd );};_gddc ._fdef [_affbg ._gfcae -1]=_eebbe ;}else {_gddc ._fdef [_affbg ._gfcae -1]=_ga .Max (_gddc ._fdef [_affbg ._gfcae -1],_eebbe );
};_gddc ._bdad =append (_gddc ._bdad ,_affbg );};_e .Slice (_gddc ._bdad ,func (_cdefe ,_ecb int )bool {_badc :=_gddc ._bdad [_cdefe ]._gfcae ;_cfdff :=_gddc ._bdad [_ecb ]._gfcae ;if _badc < _cfdff {return true ;};if _badc > _cfdff {return false ;};return _gddc ._bdad [_cdefe ]._cada < _gddc ._bdad [_ecb ]._cada ;
});};

// SetBorderColor sets the cell's border color.
func (_eagb *TableCell )SetBorderColor (col Color ){_eagb ._bccd =col ;_eagb ._gfff =col ;_eagb ._acada =col ;_eagb ._abaab =col ;};

// Width returns the current page width.
func (_ecg *Creator )Width ()float64 {return _ecg ._ebdb };

// SetFillColor sets background color for border.
func (_gddg *border )SetFillColor (col Color ){_gddg ._fdd =col };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_gc *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gc ._bb .Left ,_gc ._bb .Right ,_gc ._bb .Top ,_gc ._bb .Bottom ;};func _eeeec (_deec [][]_dd .Point )*Polygon {return &Polygon {_degac :&_dd .Polygon {Points :_deec },_cccc :1.0,_efddd :1.0};
};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_abfg *Paragraph )Height ()float64 {_abfg .wrapText ();return float64 (len (_abfg ._cadfd ))*_abfg ._beee *_abfg ._faagb ;};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_cdef *Image )SetPos (x ,y float64 ){_cdef ._afdg =PositionAbsolute ;_cdef ._eccga =x ;_cdef ._gfdea =y ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_gde *Block )AddAnnotation (annotation *_cbf .PdfAnnotation ){for _ ,_edf :=range _gde ._bd {if _edf ==annotation {return ;};};_gde ._bd =append (_gde ._bd ,annotation );};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};type cmykColor struct{_fdf ,_aaf ,_fbdd ,_bgd float64 };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_efg *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_cbbe *_cbf .PdfWriter )error ){_efg ._ccfa =pdfWriterAccessFunc ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_fadd *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_fadd .Text },nil ;};var _aadc []string ;var _eeecf []rune ;var _cdbcd float64 ;var _ffgf []float64 ;_acaea :=_fadd .Style ;for _ ,_accdg :=range _fadd .Text {if _accdg =='\u000A'{_aadc =append (_aadc ,_fa .TrimRightFunc (string (_eeecf ),_cb .IsSpace )+string (_accdg ));
_eeecf =nil ;_cdbcd =0;_ffgf =nil ;continue ;};_dabg :=_accdg ==' ';_efgb ,_adffd :=_acaea .Font .GetRuneMetrics (_accdg );if !_adffd {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_accdg ,_accdg ,_acaea .Font .BaseFont (),_acaea .Font .Subtype ());
_be .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_acaea .Font );_be .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_acaea .Font .Encoder ());return nil ,_a .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_bagba :=_acaea .FontSize *_efgb .Wx ;_addc :=_bagba ;if !_dabg {_addc =_bagba +_acaea .CharSpacing *1000.0;};if _cdbcd +_bagba > width *1000.0{_fffad :=-1;if !_dabg {for _efga :=len (_eeecf )-1;_efga >=0;_efga --{if _eeecf [_efga ]==' '{_fffad =_efga ;
break ;};};};_becf :=string (_eeecf );if _fffad > 0{_becf =string (_eeecf [0:_fffad +1]);_eeecf =append (_eeecf [_fffad +1:],_accdg );_ffgf =append (_ffgf [_fffad +1:],_addc );_cdbcd =0;for _ ,_egdd :=range _ffgf {_cdbcd +=_egdd ;};}else {if _dabg {_eeecf =[]rune {};
_ffgf =[]float64 {};_cdbcd =0;}else {_eeecf =[]rune {_accdg };_ffgf =[]float64 {_addc };_cdbcd =_addc ;};};_aadc =append (_aadc ,_fa .TrimRightFunc (_becf ,_cb .IsSpace ));}else {_eeecf =append (_eeecf ,_accdg );_cdbcd +=_addc ;_ffgf =append (_ffgf ,_addc );
};};if len (_eeecf )> 0{_aadc =append (_aadc ,string (_eeecf ));};return _aadc ,nil ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_dedg *Creator )DrawFooter (drawFooterFunc func (_cabfa *Block ,_eda FooterFunctionArgs )){_dedg ._cadd =drawFooterFunc ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_bbab *Division )Height ()float64 {var _adff float64 ;for _ ,_gefb :=range _bbab ._bdbcd {switch _gfgfg :=_gefb .(type ){case *Paragraph :_adff +=_gfgfg .Height ()+_gfgfg ._egdf .Top +_gfgfg ._egdf .Bottom ;case *StyledParagraph :_adff +=_gfgfg .Height ()+_gfgfg ._cfag .Top +_gfgfg ._cfag .Bottom ;
default:_adff +=_gfgfg .Height ();};};return _adff ;};const (DefaultHorizontalScaling =100;);

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_cgf *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faafd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dbda :=_dd .Circle {X :_cgf ._bega -_cgf ._cca /2,Y :ctx .PageHeight -_cgf ._egfe -_cgf ._bfg /2,Width :_cgf ._cca ,Height :_cgf ._bfg ,Opacity :1.0,BorderWidth :_cgf ._bcfc };
if _cgf ._fcca !=nil {_dbda .FillEnabled =true ;_dbda .FillColor =_egf (_cgf ._fcca );};if _cgf ._bcgg !=nil {_dbda .BorderEnabled =true ;_dbda .BorderColor =_egf (_cgf ._bcgg );_dbda .BorderWidth =_cgf ._bcfc ;};_fda ,_ ,_cggc :=_dbda .Draw ("");if _cggc !=nil {return nil ,ctx ,_cggc ;
};_cggc =_faafd .addContentsByString (string (_fda ));if _cggc !=nil {return nil ,ctx ,_cggc ;};return []*Block {_faafd },ctx ,nil ;};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_gdgc *Creator )PageFinalize (pageFinalizeFunc func (_cgec PageFinalizeFunctionArgs )error ){_gdgc ._ecfe =pageFinalizeFunc ;};func (_cdad *FilledCurve )draw (_ecdaf string )([]byte ,*_cbf .PdfRectangle ,error ){_dab :=_dd .NewCubicBezierPath ();
for _ ,_abg :=range _cdad ._gacg {_dab =_dab .AppendCurve (_abg );};creator :=_ag .NewContentCreator ();creator .Add_q ();if _cdad .FillEnabled &&_cdad ._egaa !=nil {creator .SetNonStrokingColor (_egf (_cdad ._egaa ));};if _cdad .BorderEnabled {if _cdad ._gcbf !=nil {creator .SetStrokingColor (_egf (_cdad ._gcbf ));
};creator .Add_w (_cdad .BorderWidth );};if len (_ecdaf )> 1{creator .Add_gs (_dg .PdfObjectName (_ecdaf ));};_dd .DrawBezierPathWithCreator (_dab ,creator );creator .Add_h ();if _cdad .FillEnabled &&_cdad .BorderEnabled {creator .Add_B ();}else if _cdad .FillEnabled {creator .Add_f ();
}else if _cdad .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_dbde :=_dab .GetBoundingBox ();if _cdad .BorderEnabled {_dbde .Height +=_cdad .BorderWidth ;_dbde .Width +=_cdad .BorderWidth ;_dbde .X -=_cdad .BorderWidth /2;_dbde .Y -=_cdad .BorderWidth /2;
};_cgfe :=&_cbf .PdfRectangle {};_cgfe .Llx =_dbde .X ;_cgfe .Lly =_dbde .Y ;_cgfe .Urx =_dbde .X +_dbde .Width ;_cgfe .Ury =_dbde .Y +_dbde .Height ;return creator .Bytes (),_cgfe ,nil ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_bedc *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfb :=ctx ;if _bedc ._dad .IsRelative (){ctx .X +=_bedc ._aaeb .Left ;ctx .Y +=_bedc ._aaeb .Top ;ctx .Width -=_bedc ._aaeb .Left +_bedc ._aaeb .Right ;ctx .Height -=_bedc ._aaeb .Top ;
};_gbf ,_eag ,_ccc :=_bedc ._baac .GeneratePageBlocks (ctx );if _ccc !=nil {return _gbf ,ctx ,_ccc ;};ctx =_eag ;_egd :=ctx .X ;_fcec :=ctx .Y -_bedc ._baac .Height ();_edfe :=int64 (ctx .Page );_daac :=_bedc .headingNumber ();_ebfc :=_bedc .headingText ();
if _bedc ._bafa {_dede :=_bedc ._gbae .Add (_daac ,_bedc ._ggb ,_c .FormatInt (_edfe ,10),_bedc ._eggc );if _bedc ._gbae ._gggc {_dede .SetLink (_edfe ,_egd ,_fcec );};};if _bedc ._eabc ==nil {_bedc ._eabc =_cbf .NewOutlineItem (_ebfc ,_cbf .NewOutlineDest (_edfe -1,_egd ,_fcec ));
if _bedc ._aeg !=nil {_bedc ._aeg ._eabc .Add (_bedc ._eabc );}else {_bedc ._ccf .Add (_bedc ._eabc );};}else {_baacd :=&_bedc ._eabc .Dest ;_baacd .Page =_edfe -1;_baacd .X =_egd ;_baacd .Y =_fcec ;};for _ ,_faf :=range _bedc ._gfgf {_eeg ,_dgg ,_cabf :=_faf .GeneratePageBlocks (ctx );
if _cabf !=nil {return _gbf ,ctx ,_cabf ;};if len (_eeg )< 1{continue ;};_gbf [len (_gbf )-1].mergeBlocks (_eeg [0]);_gbf =append (_gbf ,_eeg [1:]...);ctx =_dgg ;};if _bedc ._dad .IsRelative (){ctx .X =_dfb .X ;};if _bedc ._dad .IsAbsolute (){return _gbf ,_dfb ,nil ;
};return _gbf ,ctx ,nil ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_feg *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ccff ,_ ,_gccf :=_feg .draw ("");if _gccf !=nil {return nil ,ctx ,_gccf ;};_gccf =_ggg .addContentsByString (string (_ccff ));
if _gccf !=nil {return nil ,ctx ,_gccf ;};return []*Block {_ggg },ctx ,nil ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_bgaf :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_be .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bgaf ;
};var _agc ,_gdc ,_ceab int ;if len (hexStr )==4{var _ceg ,_dddcc ,_beea int ;_ccg ,_edcf :=_da .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_ceg ,&_dddcc ,&_beea );if _edcf !=nil {_be .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_edcf );
return _bgaf ;};if _ccg !=3{_be .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bgaf ;};_agc =_ceg *16+_ceg ;_gdc =_dddcc *16+_dddcc ;_ceab =_beea *16+_beea ;}else {_gdbge ,_bcdce :=_da .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_agc ,&_gdc ,&_ceab );
if _bcdce !=nil {_be .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _bgaf ;};if _gdbge !=3{_be .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_gdbge );
return _bgaf ;};};_aggc :=float64 (_agc )/255.0;_ada :=float64 (_gdc )/255.0;_caee :=float64 (_ceab )/255.0;_bgaf ._fgbb =_aggc ;_bgaf ._ccfc =_ada ;_bgaf ._bgbb =_caee ;return _bgaf ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_fagg []*_cbf .PdfPage ;_cbb map[*_cbf .PdfPage ]*Block ;_ade map[*_cbf .PdfPage ]_eb .Matrix ;_ceee *_cbf .PdfPage ;_beff PageSize ;_dfd DrawContext ;_cba Margins ;_ebdb ,_gbe float64 ;_dacd int ;_abbe func (_ggbg FrontpageFunctionArgs );
_febg func (_eaca *TOC )error ;_gdcf func (_edfg *Block ,_eeee HeaderFunctionArgs );_cadd func (_adb *Block ,_aab FooterFunctionArgs );_ecfe func (_bgae PageFinalizeFunctionArgs )error ;_ccfa func (_abeb *_cbf .PdfWriter )error ;_eabg bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_edef *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gcf *_cbf .Outline ;_cdf *_cbf .PdfOutlineTreeNode ;_gfge *_cbf .PdfAcroForm ;_cce _dg .PdfObject ;_efeb _cbf .Optimizer ;_cgde []*_cbf .PdfFont ;_bfa *_cbf .PdfFont ;_baba *_cbf .PdfFont ;};func _abbfc (_effab *Table ,_dddf DrawContext )([]*Block ,DrawContext ,error ){var _deaga []*Block ;
_baff :=NewBlock (_dddf .PageWidth ,_dddf .PageHeight );_abbfd :=_dddf ;if _effab ._gacf .IsAbsolute (){_dddf .X =_effab ._eabd ;_dddf .Y =_effab ._dbaa ;}else {_dddf .X +=_effab ._ggad .Left ;_dddf .Y +=_effab ._ggad .Top ;_dddf .Width -=_effab ._ggad .Left +_effab ._ggad .Right ;
_dddf .Height -=_effab ._ggad .Bottom +_effab ._ggad .Top ;};_eafbc :=_dddf .Width ;_ccfcb :=_dddf .X ;_bfdca :=_dddf .Y ;_dddf .Height =_dddf .PageHeight -_dddf .Y -_dddf .Margins .Bottom ;_caggb :=_dddf .Height ;_ddgc :=0;_gcfc ,_efbe :=-1,-1;for _ggfg ,_eabce :=range _effab ._bdad {_cbfbg :=_eabce .width (_effab ._fbba ,_eafbc );
if _effab ._fbdc {if _eabce ._gfcae >=_effab ._fdge &&_eabce ._gfcae <=_effab ._abgg {if _gcfc < 0{_gcfc =_ggfg ;};_efbe =_ggfg ;};};_bfcaf :=_effab ._fdef [_eabce ._gfcae +_eabce ._dfedf -2];if _bagc :=_eabce .height (_cbfbg );_bagc > _bfcaf {_effab ._fdef [_eabce ._gfcae +_eabce ._dfedf -2]=_bagc ;
};};var (_gbbc bool ;_eeadg int ;_bfbb int ;_aecdd bool ;_faefg int ;_egfb error ;);for _cdaf :=0;_cdaf < len (_effab ._bdad );_cdaf ++{_ffgc :=_effab ._bdad [_cdaf ];_beaf :=_ffgc .width (_effab ._fbba ,_eafbc );_ggcgag :=float64 (0.0);for _gdbde :=0;
_gdbde < _ffgc ._cada -1;_gdbde ++{_ggcgag +=_effab ._fbba [_gdbde ]*_eafbc ;};_cefg :=float64 (0.0);for _fafb :=_ddgc ;_fafb < _ffgc ._gfcae -1;_fafb ++{_cefg +=_effab ._fdef [_fafb ];};_dddf .Height =_caggb -_cefg ;_dacb :=float64 (0.0);for _cbfgf :=0;
_cbfgf < _ffgc ._dfedf ;_cbfgf ++{_dacb +=_effab ._fdef [_ffgc ._gfcae +_cbfgf -1];};_dfed :=_aecdd &&_ffgc ._gfcae !=_faefg ;_faefg =_ffgc ._gfcae ;if _dfed ||_dacb > _dddf .Height {if _effab ._cbgdd &&!_aecdd {_aecdd ,_egfb =_effab .wrapRow (_cdaf ,_dddf ,_eafbc );
if _egfb !=nil {return nil ,_dddf ,_egfb ;};if _aecdd {_cdaf --;continue ;};};_deaga =append (_deaga ,_baff );_baff =NewBlock (_dddf .PageWidth ,_dddf .PageHeight );_ccfcb =_dddf .Margins .Left ;_bfdca =_dddf .Margins .Top ;_dddf .Height =_dddf .PageHeight -_dddf .Margins .Top -_dddf .Margins .Bottom ;
_dddf .Page ++;_caggb =_dddf .Height ;_ddgc =_ffgc ._gfcae -1;_cefg =0;_aecdd =false ;if _effab ._fbdc &&_gcfc >=0{_eeadg =_cdaf ;_cdaf =_gcfc -1;_bfbb =_ddgc ;_ddgc =_effab ._fdge -1;_gbbc =true ;continue ;};if _dfed {_cdaf --;continue ;};};_dddf .Width =_beaf ;
_dddf .X =_ccfcb +_ggcgag ;_dddf .Y =_bfdca +_cefg ;_baag :=_fgfe (_dddf .X ,_dddf .Y ,_beaf ,_dacb );if _ffgc ._eeec !=nil {_baag .SetFillColor (_ffgc ._eeec );};_baag .LineStyle =_ffgc ._becd ;_baag ._efe =_ffgc ._efbf ;_baag ._cece =_ffgc ._cedga ;_baag ._fgfd =_ffgc ._aggb ;
_baag ._bbc =_ffgc ._abce ;if _ffgc ._bccd !=nil {_baag .SetColorLeft (_ffgc ._bccd );};if _ffgc ._gfff !=nil {_baag .SetColorBottom (_ffgc ._gfff );};if _ffgc ._acada !=nil {_baag .SetColorRight (_ffgc ._acada );};if _ffgc ._abaab !=nil {_baag .SetColorTop (_ffgc ._abaab );
};_baag .SetWidthBottom (_ffgc ._febea );_baag .SetWidthLeft (_ffgc ._bgdeag );_baag .SetWidthRight (_ffgc ._gcfg );_baag .SetWidthTop (_ffgc ._bbgc );_daad :=_baff .Draw (_baag );if _daad !=nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_daad );
};if _ffgc ._fadgf !=nil {_dbefa :=_ffgc ._fadgf .Width ();_egea :=_ffgc ._fadgf .Height ();_dbcae :=0.0;switch _gfcdb :=_ffgc ._fadgf .(type ){case *Paragraph :if _gfcdb ._ecec {_dbefa =_gfcdb .getMaxLineWidth ()/1000.0;};_dbefa +=_gfcdb ._egdf .Left +_gfcdb ._egdf .Right ;
_egea +=_gfcdb ._egdf .Top +_gfcdb ._egdf .Bottom ;case *StyledParagraph :if _gfcdb ._ccbc {_dbefa =_gfcdb .getMaxLineWidth ()/1000.0;};_dege ,_aace ,_fgdb :=_gfcdb .getLineMetrics (0);_fbaf ,_dggb :=_dege *_gfcdb ._gdac ,_aace *_gfcdb ._gdac ;if _gfcdb ._cgdbe ==TextVerticalAlignmentCenter {_dbcae =_dggb -(_aace +(_dege +_fgdb -_aace )/2+(_dggb -_aace )/2);
};if len (_gfcdb ._dgfag )==1{_egea =_fbaf ;}else {_egea =_egea -_dggb +_fbaf ;};_dbcae +=_fbaf -_dggb ;switch _ffgc ._bgbe {case CellVerticalAlignmentTop :_dbcae +=_fbaf *0.5;case CellVerticalAlignmentBottom :_dbcae -=_fbaf *0.5;};_dbefa +=_gfcdb ._cfag .Left +_gfcdb ._cfag .Right ;
_egea +=_gfcdb ._cfag .Top +_gfcdb ._cfag .Bottom ;case *Table :_dbefa =_beaf ;case *List :_dbefa =_beaf ;};switch _ffgc ._bbfe {case CellHorizontalAlignmentLeft :_dddf .X +=_ffgc ._abdc ;_dddf .Width -=_ffgc ._abdc ;case CellHorizontalAlignmentCenter :if _gdgg :=_beaf -_dbefa ;
_gdgg > 0{_dddf .X +=_gdgg /2;_dddf .Width -=_gdgg /2;};case CellHorizontalAlignmentRight :if _beaf > _dbefa {_dddf .X =_dddf .X +_beaf -_dbefa -_ffgc ._abdc ;_dddf .Width -=_ffgc ._abdc ;};};_dddf .Y +=_dbcae ;switch _ffgc ._bgbe {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _dfdd :=_dacb -_egea ;
_dfdd > 0{_dddf .Y +=_dfdd /2;_dddf .Height -=_dfdd /2;};case CellVerticalAlignmentBottom :if _dacb > _egea {_dddf .Y =_dddf .Y +_dacb -_egea ;_dddf .Height =_dacb ;};};_egdeb :=_baff .DrawWithContext (_ffgc ._fadgf ,_dddf );if _egdeb !=nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_egdeb );
};_dddf .Y -=_dbcae ;};_dddf .Y +=_dacb ;_dddf .Height -=_dacb ;if _gbbc &&_cdaf +1> _efbe {_bfdca +=_cefg +_dacb ;_caggb -=_dacb +_cefg ;_ddgc =_bfbb ;_cdaf =_eeadg -1;_gbbc =false ;};};_deaga =append (_deaga ,_baff );if _effab ._gacf .IsAbsolute (){return _deaga ,_abbfd ,nil ;
};_dddf .X =_abbfd .X ;_dddf .Width =_abbfd .Width ;_dddf .Y +=_effab ._ggad .Bottom ;_dddf .Height -=_effab ._ggad .Bottom ;return _deaga ,_dddf ,nil ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;);

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_gbda *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_gbda ._cba .Left =left ;_gbda ._cba .Right =right ;_gbda ._cba .Top =top ;_gbda ._cba .Bottom =bottom ;};func (_fed *Chapter )headingNumber ()string {var _ccbb string ;if _fed ._cgbd {if _fed ._fgfb !=0{_ccbb =_c .Itoa (_fed ._fgfb )+"\u002e";
};if _fed ._aeg !=nil {_dbcc :=_fed ._aeg .headingNumber ();if _dbcc !=""{_ccbb =_dbcc +_ccbb ;};};};return _ccbb ;};

// SetHeight sets the Image's document height to specified h.
func (_cfgeb *Image )SetHeight (h float64 ){_cfgeb ._fceb =h };var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);
ColorYellow =ColorRGBFromArithmetic (1,1,0););

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_bg *_ag .ContentStreamOperations ;_de *_cbf .PdfPageResources ;_gd Positioning ;_ed ,_ea float64 ;_eaf float64 ;_bc float64 ;_ef float64 ;_bb Margins ;_bd []*_cbf .PdfAnnotation ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_dcfd *TOCLine )SetLink (page int64 ,x ,y float64 ){_dcfd ._eafc =x ;_dcfd ._bgagc =y ;_dcfd ._fgfa =page ;_bbgca :=_dcfd ._gdbea ._bbfd .Color ;_dcfd .Number .Style .Color =_bbgca ;_dcfd .Title .Style .Color =_bbgca ;_dcfd .Separator .Style .Color =_bbgca ;
_dcfd .Page .Style .Color =_bbgca ;};func _ecaa (_adgg ,_ceeb ,_egcd ,_daed float64 )*Rectangle {return &Rectangle {_bfbf :_adgg ,_ddbbba :_ceeb ,_abgcg :_egcd ,_fcfc :_daed ,_dabc :ColorBlack ,_eaaeb :1.0,_ccfe :1.0,_bcff :1.0};};

// WriteToFile writes the Creator output to file specified by path.
func (_cega *Creator )WriteToFile (outputPath string )error {_fffa ,_cda :=_f .Create (outputPath );if _cda !=nil {return _cda ;};defer _fffa .Close ();return _cega .Write (_fffa );};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_dgc *Rectangle )GetCoords ()(float64 ,float64 ){return _dgc ._bfbf ,_dgc ._ddbbba };

// SetInline sets the inline mode of the division.
func (_caec *Division )SetInline (inline bool ){_caec ._gadd =inline };

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_fgbb :float64 (r )/255.0,_ccfc :float64 (g )/255.0,_bgbb :float64 (b )/255.0};};

// Height returns the current page height.
func (_dfbb *Creator )Height ()float64 {return _dfbb ._gbe };func (_aegfb *TextStyle )horizontalScale ()float64 {return _aegfb .HorizontalScaling /100};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_fbde *Invoice )AddressStyle ()TextStyle {return _fbde ._dfbe };func (_dbac *TextChunk )clone ()*TextChunk {_bdfb :=*_dbac ;_bdfb ._bfaf =_bdcg (_dbac ._bfaf );return &_bdfb ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_gcfe *TableCell )SetContent (vd VectorDrawable )error {switch _affc :=vd .(type ){case *Paragraph :if _affc ._geab {_affc ._ecec =true ;};_gcfe ._fadgf =vd ;case *StyledParagraph :if _affc ._ebbge {_affc ._ccbc =true ;};_gcfe ._fadgf =vd ;case *Image :_gcfe ._fadgf =vd ;
case *Table :_gcfe ._fadgf =vd ;case *List :_gcfe ._fadgf =vd ;case *Division :_gcfe ._fadgf =vd ;default:_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _dg .ErrTypeError ;};return nil ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_fdf :_ga .Min (float64 (c ),100)/100.0,_aaf :_ga .Min (float64 (m ),100)/100.0,_fbdd :_ga .Min (float64 (y ),100)/100.0,_bgd :_ga .Min (float64 (k ),100)/100.0};};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_agdc *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gbdf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gefd ,_dcec :=_gbdf .setOpacity (_agdc ._cccc ,_agdc ._efddd );if _dcec !=nil {return nil ,ctx ,_dcec ;};_fgad :=_agdc ._degac ;
_fgad .FillEnabled =_fgad .FillColor !=nil ;_fgad .BorderEnabled =_fgad .BorderColor !=nil &&_fgad .BorderWidth > 0;_adgd :=_fgad .Points ;for _gbeg :=range _adgd {for _cggf :=range _adgd [_gbeg ]{_egdg :=&_adgd [_gbeg ][_cggf ];_egdg .Y =ctx .PageHeight -_egdg .Y ;
};};_fecd ,_ ,_dcec :=_fgad .Draw (_gefd );if _dcec !=nil {return nil ,ctx ,_dcec ;};if _dcec =_gbdf .addContentsByString (string (_fecd ));_dcec !=nil {return nil ,ctx ,_dcec ;};return []*Block {_gbdf },ctx ,nil ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_ggbc *Paragraph )SetWidth (width float64 ){_ggbc ._ccca =width ;_ggbc .wrapText ()};

// Add adds a new Drawable to the chapter.
func (_cab *Chapter )Add (d Drawable )error {if Drawable (_cab )==d {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _cagb :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_cab ._gfgf =append (_cab ._gfgf ,d );case containerDrawable :_geaf ,_bfcc :=_cagb .ContainerComponent (_cab );if _bfcc !=nil {return _bfcc ;};
_cab ._gfgf =append (_cab ._gfgf ,_geaf );default:_be .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _a .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// SetLineOpacity sets the line opacity.
func (_geaag *Polyline )SetLineOpacity (opacity float64 ){_geaag ._cbeec =opacity };func (_gadf *Invoice )drawInformation ()*Table {_fdda :=_bgec (2);_egcf :=append ([][2]*InvoiceCell {_gadf ._abga ,_gadf ._ddgfe ,_gadf ._ddf },_gadf ._edcb ...);for _ ,_daeg :=range _egcf {_fgbf ,_dbdd :=_daeg [0],_daeg [1];
if _dbdd .Value ==""{continue ;};_cfeg :=_fdda .NewCell ();_cfeg .SetBackgroundColor (_fgbf .BackgroundColor );_gadf .setCellBorder (_cfeg ,_fgbf );_bggg :=_cggef (_fgbf .TextStyle );_bggg .Append (_fgbf .Value );_bggg .SetMargins (0,0,2,1);_cfeg .SetContent (_bggg );
_cfeg =_fdda .NewCell ();_cfeg .SetBackgroundColor (_dbdd .BackgroundColor );_gadf .setCellBorder (_cfeg ,_dbdd );_bggg =_cggef (_dbdd .TextStyle );_bggg .Append (_dbdd .Value );_bggg .SetMargins (0,0,2,1);_cfeg .SetContent (_bggg );};return _fdda ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_aac *Chapter )SetIncludeInTOC (includeInTOC bool ){_aac ._bafa =includeInTOC };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_dca *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_dca ._gaec =textOverflow };func _cggef (_eaaee TextStyle )*StyledParagraph {return &StyledParagraph {_aaca :[]*TextChunk {},_gcbb :_eaaee ,_bbfd :_beab (_eaaee .Font ),_gdac :1.0,_gdbf :TextAlignmentLeft ,_ccbc :true ,_ebbge :true ,_bdcf :0,_ffea :1,_eeef :1,_dbba :PositionRelative };
};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetTitle sets the title of the invoice.
func (_eadc *Invoice )SetTitle (title string ){_eadc ._dbad =title };

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_eeb *Creator )NewParagraph (text string )*Paragraph {return _gccc (text ,_eeb .NewTextStyle ())};

// NewFilledCurve returns a instance of filled curve.
func (_ggag *Creator )NewFilledCurve ()*FilledCurve {return _fggcc ()};

// SetLineWidth sets the line width.
func (_dcbc *Line )SetLineWidth (lw float64 ){_dcbc ._gdcgc =lw };func _dcd (_cdca ,_bbg ,_ccac ,_afed float64 )*Ellipse {_aeaf :=&Ellipse {};_aeaf ._bega =_cdca ;_aeaf ._egfe =_bbg ;_aeaf ._cca =_ccac ;_aeaf ._bfg =_afed ;_aeaf ._bcgg =ColorBlack ;_aeaf ._bcfc =1.0;
return _aeaf ;};

// SetLineHeight sets the line height (1.0 default).
func (_eafde *StyledParagraph )SetLineHeight (lineheight float64 ){_eafde ._gdac =lineheight };func _beab (_caege *_cbf .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_caege ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};func _afee (_accg string )*_cbf .PdfAnnotation {_cegb :=_cbf .NewPdfAnnotationLink ();_acda :=_cbf .NewBorderStyle ();_acda .SetBorderWidth (0);_cegb .BS =_acda .ToPdfObject ();_ggadf :=_cbf .NewPdfActionURI ();_ggadf .URI =_dg .MakeString (_accg );_cegb .SetAction (_ggadf .PdfAction );
return _cegb .PdfAnnotation ;};func _adfd (_fabg TextStyle )*List {return &List {_gffd :TextChunk {Text :"\u2022\u0020",Style :_fabg },_gfeg :0,_gdfg :true ,_ebbba :PositionRelative ,_gbgb :_fabg };};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_eedf *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eedf ._agfc .Left ,_eedf ._agfc .Right ,_eedf ._agfc .Top ,_eedf ._agfc .Bottom ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_begb *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _begb ._ddgfe [0],_begb ._ddgfe [1]};

// AppendColumn appends a column to the line items table.
func (_dcbe *Invoice )AppendColumn (description string )*InvoiceCell {_aggf :=_dcbe .NewColumn (description );_dcbe ._dcbb =append (_dcbe ._dcbb ,_aggf );return _aggf ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_cfdf *Creator )NewStyledParagraph ()*StyledParagraph {return _cggef (_cfdf .NewTextStyle ())};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_af :=&Block {};_af ._bg =&_ag .ContentStreamOperations {};_af ._de =_cbf .NewPdfPageResources ();_af ._eaf =width ;_af ._bc =height ;return _af ;};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_bega float64 ;_egfe float64 ;_cca float64 ;_bfg float64 ;_fcca Color ;_bcgg Color ;_bcfc float64 ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_adba *Invoice )NoteHeadingStyle ()TextStyle {return _adba ._bcdde };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_bfcdd *StyledParagraph )SetWidth (width float64 ){_bfcdd ._bbgd =width ;_bfcdd .wrapText ()};

// The Image type is used to draw an image onto PDF.
type Image struct{_cfee *_cbf .XObjectImage ;_aaad *_cbf .Image ;_efdb float64 ;_abfe ,_fceb float64 ;_bafab ,_effa float64 ;_afdg Positioning ;_daeaf HorizontalAlignment ;_eccga float64 ;_gfdea float64 ;_bcdb float64 ;_agfc Margins ;_bcdd ,_fdfg float64 ;
_bfeg _dg .StreamEncoder ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_fdfd *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _ggab (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_egacg *Creator )EnableFontSubsetting (font *_cbf .PdfFont ){_egacg ._cgde =append (_egacg ._cgde ,font );};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_ffcb *Chapter )GetHeading ()*Paragraph {return _ffcb ._baac };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_efef *Creator )SetOutlineTree (outlineTree *_cbf .PdfOutlineTreeNode ){_efef ._cdf =outlineTree };

// Logo returns the logo of the invoice.
func (_ddbb *Invoice )Logo ()*Image {return _ddbb ._dfde };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_begbf *Table )MultiColCell (colspan int )*TableCell {return _begbf .newCell (colspan )};func _ddg (_aga *_ag .ContentStreamOperations ,_cdb *_cbf .PdfPageResources ,_gea *_ag .ContentStreamOperations ,_dcc *_cbf .PdfPageResources )error {_cdg :=map[_dg .PdfObjectName ]_dg .PdfObjectName {};
_fb :=map[_dg .PdfObjectName ]_dg .PdfObjectName {};_dae :=map[_dg .PdfObjectName ]_dg .PdfObjectName {};_afd :=map[_dg .PdfObjectName ]_dg .PdfObjectName {};_cbe :=map[_dg .PdfObjectName ]_dg .PdfObjectName {};_fee :=map[_dg .PdfObjectName ]_dg .PdfObjectName {};
for _ ,_geb :=range *_gea {switch _geb .Operand {case "\u0044\u006f":if len (_geb .Params )==1{if _bdc ,_baaf :=_geb .Params [0].(*_dg .PdfObjectName );_baaf {if _ ,_bcd :=_cdg [*_bdc ];!_bcd {var _ced _dg .PdfObjectName ;_bca ,_ :=_dcc .GetXObjectByName (*_bdc );
if _bca !=nil {_ced =*_bdc ;for {_eca ,_ :=_cdb .GetXObjectByName (_ced );if _eca ==nil ||_eca ==_bca {break ;};_ced =_ced +"\u0030";};};_cdb .SetXObjectByName (_ced ,_bca );_cdg [*_bdc ]=_ced ;};_dgaa :=_cdg [*_bdc ];_geb .Params [0]=&_dgaa ;};};case "\u0054\u0066":if len (_geb .Params )==2{if _gfae ,_ebf :=_geb .Params [0].(*_dg .PdfObjectName );
_ebf {if _ ,_fbd :=_fb [*_gfae ];!_fbd {_agf ,_edc :=_dcc .GetFontByName (*_gfae );_cfg :=*_gfae ;if _edc &&_agf !=nil {_cfg =_fdg (_gfae .String (),_agf ,_cdb );};_cdb .SetFontByName (_cfg ,_agf );_fb [*_gfae ]=_cfg ;};_bbd :=_fb [*_gfae ];_geb .Params [0]=&_bbd ;
};};case "\u0043\u0053","\u0063\u0073":if len (_geb .Params )==1{if _afbd ,_abdg :=_geb .Params [0].(*_dg .PdfObjectName );_abdg {if _ ,_gfc :=_dae [*_afbd ];!_gfc {var _dbg _dg .PdfObjectName ;_cec ,_gcc :=_dcc .GetColorspaceByName (*_afbd );if _gcc {_dbg =*_afbd ;
for {_agec ,_bbb :=_cdb .GetColorspaceByName (_dbg );if !_bbb ||_cec ==_agec {break ;};_dbg =_dbg +"\u0030";};_cdb .SetColorspaceByName (_dbg ,_cec );_dae [*_afbd ]=_dbg ;}else {_be .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");
};};if _gb ,_dec :=_dae [*_afbd ];_dec {_geb .Params [0]=&_gb ;}else {_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_afbd );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_geb .Params )==1{if _gag ,_eff :=_geb .Params [0].(*_dg .PdfObjectName );_eff {if _ ,_ecc :=_afd [*_gag ];!_ecc {var _ffb _dg .PdfObjectName ;_agg ,_cdbg :=_dcc .GetPatternByName (*_gag );if _cdbg {_ffb =*_gag ;
for {_fcg ,_cea :=_cdb .GetPatternByName (_ffb );if !_cea ||_fcg ==_agg {break ;};_ffb =_ffb +"\u0030";};_dgb :=_cdb .SetPatternByName (_ffb ,_agg .ToPdfObject ());if _dgb !=nil {return _dgb ;};_afd [*_gag ]=_ffb ;};};if _aged ,_fgf :=_afd [*_gag ];_fgf {_geb .Params [0]=&_aged ;
};};};case "\u0073\u0068":if len (_geb .Params )==1{if _cfa ,_ede :=_geb .Params [0].(*_dg .PdfObjectName );_ede {if _ ,_fgd :=_cbe [*_cfa ];!_fgd {var _eggf _dg .PdfObjectName ;_baf ,_ddb :=_dcc .GetShadingByName (*_cfa );if _ddb {_eggf =*_cfa ;for {_cadc ,_fd :=_cdb .GetShadingByName (_eggf );
if !_fd ||_baf ==_cadc {break ;};_eggf =_eggf +"\u0030";};_gdbg :=_cdb .SetShadingByName (_eggf ,_baf .ToPdfObject ());if _gdbg !=nil {_be .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_gdbg );
return _gdbg ;};_cbe [*_cfa ]=_eggf ;}else {_be .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _cgb ,_agea :=_cbe [*_cfa ];_agea {_geb .Params [0]=&_cgb ;}else {_be .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_cfa );
};};};case "\u0067\u0073":if len (_geb .Params )==1{if _dce ,_acb :=_geb .Params [0].(*_dg .PdfObjectName );_acb {if _ ,_cbfa :=_fee [*_dce ];!_cbfa {var _fge _dg .PdfObjectName ;_dac ,_bdag :=_dcc .GetExtGState (*_dce );if _bdag {_fge =*_dce ;_efa :=1;
for {_gge ,_dccf :=_cdb .GetExtGState (_fge );if !_dccf ||_dac ==_gge {break ;};_fge =_dg .PdfObjectName (_da .Sprintf ("\u0047\u0053\u0025\u0064",_efa ));_efa ++;};};_cdb .AddExtGState (_fge ,_dac );_fee [*_dce ]=_fge ;};_ebe :=_fee [*_dce ];_geb .Params [0]=&_ebe ;
};};};*_aga =append (*_aga ,_geb );};return nil ;};func _egf (_faeb Color )_cbf .PdfColor {if _faeb ==nil {_faeb =ColorBlack ;};switch _abbb :=_faeb .(type ){case cmykColor :return _cbf .NewPdfColorDeviceCMYK (_abbb ._fdf ,_abbb ._aaf ,_abbb ._fbdd ,_abbb ._bgd );
};return _cbf .NewPdfColorDeviceRGB (_faeb .ToRGB ());};

// SetFillColor sets the fill color.
func (_dcdd *Ellipse )SetFillColor (col Color ){_dcdd ._fcca =col };

// GeneratePageBlocks implements drawable interface.
func (_ebg *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fea :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ecd :=_ebg ._fba ;_cedc :=ctx .PageHeight -_ebg ._agd ;if _ebg ._fdd !=nil {_dfa :=_dd .Rectangle {Opacity :1.0,X :_ebg ._fba ,Y :ctx .PageHeight -_ebg ._agd -_ebg ._gfg ,Height :_ebg ._gfg ,Width :_ebg ._ffc };
_dfa .FillEnabled =true ;_dfa .FillColor =_egf (_ebg ._fdd );_dfa .BorderEnabled =false ;_egb ,_ ,_eea :=_dfa .Draw ("");if _eea !=nil {return nil ,ctx ,_eea ;};_eea =_fea .addContentsByString (string (_egb ));if _eea !=nil {return nil ,ctx ,_eea ;};};
_ecf :=_ebg ._bcdg ;_gad :=_ebg ._gbb ;_ged :=_ebg ._cbec ;_ebd :=_ebg ._fce ;_cbc :=_ebg ._bcdg ;if _ebg ._fgfd ==CellBorderStyleDouble {_cbc +=2*_ecf ;};_dcb :=_ebg ._gbb ;if _ebg ._bbc ==CellBorderStyleDouble {_dcb +=2*_gad ;};_ddbg :=_ebg ._cbec ;if _ebg ._efe ==CellBorderStyleDouble {_ddbg +=2*_ged ;
};_cde :=_ebg ._fce ;if _ebg ._cece ==CellBorderStyleDouble {_cde +=2*_ebd ;};if _ebg ._bcdg !=0{_bab :=_ecd ;_cdc :=_cedc ;if _ebg ._fgfd ==CellBorderStyleDouble {_cdc -=_ecf ;_abfc :=_dd .BasicLine {};_abfc .X1 =_bab -_cbc /2;_abfc .Y1 =_cdc +2*_ecf ;
_abfc .X2 =_bab +_ebg ._ffc +_cbc /2;_abfc .Y2 =_cdc +2*_ecf ;_abfc .LineColor =_egf (_ebg ._baaa );_abfc .LineWidth =_ebg ._bcdg ;_abfc .LineStyle =_ebg .LineStyle ;_cbdd ,_ ,_cfd :=_abfc .Draw ("");if _cfd !=nil {return nil ,ctx ,_cfd ;};_cfd =_fea .addContentsByString (string (_cbdd ));
if _cfd !=nil {return nil ,ctx ,_cfd ;};};_dbe :=_dd .BasicLine {LineWidth :_ebg ._bcdg ,Opacity :1.0,LineColor :_egf (_ebg ._baaa ),X1 :_bab -_cbc /2+(_ddbg -_ebg ._cbec ),Y1 :_cdc ,X2 :_bab +_ebg ._ffc +_cbc /2-(_cde -_ebg ._fce ),Y2 :_cdc ,LineStyle :_ebg .LineStyle };
_ggeb ,_ ,_bbf :=_dbe .Draw ("");if _bbf !=nil {return nil ,ctx ,_bbf ;};_bbf =_fea .addContentsByString (string (_ggeb ));if _bbf !=nil {return nil ,ctx ,_bbf ;};};if _ebg ._gbb !=0{_cage :=_ecd ;_gfd :=_cedc -_ebg ._gfg ;if _ebg ._bbc ==CellBorderStyleDouble {_gfd +=_gad ;
_dbc :=_dd .BasicLine {LineWidth :_ebg ._gbb ,Opacity :1.0,LineColor :_egf (_ebg ._deab ),X1 :_cage -_dcb /2,Y1 :_gfd -2*_gad ,X2 :_cage +_ebg ._ffc +_dcb /2,Y2 :_gfd -2*_gad ,LineStyle :_ebg .LineStyle };_cfae ,_ ,_bfcd :=_dbc .Draw ("");if _bfcd !=nil {return nil ,ctx ,_bfcd ;
};_bfcd =_fea .addContentsByString (string (_cfae ));if _bfcd !=nil {return nil ,ctx ,_bfcd ;};};_dddc :=_dd .BasicLine {LineWidth :_ebg ._gbb ,Opacity :1.0,LineColor :_egf (_ebg ._deab ),X1 :_cage -_dcb /2+(_ddbg -_ebg ._cbec ),Y1 :_gfd ,X2 :_cage +_ebg ._ffc +_dcb /2-(_cde -_ebg ._fce ),Y2 :_gfd ,LineStyle :_ebg .LineStyle };
_bad ,_ ,_ggf :=_dddc .Draw ("");if _ggf !=nil {return nil ,ctx ,_ggf ;};_ggf =_fea .addContentsByString (string (_bad ));if _ggf !=nil {return nil ,ctx ,_ggf ;};};if _ebg ._cbec !=0{_dde :=_ecd ;_cfe :=_cedc ;if _ebg ._efe ==CellBorderStyleDouble {_dde +=_ged ;
_ccd :=_dd .BasicLine {LineWidth :_ebg ._cbec ,Opacity :1.0,LineColor :_egf (_ebg ._gcg ),X1 :_dde -2*_ged ,Y1 :_cfe +_ddbg /2,X2 :_dde -2*_ged ,Y2 :_cfe -_ebg ._gfg -_ddbg /2,LineStyle :_ebg .LineStyle };_agdb ,_ ,_cbg :=_ccd .Draw ("");if _cbg !=nil {return nil ,ctx ,_cbg ;
};_cbg =_fea .addContentsByString (string (_agdb ));if _cbg !=nil {return nil ,ctx ,_cbg ;};};_dccd :=_dd .BasicLine {LineWidth :_ebg ._cbec ,Opacity :1.0,LineColor :_egf (_ebg ._gcg ),X1 :_dde ,Y1 :_cfe +_ddbg /2-(_cbc -_ebg ._bcdg ),X2 :_dde ,Y2 :_cfe -_ebg ._gfg -_ddbg /2+(_dcb -_ebg ._gbb ),LineStyle :_ebg .LineStyle };
_dbfe ,_ ,_eac :=_dccd .Draw ("");if _eac !=nil {return nil ,ctx ,_eac ;};_eac =_fea .addContentsByString (string (_dbfe ));if _eac !=nil {return nil ,ctx ,_eac ;};};if _ebg ._fce !=0{_cdge :=_ecd +_ebg ._ffc ;_deag :=_cedc ;if _ebg ._cece ==CellBorderStyleDouble {_cdge -=_ebd ;
_gba :=_dd .BasicLine {LineWidth :_ebg ._fce ,Opacity :1.0,LineColor :_egf (_ebg ._ddgd ),X1 :_cdge +2*_ebd ,Y1 :_deag +_cde /2,X2 :_cdge +2*_ebd ,Y2 :_deag -_ebg ._gfg -_cde /2,LineStyle :_ebg .LineStyle };_aba ,_ ,_cgg :=_gba .Draw ("");if _cgg !=nil {return nil ,ctx ,_cgg ;
};_cgg =_fea .addContentsByString (string (_aba ));if _cgg !=nil {return nil ,ctx ,_cgg ;};};_cdgec :=_dd .BasicLine {LineWidth :_ebg ._fce ,Opacity :1.0,LineColor :_egf (_ebg ._ddgd ),X1 :_cdge ,Y1 :_deag +_cde /2-(_cbc -_ebg ._bcdg ),X2 :_cdge ,Y2 :_deag -_ebg ._gfg -_cde /2+(_dcb -_ebg ._gbb ),LineStyle :_ebg .LineStyle };
_ega ,_ ,_gbbe :=_cdgec .Draw ("");if _gbbe !=nil {return nil ,ctx ,_gbbe ;};_gbbe =_fea .addContentsByString (string (_ega ));if _gbbe !=nil {return nil ,ctx ,_gbbe ;};};return []*Block {_fea },ctx ,nil ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bgde *Creator )SetOptimizer (optimizer _cbf .Optimizer ){_bgde ._efeb =optimizer };

// NewColumn returns a new column for the line items invoice table.
func (_caca *Invoice )NewColumn (description string )*InvoiceCell {return _caca .newColumn (description ,CellHorizontalAlignmentLeft );};

// Lines returns all the lines the table of contents has.
func (_baeg *TOC )Lines ()[]*TOCLine {return _baeg ._fdba };func (_bfecc *Table )clone ()*Table {_ddfac :=*_bfecc ;_ddfac ._fdef =make ([]float64 ,len (_bfecc ._fdef ));copy (_ddfac ._fdef ,_bfecc ._fdef );_ddfac ._fbba =make ([]float64 ,len (_bfecc ._fbba ));
copy (_ddfac ._fbba ,_bfecc ._fbba );_ddfac ._bdad =make ([]*TableCell ,0,len (_bfecc ._bdad ));for _ ,_gbfga :=range _bfecc ._bdad {_geagc :=*_gbfga ;_geagc ._faded =&_ddfac ;_ddfac ._bdad =append (_ddfac ._bdad ,&_geagc );};return &_ddfac ;};func _fbgb (_cedd ,_daega ,_gdbfe string ,_eadg uint ,_edcfe TextStyle )*TOCLine {return _dbfc (TextChunk {Text :_cedd ,Style :_edcfe },TextChunk {Text :_daega ,Style :_edcfe },TextChunk {Text :_gdbfe ,Style :_edcfe },_eadg ,_edcfe );
};func _ddbd (_ebege *_cbf .PdfAnnotationLink )*_cbf .PdfAnnotationLink {if _ebege ==nil {return nil ;};_ffaae :=_cbf .NewPdfAnnotationLink ();_ffaae .BS =_ebege .BS ;_ffaae .A =_ebege .A ;if _adge ,_acgea :=_ebege .GetAction ();_acgea ==nil &&_adge !=nil {_ffaae .SetAction (_adge );
};if _adfca ,_dbbaf :=_ebege .Dest .(*_dg .PdfObjectArray );_dbbaf {_ffaae .Dest =_dg .MakeArray (_adfca .Elements ()...);};return _ffaae ;};

// MoveX moves the drawing context to absolute position x.
func (_edg *Creator )MoveX (x float64 ){_edg ._dfd .X =x };func _febed (_dgcd *_f .File )([]*_cbf .PdfPage ,error ){_eddd ,_caeaf :=_cbf .NewPdfReader (_dgcd );if _caeaf !=nil {return nil ,_caeaf ;};_ecea ,_caeaf :=_eddd .GetNumPages ();if _caeaf !=nil {return nil ,_caeaf ;
};var _bdfcg []*_cbf .PdfPage ;for _acgc :=0;_acgc < _ecea ;_acgc ++{_bffc ,_cdaa :=_eddd .GetPage (_acgc +1);if _cdaa !=nil {return nil ,_cdaa ;};_bdfcg =append (_bdfcg ,_bffc );};return _bdfcg ,nil ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_age *Block )ScaleToHeight (h float64 ){_gff :=h /_age ._bc ;_age .Scale (_gff ,_gff )};

// SetBorderWidth sets the border width.
func (_dfad *CurvePolygon )SetBorderWidth (borderWidth float64 ){_dfad ._edce .BorderWidth =borderWidth };func (_fac *Creator )setActivePage (_gce *_cbf .PdfPage ){_fac ._ceee =_gce };func _dbfc (_cgga ,_ffad ,_ddgb TextChunk ,_caeca uint ,_dcfcf TextStyle )*TOCLine {_fgab :=_cggef (_dcfcf );
_fgab .SetEnableWrap (true );_fgab .SetTextAlignment (TextAlignmentLeft );_fgab .SetMargins (0,0,2,2);_daeag :=&TOCLine {_gdbea :_fgab ,Number :_cgga ,Title :_ffad ,Page :_ddgb ,Separator :TextChunk {Text :"\u002e",Style :_dcfcf },_ggde :0,_fcgd :_caeca ,_dgga :10,_dfbd :PositionRelative };
_fgab ._cfag .Left =_daeag ._ggde +float64 (_daeag ._fcgd -1)*_daeag ._dgga ;_fgab ._bbed =_daeag .prepareParagraph ;return _daeag ;};

// Angle returns the block rotation angle in degrees.
func (_bef *Block )Angle ()float64 {return _bef ._ef };func _bff (_acca string )(*Image ,error ){_eeae ,_fca :=_f .Open (_acca );if _fca !=nil {return nil ,_fca ;};defer _eeae .Close ();_cced ,_fca :=_cbf .ImageHandling .Read (_eeae );if _fca !=nil {_be .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fca );
return nil ,_fca ;};return _ggca (_cced );};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_fgbb :_ga .Max (_ga .Min (r ,1.0),0.0),_ccfc :_ga .Max (_ga .Min (g ,1.0),0.0),_bgbb :_ga .Max (_ga .Min (b ,1.0),0.0)};};

// GetOptimizer returns current PDF optimizer.
func (_daee *Creator )GetOptimizer ()_cbf .Optimizer {return _daee ._efeb };

// SetFillColor sets the fill color.
func (_ecdf *Polygon )SetFillColor (color Color ){_ecdf ._degac .FillColor =_egf (color )};

// CreateTableOfContents sets a function to generate table of contents.
func (_cbfg *Creator )CreateTableOfContents (genTOCFunc func (_daea *TOC )error ){_cbfg ._febg =genTOCFunc ;};

// SetStyleLeft sets border style for left side.
func (_cdba *border )SetStyleLeft (style CellBorderStyle ){_cdba ._efe =style };func (_dbgge *StyledParagraph )wrapText ()error {return _dbgge .wrapChunks (true )};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_edefe *Invoice )TotalLines ()[][2]*InvoiceCell {_gfca :=[][2]*InvoiceCell {_edefe ._aefb };_gfca =append (_gfca ,_edefe ._gdgd ...);return append (_gfca ,_edefe ._edgd );};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetLineHeight sets the line height (1.0 default).
func (_feba *Paragraph )SetLineHeight (lineheight float64 ){_feba ._beee =lineheight };func _edca (_egdbg *_cbf .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_egdbg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_bdgb *_dd .PolyBezierCurve ;_afbe float64 ;_dcba float64 ;};

// SetPos sets absolute positioning with specified coordinates.
func (_aagd *Paragraph )SetPos (x ,y float64 ){_aagd ._cfaa =PositionAbsolute ;_aagd ._degg =x ;_aagd ._abbfb =y ;};

// AddLine appends a new line to the invoice line items table.
func (_dgfa *Invoice )AddLine (values ...string )[]*InvoiceCell {_bfeb :=len (_dgfa ._dcbb );var _fagb []*InvoiceCell ;for _fbbe ,_ddda :=range values {_dfg :=_dgfa .newCell (_ddda ,_dgfa ._ddfe );if _fbbe < _bfeb {_dfg .Alignment =_dgfa ._dcbb [_fbbe ].Alignment ;
};_fagb =append (_fagb ,_dfg );};_dgfa ._feec =append (_dgfa ._feec ,_fagb );return _fagb ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_eeec Color ;_becd _dd .LineStyle ;_efbf CellBorderStyle ;_bccd Color ;_bgdeag float64 ;_abce CellBorderStyle ;_gfff Color ;_febea float64 ;_cedga CellBorderStyle ;_acada Color ;_gcfg float64 ;_aggb CellBorderStyle ;_abaab Color ;
_bbgc float64 ;_gfcae ,_cada int ;_dfedf int ;_adcec int ;_fadgf VectorDrawable ;_bbfe CellHorizontalAlignment ;_bgbe CellVerticalAlignment ;_abdc float64 ;_faded *Table ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_eeea *Table )SetPos (x ,y float64 ){_eeea ._gacf =PositionAbsolute ;_eeea ._eabd =x ;_eeea ._dbaa =y ;};func (_abbed *TOCLine )getLineLink ()*_cbf .PdfAnnotation {if _abbed ._fgfa <=0{return nil ;};return _gafe (_abbed ._fgfa -1,_abbed ._eafc ,_abbed ._bgagc ,0);
};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_dbgg *Creator )NewPolyBezierCurve (curves []_dd .CubicBezierCurve )*PolyBezierCurve {return _fagc (curves );};func (_aabb *Creator )initContext (){_aabb ._dfd .X =_aabb ._cba .Left ;_aabb ._dfd .Y =_aabb ._cba .Top ;_aabb ._dfd .Width =_aabb ._ebdb -_aabb ._cba .Right -_aabb ._cba .Left ;
_aabb ._dfd .Height =_aabb ._gbe -_aabb ._cba .Bottom -_aabb ._cba .Top ;_aabb ._dfd .PageHeight =_aabb ._gbe ;_aabb ._dfd .PageWidth =_aabb ._ebdb ;_aabb ._dfd .Margins =_aabb ._cba ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;
CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// DrawWithContext draws the Block using the specified drawing context.
func (_dgee *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_eggb ,_ ,_abd :=d .GeneratePageBlocks (ctx );if _abd !=nil {return _abd ;};if len (_eggb )!=1{return _a .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_fe :=range _eggb {if _aae :=_dgee .mergeBlocks (_fe );_aae !=nil {return _aae ;};};return nil ;};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_gbdef *TOCLine )SetLevelOffset (levelOffset float64 ){_gbdef ._dgga =levelOffset ;_gbdef ._gdbea ._cfag .Left =_gbdef ._ggde +float64 (_gbdef ._fcgd -1)*_gbdef ._dgga ;};

// SetBorderOpacity sets the border opacity.
func (_faaf *CurvePolygon )SetBorderOpacity (opacity float64 ){_faaf ._fgcae =opacity };

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_dace *Image )ConvertToBinary ()error {return _dace ._aaad .ConvertToBinary ()};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_aecg *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fadg :=ctx ;var _bbcg []*Block ;_edbd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _aecg ._dbba .IsRelative (){ctx .X +=_aecg ._cfag .Left ;ctx .Y +=_aecg ._cfag .Top ;
ctx .Width -=_aecg ._cfag .Left +_aecg ._cfag .Right ;ctx .Height -=_aecg ._cfag .Top +_aecg ._cfag .Bottom ;_aecg .SetWidth (ctx .Width );}else {if int (_aecg ._bbgd )<=0{_aecg .SetWidth (_aecg .getTextWidth ()/1000.0);};ctx .X =_aecg ._cceb ;ctx .Y =_aecg ._befd ;
};if _aecg ._bbed !=nil {_aecg ._bbed (_aecg ,ctx );};if _eacg :=_aecg .wrapText ();_eacg !=nil {return nil ,ctx ,_eacg ;};_edba :=_aecg ._dgfag ;for {_dcbab ,_bddb ,_afafb :=_bcace (_edbd ,_aecg ,_edba ,ctx );if _afafb !=nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_afafb );
return nil ,ctx ,_afafb ;};ctx =_dcbab ;_bbcg =append (_bbcg ,_edbd );if _edba =_bddb ;len (_bddb )==0{break ;};_edbd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dcbab =ctx ;_dcbab .Y =ctx .Margins .Top ;_dcbab .X =ctx .Margins .Left +_aecg ._cfag .Left ;
_dcbab .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_aecg ._cfag .Bottom ;_dcbab .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_aecg ._cfag .Left -_aecg ._cfag .Right ;ctx =_dcbab ;};if _aecg ._dbba .IsRelative (){ctx .X -=_aecg ._cfag .Left ;
ctx .Width =_fadg .Width ;return _bbcg ,ctx ,nil ;};return _bbcg ,_fadg ,nil ;};

// SetBorderWidth sets the border width.
func (_ccba *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_ccba ._bdgb .BorderWidth =borderWidth ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_ecac *Invoice )InfoLines ()[][2]*InvoiceCell {_fdde :=[][2]*InvoiceCell {_ecac ._abga ,_ecac ._ddgfe ,_ecac ._ddf };return append (_fdde ,_ecac ._edcb ...);};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_gbde *Creator )Finalize ()error {if _gbde ._eabg {return nil ;};_dfc :=len (_gbde ._fagg );_dcg :=0;if _gbde ._abbe !=nil {_dcg ++;};if _gbde .AddTOC {_gbde .initContext ();_gbde ._dfd .Page =_dcg +1;if _gbde ._febg !=nil {if _gac :=_gbde ._febg (_gbde ._edef );
_gac !=nil {return _gac ;};};_agde ,_ ,_bebb :=_gbde ._edef .GeneratePageBlocks (_gbde ._dfd );if _bebb !=nil {_be .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_bebb );
return _bebb ;};_dcg +=len (_agde );_ebeg :=_gbde ._edef .Lines ();for _ ,_cdcd :=range _ebeg {_ggfe ,_fdc :=_c .Atoi (_cdcd .Page .Text );if _fdc !=nil {continue ;};_cdcd .Page .Text =_c .Itoa (_ggfe +_dcg );};};_ggae :=false ;if _gbde ._abbe !=nil {_dfc ++;
_fcecd :=_gbde .newPage ();_gbde ._fagg =append ([]*_cbf .PdfPage {_fcecd },_gbde ._fagg ...);_gbde .setActivePage (_fcecd );_gbag :=FrontpageFunctionArgs {PageNum :1,TotalPages :_dfc };_gbde ._abbe (_gbag );_ggae =true ;};var _dddb []*_cbf .PdfPage ;if _gbde .AddTOC {_gbde .initContext ();
if _gbde ._febg !=nil {if _fcce :=_gbde ._febg (_gbde ._edef );_fcce !=nil {_be .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_fcce );return _fcce ;
};};_fdcf :=_gbde ._edef .Lines ();for _ ,_geg :=range _fdcf {_geg ._fgfa +=int64 (_dcg );};_ccge ,_ ,_ :=_gbde ._edef .GeneratePageBlocks (_gbde ._dfd );for _ ,_ebgc :=range _ccge {_ebgc .SetPos (0,0);_dfc ++;_afc :=_gbde .newPage ();_dddb =append (_dddb ,_afc );
_gbde .setActivePage (_afc );_gbde .Draw (_ebgc );};if _ggae {_cgdd :=_gbde ._fagg [0];_aef :=_gbde ._fagg [1:];_gbde ._fagg =append ([]*_cbf .PdfPage {_cgdd },_dddb ...);_gbde ._fagg =append (_gbde ._fagg ,_aef ...);}else {_gbde ._fagg =append (_dddb ,_gbde ._fagg ...);
};};if _gbde ._gcf !=nil &&_gbde .AddOutlines {var _acbc func (_bea *_cbf .OutlineItem );_acbc =func (_fbdb *_cbf .OutlineItem ){_fbdb .Dest .Page +=int64 (_dcg );if _gccb :=int (_fbdb .Dest .Page );_gccb >=0&&_gccb < len (_gbde ._fagg ){_fbdb .Dest .PageObj =_gbde ._fagg [_gccb ].GetPageAsIndirectObject ();
}else {_be .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gccb );
};_fbdb .Dest .Y =_gbde ._gbe -_fbdb .Dest .Y ;_cadf :=_fbdb .Items ();for _ ,_ggfa :=range _cadf {_acbc (_ggfa );};};_gaa :=_gbde ._gcf .Items ();for _ ,_eec :=range _gaa {_acbc (_eec );};if _gbde .AddTOC {var _gdcg int ;if _ggae {_gdcg =1;};_cbag :=_cbf .NewOutlineDest (int64 (_gdcg ),0,_gbde ._gbe );
if _gdcg >=0&&_gdcg < len (_gbde ._fagg ){_cbag .PageObj =_gbde ._fagg [_gdcg ].GetPageAsIndirectObject ();}else {_be .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gdcg );
};_gbde ._gcf .Insert (0,_cbf .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_cbag ));};};for _eacd ,_faa :=range _gbde ._fagg {_gbde .setActivePage (_faa );if _gbde ._ecfe !=nil {_geff ,_beba ,_ffbd :=_faa .Size ();
if _ffbd !=nil {return _ffbd ;};_fdcg :=PageFinalizeFunctionArgs {PageNum :_eacd +1,PageWidth :_geff ,PageHeight :_beba ,TOCPages :len (_dddb ),TotalPages :_dfc };if _fgbc :=_gbde ._ecfe (_fdcg );_fgbc !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_fgbc );
return _fgbc ;};};if _gbde ._gdcf !=nil {_bgac :=NewBlock (_gbde ._ebdb ,_gbde ._cba .Top );_deg :=HeaderFunctionArgs {PageNum :_eacd +1,TotalPages :_dfc };_gbde ._gdcf (_bgac ,_deg );_bgac .SetPos (0,0);if _dfeae :=_gbde .Draw (_bgac );_dfeae !=nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_dfeae );
return _dfeae ;};};if _gbde ._cadd !=nil {_ceda :=NewBlock (_gbde ._ebdb ,_gbde ._cba .Bottom );_agga :=FooterFunctionArgs {PageNum :_eacd +1,TotalPages :_dfc };_gbde ._cadd (_ceda ,_agga );_ceda .SetPos (0,_gbde ._gbe -_ceda ._bc );if _facb :=_gbde .Draw (_ceda );
_facb !=nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_facb );return _facb ;};};_fedc ,_fef :=_gbde ._cbb [_faa ];if !_fef {continue ;};if _cbcd ,_cff :=_gbde ._ade [_faa ];
_cff {_fedc .transform (_cbcd );};if _dgeb :=_fedc .drawToPage (_faa );_dgeb !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_eacd +1,_dgeb );
return _dgeb ;};};_gbde ._eabg =true ;return nil ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_ebgg *Image )GetHorizontalAlignment ()HorizontalAlignment {return _ebgg ._daeaf };func _gbfg (_agfe *Block ,_efba *Image ,_gdde DrawContext )(DrawContext ,error ){_gadg :=_gdde ;_aec :=1;_ebfe :=_dg .PdfObjectName (_da .Sprintf ("\u0049\u006d\u0067%\u0064",_aec ));
for _agfe ._de .HasXObjectByName (_ebfe ){_aec ++;_ebfe =_dg .PdfObjectName (_da .Sprintf ("\u0049\u006d\u0067%\u0064",_aec ));};_cgeb :=_agfe ._de .SetXObjectImageByName (_ebfe ,_efba ._cfee );if _cgeb !=nil {return _gdde ,_cgeb ;};_dccc :=0;_gbac :=_dg .PdfObjectName (_da .Sprintf ("\u0047\u0053\u0025\u0064",_dccc ));
for _agfe ._de .HasExtGState (_gbac ){_dccc ++;_gbac =_dg .PdfObjectName (_da .Sprintf ("\u0047\u0053\u0025\u0064",_dccc ));};_adfc :=_dg .MakeDict ();_adfc .Set ("\u0042\u004d",_dg .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _efba ._bcdb < 1.0{_adfc .Set ("\u0043\u0041",_dg .MakeFloat (_efba ._bcdb ));
_adfc .Set ("\u0063\u0061",_dg .MakeFloat (_efba ._bcdb ));};_cgeb =_agfe ._de .AddExtGState (_gbac ,_dg .MakeIndirectObject (_adfc ));if _cgeb !=nil {return _gdde ,_cgeb ;};_fegc :=_efba .Width ();_acad :=_efba .Height ();_ ,_bgdegf :=_efba .rotatedSize ();
_ddgde :=_gdde .X ;_ddded :=_gdde .PageHeight -_gdde .Y -_acad ;if _efba ._afdg .IsRelative (){_ddded -=(_bgdegf -_acad )/2;switch _efba ._daeaf {case HorizontalAlignmentCenter :_ddgde +=(_gdde .Width -_fegc )/2;case HorizontalAlignmentRight :_ddgde =_gdde .PageWidth -_gdde .Margins .Right -_efba ._agfc .Right -_fegc ;
};};_aaba :=_efba ._efdb ;_aggd :=_ag .NewContentCreator ();_aggd .Add_gs (_gbac );_aggd .Translate (_ddgde ,_ddded );if _aaba !=0{_aggd .Translate (_fegc /2,_acad /2);_aggd .RotateDeg (_aaba );_aggd .Translate (-_fegc /2,-_acad /2);};_aggd .Scale (_fegc ,_acad ).Add_Do (_ebfe );
_afge :=_aggd .Operations ();_afge .WrapIfNeeded ();_agfe .addContents (_afge );if _efba ._afdg .IsRelative (){_gdde .Y +=_bgdegf ;_gdde .Height -=_bgdegf ;return _gdde ,nil ;};return _gadg ,nil ;};func (_ffcba *Invoice )drawSection (_dgec ,_afdga string )[]*StyledParagraph {var _affbc []*StyledParagraph ;
if _dgec !=""{_aeec :=_cggef (_ffcba ._bcdde );_aeec .SetMargins (0,0,0,5);_aeec .Append (_dgec );_affbc =append (_affbc ,_aeec );};if _afdga !=""{_gbbeb :=_cggef (_ffcba ._fgbcg );_gbbeb .Append (_afdga );_affbc =append (_affbc ,_gbbeb );};return _affbc ;
};func (_bffd *StyledParagraph )getTextWidth ()float64 {var _gbaag float64 ;_gaae :=len (_bffd ._aaca );for _bedf ,_cbcca :=range _bffd ._aaca {_fde :=&_cbcca .Style ;_gcac :=len (_cbcca .Text );for _bbcf ,_fgfbf :=range _cbcca .Text {if _fgfbf =='\u000A'{continue ;
};_ggga ,_fefc :=_fde .Font .GetRuneMetrics (_fgfbf );if !_fefc {_be .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fgfbf );
return -1;};_gbaag +=_fde .FontSize *_ggga .Wx *_fde .horizontalScale ();if _fgfbf !=' '&&(_bedf !=_gaae -1||_bbcf !=_gcac -1){_gbaag +=_fde .CharSpacing *1000.0;};};};return _gbaag ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_deaa *Table )SetMargins (left ,right ,top ,bottom float64 ){_deaa ._ggad .Left =left ;_deaa ._ggad .Right =right ;_deaa ._ggad .Top =top ;_deaa ._ggad .Bottom =bottom ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_egac *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _egac ._aaeb .Left ,_egac ._aaeb .Right ,_egac ._aaeb .Top ,_egac ._aaeb .Bottom ;};

// SetColor sets the line color.
func (_fec *Curve )SetColor (col Color ){_fec ._eadb =col };

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_aacd DrawContext )([]*Block ,DrawContext ,error );};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_dbd *Creator )MoveDown (dy float64 ){_dbd ._dfd .Y +=dy };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_bccc *StyledParagraph )Insert (index uint ,text string )*TextChunk {_gbagc :=uint (len (_bccc ._aaca ));if index > _gbagc {index =_gbagc ;};_ebgd :=NewTextChunk (text ,_bccc ._gcbb );_bccc ._aaca =append (_bccc ._aaca [:index ],append ([]*TextChunk {_ebgd },_bccc ._aaca [index :]...)...);
_bccc .wrapText ();return _ebgd ;};

// Cols returns the total number of columns the table has.
func (_cccg *Table )Cols ()int {return _cccg ._fcedd };

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_bcdca float64 ;_edeb float64 ;_gacd float64 ;_cfbb float64 ;_eccg float64 ;_gbed float64 ;_eadb Color ;_fcga float64 ;};

// SetText sets the text content of the Paragraph.
func (_afgbc *Paragraph )SetText (text string ){_afgbc ._dcebg =text };func (_debee *StyledParagraph )getMaxLineWidth ()float64 {if _debee ._dgfag ==nil ||len (_debee ._dgfag )==0{_debee .wrapText ();};var _bcaa float64 ;for _ ,_ebbfa :=range _debee ._dgfag {_fefca :=_debee .getTextLineWidth (_ebbfa );
if _fefca > _bcaa {_bcaa =_fefca ;};};return _bcaa ;};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_geaa *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_acddc :=_cggef (_geaa ._gbgb );_acddc .Append (text );_fcba ,_eafbd :=_geaa .Add (_acddc );return _acddc ,_fcba ,_eafbd ;};func (_ecff *Image )makeXObject ()error {_gfcd :=_ecff ._bfeg ;
if _gfcd ==nil {_gfcd =_dg .NewFlateEncoder ();};_afgb ,_cac :=_cbf .NewXObjectImageFromImage (_ecff ._aaad ,nil ,_gfcd );if _cac !=nil {_be .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cac );
return _cac ;};_ecff ._cfee =_afgb ;return nil ;};

// SetWidthLeft sets border width for left.
func (_abe *border )SetWidthLeft (bw float64 ){_abe ._cbec =bw };

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_bdf *Creator )NewImageFromGoImage (goimg _ec .Image )(*Image ,error ){return _eebe (goimg )};func (_ffga *Invoice )generateHeaderBlocks (_ggeg DrawContext )([]*Block ,DrawContext ,error ){_abgc :=_cggef (_ffga ._acdb );_abgc .SetEnableWrap (true );
_abgc .Append (_ffga ._dbad );_decb :=_bgec (2);if _ffga ._dfde !=nil {_fecf :=_decb .NewCell ();_fecf .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_fecf .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fecf .SetIndent (0);_fecf .SetContent (_ffga ._dfde );
_ffga ._dfde .ScaleToHeight (_abgc .Height ()+20);}else {_decb .SkipCells (1);};_bdce :=_decb .NewCell ();_bdce .SetHorizontalAlignment (CellHorizontalAlignmentRight );_bdce .SetVerticalAlignment (CellVerticalAlignmentMiddle );_bdce .SetContent (_abgc );
return _decb .GeneratePageBlocks (_ggeg );};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_beae *Line )SetColor (col Color ){_beae ._efab =col };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_faef *Creator )NewPage ()*_cbf .PdfPage {_ebbb :=_faef .newPage ();_faef ._fagg =append (_faef ._fagg ,_ebbb );_faef ._dfd .Page ++;return _ebbb ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;
);func _eaef ()*PageBreak {return &PageBreak {}};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_agff *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _a .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _a .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _a .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_agff ._fbdc =true ;_agff ._fdge =startRow ;_agff ._abgg =endRow ;return nil ;};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_acdf *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_acdf ._fcedd {_be .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_acdf ._fbba =widths ;return nil ;};

// SkipRows skips over a specified number of rows in the table.
func (_baafc *Table )SkipRows (num int ){_gdgab :=num *_baafc ._fcedd -1;if _gdgab < 0{_be .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_baafc ._edcbf +=_gdgab ;};

// Rows returns the total number of rows the table has.
func (_aege *Table )Rows ()int {return _aege ._aafb };

// SetBorderWidth sets the border width.
func (_dccb *Rectangle )SetBorderWidth (bw float64 ){_dccb ._eaaeb =bw };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_egde *StyledParagraph )SetTextAlignment (align TextAlignment ){_egde ._gdbf =align };

// SetMargins sets the margins of the paragraph.
func (_cbgd *List )SetMargins (left ,right ,top ,bottom float64 ){_cbgd ._dbea .Left =left ;_cbgd ._dbea .Right =right ;_cbgd ._dbea .Top =top ;_cbgd ._dbea .Bottom =bottom ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_debe *_dd .Polyline ;_cbeec float64 ;};

// SetFillColor sets the fill color.
func (_gbgd *PolyBezierCurve )SetFillColor (color Color ){_gbgd ._bdgb .FillColor =_egf (color )};

// Reset removes all the text chunks the paragraph contains.
func (_cfbe *StyledParagraph )Reset (){_cfbe ._aaca =[]*TextChunk {}};func (_ceabe *StyledParagraph )wrapChunks (_beaa bool )error {if !_ceabe ._ccbc ||int (_ceabe ._bbgd )<=0{_ceabe ._dgfag =[][]*TextChunk {_ceabe ._aaca };return nil ;};_ceabe ._dgfag =[][]*TextChunk {};
var _caaf []*TextChunk ;var _gbaee float64 ;_ebgbb :=_cb .IsSpace ;if !_beaa {_ebgbb =func (rune )bool {return false };};for _ ,_dcfa :=range _ceabe ._aaca {_ebbbb :=_dcfa .Style ;_dcef :=_dcfa ._bfaf ;var (_fded []rune ;_dgce []float64 ;);for _ ,_cafg :=range _dcfa .Text {if _cafg =='\u000A'{if !_beaa {_fded =append (_fded ,_cafg );
};_caaf =append (_caaf ,&TextChunk {Text :_fa .TrimRightFunc (string (_fded ),_ebgbb ),Style :_ebbbb ,_bfaf :_bdcg (_dcef )});_ceabe ._dgfag =append (_ceabe ._dgfag ,_caaf );_caaf =nil ;_gbaee =0;_fded =nil ;_dgce =nil ;continue ;};_afec :=_cafg ==' ';
_adgbc ,_fcdd :=_ebbbb .Font .GetRuneMetrics (_cafg );if !_fcdd {_be .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cafg );
return _a .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_fafd :=_ebbbb .FontSize *_adgbc .Wx *_ebbbb .horizontalScale ();_gbfd :=_fafd ;if !_afec {_gbfd =_fafd +_ebbbb .CharSpacing *1000.0;
};if _gbaee +_fafd > _ceabe ._bbgd *1000.0{_gcgb :=-1;if !_afec {for _bgacg :=len (_fded )-1;_bgacg >=0;_bgacg --{if _fded [_bgacg ]==' '{_gcgb =_bgacg ;break ;};};};_bagg :=string (_fded );if _gcgb >=0{_bagg =string (_fded [0:_gcgb +1]);_fded =_fded [_gcgb +1:];
_fded =append (_fded ,_cafg );_dgce =_dgce [_gcgb +1:];_dgce =append (_dgce ,_gbfd );_gbaee =0;for _ ,_dcbbb :=range _dgce {_gbaee +=_dcbbb ;};}else {if _afec {_gbaee =0;_fded =[]rune {};_dgce =[]float64 {};}else {_gbaee =_gbfd ;_fded =[]rune {_cafg };
_dgce =[]float64 {_gbfd };};};if !_beaa &&_afec {_bagg +="\u0020";};_caaf =append (_caaf ,&TextChunk {Text :_fa .TrimRightFunc (_bagg ,_ebgbb ),Style :_ebbbb ,_bfaf :_bdcg (_dcef )});_ceabe ._dgfag =append (_ceabe ._dgfag ,_caaf );_caaf =[]*TextChunk {};
}else {_gbaee +=_gbfd ;_fded =append (_fded ,_cafg );_dgce =append (_dgce ,_gbfd );};};if len (_fded )> 0{_caaf =append (_caaf ,&TextChunk {Text :string (_fded ),Style :_ebbbb ,_bfaf :_bdcg (_dcef )});};};if len (_caaf )> 0{_ceabe ._dgfag =append (_ceabe ._dgfag ,_caaf );
};return nil ;};

// SellerAddress returns the seller address used in the invoice template.
func (_bgg *Invoice )SellerAddress ()*InvoiceAddress {return _bgg ._gbcd };

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ebbg *Creator )SetPageLabels (pageLabels _dg .PdfObject ){_ebbg ._cce =pageLabels };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_ggcf *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_ggcf ._bgbe =valign };func (_egcb *Invoice )generateTotalBlocks (_fedcg DrawContext )([]*Block ,DrawContext ,error ){_fcbe :=_bgec (4);_fcbe .SetMargins (0,0,10,10);_fcceg :=[][2]*InvoiceCell {_egcb ._aefb };
_fcceg =append (_fcceg ,_egcb ._gdgd ...);_fcceg =append (_fcceg ,_egcb ._edgd );for _ ,_febb :=range _fcceg {_gec ,_defa :=_febb [0],_febb [1];if _defa .Value ==""{continue ;};_fcbe .SkipCells (2);_gagf :=_fcbe .NewCell ();_gagf .SetBackgroundColor (_gec .BackgroundColor );
_gagf .SetHorizontalAlignment (_defa .Alignment );_egcb .setCellBorder (_gagf ,_gec );_dfdcd :=_cggef (_gec .TextStyle );_dfdcd .SetMargins (0,0,2,1);_dfdcd .Append (_gec .Value );_gagf .SetContent (_dfdcd );_gagf =_fcbe .NewCell ();_gagf .SetBackgroundColor (_defa .BackgroundColor );
_gagf .SetHorizontalAlignment (_defa .Alignment );_egcb .setCellBorder (_gagf ,_gec );_dfdcd =_cggef (_defa .TextStyle );_dfdcd .SetMargins (0,0,2,1);_dfdcd .Append (_defa .Value );_gagf .SetContent (_dfdcd );};return _fcbe .GeneratePageBlocks (_fedcg );
};

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_ggaed *Division )Width ()float64 {return 0};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_eadd *Paragraph )SetTextAlignment (align TextAlignment ){_eadd ._gbaea =align };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_bfaf *_cbf .PdfAnnotation ;_dddcf bool ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_cdebg *TOCLine )LevelOffset ()float64 {return _cdebg ._dgga };

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_adeg *TOC )SetLineNumberStyle (style TextStyle ){_adeg ._dbbg =style };

// GeneratePageBlocks generates a page break block.
func (_cdcb *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acea :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_aecd :=ctx ;_aecd .Y =ctx .Margins .Top ;
_aecd .X =ctx .Margins .Left ;_aecd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_aecd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_aecd ;return _acea ,ctx ,nil ;};

// SetWidth sets line width.
func (_dadf *Curve )SetWidth (width float64 ){_dadf ._fcga =width };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_ggcga *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egab :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cgae ,_afae :=_egab .setOpacity (_ggcga ._cbeec ,_ggcga ._cbeec );if _afae !=nil {return nil ,ctx ,_afae ;
};_dceg :=_ggcga ._debe .Points ;for _efbbc :=range _dceg {_bfba :=&_dceg [_efbbc ];_bfba .Y =ctx .PageHeight -_bfba .Y ;};_fada ,_ ,_afae :=_ggcga ._debe .Draw (_cgae );if _afae !=nil {return nil ,ctx ,_afae ;};if _afae =_egab .addContentsByString (string (_fada ));
_afae !=nil {return nil ,ctx ,_afae ;};return []*Block {_egab },ctx ,nil ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_agaa *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_gece ,_aecde :=_agaa .Wrap (width );if _aecde !=nil {return nil ,_aecde ;};_bgcbc :=int (height /_agaa .Style .FontSize );if _bgcbc >=len (_gece ){return nil ,nil ;};_efded :="\u000a";
_agaa .Text =_fa .Replace (_fa .Join (_gece [:_bgcbc ],"\u0020"),_efded +"\u0020",_efded ,-1);_ebgcc :=_fa .Replace (_fa .Join (_gece [_bgcbc :],"\u0020"),_efded +"\u0020",_efded ,-1);return NewTextChunk (_ebgcc ,_agaa .Style ),nil ;};var PPMM =float64 (72*1.0/25.4);


// SetWidthBottom sets border width for bottom.
func (_ddd *border )SetWidthBottom (bw float64 ){_ddd ._gbb =bw };

// SetOpacity sets opacity for Image.
func (_ffaa *Image )SetOpacity (opacity float64 ){_ffaa ._bcdb =opacity };func (_fgfeg *Paragraph )getTextWidth ()float64 {_gagc :=0.0;for _ ,_baaab :=range _fgfeg ._dcebg {if _baaab =='\u000A'{continue ;};_ddfa ,_gbbec :=_fgfeg ._ddcg .GetRuneMetrics (_baaab );
if !_gbbec {_be .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_baaab ,_baaab );
return -1;};_gagc +=_fgfeg ._faagb *_ddfa .Wx ;};return _gagc ;};

// Title returns the title of the invoice.
func (_ace *Invoice )Title ()string {return _ace ._dbad };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_fgdg *List )Marker ()*TextChunk {return &_fgdg ._gffd };

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_dadd *Creator )MoveTo (x ,y float64 ){_dadd ._dfd .X =x ;_dadd ._dfd .Y =y };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_afcd *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeecd :=ctx ;var _cabfad []*Block ;_ggfcc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _afcd ._cfaa .IsRelative (){ctx .X +=_afcd ._egdf .Left ;ctx .Y +=_afcd ._egdf .Top ;
ctx .Width -=_afcd ._egdf .Left +_afcd ._egdf .Right ;ctx .Height -=_afcd ._egdf .Top +_afcd ._egdf .Bottom ;_afcd .SetWidth (ctx .Width );if _afcd .Height ()> ctx .Height {_cabfad =append (_cabfad ,_ggfcc );_ggfcc =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_fega :=ctx ;_fega .Y =ctx .Margins .Top ;_fega .X =ctx .Margins .Left +_afcd ._egdf .Left ;_fega .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_afcd ._egdf .Bottom ;_fega .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_afcd ._egdf .Left -_afcd ._egdf .Right ;
ctx =_fega ;};}else {if int (_afcd ._ccca )<=0{_afcd .SetWidth (_afcd .getTextWidth ());};ctx .X =_afcd ._degg ;ctx .Y =_afcd ._abbfb ;};ctx ,_fcf :=_afa (_ggfcc ,_afcd ,ctx );if _fcf !=nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcf );
return nil ,ctx ,_fcf ;};_cabfad =append (_cabfad ,_ggfcc );if _afcd ._cfaa .IsRelative (){ctx .X -=_afcd ._egdf .Left ;ctx .Width =_aeecd .Width ;return _cabfad ,ctx ,nil ;};return _cabfad ,_aeecd ,nil ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_caeb []*listItem ;_dbea Margins ;_gffd TextChunk ;_gfeg float64 ;_gdfg bool ;_ebbba Positioning ;_gbgb TextStyle ;};func (_cfc *Chapter )headingText ()string {_bga :=_cfc ._ggb ;if _bae :=_cfc .headingNumber ();_bae !=""{_bga =_da .Sprintf ("\u0025\u0073\u0020%\u0073",_bae ,_bga );
};return _bga ;};

// CurCol returns the currently active cell's column number.
func (_bcbc *Table )CurCol ()int {_abcdf :=(_bcbc ._edcbf -1)%(_bcbc ._fcedd )+1;return _abcdf };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_dbggd *TOCLine )SetStyle (style TextStyle ){_dbggd .Number .Style =style ;_dbggd .Title .Style =style ;_dbggd .Separator .Style =style ;_dbggd .Page .Style =style ;};

// SetDate sets the date of the invoice.
func (_fcgaa *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_fcgaa ._ddgfe [1].Value =date ;return _fcgaa ._ddgfe [0],_fcgaa ._ddgfe [1];};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_cdfa *Invoice )SetNoteStyle (style TextStyle ){_cdfa ._fgbcg =style };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_cbf .PdfPage )(*Block ,error ){_dga :=&Block {};_bdg ,_ae :=page .GetAllContentStreams ();if _ae !=nil {return nil ,_ae ;};_ff :=_ag .NewContentStreamParser (_bdg );_ca ,_ae :=_ff .Parse ();if _ae !=nil {return nil ,_ae ;};
_ca .WrapIfNeeded ();_dga ._bg =_ca ;if page .Resources !=nil {_dga ._de =page .Resources ;}else {_dga ._de =_cbf .NewPdfPageResources ();};_cad ,_ae :=page .GetMediaBox ();if _ae !=nil {return nil ,_ae ;};if _cad .Llx !=0||_cad .Lly !=0{_dga .translate (-_cad .Llx ,_cad .Lly );
};_dga ._eaf =_cad .Urx -_cad .Llx ;_dga ._bc =_cad .Ury -_cad .Lly ;if page .Rotate !=nil {_dga ._ef =-float64 (*page .Rotate );};return _dga ,nil ;};func (_gee *Block )translate (_ggaf ,_gfa float64 ){_eaa :=_ag .NewContentCreator ().Translate (_ggaf ,-_gfa ).Operations ();
*_gee ._bg =append (*_eaa ,*_gee ._bg ...);_gee ._bg .WrapIfNeeded ();};func _dbed (_bgcb ,_fgce ,_aced ,_egbf float64 )*Line {_dbeg :=&Line {};_dbeg ._dceb =_bgcb ;_dbeg ._edfge =_fgce ;_dbeg ._cffa =_aced ;_dbeg ._gddf =_egbf ;_dbeg ._efab =ColorBlack ;
_dbeg ._gdcgc =1.0;return _dbeg ;};type border struct{_fba float64 ;_agd float64 ;_ffc float64 ;_gfg float64 ;_fdd Color ;_gcg Color ;_cbec float64 ;_deab Color ;_gbb float64 ;_ddgd Color ;_fce float64 ;_baaa Color ;_bcdg float64 ;LineStyle _dd .LineStyle ;
_efe CellBorderStyle ;_cece CellBorderStyle ;_fgfd CellBorderStyle ;_bbc CellBorderStyle ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_gffff *TOC )SetLineSeparatorStyle (style TextStyle ){_gffff ._dgdc =style };func (_fbe *Creator )newPage ()*_cbf .PdfPage {_badb :=_cbf .NewPdfPage ();_cceg :=_fbe ._beff [0];_ecda :=_fbe ._beff [1];_cdgb :=_cbf .PdfRectangle {Llx :0,Lly :0,Urx :_cceg ,Ury :_ecda };
_badb .MediaBox =&_cdgb ;_fbe ._ebdb =_cceg ;_fbe ._gbe =_ecda ;_fbe .initContext ();return _badb ;};

// SetAngle sets the rotation angle in degrees.
func (_cc *Block )SetAngle (angleDeg float64 ){_cc ._ef =angleDeg };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_dbfegg *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dbfegg ._egdf .Left ,_dbfegg ._egdf .Right ,_dbfegg ._egdf .Top ,_dbfegg ._egdf .Bottom ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;
HorizontalAlignmentRight ;);

// CreateFrontPage sets a function to generate a front Page.
func (_aed *Creator )CreateFrontPage (genFrontPageFunc func (_gfgd FrontpageFunctionArgs )){_aed ._abbe =genFrontPageFunc ;};func _bcace (_ccae *Block ,_ggegf *StyledParagraph ,_egdb [][]*TextChunk ,_ffbbe DrawContext )(DrawContext ,[][]*TextChunk ,error ){_bfcce :=1;
_ddcga :=_dg .PdfObjectName (_da .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bfcce ));for _ccae ._de .HasFontByName (_ddcga ){_bfcce ++;_ddcga =_dg .PdfObjectName (_da .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bfcce ));};_ddag :=_ccae ._de .SetFontByName (_ddcga ,_ggegf ._gcbb .Font .ToPdfObject ());
if _ddag !=nil {return _ffbbe ,nil ,_ddag ;};_bfcce ++;_ebed :=_ddcga ;_ddafg :=_ggegf ._gcbb .FontSize ;_abcd :=_ggegf ._dbba .IsRelative ();var _gcbbc [][]_dg .PdfObjectName ;var _beca [][]*TextChunk ;var _cdfaa float64 ;for _geag ,_efcb :=range _egdb {var _dcdf []_dg .PdfObjectName ;
var _geffb float64 ;for _ ,_ccgd :=range _efcb {_gcab :=_ccgd .Style ;if _gcab .FontSize > _geffb {_geffb =_gcab .FontSize ;};_ddcga =_dg .PdfObjectName (_da .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bfcce ));_ecggg :=_ccae ._de .SetFontByName (_ddcga ,_gcab .Font .ToPdfObject ());
if _ecggg !=nil {return _ffbbe ,nil ,_ecggg ;};_dcdf =append (_dcdf ,_ddcga );_bfcce ++;};_geffb *=_ggegf ._gdac ;if _abcd &&_cdfaa +_geffb > _ffbbe .Height {_beca =_egdb [_geag :];_egdb =_egdb [:_geag ];break ;};_cdfaa +=_geffb ;_gcbbc =append (_gcbbc ,_dcdf );
};_agca ,_afafe ,_cgdbd :=_ggegf .getLineMetrics (0);_dccbb ,_adbaa :=_agca *_ggegf ._gdac ,_afafe *_ggegf ._gdac ;_cfggf :=_ag .NewContentCreator ();_cfggf .Add_q ();_agdg :=_adbaa ;if _ggegf ._cgdbe ==TextVerticalAlignmentCenter {_agdg =_afafe +(_agca +_cgdbd -_afafe )/2+(_adbaa -_afafe )/2;
};_fcdb :=_ffbbe .PageHeight -_ffbbe .Y -_agdg ;_cfggf .Translate (_ffbbe .X ,_fcdb );_acbd :=_fcdb ;if _ggegf ._bdcf !=0{_cfggf .RotateDeg (_ggegf ._bdcf );};if _ggegf ._gaec ==TextOverflowHidden {_cfggf .Add_re (0,-_cdfaa +_dccbb +1,_ggegf ._bbgd ,_cdfaa ).Add_W ().Add_n ();
};_cfggf .Add_BT ();var _agef []*_dd .BasicLine ;for _beed ,_caecdd :=range _egdb {_eefaa :=_ffbbe .X ;if _beed !=0{_cfggf .Add_Tstar ();};_acae :=_beed ==len (_egdb )-1;var (_effag float64 ;_bbecd float64 ;_gdgcf float64 ;_febf uint ;);var _cdfd []float64 ;
for _ ,_cfcd :=range _caecdd {_fdab :=&_cfcd .Style ;if _fdab .FontSize > _bbecd {_bbecd =_fdab .FontSize ;};_fgbcf ,_cdfec :=_fdab .Font .GetRuneMetrics (' ');if !_cdfec {return _ffbbe ,nil ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _bfgd uint ;var _cggce float64 ;_edcg :=len (_cfcd .Text );for _dfbef ,_ffaf :=range _cfcd .Text {if _ffaf ==' '{_bfgd ++;continue ;};if _ffaf =='\u000A'{continue ;};_gbec ,_fdega :=_fdab .Font .GetRuneMetrics (_ffaf );if !_fdega {_be .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_ffaf );
return _ffbbe ,nil ,_a .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_cggce +=_fdab .FontSize *_gbec .Wx *_fdab .horizontalScale ();if _dfbef !=_edcg -1{_cggce +=_fdab .CharSpacing *1000.0;
};};_cdfd =append (_cdfd ,_cggce );_effag +=_cggce ;_gdgcf +=float64 (_bfgd )*_fgbcf .Wx *_fdab .FontSize *_fdab .horizontalScale ();_febf +=_bfgd ;};_bbecd *=_ggegf ._gdac ;var _geda []_dg .PdfObject ;_fagcg :=_ggegf ._bbgd *1000.0;if _ggegf ._gdbf ==TextAlignmentJustify {if _febf > 0&&!_acae {_gdgcf =(_fagcg -_effag )/float64 (_febf )/_ddafg ;
};}else if _ggegf ._gdbf ==TextAlignmentCenter {_cafgb :=(_fagcg -_effag -_gdgcf )/2;_febd :=_cafgb /_ddafg ;_geda =append (_geda ,_dg .MakeFloat (-_febd ));_eefaa +=_cafgb /1000.0;}else if _ggegf ._gdbf ==TextAlignmentRight {_bccg :=(_fagcg -_effag -_gdgcf );
_afdf :=_bccg /_ddafg ;_geda =append (_geda ,_dg .MakeFloat (-_afdf ));_eefaa +=_bccg /1000.0;};if len (_geda )> 0{_cfggf .Add_Tf (_ebed ,_ddafg ).Add_TL (_ddafg *_ggegf ._gdac ).Add_TJ (_geda ...);};var _fbeg float64 ;for _cdefa ,_babb :=range _caecdd {_ggaa :=&_babb .Style ;
if _ggaa .FontSize > _fbeg {_fbeg =_ggaa .FontSize ;};_dagd :=_ebed ;_eaaef :=_ddafg ;_febfd :=_ggaa .OutlineColor !=nil ;_aeae :=_ggaa .HorizontalScaling !=DefaultHorizontalScaling ;_acee :=_ggaa .OutlineSize !=1;if _acee {_cfggf .Add_w (_ggaa .OutlineSize );
};_eba :=_ggaa .RenderingMode !=TextRenderingModeFill ;if _eba {_cfggf .Add_Tr (int64 (_ggaa .RenderingMode ));};_bfca :=_ggaa .CharSpacing !=0;if _bfca {_cfggf .Add_Tc (_ggaa .CharSpacing );};_abfce :=_ggaa .TextRise !=0;if _abfce {_cfggf .Add_Ts (_ggaa .TextRise );
};if _ggegf ._gdbf !=TextAlignmentJustify ||_acae {_eeba ,_bgaac :=_ggaa .Font .GetRuneMetrics (' ');if !_bgaac {return _ffbbe ,nil ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};_dagd =_gcbbc [_beed ][_cdefa ];_eaaef =_ggaa .FontSize ;_gdgcf =_eeba .Wx *_ggaa .horizontalScale ();};_edbg :=_ggaa .Font .Encoder ();var _ceaad []byte ;for _ ,_agfbf :=range _babb .Text {if _agfbf =='\u000A'{continue ;};if _agfbf ==' '{if len (_ceaad )> 0{if _febfd {_cfggf .SetStrokingColor (_egf (_ggaa .OutlineColor ));
};if _aeae {_cfggf .Add_Tz (_ggaa .HorizontalScaling );};_cfggf .SetNonStrokingColor (_egf (_ggaa .Color )).Add_Tf (_gcbbc [_beed ][_cdefa ],_ggaa .FontSize ).Add_TJ ([]_dg .PdfObject {_dg .MakeStringFromBytes (_ceaad )}...);_ceaad =nil ;};if _aeae {_cfggf .Add_Tz (DefaultHorizontalScaling );
};_cfggf .Add_Tf (_dagd ,_eaaef ).Add_TJ ([]_dg .PdfObject {_dg .MakeFloat (-_gdgcf )}...);_cdfd [_cdefa ]+=_gdgcf *_eaaef ;}else {if _ ,_efbbg :=_edbg .RuneToCharcode (_agfbf );!_efbbg {_be .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_agfbf ,_agfbf );
continue ;};_ceaad =append (_ceaad ,_edbg .Encode (string (_agfbf ))...);};};if len (_ceaad )> 0{if _febfd {_cfggf .SetStrokingColor (_egf (_ggaa .OutlineColor ));};if _aeae {_cfggf .Add_Tz (_ggaa .HorizontalScaling );};_cfggf .SetNonStrokingColor (_egf (_ggaa .Color )).Add_Tf (_gcbbc [_beed ][_cdefa ],_ggaa .FontSize ).Add_TJ ([]_dg .PdfObject {_dg .MakeStringFromBytes (_ceaad )}...);
};_afcde :=_cdfd [_cdefa ]/1000.0;if _ggaa .Underline {_cgddd :=_ggaa .UnderlineStyle .Color ;if _cgddd ==nil {_cgddd =_babb .Style .Color ;};_acbde ,_bfgdc ,_ebdd :=_cgddd .ToRGB ();_caea :=_eefaa -_ffbbe .X ;_decbf :=_acbd -_fcdb +_ggaa .TextRise -_ggaa .UnderlineStyle .Offset ;
_agef =append (_agef ,&_dd .BasicLine {X1 :_caea ,Y1 :_decbf ,X2 :_caea +_afcde ,Y2 :_decbf ,LineWidth :_babb .Style .UnderlineStyle .Thickness ,LineColor :_cbf .NewPdfColorDeviceRGB (_acbde ,_bfgdc ,_ebdd )});};if _babb ._bfaf !=nil {var _ddgg *_dg .PdfObjectArray ;
if !_babb ._dddcf {switch _agge :=_babb ._bfaf .GetContext ().(type ){case *_cbf .PdfAnnotationLink :_ddgg =_dg .MakeArray ();_agge .Rect =_ddgg ;_dbge ,_bdafa :=_agge .Dest .(*_dg .PdfObjectArray );if _bdafa &&_dbge .Len ()==5{_eadda ,_agbb :=_dbge .Get (1).(*_dg .PdfObjectName );
if _agbb &&_eadda .String ()=="\u0058\u0059\u005a"{_gbeb ,_bdbb :=_dg .GetNumberAsFloat (_dbge .Get (3));if _bdbb ==nil {_dbge .Set (3,_dg .MakeFloat (_ffbbe .PageHeight -_gbeb ));};};};};_babb ._dddcf =true ;};if _ddgg !=nil {_gaac :=_dd .NewPoint (_eefaa -_ffbbe .X ,_acbd +_ggaa .TextRise -_fcdb ).Rotate (_ggegf ._bdcf );
_gaac .X +=_ffbbe .X ;_gaac .Y +=_fcdb ;_bgdea ,_dfgg ,_gffe ,_gfacae :=_agdgd (_afcde ,_bbecd ,_ggegf ._bdcf );_gaac .X +=_bgdea ;_gaac .Y +=_dfgg ;_ddgg .Clear ();_ddgg .Append (_dg .MakeFloat (_gaac .X ));_ddgg .Append (_dg .MakeFloat (_gaac .Y ));_ddgg .Append (_dg .MakeFloat (_gaac .X +_gffe ));
_ddgg .Append (_dg .MakeFloat (_gaac .Y +_gfacae ));};_ccae .AddAnnotation (_babb ._bfaf );};_eefaa +=_afcde ;if _acee {_cfggf .Add_w (1.0);};if _febfd {_cfggf .Add_RG (0.0,0.0,0.0);};if _eba {_cfggf .Add_Tr (int64 (TextRenderingModeFill ));};if _bfca {_cfggf .Add_Tc (0);
};if _abfce {_cfggf .Add_Ts (0);};if _aeae {_cfggf .Add_Tz (DefaultHorizontalScaling );};};_cfggf .Add_TL (_fbeg *_ggegf ._gdac );_acbd -=_bbecd ;};_cfggf .Add_ET ();for _ ,_acaf :=range _agef {_cfggf .SetStrokingColor (_acaf .LineColor ).Add_w (_acaf .LineWidth ).Add_m (_acaf .X1 ,_acaf .Y1 ).Add_l (_acaf .X2 ,_acaf .Y2 ).Add_s ();
};_cfggf .Add_Q ();_egfg :=_cfggf .Operations ();_egfg .WrapIfNeeded ();_ccae .addContents (_egfg );if _abcd {_gcfa :=_cdfaa +_ggegf ._cfag .Bottom ;_ffbbe .Y +=_gcfa ;_ffbbe .Height -=_gcfa ;if _ffbbe .Inline {_ffbbe .X +=_ggegf .Width ()+_ggegf ._cfag .Right ;
};};return _ffbbe ,_beca ,nil ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_eegaf *Invoice )Terms ()(string ,string ){return _eegaf ._bbce [0],_eegaf ._bbce [1]};

// SetNumber sets the number of the invoice.
func (_gffc *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gffc ._abga [1].Value =number ;return _gffc ._abga [0],_gffc ._abga [1];};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_gggf *Invoice )SetColumns (cols []*InvoiceCell ){_gggf ._dcbb =cols };

// SetTitleStyle sets the style properties of the invoice title.
func (_dcdb *Invoice )SetTitleStyle (style TextStyle ){_dcdb ._acdb =style };

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_edce *_dd .CurvePolygon ;_ccgee float64 ;_fgcae float64 ;};

// MoveY moves the drawing context to absolute position y.
func (_faag *Creator )MoveY (y float64 ){_faag ._dfd .Y =y };

// SetBorderOpacity sets the border opacity.
func (_cgdg *Polygon )SetBorderOpacity (opacity float64 ){_cgdg ._efddd =opacity };

// SetAngle sets the rotation angle of the text.
func (_agb *Paragraph )SetAngle (angle float64 ){_agb ._bgbgc =angle };

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_ecfeg *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ecfeg ._cfag .Left ,_ecfeg ._cfag .Right ,_ecfeg ._cfag .Top ,_ecfeg ._cfag .Bottom ;};func _adgb ()*Division {return &Division {_bdbcd :[]VectorDrawable {}}};

// GetMargins returns the left, right, top, bottom Margins.
func (_geafg *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _geafg ._ggad .Left ,_geafg ._ggad .Right ,_geafg ._ggad .Top ,_geafg ._ggad .Bottom ;};

// SetAngle sets Image rotation angle in degrees.
func (_faae *Image )SetAngle (angle float64 ){_faae ._efdb =angle };func (_cg *Block )addContentsByString (_abbf string )error {_eab :=_ag .NewContentStreamParser (_abbf );_eafg ,_dge :=_eab .Parse ();if _dge !=nil {return _dge ;};_cg ._bg .WrapIfNeeded ();
_eafg .WrapIfNeeded ();*_cg ._bg =append (*_cg ._bg ,*_eafg ...);return nil ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_bfad *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _bfad ._cfee ==nil {if _aacb :=_bfad .makeXObject ();_aacb !=nil {return nil ,ctx ,_aacb ;};};var _dee []*Block ;_bdfa :=ctx ;_bdfc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _bfad ._afdg .IsRelative (){ctx .X +=_bfad ._agfc .Left ;ctx .Y +=_bfad ._agfc .Top ;ctx .Width -=_bfad ._agfc .Left +_bfad ._agfc .Right ;ctx .Height -=_bfad ._agfc .Top +_bfad ._agfc .Bottom ;if _bfad ._fceb > ctx .Height {_dee =append (_dee ,_bdfc );
_bdfc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dddcda :=ctx ;_dddcda .Y =ctx .Margins .Top +_bfad ._agfc .Top ;_dddcda .X =ctx .Margins .Left +_bfad ._agfc .Left ;_dddcda .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_bfad ._agfc .Top -_bfad ._agfc .Bottom ;
_dddcda .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bfad ._agfc .Left -_bfad ._agfc .Right ;ctx =_dddcda ;_bdfa .X =ctx .Margins .Left ;_bdfa .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_bfad ._eccga ;
ctx .Y =_bfad ._gfdea ;};ctx ,_bfdc :=_gbfg (_bdfc ,_bfad ,ctx );if _bfdc !=nil {return nil ,ctx ,_bfdc ;};_dee =append (_dee ,_bdfc );if _bfad ._afdg .IsAbsolute (){ctx =_bdfa ;}else {ctx .X =_bdfa .X ;ctx .Y +=_bfad ._agfc .Bottom ;ctx .Width =_bdfa .Width ;
};return _dee ,ctx ,nil ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_bbe *Creator )SetPageSize (size PageSize ){_bbe ._beff =size ;_bbe ._ebdb =size [0];_bbe ._gbe =size [1];_agce :=0.1*_bbe ._ebdb ;_bbe ._cba .Left =_agce ;_bbe ._cba .Right =_agce ;_bbe ._cba .Top =_agce ;_bbe ._cba .Bottom =_agce ;};func (_ge *Block )addContents (_cf *_ag .ContentStreamOperations ){_ge ._bg .WrapIfNeeded ();
_cf .WrapIfNeeded ();*_ge ._bg =append (*_ge ._bg ,*_cf ...);};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_dadc *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edfa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eafbdc ,_ceabf :=_edfa .setOpacity (_dadc ._afbe ,_dadc ._dcba );if _ceabf !=nil {return nil ,ctx ,_ceabf ;
};_egggb :=_dadc ._bdgb ;_egggb .FillEnabled =_egggb .FillColor !=nil ;var (_dagf =ctx .PageHeight ;_ffec =_egggb .Curves ;_ffed =make ([]_dd .CubicBezierCurve ,0,len (_egggb .Curves )););for _fgge :=range _egggb .Curves {_dcfg :=_ffec [_fgge ];_dcfg .P0 .Y =_dagf -_dcfg .P0 .Y ;
_dcfg .P1 .Y =_dagf -_dcfg .P1 .Y ;_dcfg .P2 .Y =_dagf -_dcfg .P2 .Y ;_dcfg .P3 .Y =_dagf -_dcfg .P3 .Y ;_ffed =append (_ffed ,_dcfg );};_egggb .Curves =_ffed ;defer func (){_egggb .Curves =_ffec }();_fcdf ,_ ,_ceabf :=_egggb .Draw (_eafbdc );if _ceabf !=nil {return nil ,ctx ,_ceabf ;
};if _ceabf =_edfa .addContentsByString (string (_fcdf ));_ceabf !=nil {return nil ,ctx ,_ceabf ;};return []*Block {_edfa },ctx ,nil ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bedd *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _bedd ._ddf [0],_bedd ._ddf [1]};

// NewDivision returns a new Division container component.
func (_adf *Creator )NewDivision ()*Division {return _adgb ()};

// SetFillColor sets the fill color.
func (_acd *CurvePolygon )SetFillColor (color Color ){_acd ._edce .FillColor =_egf (color )};type rgbColor struct{_fgbb ,_ccfc ,_bgbb float64 };

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_cagf *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_cagf ._aaeb .Left =left ;_cagf ._aaeb .Right =right ;_cagf ._aaeb .Top =top ;_cagf ._aaeb .Bottom =bottom ;};

// SetIndent sets the cell's left indent.
func (_adbc *TableCell )SetIndent (indent float64 ){_adbc ._abdc =indent };

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_bdbcd []VectorDrawable ;_ffgb Positioning ;_dadg Margins ;_gadd bool ;};func _gccc (_bbaa string ,_efdc TextStyle )*Paragraph {_badg :=&Paragraph {_dcebg :_bbaa ,_ddcg :_efdc .Font ,_faagb :_efdc .FontSize ,_beee :1.0,_ecec :true ,_geab :true ,_gbaea :TextAlignmentLeft ,_bgbgc :0,_cegc :1,_agfec :1,_cfaa :PositionRelative };
_badg .SetColor (_efdc .Color );return _badg ;};

// IsRelative checks if the positioning is relative.
func (_fgdc Positioning )IsRelative ()bool {return _fgdc ==PositionRelative };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_cdbc *Image )SetEncoder (encoder _dg .StreamEncoder ){_cdbc ._bfeg =encoder };

// SetSideBorderColor sets the cell's side border color.
func (_edea *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_edea ._abaab =col ;case CellBorderSideBottom :_edea ._gfff =col ;case CellBorderSideLeft :_edea ._bccd =col ;case CellBorderSideRight :_edea ._acada =col ;
};};

// CurRow returns the currently active cell's row number.
func (_eecac *Table )CurRow ()int {_fadf :=(_eecac ._edcbf -1)/_eecac ._fcedd +1;return _fadf };

// SetFillColor sets the fill color.
func (_cbgb *Rectangle )SetFillColor (col Color ){_cbgb ._effba =col };

// NewTOC creates a new table of contents.
func (_gfde *Creator )NewTOC (title string )*TOC {_efae :=_gfde .NewTextStyle ();_efae .Font =_gfde ._baba ;return _bgebf (title ,_gfde .NewTextStyle (),_efae );};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_eacb *List )Add (item VectorDrawable )(*TextChunk ,error ){_eagfe :=&listItem {_gdfa :item ,_egda :_eacb ._gffd };switch _fceag :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _fceag ._gdfg {_fceag ._gfeg =15;};default:return nil ,_a .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_eacb ._caeb =append (_eacb ._caeb ,_eagfe );return &_eagfe ._egda ,nil ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_bfbf float64 ;_ddbbba float64 ;_abgcg float64 ;_fcfc float64 ;_effba Color ;_ccfe float64 ;_dabc Color ;_eaaeb float64 ;_bcff float64 ;};

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_dcbd *Ellipse )GetCoords ()(float64 ,float64 ){return _dcbd ._bega ,_dcbd ._egfe };

// SetStyleBottom sets border style for bottom side.
func (_gca *border )SetStyleBottom (style CellBorderStyle ){_gca ._bbc =style };

// Height returns the Block's height.
func (_bed *Block )Height ()float64 {return _bed ._bc };func _bgec (_bddba int )*Table {_abgca :=&Table {_fcedd :_bddba ,_efgfd :10.0,_fbba :[]float64 {},_fdef :[]float64 {},_bdad :[]*TableCell {}};_abgca .resetColumnWidths ();return _abgca ;};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_afcb *Image )SetMargins (left ,right ,top ,bottom float64 ){_afcb ._agfc .Left =left ;_afcb ._agfc .Right =right ;_afcb ._agfc .Top =top ;_afcb ._agfc .Bottom =bottom ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bdac *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acbb :=ctx ;_febde ,ctx ,_gadee :=_bdac ._gdbea .GeneratePageBlocks (ctx );if _gadee !=nil {return _febde ,ctx ,_gadee ;};if _bdac ._dfbd .IsRelative (){ctx .X =_acbb .X ;
};if _bdac ._dfbd .IsAbsolute (){return _febde ,_acbb ,nil ;};return _febde ,ctx ,nil ;};func _gbedg (_aaebd ,_cgebe TextStyle )*Invoice {_gccg :=&Invoice {_dbad :"\u0049N\u0056\u004f\u0049\u0043\u0045",_cbcb :"\u002c\u0020",_daaf :_aaebd ,_aeab :_cgebe };
_gccg ._gbcd =&InvoiceAddress {Separator :_gccg ._cbcb };_gccg ._egca =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_gccg ._cbcb };_gedbg :=ColorRGBFrom8bit (245,245,245);_ebbfg :=ColorRGBFrom8bit (155,155,155);_gccg ._acdb =_cgebe ;
_gccg ._acdb .Color =_ebbfg ;_gccg ._acdb .FontSize =20;_gccg ._dfbe =_aaebd ;_gccg ._bbgg =_cgebe ;_gccg ._fgbcg =_aaebd ;_gccg ._bcdde =_cgebe ;_gccg ._fdag =_gccg .NewCellProps ();_gccg ._fdag .BackgroundColor =_gedbg ;_gccg ._fdag .TextStyle =_cgebe ;
_gccg ._bge =_gccg .NewCellProps ();_gccg ._bge .TextStyle =_cgebe ;_gccg ._bge .BackgroundColor =_gedbg ;_gccg ._bge .BorderColor =_gedbg ;_gccg ._ddfe =_gccg .NewCellProps ();_gccg ._ddfe .BorderColor =_gedbg ;_gccg ._ddfe .BorderSides =[]CellBorderSide {CellBorderSideBottom };
_gccg ._ddfe .Alignment =CellHorizontalAlignmentRight ;_gccg ._dbb =_gccg .NewCellProps ();_gccg ._dbb .Alignment =CellHorizontalAlignmentRight ;_gccg ._abga =[2]*InvoiceCell {_gccg .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_gccg ._fdag ),_gccg .newCell ("",_gccg ._fdag )};
_gccg ._ddgfe =[2]*InvoiceCell {_gccg .newCell ("\u0044\u0061\u0074\u0065",_gccg ._fdag ),_gccg .newCell ("",_gccg ._fdag )};_gccg ._ddf =[2]*InvoiceCell {_gccg .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_gccg ._fdag ),_gccg .newCell ("",_gccg ._fdag )};
_gccg ._aefb =[2]*InvoiceCell {_gccg .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_gccg ._dbb ),_gccg .newCell ("",_gccg ._dbb )};_aee :=_gccg ._dbb ;_aee .TextStyle =_cgebe ;_aee .BackgroundColor =_gedbg ;_aee .BorderColor =_gedbg ;_gccg ._edgd =[2]*InvoiceCell {_gccg .newCell ("\u0054\u006f\u0074a\u006c",_aee ),_gccg .newCell ("",_aee )};
_gccg ._aag =[2]string {"\u004e\u006f\u0074e\u0073",""};_gccg ._bbce =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};_gccg ._dcbb =[]*InvoiceCell {_gccg .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_gccg .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_gccg .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_gccg .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _gccg ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SetTotal sets the total of the invoice.
func (_fgec *Invoice )SetTotal (value string ){_fgec ._edgd [1].Value =value };

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetBorderWidth sets the border width.
func (_begeb *Polygon )SetBorderWidth (borderWidth float64 ){_begeb ._degac .BorderWidth =borderWidth };

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_bdbcc *Invoice )NoteStyle ()TextStyle {return _bdbcc ._fgbcg };func (_dfag *Invoice )setCellBorder (_ebcd *TableCell ,_dedc *InvoiceCell ){for _ ,_bfdcd :=range _dedc .BorderSides {_ebcd .SetBorder (_bfdcd ,CellBorderStyleSingle ,_dedc .BorderWidth );
};_ebcd .SetBorderColor (_dedc .BorderColor );};

// Width returns the width of the Paragraph.
func (_ebdfc *StyledParagraph )Width ()float64 {if _ebdfc ._ccbc &&int (_ebdfc ._bbgd )> 0{return _ebdfc ._bbgd ;};return _ebdfc .getTextWidth ()/1000.0;};

// NewTable create a new Table with a specified number of columns.
func (_gfe *Creator )NewTable (cols int )*Table {return _bgec (cols )};

// SkipCells skips over a specified number of cells in the table.
func (_abcc *Table )SkipCells (num int ){if num < 0{_be .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_abcc ._edcbf +=num ;};func _fagc (_cdeb []_dd .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_bdgb :&_dd .PolyBezierCurve {Curves :_cdeb ,BorderColor :_cbf .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_afbe :1.0,_dcba :1.0};
};

// IsAbsolute checks if the positioning is absolute.
func (_ffbb Positioning )IsAbsolute ()bool {return _ffbb ==PositionAbsolute };func (_gbgda *TOCLine )prepareParagraph (_bgab *StyledParagraph ,_dgeab DrawContext ){_fccd :=_gbgda .Title .Text ;if _gbgda .Number .Text !=""{_fccd ="\u0020"+_fccd ;};_fccd +="\u0020";
_bfde :=_gbgda .Page .Text ;if _bfde !=""{_bfde ="\u0020"+_bfde ;};_bgab ._aaca =[]*TextChunk {{Text :_gbgda .Number .Text ,Style :_gbgda .Number .Style ,_bfaf :_gbgda .getLineLink ()},{Text :_fccd ,Style :_gbgda .Title .Style ,_bfaf :_gbgda .getLineLink ()},{Text :_bfde ,Style :_gbgda .Page .Style ,_bfaf :_gbgda .getLineLink ()}};
_bgab .wrapText ();_bgede :=len (_bgab ._dgfag );if _bgede ==0{return ;};_bcaad :=_dgeab .Width *1000-_bgab .getTextLineWidth (_bgab ._dgfag [_bgede -1]);_dcfgf :=_bgab .getTextLineWidth ([]*TextChunk {&_gbgda .Separator });_dbae :=int (_bcaad /_dcfgf );
_ecbd :=_fa .Repeat (_gbgda .Separator .Text ,_dbae );_cdbfd :=_gbgda .Separator .Style ;_aabe :=_bgab .Insert (2,_ecbd );_aabe .Style =_cdbfd ;_aabe ._bfaf =_gbgda .getLineLink ();_bcaad =_bcaad -float64 (_dbae )*_dcfgf ;if _bcaad > 500{_ggdb ,_gdee :=_cdbfd .Font .GetRuneMetrics (' ');
if _gdee &&_bcaad > _ggdb .Wx {_gbad :=int (_bcaad /_ggdb .Wx );if _gbad > 0{_fdabd :=_cdbfd ;_fdabd .FontSize =1;_aabe =_bgab .Insert (2,_fa .Repeat ("\u0020",_gbad ));_aabe .Style =_fdabd ;_aabe ._bfaf =_gbgda .getLineLink ();};};};};func (_gceac *StyledParagraph )getTextHeight ()float64 {var _dage float64 ;
for _ ,_dbdc :=range _gceac ._aaca {_bbbb :=_dbdc .Style .FontSize *_gceac ._gdac ;if _bbbb > _dage {_dage =_bbbb ;};};return _dage ;};

// SetBorderColor sets the border color.
func (_ddbbb *PolyBezierCurve )SetBorderColor (color Color ){_ddbbb ._bdgb .BorderColor =_egf (color )};

// RotatedSize returns the width and height of the rotated block.
func (_ac *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_gf ,_ad :=_agdgd (_ac ._eaf ,_ac ._bc ,_ac ._ef );return _gf ,_ad ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_afedc *TOC )SetShowLinks (showLinks bool ){_afedc ._gggc =showLinks };

// Add adds a new line with the default style to the table of contents.
func (_ebga *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_bdga :=_ebga .AddLine (_dbfc (TextChunk {Text :number ,Style :_ebga ._dbbg },TextChunk {Text :title ,Style :_ebga ._abca },TextChunk {Text :page ,Style :_ebga ._cfebf },level ,_ebga ._gceaa ));
if _bdga ==nil {return nil ;};_fbec :=&_ebga ._decbc ;_bdga .SetMargins (_fbec .Left ,_fbec .Right ,_fbec .Top ,_fbec .Bottom );_bdga .SetLevelOffset (_ebga ._gfga );_bdga .Separator .Text =_ebga ._bdadg ;_bdga .Separator .Style =_ebga ._dgdc ;return _bdga ;
};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_dcebg string ;_ddcg *_cbf .PdfFont ;_faagb float64 ;_beee float64 ;_bgcg Color ;_gbaea TextAlignment ;_ecec bool ;_ccca float64 ;_cbee int ;_geab bool ;_bgbgc float64 ;_egdf Margins ;_cfaa Positioning ;_degg float64 ;_abbfb float64 ;
_cegc ,_agfec float64 ;_cadfd []string ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ddeg *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acaeb :=ctx ;_agad ,ctx ,_aegc :=_ddeg ._adfg .GeneratePageBlocks (ctx );if _aegc !=nil {return _agad ,ctx ,_aegc ;};for _ ,_edcaa :=range _ddeg ._fdba {_ccdg :=_edcaa ._fgfa ;
if !_ddeg ._gggc {_edcaa ._fgfa =0;};_bcgf ,_cacd ,_egef :=_edcaa .GeneratePageBlocks (ctx );_edcaa ._fgfa =_ccdg ;if _egef !=nil {return _agad ,ctx ,_egef ;};if len (_bcgf )< 1{continue ;};_agad [len (_agad )-1].mergeBlocks (_bcgf [0]);_agad =append (_agad ,_bcgf [1:]...);
ctx =_cacd ;};if _ddeg ._fedfg .IsRelative (){ctx .X =_acaeb .X ;};if _ddeg ._fedfg .IsAbsolute (){return _agad ,_acaeb ,nil ;};return _agad ,ctx ,nil ;};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_gae *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egad :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ccea ,_add :=_egad .setOpacity (_gae ._ccgee ,_gae ._fgcae );if _add !=nil {return nil ,ctx ,_add ;};_efbc :=_gae ._edce ;
_efbc .FillEnabled =_efbc .FillColor !=nil ;_efbc .BorderEnabled =_efbc .BorderColor !=nil &&_efbc .BorderWidth > 0;var (_cfgg =ctx .PageHeight ;_bbfg =_efbc .Rings ;_def =make ([][]_dd .CubicBezierCurve ,0,len (_efbc .Rings )););for _ ,_gfac :=range _bbfg {_egade :=make ([]_dd .CubicBezierCurve ,0,len (_gfac ));
for _ ,_dgf :=range _gfac {_bgdeg :=_dgf ;_bgdeg .P0 .Y =_cfgg -_bgdeg .P0 .Y ;_bgdeg .P1 .Y =_cfgg -_bgdeg .P1 .Y ;_bgdeg .P2 .Y =_cfgg -_bgdeg .P2 .Y ;_bgdeg .P3 .Y =_cfgg -_bgdeg .P3 .Y ;_egade =append (_egade ,_bgdeg );};_def =append (_def ,_egade );
};_efbc .Rings =_def ;defer func (){_efbc .Rings =_bbfg }();_aeaa ,_ ,_add :=_efbc .Draw (_ccea );if _add !=nil {return nil ,ctx ,_add ;};if _add =_egad .addContentsByString (string (_aeaa ));_add !=nil {return nil ,ctx ,_add ;};return []*Block {_egad },ctx ,nil ;
};

// Width returns the cell's width based on the input draw context.
func (_bdagb *TableCell )Width (ctx DrawContext )float64 {_cceda :=float64 (0.0);for _acgd :=0;_acgd < _bdagb ._adcec ;_acgd ++{_cceda +=_bdagb ._faded ._fbba [_bdagb ._cada +_acgd -1];};_afdb :=ctx .Width *_cceda ;return _afdb ;};func _gdd (_efff ,_cag *_cbf .PdfPageResources )error {_bee ,_ :=_efff .GetColorspaces ();
if _bee !=nil &&len (_bee .Colorspaces )> 0{for _ece ,_gef :=range _bee .Colorspaces {_aaec :=*_dg .MakeName (_ece );if _cag .HasColorspaceByName (_aaec ){continue ;};_bfe :=_cag .SetColorspaceByName (_aaec ,_gef );if _bfe !=nil {return _bfe ;};};};return nil ;
};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_cdbaa *Creator )NewTextStyle ()TextStyle {return _edca (_cdbaa ._bfa )};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_abcb *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_caac :=&_abcb ._gdbea ._cfag ;return _abcb ._ggde ,_caac .Right ,_caac .Top ,_caac .Bottom ;};

// NewInvoice returns an instance of an empty invoice.
func (_eebb *Creator )NewInvoice ()*Invoice {_dbfeg :=_eebb .NewTextStyle ();_dbfeg .Font =_eebb ._baba ;return _gbedg (_eebb .NewTextStyle (),_dbfeg );};

// SetWidthTop sets border width for top.
func (_gbd *border )SetWidthTop (bw float64 ){_gbd ._bcdg =bw };

// GeneratePageBlocks draws the curve onto page blocks.
func (_ceaa *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eceb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_agdd :=_ag .NewContentCreator ();_agdd .Add_q ().Add_w (_ceaa ._fcga ).SetStrokingColor (_egf (_ceaa ._eadb )).Add_m (_ceaa ._bcdca ,ctx .PageHeight -_ceaa ._edeb ).Add_v (_ceaa ._gacd ,ctx .PageHeight -_ceaa ._cfbb ,_ceaa ._eccg ,ctx .PageHeight -_ceaa ._gbed ).Add_S ().Add_Q ();
_befe :=_eceb .addContentsByString (_agdd .String ());if _befe !=nil {return nil ,ctx ,_befe ;};return []*Block {_eceb },ctx ,nil ;};func (_fcea *InvoiceAddress )fmtLine (_aafe ,_aegf string ,_ebdf bool )string {if _ebdf {_aegf ="";};return _da .Sprintf ("\u0025\u0073\u0025s\u000a",_aegf ,_aafe );
};

// NewPolyline creates a new polyline.
func (_cef *Creator )NewPolyline (points []_dd .Point )*Polyline {return _ecgb (points )};

// SetBorderOpacity sets the border opacity.
func (_bdgbe *Rectangle )SetBorderOpacity (opacity float64 ){_bdgbe ._bcff =opacity };

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_bagb *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _bagb ._dceb ,_bagb ._edfge ,_bagb ._cffa ,_bagb ._gddf ;};func (_dfcg *Paragraph )getMaxLineWidth ()float64 {if _dfcg ._cadfd ==nil ||len (_dfcg ._cadfd )==0{_dfcg .wrapText ();
};var _fggg float64 ;for _ ,_gdfd :=range _dfcg ._cadfd {_gdad :=_dfcg .getTextLineWidth (_gdfd );if _gdad > _fggg {_fggg =_gdad ;};};return _fggg ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_dabb *TOC )SetLineStyle (style TextStyle ){_dabb .SetLineNumberStyle (style );_dabb .SetLineTitleStyle (style );_dabb .SetLineSeparatorStyle (style );_dabb .SetLinePageStyle (style );};

// Height returns Image's document height.
func (_efde *Image )Height ()float64 {return _efde ._fceb };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_accf *Creator )Draw (d Drawable )error {if _accf .getActivePage ()==nil {_accf .NewPage ();};_ffg ,_bgba ,_bcg :=d .GeneratePageBlocks (_accf ._dfd );if _bcg !=nil {return _bcg ;};for _dda ,_dfcc :=range _ffg {if _dda > 0{_accf .NewPage ();};_fgcf :=_accf .getActivePage ();
if _cfge ,_gfag :=_accf ._cbb [_fgcf ];_gfag {if _bdef :=_cfge .mergeBlocks (_dfcc );_bdef !=nil {return _bdef ;};if _fbab :=_gdd (_dfcc ._de ,_cfge ._de );_fbab !=nil {return _fbab ;};}else {_accf ._cbb [_fgcf ]=_dfcc ;};};_accf ._dfd .X =_bgba .X ;_accf ._dfd .Y =_bgba .Y ;
_accf ._dfd .Height =_bgba .PageHeight -_bgba .Y -_bgba .Margins .Bottom ;return nil ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_abgaa *List )Width ()float64 {return 0};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_gg *Block )duplicate ()*Block {_fc :=&Block {};*_fc =*_gg ;_db :=_ag .ContentStreamOperations {};_db =append (_db ,*_gg ._bg ...);_fc ._bg =&_db ;return _fc ;};

// EnableRowWrap enables/disables row wrapping across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_gbcde *Table )EnableRowWrap (enable bool ){_gbcde ._cbgdd =enable };

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;func (_addb *Division )ctxHeight (_gbg float64 )float64 {var _geef float64 ;for _ ,_adcc :=range _addb ._bdbcd {switch _bcf :=_adcc .(type ){case *Paragraph :if _bcf ._ecec {_bcf .SetWidth (_gbg );};_geef +=_bcf .Height ()+_bcf ._egdf .Top +_bcf ._egdf .Bottom ;
case *StyledParagraph :if _bcf ._ccbc {_bcf .SetWidth (_gbg );};_geef +=_bcf .Height ()+_bcf ._cfag .Top +_bcf ._cfag .Bottom ;default:_geef +=_bcf .Height ();};};return _geef ;};func (_ebbc cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_aea :=_ebbc ._bgd ;
return 1-(_ebbc ._fdf *(1-_aea )+_aea ),1-(_ebbc ._aaf *(1-_aea )+_aea ),1-(_ebbc ._fbdd *(1-_aea )+_aea );};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_adcbc *Creator )RotateDeg (angleDeg int64 )error {_adad :=_adcbc .getActivePage ();if _adad ==nil {_be .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _a .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_be .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _fdb int64 ;if _adad .Rotate !=nil {_fdb =*(_adad .Rotate );};_fdb +=angleDeg ;_adad .Rotate =&_fdb ;return nil ;};func (_aedg *Invoice )drawAddress (_bcgc *InvoiceAddress )[]*StyledParagraph {var _eadf []*StyledParagraph ;
if _bcgc .Heading !=""{_ebba :=_cggef (_aedg ._bbgg );_ebba .SetMargins (0,0,0,7);_ebba .Append (_bcgc .Heading );_eadf =append (_eadf ,_ebba );};_fcccb :=_cggef (_aedg ._dfbe );_fcccb .SetLineHeight (1.2);_egge :=_bcgc .Separator ;if _egge ==""{_egge =_aedg ._cbcb ;
};_fccad :=_bcgc .City ;if _bcgc .State !=""{if _fccad !=""{_fccad +=_egge ;};_fccad +=_bcgc .State ;};if _bcgc .Zip !=""{if _fccad !=""{_fccad +=_egge ;};_fccad +=_bcgc .Zip ;};if _bcgc .Name !=""{_fcccb .Append (_bcgc .Name +"\u000a");};if _bcgc .Street !=""{_fcccb .Append (_bcgc .Street +"\u000a");
};if _bcgc .Street2 !=""{_fcccb .Append (_bcgc .Street2 +"\u000a");};if _fccad !=""{_fcccb .Append (_fccad +"\u000a");};if _bcgc .Country !=""{_fcccb .Append (_bcgc .Country +"\u000a");};_cfca :=_cggef (_aedg ._dfbe );_cfca .SetLineHeight (1.2);_cfca .SetMargins (0,0,7,0);
if _bcgc .Phone !=""{_cfca .Append (_bcgc .fmtLine (_bcgc .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_bcgc .HidePhoneLabel ));};if _bcgc .Email !=""{_cfca .Append (_bcgc .fmtLine (_bcgc .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_bcgc .HideEmailLabel ));
};_eadf =append (_eadf ,_fcccb ,_cfca );return _eadf ;};func (_gcea *Invoice )generateLineBlocks (_gfagf DrawContext )([]*Block ,DrawContext ,error ){_ggcb :=_bgec (len (_gcea ._dcbb ));_ggcb .SetMargins (0,0,25,0);for _ ,_dbcf :=range _gcea ._dcbb {_dfeab :=_cggef (_dbcf .TextStyle );
_dfeab .SetMargins (0,0,1,0);_dfeab .Append (_dbcf .Value );_aebb :=_ggcb .NewCell ();_aebb .SetHorizontalAlignment (_dbcf .Alignment );_aebb .SetBackgroundColor (_dbcf .BackgroundColor );_gcea .setCellBorder (_aebb ,_dbcf );_aebb .SetContent (_dfeab );
};for _ ,_gcaa :=range _gcea ._feec {for _ ,_dggf :=range _gcaa {_fbbdg :=_cggef (_dggf .TextStyle );_fbbdg .SetMargins (0,0,3,2);_fbbdg .Append (_dggf .Value );_cecc :=_ggcb .NewCell ();_cecc .SetHorizontalAlignment (_dggf .Alignment );_cecc .SetBackgroundColor (_dggf .BackgroundColor );
_gcea .setCellBorder (_cecc ,_dggf );_cecc .SetContent (_fbbdg );};};return _ggcb .GeneratePageBlocks (_gfagf );};func (_ccbd *StyledParagraph )appendChunk (_fbfg *TextChunk )*TextChunk {_ccbd ._aaca =append (_ccbd ._aaca ,_fbfg );_ccbd .wrapText ();return _fbfg ;
};

// TextAlignment options for paragraph.
type TextAlignment int ;func (_bged *Invoice )generateInformationBlocks (_dag DrawContext )([]*Block ,DrawContext ,error ){_ffda :=_cggef (_bged ._daaf );_ffda .SetMargins (0,0,0,20);_gfcb :=_bged .drawAddress (_bged ._gbcd );_gfcb =append (_gfcb ,_ffda );
_gfcb =append (_gfcb ,_bged .drawAddress (_bged ._egca )...);_defd :=_adgb ();for _ ,_gdff :=range _gfcb {_defd .Add (_gdff );};_gagd :=_bged .drawInformation ();_acf :=_bgec (2);_acf .SetMargins (0,0,25,0);_cfdc :=_acf .NewCell ();_cfdc .SetIndent (0);
_cfdc .SetContent (_defd );_cfdc =_acf .NewCell ();_cfdc .SetContent (_gagd );return _acf .GeneratePageBlocks (_dag );};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_fgg *Creator )AddPage (page *_cbf .PdfPage )error {_gdbd ,_effb :=page .GetMediaBox ();if _effb !=nil {_be .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_effb );
return _effb ;};_gdbd .Normalize ();_edfgb ,_abef :=_gdbd .Llx ,_gdbd .Lly ;_gdf :=_eb .IdentityMatrix ();_adcb :=page .Rotate ;_ddgf :=_adcb !=nil &&*_adcb %360!=0&&*_adcb %90==0;if _ddgf {_fggc :=float64 ((360+*page .Rotate %360)%360);if _fggc ==90{_gdf =_gdf .Translate (_gdbd .Width (),0);
}else if _fggc ==180{_gdf =_gdf .Translate (_gdbd .Width (),_gdbd .Height ());}else if _fggc ==270{_gdf =_gdf .Translate (0,_gdbd .Height ());};_gdf =_gdf .Mult (_eb .RotationMatrix (_fggc *_ga .Pi /180));_gdf =_gdf .Round (0.000001);_bbaf :=_fdbg (_gdbd ,_gdf );
_gdbd =_bbaf ;_gdbd .Normalize ();};if _edfgb !=0||_abef !=0{_gdf =_eb .TranslationMatrix (_edfgb ,_abef ).Mult (_gdf );};if !_gdf .Identity (){if _fgg ._ade ==nil {_fgg ._ade =map[*_cbf .PdfPage ]_eb .Matrix {};};_gdf =_gdf .Round (0.000001);_fgg ._ade [page ]=_gdf ;
};_fgg ._ebdb =_gdbd .Width ();_fgg ._gbe =_gdbd .Height ();_fgg .initContext ();_fgg ._fagg =append (_fgg ._fagg ,page );_fgg ._dfd .Page ++;return nil ;};

// Columns returns all the columns in the invoice line items table.
func (_cgea *Invoice )Columns ()[]*InvoiceCell {return _cgea ._dcbb };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cdde *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _aeabb float64 ;var _aggfd []*StyledParagraph ;for _ ,_bgeda :=range _cdde ._caeb {_fgda :=_cggef (_cdde ._gbgb );_fgda .SetEnableWrap (false );_fgda .SetTextAlignment (TextAlignmentRight );
_fgda .Append (_bgeda ._egda .Text ).Style =_bgeda ._egda .Style ;_ffdf :=_fgda .getTextWidth ()/1000.0/ctx .Width ;if _aeabb < _ffdf {_aeabb =_ffdf ;};_aggfd =append (_aggfd ,_fgda );};_caecd :=_bgec (2);_caecd .SetColumnWidths (_aeabb ,1-_aeabb );_caecd .SetMargins (_cdde ._gfeg ,0,0,0);
for _bbced ,_ddfeb :=range _cdde ._caeb {_ebfbb :=_caecd .NewCell ();_ebfbb .SetIndent (0);_ebfbb .SetContent (_aggfd [_bbced ]);_ebfbb =_caecd .NewCell ();_ebfbb .SetIndent (0);_ebfbb .SetContent (_ddfeb ._gdfa );};return _caecd .GeneratePageBlocks (ctx );
};func (_cgeab *Table )resetColumnWidths (){_cgeab ._fbba =[]float64 {};_aagdf :=float64 (1.0)/float64 (_cgeab ._fcedd );for _dcea :=0;_dcea < _cgeab ._fcedd ;_dcea ++{_cgeab ._fbba =append (_cgeab ._fbba ,_aagdf );};};const (PositionRelative Positioning =iota ;
PositionAbsolute ;);

// NewPolygon creates a new polygon.
func (_dbce *Creator )NewPolygon (points [][]_dd .Point )*Polygon {return _eeeec (points )};func (_eabf *Block )drawToPage (_cgdf *_cbf .PdfPage )error {_efb :=&_ag .ContentStreamOperations {};if _cgdf .Resources ==nil {_cgdf .Resources =_cbf .NewPdfPageResources ();
};_egc :=_ddg (_efb ,_cgdf .Resources ,_eabf ._bg ,_eabf ._de );if _egc !=nil {return _egc ;};if _egc =_gdd (_eabf ._de ,_cgdf .Resources );_egc !=nil {return _egc ;};if _egc =_cgdf .AppendContentBytes (_efb .Bytes (),true );_egc !=nil {return _egc ;};
for _ ,_beb :=range _eabf ._bd {_cgdf .AddAnnotation (_beb );};return nil ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_aaca []*TextChunk ;_gcbb TextStyle ;_bbfd TextStyle ;_gdbf TextAlignment ;_cgdbe TextVerticalAlignment ;_gdac float64 ;_ccbc bool ;_bbgd float64 ;_ebbge bool ;_gaec TextOverflow ;_bdcf float64 ;_cfag Margins ;_dbba Positioning ;
_cceb float64 ;_befd float64 ;_ffea float64 ;_eeef float64 ;_dgfag [][]*TextChunk ;_bbed func (_gcbd *StyledParagraph ,_aegd DrawContext );};

// Level returns the indentation level of the TOC line.
func (_dcgb *TOCLine )Level ()uint {return _dcgb ._fcgd };func _fggcc ()*FilledCurve {_cgfg :=FilledCurve {};_cgfg ._gacg =[]_dd .CubicBezierCurve {};return &_cgfg ;};func _ecgb (_feed []_dd .Point )*Polyline {return &Polyline {_debe :&_dd .Polyline {Points :_feed ,LineColor :_cbf .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_cbeec :1.0};
};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_ebgb *Chapter )SetShowNumbering (show bool ){_ebgb ._cgbd =show ;_ebgb ._baac .SetText (_ebgb .headingText ());};

// NewChapter creates a new chapter with the specified title as the heading.
func (_fad *Creator )NewChapter (title string )*Chapter {_fad ._dacd ++;_gda :=_fad .NewTextStyle ();_gda .FontSize =16;return _beg (nil ,_fad ._edef ,_fad ._gcf ,title ,_fad ._dacd ,_gda );};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cegf *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_adgf :=[2]*InvoiceCell {_cegf .newCell (description ,_cegf ._fdag ),_cegf .newCell (value ,_cegf ._fdag )};_cegf ._edcb =append (_cegf ._edcb ,_adgf );return _adgf [0],_adgf [1];
};

// SetBorderColor sets the border color.
func (_acfe *Polygon )SetBorderColor (color Color ){_acfe ._degac .BorderColor =_egf (color )};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_ffgab *StyledParagraph )Height ()float64 {_ffgab .wrapText ();var _bdaf float64 ;for _ ,_cgeg :=range _ffgab ._dgfag {var _ageca float64 ;for _ ,_geabd :=range _cgeg {_bcge :=_ffgab ._gdac *_geabd .Style .FontSize ;if _bcge > _ageca {_ageca =_bcge ;
};};_bdaf +=_ageca ;};return _bdaf ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_bfeba *StyledParagraph )SetEnableWrap (enableWrap bool ){_bfeba ._ccbc =enableWrap ;_bfeba ._ebbge =false ;};

// Write output of creator to io.Writer interface.
func (_cdcdd *Creator )Write (ws _g .Writer )error {if _bgce :=_cdcdd .Finalize ();_bgce !=nil {return _bgce ;};_eeeb :=_cbf .NewPdfWriter ();_eeeb .SetOptimizer (_cdcdd ._efeb );if _cdcdd ._gfge !=nil {_dfeaa :=_eeeb .SetForms (_cdcdd ._gfge );if _dfeaa !=nil {_be .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_dfeaa );
return _dfeaa ;};};if _cdcdd ._cdf !=nil {_eeeb .AddOutlineTree (_cdcdd ._cdf );}else if _cdcdd ._gcf !=nil &&_cdcdd .AddOutlines {_eeeb .AddOutlineTree (&_cdcdd ._gcf .ToPdfOutline ().PdfOutlineTreeNode );};if _cdcdd ._cce !=nil {if _agcd :=_eeeb .SetPageLabels (_cdcdd ._cce );
_agcd !=nil {_be .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_agcd );return _agcd ;};};if _cdcdd ._cgde !=nil {for _ ,_efd :=range _cdcdd ._cgde {_afdd :=_efd .SubsetRegistered ();
if _afdd !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_afdd );return _afdd ;};};};if _cdcdd ._ccfa !=nil {_eef :=_cdcdd ._ccfa (&_eeeb );
if _eef !=nil {_be .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_eef );return _eef ;};};for _ ,_cgdc :=range _cdcdd ._fagg {_ecad :=_eeeb .AddPage (_cgdc );if _ecad !=nil {_be .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_ecad );
return _ecad ;};};_dbfec :=_eeeb .Write (ws );if _dbfec !=nil {return _dbfec ;};return nil ;};func (_eae rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _eae ._fgbb ,_eae ._ccfc ,_eae ._bgbb };

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_gade *TableCell )SetBorderLineStyle (style _dd .LineStyle ){_gade ._becd =style };

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_eccf *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_eccf ._edef =toc ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_cgee *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_bgbg :=uint (len (_cgee ._dcbb ));if index > _bgbg {index =_bgbg ;};_adda :=_cgee .NewColumn (description );_cgee ._dcbb =append (_cgee ._dcbb [:index ],append ([]*InvoiceCell {_adda },_cgee ._dcbb [index :]...)...);
return _adda ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_bec *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_efbb :=&InvoiceCell {_bec ._dbb ,desc };_bfec :=&InvoiceCell {_bec ._dbb ,value };_bec ._gdgd =append (_bec ._gdgd ,[2]*InvoiceCell {_efbb ,_bfec });return _efbb ,_bfec ;
};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// Length calculates and returns the line length.
func (_dfce *Line )Length ()float64 {return _ga .Sqrt (_ga .Pow (_dfce ._cffa -_dfce ._dceb ,2.0)+_ga .Pow (_dfce ._gddf -_dfce ._edfge ,2.0));};func (_gfacd *Invoice )generateNoteBlocks (_cgged DrawContext )([]*Block ,DrawContext ,error ){_cffg :=_adgb ();
_cecd :=append ([][2]string {_gfacd ._aag ,_gfacd ._bbce },_gfacd ._fcgb ...);for _ ,_efgf :=range _cecd {if _efgf [1]!=""{_eafb :=_gfacd .drawSection (_efgf [0],_efgf [1]);for _ ,_cadcg :=range _eafb {_cffg .Add (_cadcg );};_egace :=_cggef (_gfacd ._daaf );
_egace .SetMargins (0,0,10,0);_cffg .Add (_egace );};};return _cffg .GeneratePageBlocks (_cgged );};func (_ddfde *Table )wrapRow (_cdda int ,_aeda DrawContext ,_dedee float64 )(bool ,error ){if !_ddfde ._cbgdd {return false ,nil ;};var (_cedg =_ddfde ._bdad [_cdda ];
_acddd =-1;_caegb []*TableCell ;_bbee float64 ;_bfea bool ;_eade =make ([]float64 ,0,len (_ddfde ._fbba )););_abbgc :=func (_gdggd *TableCell ,_aaab VectorDrawable ,_bcba bool )*TableCell {_baaaa :=*_gdggd ;_baaaa ._fadgf =_aaab ;if _bcba {_baaaa ._gfcae ++;
};return &_baaaa ;};_agee :=func (_cecda int ,_ddca VectorDrawable ){var _bgeb float64 =-1;if _ddca ==nil {if _fgac :=_eade [_cecda -_cdda ];_fgac > _aeda .Height {_ddca =_ddfde ._bdad [_cecda ]._fadgf ;_ddfde ._bdad [_cecda ]._fadgf =nil ;_eade [_cecda -_cdda ]=0;
_bgeb =_fgac ;};};_eagdc :=_abbgc (_ddfde ._bdad [_cecda ],_ddca ,true );_caegb =append (_caegb ,_eagdc );if _bgeb < 0{_bgeb =_eagdc .height (_aeda .Width );};if _bgeb > _bbee {_bbee =_bgeb ;};};for _bgcbf :=_cdda ;_bgcbf < len (_ddfde ._bdad );_bgcbf ++{_edfgbf :=_ddfde ._bdad [_bgcbf ];
if _cedg ._gfcae !=_edfgbf ._gfcae {_acddd =_bgcbf ;break ;};_aeda .Width =_edfgbf .width (_ddfde ._fbba ,_dedee );var _gecf VectorDrawable ;switch _abaa :=_edfgbf ._fadgf .(type ){case *StyledParagraph :if _gcabe :=_edfgbf .height (_aeda .Width );_gcabe > _aeda .Height {_edeg :=_aeda ;
_edeg .Height =_ga .Floor (_aeda .Height -_abaa ._cfag .Top -_abaa ._cfag .Bottom -0.5*_abaa .getTextHeight ());_bgf ,_gdbab ,_gfba :=_abaa .split (_edeg );if _gfba !=nil {return false ,_gfba ;};if _bgf !=nil &&_gdbab !=nil {_abaa =_bgf ;_edfgbf =_abbgc (_edfgbf ,_bgf ,false );
_ddfde ._bdad [_bgcbf ]=_edfgbf ;_gecf =_gdbab ;_bfea =true ;};};};_eade =append (_eade ,_edfgbf .height (_aeda .Width ));if _bfea {if _caegb ==nil {_caegb =make ([]*TableCell ,0,len (_ddfde ._fbba ));for _fabe :=_cdda ;_fabe < _bgcbf ;_fabe ++{_agee (_fabe ,nil );
};};_agee (_bgcbf ,_gecf );};};var _egded float64 ;for _ ,_dfff :=range _eade {if _dfff > _egded {_egded =_dfff ;};};if _bfea &&_egded < _aeda .Height {if _acddd < 0{_acddd =len (_ddfde ._bdad );};_deada :=_ddfde ._bdad [_acddd -1]._gfcae +_ddfde ._bdad [_acddd -1]._dfedf -1;
for _ecde :=_acddd ;_ecde < len (_ddfde ._bdad );_ecde ++{_ddfde ._bdad [_ecde ]._gfcae ++;};_ddfde ._bdad =append (_ddfde ._bdad [:_acddd ],append (_caegb ,_ddfde ._bdad [_acddd :]...)...);_ddfde ._fdef =append (_ddfde ._fdef [:_deada ],append ([]float64 {_bbee },_ddfde ._fdef [_deada :]...)...);
_ddfde ._fdef [_cedg ._gfcae +_cedg ._dfedf -2]=_egded ;};return _bfea ,nil ;};func _bdcg (_gcef *_cbf .PdfAnnotation )*_cbf .PdfAnnotation {if _gcef ==nil {return nil ;};var _ddff *_cbf .PdfAnnotation ;switch _gdcge :=_gcef .GetContext ().(type ){case *_cbf .PdfAnnotationLink :if _fedf :=_ddbd (_gdcge );
_fedf !=nil {_ddff =_fedf .PdfAnnotation ;};};return _ddff ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_ecee *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_cfea :=NewTextChunk (text ,_ecee ._bbfd );_cfea ._bfaf =_afee (url );return _ecee .appendChunk (_cfea );};func _ggca (_fecc *_cbf .Image )(*Image ,error ){_abdb :=float64 (_fecc .Width );
_dgbb :=float64 (_fecc .Height );return &Image {_aaad :_fecc ,_bafab :_abdb ,_effa :_dgbb ,_abfe :_abdb ,_fceb :_dgbb ,_efdb :0,_bcdb :1.0,_afdg :PositionRelative },nil ;};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// SetRowHeight sets the height for a specified row.
func (_aaef *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_aaef ._fdef ){return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aaef ._fdef [row -1]=h ;return nil ;
};

// Indent returns the left offset of the list when nested into another list.
func (_eeca *List )Indent ()float64 {return _eeca ._gfeg };func (_fdeg *StyledParagraph )split (_acbg DrawContext )(_fbbb ,_addf *StyledParagraph ,_efag error ){if _efag =_fdeg .wrapChunks (false );_efag !=nil {return nil ,nil ,_efag ;};_gacc :=func (_egag []*TextChunk ,_gbcg []*TextChunk )[]*TextChunk {if len (_gbcg )==0{return _egag ;
};_edge :=len (_egag );if _edge ==0{return append (_egag ,_gbcg ...);};_egag [_edge -1].Text +=_gbcg [0].Text ;return append (_egag ,_gbcg [1:]...);};_dgbd :=func (_agcg *StyledParagraph ,_dggfe []*TextChunk )*StyledParagraph {if len (_dggfe )==0{return nil ;
};_cedb :=*_agcg ;_cedb ._aaca =_dggfe ;return &_cedb ;};var (_aedf float64 ;_fdad []*TextChunk ;_abgd []*TextChunk ;);for _ ,_gffcg :=range _fdeg ._dgfag {var _faebd float64 ;_fffg :=make ([]*TextChunk ,0,len (_gffcg ));for _ ,_bcea :=range _gffcg {if _gabc :=_bcea .Style .FontSize ;
_gabc > _faebd {_faebd =_gabc ;};_fffg =append (_fffg ,_bcea .clone ());};_faebd *=_fdeg ._gdac ;if _fdeg ._dbba .IsRelative (){if _aedf +_faebd > _acbg .Height {_abgd =_gacc (_abgd ,_fffg );}else {_fdad =_gacc (_fdad ,_fffg );};};_aedf +=_faebd ;};_fdeg ._dgfag =nil ;
if len (_abgd )==0{return _fdeg ,nil ,nil ;};return _dgbd (_fdeg ,_fdad ),_dgbd (_fdeg ,_abgd ),nil ;};

// GetCoords returns coordinates of border.
func (_cge *border )GetCoords ()(float64 ,float64 ){return _cge ._fba ,_cge ._agd };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_fgfb int ;_ggb string ;_baac *Paragraph ;_gfgf []Drawable ;_fff int ;_cgbd bool ;_bafa bool ;_dad Positioning ;_gdg ,_fgfec float64 ;_aaeb Margins ;_aeg *Chapter ;_gbae *TOC ;_ccf *_cbf .Outline ;_eabc *_cbf .OutlineItem ;_eggc uint ;
};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_fdf :_ga .Max (_ga .Min (c ,1.0),0.0),_aaf :_ga .Max (_ga .Min (m ,1.0),0.0),_fbdd :_ga .Max (_ga .Min (y ,1.0),0.0),_bgd :_ga .Max (_ga .Min (k ,1.0),0.0)};};

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_ccfb *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_ccfb ._cgdbe =align ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_eegd *Invoice )Sections ()[][2]string {return _eegd ._fcgb };func (_fab *Image )rotatedSize ()(float64 ,float64 ){_dbgb :=_fab ._abfe ;_bfadf :=_fab ._fceb ;_fcab :=_fab ._efdb ;if _fcab ==0{return _dbgb ,_bfadf ;};_acge :=_dd .Path {Points :[]_dd .Point {_dd .NewPoint (0,0).Rotate (_fcab ),_dd .NewPoint (_dbgb ,0).Rotate (_fcab ),_dd .NewPoint (0,_bfadf ).Rotate (_fcab ),_dd .NewPoint (_dbgb ,_bfadf ).Rotate (_fcab )}}.GetBoundingBox ();
return _acge .Width ,_acge .Height ;};

// NewImageFromData creates an Image from image data.
func (_cbddd *Creator )NewImageFromData (data []byte )(*Image ,error ){return _fdbb (data )};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_abc *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_caa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_agedg :=_dd .Rectangle {Opacity :1.0,X :_abc ._bfbf ,Y :ctx .PageHeight -_abc ._ddbbba -_abc ._fcfc ,Height :_abc ._fcfc ,Width :_abc ._abgcg };
if _abc ._effba !=nil {_agedg .FillEnabled =true ;_agedg .FillColor =_egf (_abc ._effba );};if _abc ._dabc !=nil &&_abc ._eaaeb > 0{_agedg .BorderEnabled =true ;_agedg .BorderColor =_egf (_abc ._dabc );_agedg .BorderWidth =_abc ._eaaeb ;};_fccea ,_affe :=_caa .setOpacity (_abc ._ccfe ,_abc ._bcff );
if _affe !=nil {return nil ,ctx ,_affe ;};_afad ,_ ,_affe :=_agedg .Draw (_fccea );if _affe !=nil {return nil ,ctx ,_affe ;};if _affe =_caa .addContentsByString (string (_afad ));_affe !=nil {return nil ,ctx ,_affe ;};return []*Block {_caa },ctx ,nil ;
};

// SetBackgroundColor sets the cell's background color.
func (_egee *TableCell )SetBackgroundColor (col Color ){_egee ._eeec =col };

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_bdbc *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_daa :=_ag .NewContentCreator ();_bf ,_dfe :=_bdbc .Width (),_bdbc .Height ();if _bdbc ._gd .IsRelative (){_daa .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_dfe );
}else {_daa .Translate (_bdbc ._ed ,ctx .PageHeight -_bdbc ._ea -_dfe );};_aff :=_dfe ;if _bdbc ._ef !=0{_daa .Translate (_bf /2,_dfe /2);_daa .RotateDeg (_bdbc ._ef );_daa .Translate (-_bf /2,-_dfe /2);_ ,_aff =_bdbc .RotatedSize ();};if _bdbc ._gd .IsRelative (){ctx .Y +=_aff ;
};_abb :=_bdbc .duplicate ();_eg :=append (*_daa .Operations (),*_abb ._bg ...);_eg .WrapIfNeeded ();_abb ._bg =&_eg ;return []*Block {_abb },ctx ,nil ;};

// SetColorBottom sets border color for bottom.
func (_ffe *border )SetColorBottom (col Color ){_ffe ._deab =col };func _gafe (_bfbga int64 ,_ecaae ,_ccbag ,_fdcde float64 )*_cbf .PdfAnnotation {_fcbaf :=_cbf .NewPdfAnnotationLink ();_ggd :=_cbf .NewBorderStyle ();_ggd .SetBorderWidth (0);_fcbaf .BS =_ggd .ToPdfObject ();
if _bfbga < 0{_bfbga =0;};_fcbaf .Dest =_dg .MakeArray (_dg .MakeInteger (_bfbga ),_dg .MakeName ("\u0058\u0059\u005a"),_dg .MakeFloat (_ecaae ),_dg .MakeFloat (_ccbag ),_dg .MakeFloat (_fdcde ));return _fcbaf .PdfAnnotation ;};

// SetSellerAddress sets the seller address of the invoice.
func (_bfgc *Invoice )SetSellerAddress (address *InvoiceAddress ){_bfgc ._gbcd =address };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_fcd *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _dbfc (number ,title ,page ,level ,style );};func (_egbg *TableCell )width (_fddcg []float64 ,_fbee float64 )float64 {_cadb :=float64 (0.0);
for _gfcg :=0;_gfcg < _egbg ._adcec ;_gfcg ++{_cadb +=_fddcg [_egbg ._cada +_gfcg -1];};return _cadb *_fbee ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;func _bgebf (_aabd string ,_eagde ,_bdgf TextStyle )*TOC {_bfdd :=_bdgf ;_bfdd .FontSize =14;_adea :=_cggef (_bfdd );_adea .SetEnableWrap (true );_adea .SetTextAlignment (TextAlignmentLeft );_adea .SetMargins (0,0,0,5);_dbee :=_adea .Append (_aabd );
_dbee .Style =_bfdd ;return &TOC {_adfg :_adea ,_fdba :[]*TOCLine {},_dbbg :_eagde ,_abca :_eagde ,_dgdc :_eagde ,_cfebf :_eagde ,_bdadg :"\u002e",_gfga :10,_decbc :Margins {0,0,2,2},_fedfg :PositionRelative ,_gceaa :_eagde ,_gggc :true };};

// SetWidthRight sets border width for right.
func (_ebfb *border )SetWidthRight (bw float64 ){_ebfb ._fce =bw };var PPI float64 =72;

// Height returns the height of the list.
func (_gdcgca *List )Height ()float64 {var _gab float64 ;for _ ,_aggcc :=range _gdcgca ._caeb {_gab +=_aggcc ._gdfa .Height ();};return _gab ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_dgd *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _acdd []*Block ;_bcbg :=ctx ;if _dgd ._ffgb .IsRelative (){ctx .X +=_dgd ._dadg .Left ;ctx .Y +=_dgd ._dadg .Top ;ctx .Width -=_dgd ._dadg .Left +_dgd ._dadg .Right ;
ctx .Height -=_dgd ._dadg .Top +_dgd ._dadg .Bottom ;};ctx .Inline =_dgd ._gadd ;_affgg :=ctx ;_fcb :=ctx ;var _daddd float64 ;for _ ,_fbae :=range _dgd ._bdbcd {if ctx .Inline {if (ctx .X -_affgg .X )+_fbae .Width ()<=ctx .Width {ctx .Y =_fcb .Y ;ctx .Height =_fcb .Height ;
}else {ctx .X =_affgg .X ;ctx .Width =_affgg .Width ;_fcb .Y +=_daddd ;_fcb .Height -=_daddd ;_daddd =0;};};_gcba ,_gdfc ,_aded :=_fbae .GeneratePageBlocks (ctx );if _aded !=nil {_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_aded );
return nil ,ctx ,_aded ;};if len (_gcba )< 1{continue ;};if len (_acdd )> 0{_acdd [len (_acdd )-1].mergeBlocks (_gcba [0]);_acdd =append (_acdd ,_gcba [1:]...);}else {_acdd =append (_acdd ,_gcba [0:]...);};if ctx .Inline {if ctx .Page !=_gdfc .Page {_affgg .Y =ctx .Margins .Top ;
_affgg .Height =ctx .PageHeight -ctx .Margins .Top ;_fcb .Y =_affgg .Y ;_fcb .Height =_affgg .Height ;_daddd =_gdfc .Height -_affgg .Height ;}else {if _cfaef :=ctx .Height -_gdfc .Height ;_cfaef > _daddd {_daddd =_cfaef ;};};}else {_gdfc .X =ctx .X ;};
ctx =_gdfc ;};ctx .Inline =_bcbg .Inline ;if _dgd ._ffgb .IsRelative (){ctx .X =_bcbg .X ;};if _dgd ._ffgb .IsAbsolute (){return _acdd ,_bcbg ,nil ;};return _acdd ,ctx ,nil ;};

// SetFillOpacity sets the fill opacity.
func (_geae *Polygon )SetFillOpacity (opacity float64 ){_geae ._cccc =opacity };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_dgbg *Creator )SetForms (form *_cbf .PdfAcroForm )error {_dgbg ._gfge =form ;return nil };

// SetMargins sets the Paragraph's margins.
func (_acfb *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_acfb ._cfag .Left =left ;_acfb ._cfag .Right =right ;_acfb ._cfag .Top =top ;_acfb ._cfag .Bottom =bottom ;};func (_ffee *Creator )getActivePage ()*_cbf .PdfPage {if _ffee ._ceee ==nil {if len (_ffee ._fagg )==0{return nil ;
};return _ffee ._fagg [len (_ffee ._fagg )-1];};return _ffee ._ceee ;};

// Heading returns the heading component of the table of contents.
func (_feda *TOC )Heading ()*StyledParagraph {return _feda ._adfg };

// AddSection adds a new content section at the end of the invoice.
func (_bddf *Invoice )AddSection (title ,content string ){_bddf ._fcgb =append (_bddf ._fcgb ,[2]string {title ,content });};

// SetNotes sets the notes section of the invoice.
func (_cggg *Invoice )SetNotes (title ,content string ){_cggg ._aag =[2]string {title ,content }};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_adfg *StyledParagraph ;_fdba []*TOCLine ;_dbbg TextStyle ;_abca TextStyle ;_dgdc TextStyle ;_cfebf TextStyle ;_bdadg string ;_gfga float64 ;_decbc Margins ;_fedfg Positioning ;_gceaa TextStyle ;_gggc bool ;};const (TextOverflowVisible TextOverflow =iota ;
TextOverflowHidden ;);func _afa (_efdd *Block ,_dgae *Paragraph ,_badbb DrawContext )(DrawContext ,error ){_dacg :=1;_dgag :=_dg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_c .Itoa (_dacg ));for _efdd ._de .HasFontByName (_dgag ){_dacg ++;_dgag =_dg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_c .Itoa (_dacg ));
};_dbef :=_efdd ._de .SetFontByName (_dgag ,_dgae ._ddcg .ToPdfObject ());if _dbef !=nil {return _badbb ,_dbef ;};_dgae .wrapText ();_cagg :=_ag .NewContentCreator ();_cagg .Add_q ();_gaeb :=_badbb .PageHeight -_badbb .Y -_dgae ._faagb *_dgae ._beee ;_cagg .Translate (_badbb .X ,_gaeb );
if _dgae ._bgbgc !=0{_cagg .RotateDeg (_dgae ._bgbgc );};_cagg .Add_BT ().SetNonStrokingColor (_egf (_dgae ._bgcg )).Add_Tf (_dgag ,_dgae ._faagb ).Add_TL (_dgae ._faagb *_dgae ._beee );for _ddfd ,_ebdc :=range _dgae ._cadfd {if _ddfd !=0{_cagg .Add_Tstar ();
};_dbcff :=[]rune (_ebdc );_eebg :=0.0;_deaf :=0;for _bacd ,_geeb :=range _dbcff {if _geeb ==' '{_deaf ++;continue ;};if _geeb =='\u000A'{continue ;};_acde ,_cfdfb :=_dgae ._ddcg .GetRuneMetrics (_geeb );if !_cfdfb {_be .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_bacd ,_geeb ,_geeb ,_dgae ._ddcg .BaseFont (),_dgae ._ddcg .Subtype ());
return _badbb ,_a .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_eebg +=_dgae ._faagb *_acde .Wx ;};var _dacge []_dg .PdfObject ;_ffge ,_dega :=_dgae ._ddcg .GetRuneMetrics (' ');
if !_dega {return _badbb ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_dbca :=_ffge .Wx ;switch _dgae ._gbaea {case TextAlignmentJustify :if _deaf > 0&&_ddfd < len (_dgae ._cadfd )-1{_dbca =(_dgae ._ccca *1000.0-_eebg )/float64 (_deaf )/_dgae ._faagb ;
};case TextAlignmentCenter :_fga :=_eebg +float64 (_deaf )*_dbca *_dgae ._faagb ;_cgaf :=(_dgae ._ccca *1000.0-_fga )/2/_dgae ._faagb ;_dacge =append (_dacge ,_dg .MakeFloat (-_cgaf ));case TextAlignmentRight :_fgag :=_eebg +float64 (_deaf )*_dbca *_dgae ._faagb ;
_dcda :=(_dgae ._ccca *1000.0-_fgag )/_dgae ._faagb ;_dacge =append (_dacge ,_dg .MakeFloat (-_dcda ));};_bgdc :=_dgae ._ddcg .Encoder ();var _gaebc []byte ;for _ ,_dcf :=range _dbcff {if _dcf =='\u000A'{continue ;};if _dcf ==' '{if len (_gaebc )> 0{_dacge =append (_dacge ,_dg .MakeStringFromBytes (_gaebc ));
_gaebc =nil ;};_dacge =append (_dacge ,_dg .MakeFloat (-_dbca ));}else {if _ ,_ecacc :=_bgdc .RuneToCharcode (_dcf );!_ecacc {_be .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_dcf ,_dcf );
continue ;};_gaebc =append (_gaebc ,_bgdc .Encode (string (_dcf ))...);};};if len (_gaebc )> 0{_dacge =append (_dacge ,_dg .MakeStringFromBytes (_gaebc ));};_cagg .Add_TJ (_dacge ...);};_cagg .Add_ET ();_cagg .Add_Q ();_afaf :=_cagg .Operations ();_afaf .WrapIfNeeded ();
_efdd .addContents (_afaf );if _dgae ._cfaa .IsRelative (){_fgfbg :=_dgae .Height ()+_dgae ._egdf .Bottom ;_badbb .Y +=_fgfbg ;_badbb .Height -=_fgfbg ;if _badbb .Inline {_badbb .X +=_dgae .Width ()+_dgae ._egdf .Right ;};};return _badbb ,nil ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// TitleStyle returns the style properties used to render the invoice title.
func (_eceg *Invoice )TitleStyle ()TextStyle {return _eceg ._acdb };

// NewList creates a new list.
func (_ddaf *Creator )NewList ()*List {return _adfd (_ddaf .NewTextStyle ())};

// DrawHeader sets a function to draw a header on created output pages.
func (_ecaf *Creator )DrawHeader (drawHeaderFunc func (_fbg *Block ,_gcfd HeaderFunctionArgs )){_ecaf ._gdcf =drawHeaderFunc ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;
TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetText replaces all the text of the paragraph with the specified one.
func (_dcbbd *StyledParagraph )SetText (text string )*TextChunk {_dcbbd .Reset ();return _dcbbd .Append (text );};

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_dceb float64 ;_edfge float64 ;_cffa float64 ;_gddf float64 ;_efab Color ;_gdcgc float64 ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_bgag *Table )Width ()float64 {return 0};type listItem struct{_gdfa VectorDrawable ;_egda TextChunk ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_gace *List )SetIndent (indent float64 ){_gace ._gfeg =indent ;_gace ._gdfg =false };

// NewCell returns a new invoice table cell.
func (_accc *Invoice )NewCell (value string )*InvoiceCell {return _accc .newCell (value ,_accc .NewCellProps ());};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Width returns the Block's width.
func (_afb *Block )Width ()float64 {return _afb ._eaf };

// Invoice represents a configurable invoice template.
type Invoice struct{_dbad string ;_dfde *Image ;_egca *InvoiceAddress ;_gbcd *InvoiceAddress ;_cbcb string ;_abga [2]*InvoiceCell ;_ddgfe [2]*InvoiceCell ;_ddf [2]*InvoiceCell ;_edcb [][2]*InvoiceCell ;_dcbb []*InvoiceCell ;_feec [][]*InvoiceCell ;_aefb [2]*InvoiceCell ;
_edgd [2]*InvoiceCell ;_gdgd [][2]*InvoiceCell ;_aag [2]string ;_bbce [2]string ;_fcgb [][2]string ;_daaf TextStyle ;_aeab TextStyle ;_acdb TextStyle ;_dfbe TextStyle ;_bbgg TextStyle ;_fgbcg TextStyle ;_bcdde TextStyle ;_fdag InvoiceCellProps ;_bge InvoiceCellProps ;
_ddfe InvoiceCellProps ;_dbb InvoiceCellProps ;_gdba Positioning ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_ecgf Drawable )(Drawable ,error );};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_dgad *Invoice )SetAddressHeadingStyle (style TextStyle ){_dgad ._bbgg =style };

// Scale block by specified factors in the x and y directions.
func (_dba *Block )Scale (sx ,sy float64 ){_gga :=_ag .NewContentCreator ().Scale (sx ,sy ).Operations ();*_dba ._bg =append (*_gga ,*_dba ._bg ...);_dba ._bg .WrapIfNeeded ();_dba ._eaf *=sx ;_dba ._bc *=sy ;};

// Append adds a new text chunk to the paragraph.
func (_cdgg *StyledParagraph )Append (text string )*TextChunk {_bce :=NewTextChunk (text ,_cdgg ._gcbb );return _cdgg .appendChunk (_bce );};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_gdbea *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_ggde float64 ;_fcgd uint ;_dgga float64 ;_dfbd Positioning ;_eafc float64 ;_bgagc float64 ;_fgfa int64 ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_cfbff *TOC )SetLineLevelOffset (levelOffset float64 ){_cfbff ._gfga =levelOffset };

// SetLineWidth sets the line width.
func (_bgaa *Polyline )SetLineWidth (lineWidth float64 ){_bgaa ._debe .LineWidth =lineWidth };func (_fgc *Block )transform (_aca _eb .Matrix ){_gcb :=_ag .NewContentCreator ().Add_cm (_aca [0],_aca [1],_aca [3],_aca [4],_aca [6],_aca [7]).Operations ();
*_fgc ._bg =append (*_gcb ,*_fgc ._bg ...);_fgc ._bg .WrapIfNeeded ();};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// Notes returns the notes section of the invoice as a title-content pair.
func (_eecc *Invoice )Notes ()(string ,string ){return _eecc ._aag [0],_eecc ._aag [1]};func _fdbg (_aabf *_cbf .PdfRectangle ,_cdbb _eb .Matrix )*_cbf .PdfRectangle {var _ccfbc _cbf .PdfRectangle ;_ccfbc .Llx ,_ccfbc .Lly =_cdbb .Transform (_aabf .Llx ,_aabf .Lly );
_ccfbc .Urx ,_ccfbc .Ury =_cdbb .Transform (_aabf .Urx ,_aabf .Ury );_ccfbc .Normalize ();return &_ccfbc ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_bac *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abebg :=ctx ;_ecgg :=[]func (_eggg DrawContext )([]*Block ,DrawContext ,error ){_bac .generateHeaderBlocks ,_bac .generateInformationBlocks ,_bac .generateLineBlocks ,_bac .generateTotalBlocks ,_bac .generateNoteBlocks };
var _cegfe []*Block ;for _ ,_ageb :=range _ecgg {_edaf ,_baad ,_cccb :=_ageb (ctx );if _cccb !=nil {return _cegfe ,ctx ,_cccb ;};if len (_cegfe )==0{_cegfe =_edaf ;}else if len (_edaf )> 0{_cegfe [len (_cegfe )-1].mergeBlocks (_edaf [0]);_cegfe =append (_cegfe ,_edaf [1:]...);
};ctx =_baad ;};if _bac ._gdba .IsRelative (){ctx .X =_abebg .X ;};if _bac ._gdba .IsAbsolute (){return _cegfe ,_abebg ,nil ;};return _cegfe ,ctx ,nil ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_cgd *Block )ScaleToWidth (w float64 ){_aa :=w /_cgd ._eaf ;_cgd .Scale (_aa ,_aa )};func (_acdbd *Invoice )newColumn (_faffa string ,_ccec CellHorizontalAlignment )*InvoiceCell {_agfb :=&InvoiceCell {_acdbd ._bge ,_faffa };_agfb .Alignment =_ccec ;
return _agfb ;};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_bege *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_bege ._daeaf =alignment };

// SetMargins sets the margins TOC line.
func (_caab *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_caab ._ggde =left ;_egdga :=&_caab ._gdbea ._cfag ;_egdga .Left =_caab ._ggde +float64 (_caab ._fcgd -1)*_caab ._dgga ;_egdga .Right =right ;_egdga .Top =top ;_egdga .Bottom =bottom ;
};

// NewSubchapter creates a new child chapter with the specified title.
func (_gcdd *Chapter )NewSubchapter (title string )*Chapter {_acc :=_edca (_gcdd ._baac ._ddcg );_acc .FontSize =14;_gcdd ._fff ++;_afe :=_beg (_gcdd ,_gcdd ._gbae ,_gcdd ._ccf ,title ,_gcdd ._fff ,_acc );_gcdd .Add (_afe );return _afe ;};

// SetBorderColor sets border color.
func (_cfcaf *Rectangle )SetBorderColor (col Color ){_cfcaf ._dabc =col };

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_bbede *TOC )SetLineTitleStyle (style TextStyle ){_bbede ._abca =style };func _fgfe (_fbb ,_ead ,_adc ,_efc float64 )*border {_ffdg :=&border {};_ffdg ._fba =_fbb ;_ffdg ._agd =_ead ;_ffdg ._ffc =_adc ;_ffdg ._gfg =_efc ;_ffdg ._baaa =ColorBlack ;
_ffdg ._deab =ColorBlack ;_ffdg ._gcg =ColorBlack ;_ffdg ._ddgd =ColorBlack ;_ffdg ._bcdg =0;_ffdg ._gbb =0;_ffdg ._cbec =0;_ffdg ._fce =0;_ffdg .LineStyle =_dd .LineStyleSolid ;return _ffdg ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_cgfc *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_cgfc ._fdba =append (_cgfc ._fdba ,line );return line ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_fdfe *Invoice )SetNoteHeadingStyle (style TextStyle ){_fdfe ._bcdde =style };

// SetFillColor sets the fill color for the path.
func (_faeg *FilledCurve )SetFillColor (color Color ){_faeg ._egaa =color };

// NewImage create a new image from a unidoc image (model.Image).
func (_ecdd *Creator )NewImage (img *_cbf .Image )(*Image ,error ){return _ggca (img )};

// SetLevel sets the indentation level of the TOC line.
func (_adbd *TOCLine )SetLevel (level uint ){_adbd ._fcgd =level ;_adbd ._gdbea ._cfag .Left =_adbd ._ggde +float64 (_adbd ._fcgd -1)*_adbd ._dgga ;};

// SetLineColor sets the line color.
func (_beec *Polyline )SetLineColor (color Color ){_beec ._debe .LineColor =_egf (color )};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bdab *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bdab ._egca =address };

// SetStyleRight sets border style for right side.
func (_adg *border )SetStyleRight (style CellBorderStyle ){_adg ._cece =style };

// SetBorderColor sets the border color for the path.
func (_ddc *FilledCurve )SetBorderColor (color Color ){_ddc ._gcbf =color };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_gfb *Image )ScaleToHeight (h float64 ){_gfgb :=_gfb ._abfe /_gfb ._fceb ;_gfb ._fceb =h ;_gfb ._abfe =h *_gfgb ;};func (_cbcc *List )tableHeight (_cgda float64 )float64 {var _edd float64 ;for _ ,_fbgc :=range _cbcc ._caeb {switch _bfbc :=_fbgc ._gdfa .(type ){case *Paragraph :_dfeb :=_bfbc ;
if _dfeb ._ecec {_dfeb .SetWidth (_cgda );};_edd +=_dfeb .Height ()+_dfeb ._egdf .Bottom +_dfeb ._egdf .Bottom ;_edd +=0.5*_dfeb ._faagb *_dfeb ._beee ;case *StyledParagraph :_eabb :=_bfbc ;if _eabb ._ccbc {_eabb .SetWidth (_cgda );};_edd +=_eabb .Height ()+_eabb ._cfag .Top +_eabb ._cfag .Bottom ;
_edd +=0.5*_eabb .getTextHeight ();default:_edd +=_fbgc ._gdfa .Height ();};};return _edd ;};

// SetSubtotal sets the subtotal of the invoice.
func (_acbf *Invoice )SetSubtotal (value string ){_acbf ._aefb [1].Value =value };

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_fdcd *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _dcd (xc ,yc ,width ,height );};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_dabd *Invoice )SetAddressStyle (style TextStyle ){_dabd ._dfbe =style };

// SetBorderWidth sets the border width.
func (_aebd *Ellipse )SetBorderWidth (bw float64 ){_aebd ._bcfc =bw };

// Width returns Image's document width.
func (_gfda *Image )Width ()float64 {return _gfda ._abfe };

// NewPageBreak create a new page break.
func (_cbbb *Creator )NewPageBreak ()*PageBreak {return _eaef ()};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_fg *Block )SetPos (x ,y float64 ){_fg ._gd =PositionAbsolute ;_fg ._ed =x ;_fg ._ea =y };

// SetColorRight sets border color for right.
func (_cbdc *border )SetColorRight (col Color ){_cbdc ._ddgd =col };

// Margins returns the margins of the list: left, right, top, bottom.
func (_cbfb *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _cbfb ._dbea .Left ,_cbfb ._dbea .Right ,_cbfb ._dbea .Top ,_cbfb ._dbea .Bottom ;};func (_cgc *Table )newCell (_dacf int )*TableCell {_cgc ._edcbf ++;_efaga :=(_cgc ._edcbf -1)/_cgc ._fcedd +1;
for _efaga > _cgc ._aafb {_cgc ._aafb ++;_cgc ._fdef =append (_cgc ._fdef ,_cgc ._efgfd );};_abegg :=(_cgc ._edcbf -1)%(_cgc ._fcedd )+1;_fgfee :=&TableCell {};_fgfee ._gfcae =_efaga ;_fgfee ._cada =_abegg ;_fgfee ._dfedf =1;_fgfee ._abdc =5;_fgfee ._efbf =CellBorderStyleNone ;
_fgfee ._becd =_dd .LineStyleSolid ;_fgfee ._bbfe =CellHorizontalAlignmentLeft ;_fgfee ._bgbe =CellVerticalAlignmentTop ;_fgfee ._bgdeag =0;_fgfee ._febea =0;_fgfee ._gcfg =0;_fgfee ._bbgc =0;_gdae :=ColorBlack ;_fgfee ._bccd =_gdae ;_fgfee ._gfff =_gdae ;
_fgfee ._acada =_gdae ;_fgfee ._abaab =_gdae ;if _dacf < 1{_be .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_dacf );
_dacf =1;};_fffc :=_cgc ._fcedd -(_fgfee ._cada -1);if _dacf > _fffc {_be .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_dacf ,_fffc );
_dacf =_fffc ;};_fgfee ._adcec =_dacf ;_cgc ._edcbf +=_dacf -1;_cgc ._bdad =append (_cgc ._bdad ,_fgfee );_fgfee ._faded =_cgc ;return _fgfee ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_gcdc *Invoice )SetTerms (title ,content string ){_gcdc ._bbce =[2]string {title ,content }};func (_cfdg *Paragraph )wrapText ()error {if !_cfdg ._ecec ||int (_cfdg ._ccca )<=0{_cfdg ._cadfd =[]string {_cfdg ._dcebg };return nil ;};_fcceb :=NewTextChunk (_cfdg ._dcebg ,TextStyle {Font :_cfdg ._ddcg ,FontSize :_cfdg ._faagb });
_gbbd ,_eaae :=_fcceb .Wrap (_cfdg ._ccca );if _eaae !=nil {return _eaae ;};if _cfdg ._cbee > 0&&len (_gbbd )> _cfdg ._cbee {_gbbd =_gbbd [:_cfdg ._cbee ];};_cfdg ._cadfd =_gbbd ;return nil ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_ddac *Invoice )AddressHeadingStyle ()TextStyle {return _ddac ._aeab };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_abcaf *TOC )SetHeading (text string ,style TextStyle ){_aedea :=_abcaf .Heading ();_aedea .Reset ();_eaac :=_aedea .Append (text );_eaac .Style =style ;};func (_ccb *Block )setOpacity (_bdb float64 ,_bda float64 )(string ,error ){if (_bdb < 0||_bdb >=1.0)&&(_bda < 0||_bda >=1.0){return "",nil ;
};_bdd :=0;_ce :=_da .Sprintf ("\u0047\u0053\u0025\u0064",_bdd );for _ccb ._de .HasExtGState (_dg .PdfObjectName (_ce )){_bdd ++;_ce =_da .Sprintf ("\u0047\u0053\u0025\u0064",_bdd );};_gdb :=_dg .MakeDict ();if _bdb >=0&&_bdb < 1.0{_gdb .Set ("\u0063\u0061",_dg .MakeFloat (_bdb ));
};if _bda >=0&&_bda < 1.0{_gdb .Set ("\u0043\u0041",_dg .MakeFloat (_bda ));};_ab :=_ccb ._de .AddExtGState (_dg .PdfObjectName (_ce ),_gdb );if _ab !=nil {return "",_ab ;};return _ce ,nil ;};

// Height returns the total height of all rows.
func (_dccdd *Table )Height ()float64 {_dedb :=float64 (0.0);for _ ,_fcbf :=range _dccdd ._fdef {_dedb +=_fcbf ;};return _dedb ;};

// SetColorTop sets border color for top.
func (_effc *border )SetColorTop (col Color ){_effc ._baaa =col };

// AppendCurve appends a Bezier curve to the filled curve.
func (_ebc *FilledCurve )AppendCurve (curve _dd .CubicBezierCurve )*FilledCurve {_ebc ._gacg =append (_ebc ._gacg ,curve );return _ebc ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_cbege *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_cecb :=&_cbege ._decbc ;_cecb .Left =left ;_cecb .Right =right ;_cecb .Top =top ;_cecb .Bottom =bottom ;};

// SetBorder sets the cell's border style.
func (_aede *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_aede ._efbf =CellBorderStyleSingle ;_aede ._bgdeag =width ;_aede ._abce =CellBorderStyleSingle ;
_aede ._febea =width ;_aede ._cedga =CellBorderStyleSingle ;_aede ._gcfg =width ;_aede ._aggb =CellBorderStyleSingle ;_aede ._bbgc =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_aede ._efbf =CellBorderStyleDouble ;_aede ._bgdeag =width ;
_aede ._abce =CellBorderStyleDouble ;_aede ._febea =width ;_aede ._cedga =CellBorderStyleDouble ;_aede ._gcfg =width ;_aede ._aggb =CellBorderStyleDouble ;_aede ._bbgc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_aede ._efbf =style ;
_aede ._bgdeag =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_aede ._abce =style ;_aede ._febea =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_aede ._cedga =style ;
_aede ._gcfg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_aede ._aggb =style ;_aede ._bbgc =width ;};};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_ffece *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgdaf :=_ffece ;if _ffece ._cbgdd {_fgdaf =_ffece .clone ();};return _abbfc (_fgdaf ,ctx );};

// BuyerAddress returns the buyer address used in the invoice template.
func (_eaaf *Invoice )BuyerAddress ()*InvoiceAddress {return _eaaf ._egca };func _beg (_abeg *Chapter ,_bba *TOC ,_bbff *_cbf .Outline ,_gdbe string ,_bfee int ,_cedcc TextStyle )*Chapter {var _cbcf uint =1;if _abeg !=nil {_cbcf =_abeg ._eggc +1;};_bfcg :=&Chapter {_fgfb :_bfee ,_ggb :_gdbe ,_cgbd :true ,_bafa :true ,_aeg :_abeg ,_gbae :_bba ,_ccf :_bbff ,_gfgf :[]Drawable {},_eggc :_cbcf };
_caeg :=_gccc (_bfcg .headingText (),_cedcc );_caeg .SetFont (_cedcc .Font );_caeg .SetFontSize (_cedcc .FontSize );_bfcg ._baac =_caeg ;return _bfcg ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_gacg []_dd .CubicBezierCurve ;FillEnabled bool ;_egaa Color ;BorderEnabled bool ;BorderWidth float64 ;_gcbf Color ;};

// SetColorLeft sets border color for left.
func (_eafd *border )SetColorLeft (col Color ){_eafd ._gcg =col };

// Context returns the current drawing context.
func (_bcac *Creator )Context ()DrawContext {return _bcac ._dfd };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};func (_dff *Invoice )newCell (_eedg string ,_eegdd InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_eegdd ,_eedg };};

// SetFillOpacity sets the fill opacity.
func (_gbef *PolyBezierCurve )SetFillOpacity (opacity float64 ){_gbef ._afbe =opacity };

// SetEnableWrap sets the line wrapping enabled flag.
func (_gdbef *Paragraph )SetEnableWrap (enableWrap bool ){_gdbef ._ecec =enableWrap ;_gdbef ._geab =false ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_bfbe *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _fbgb (number ,title ,page ,level ,_bfbe .NewTextStyle ());};

// SetPos sets absolute positioning with specified coordinates.
func (_gbee *StyledParagraph )SetPos (x ,y float64 ){_gbee ._dbba =PositionAbsolute ;_gbee ._cceb =x ;_gbee ._befd =y ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_baa *Block )SetMargins (left ,right ,top ,bottom float64 ){_baa ._bb .Left =left ;_baa ._bb .Right =right ;_baa ._bb .Top =top ;_baa ._bb .Bottom =bottom ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_deb *Creator )MoveRight (dx float64 ){_deb ._dfd .X +=dx };

// NewCurvePolygon creates a new curve polygon.
func (_ebbf *Creator )NewCurvePolygon (rings [][]_dd .CubicBezierCurve )*CurvePolygon {return _fbbd (rings );};

// NewCellProps returns the default properties of an invoice cell.
func (_daaa *Invoice )NewCellProps ()InvoiceCellProps {_cbea :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_daaa ._daaf ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_cbea ,BorderColor :_cbea ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetFont sets the Paragraph's font.
func (_fagd *Paragraph )SetFont (font *_cbf .PdfFont ){_fagd ._ddcg =font };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_dcebc *Table )NewCell ()*TableCell {return _dcebc .newCell (1)};

// GetRowHeight returns the height of the specified row.
func (_eabe *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_eabe ._fdef ){return 0,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _eabe ._fdef [row -1],nil ;
};func (_dfbea *StyledParagraph )getLineMetrics (_caed int )(_gfab ,_adce ,_begebd float64 ){if _dfbea ._dgfag ==nil ||len (_dfbea ._dgfag )==0{_dfbea .wrapText ();};if _caed < 0||_caed > len (_dfbea ._dgfag )-1{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_caed );
return 0,0,0;};_cdbab :=_dfbea ._dgfag [_caed ];for _ ,_cbge :=range _cdbab {_cfbd ,_fggga :=_cbge .Style .Font .GetFontDescriptor ();if _fggga !=nil {_be .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _ffbfa ,_facbc float64 ;if _cfbd !=nil {if _ffbfa ,_fggga =_cfbd .GetCapHeight ();_fggga !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_fggga );
};if _facbc ,_fggga =_cfbd .GetDescent ();_fggga !=nil {_be .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_fggga );
};};if int (_ffbfa )<=0{_be .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_ffbfa =1000;};if _beecb :=_ffbfa /1000.0*_cbge .Style .FontSize ;_beecb > _gfab {_gfab =_beecb ;};if _dddd :=_cbge .Style .FontSize ;_dddd > _adce {_adce =_dddd ;};if _eefa :=_facbc /1000.0*_cbge .Style .FontSize ;_eefa < _begebd {_begebd =_eefa ;};};
return _gfab ,_adce ,_begebd ;};func (_fggb *StyledParagraph )getTextLineWidth (_fgfeb []*TextChunk )float64 {var _cfbed float64 ;_gecd :=len (_fgfeb );for _gagg ,_ffag :=range _fgfeb {_fddab :=&_ffag .Style ;_deagf :=len (_ffag .Text );for _fefa ,_edfc :=range _ffag .Text {if _edfc =='\u000A'{continue ;
};_daecc ,_ddbc :=_fddab .Font .GetRuneMetrics (_edfc );if !_ddbc {_be .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_edfc );
return -1;};_cfbed +=_fddab .FontSize *_daecc .Wx *_fddab .horizontalScale ();if _edfc !=' '&&(_gagg !=_gecd -1||_fefa !=_deagf -1){_cfbed +=_fddab .CharSpacing *1000.0;};};};return _cfbed ;};

// SetFillOpacity sets the fill opacity.
func (_feae *CurvePolygon )SetFillOpacity (opacity float64 ){_feae ._ccgee =opacity };

// SetFontSize sets the font size in document units (points).
func (_gecc *Paragraph )SetFontSize (fontSize float64 ){_gecc ._faagb =fontSize };

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_edgf *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _dbed (x1 ,y1 ,x2 ,y2 )};func (_cfab *Paragraph )getTextLineWidth (_fbf string )float64 {var _daeb float64 ;for _ ,_gdec :=range _fbf {if _gdec =='\u000A'{continue ;};_baae ,_bcdcd :=_cfab ._ddcg .GetRuneMetrics (_gdec );
if !_bcdcd {_be .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gdec ,_gdec );
return -1;};_daeb +=_cfab ._faagb *_baae .Wx ;};return _daeb ;};func _fdbb (_fddc []byte )(*Image ,error ){_bdaa :=_d .NewReader (_fddc );_ffbf ,_cdbf :=_cbf .ImageHandling .Read (_bdaa );if _cdbf !=nil {_be .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cdbf );
return nil ,_cdbf ;};return _ggca (_ffbf );};func (_debf *TableCell )height (_eacf float64 )float64 {var _dcfc float64 ;switch _gcaaa :=_debf ._fadgf .(type ){case *Paragraph :if _gcaaa ._ecec {_gcaaa .SetWidth (_eacf -_debf ._abdc -_gcaaa ._egdf .Left -_gcaaa ._egdf .Right );
};_dcfc =_gcaaa .Height ()+_gcaaa ._egdf .Top +_gcaaa ._egdf .Bottom +0.5*_gcaaa ._faagb *_gcaaa ._beee ;case *StyledParagraph :if _gcaaa ._ccbc {_gcaaa .SetWidth (_eacf -_debf ._abdc -_gcaaa ._cfag .Left -_gcaaa ._cfag .Right );};_dcfc =_gcaaa .Height ()+_gcaaa ._cfag .Top +_gcaaa ._cfag .Bottom +0.5*_gcaaa .getTextHeight ();
case *Image :_dcfc =_gcaaa .Height ()+_gcaaa ._agfc .Top +_gcaaa ._agfc .Bottom ;case *Table :_dcfc =_gcaaa .Height ()+_gcaaa ._ggad .Top +_gcaaa ._ggad .Bottom ;case *List :_dcfc =_gcaaa .tableHeight (_eacf -_debf ._abdc )+_gcaaa ._dbea .Top +_gcaaa ._dbea .Bottom ;
case *Division :_dcfc =_gcaaa .ctxHeight (_eacf -_debf ._abdc )+_gcaaa ._dadg .Top +_gcaaa ._dadg .Bottom ;};return _dcfc ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_efcc *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _efcc ._abga [0],_efcc ._abga [1]};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_ggcad *Paragraph )SetColor (col Color ){_ggcad ._bgcg =col };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_aceb *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _aceb ._edgd [0],_aceb ._edgd [1]};

// Inline returns whether the inline mode of the division is active.
func (_efee *Division )Inline ()bool {return _efee ._gadd };

// Width returns the width of the Paragraph.
func (_cbcg *Paragraph )Width ()float64 {if _cbcg ._ecec &&int (_cbcg ._ccca )> 0{return _cbcg ._ccca ;};return _cbcg .getTextWidth ()/1000.0;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_fadae *TOC )SetLinePageStyle (style TextStyle ){_fadae ._cfebf =style };

// SetLogo sets the logo of the invoice.
func (_aecf *Invoice )SetLogo (logo *Image ){_aecf ._dfde =logo };

// TOC returns the table of contents component of the creator.
func (_agedc *Creator )TOC ()*TOC {return _agedc ._edef };

// Lines returns all the rows of the invoice line items table.
func (_defb *Invoice )Lines ()[][]*InvoiceCell {return _defb ._feec };

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _dddcd ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_dfea :=&Creator {};_dfea ._fagg =[]*_cbf .PdfPage {};_dfea ._cbb =map[*_cbf .PdfPage ]*Block {};_dfea .SetPageSize (PageSizeLetter );_ggeeb :=0.1*_dfea ._ebdb ;
_dfea ._cba .Left =_ggeeb ;_dfea ._cba .Right =_ggeeb ;_dfea ._cba .Top =_ggeeb ;_dfea ._cba .Bottom =_ggeeb ;var _eagd error ;_dfea ._bfa ,_eagd =_cbf .NewStandard14Font (_cbf .HelveticaName );if _eagd !=nil {_dfea ._bfa =_cbf .DefaultFont ();};_dfea ._baba ,_eagd =_cbf .NewStandard14Font (_cbf .HelveticaBoldName );
if _eagd !=nil {_dfea ._bfa =_cbf .DefaultFont ();};_dfea ._edef =_dfea .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_dfea .AddOutlines =true ;_dfea ._gcf =_cbf .NewOutline ();_ba .TrackUse (_dddcd );
return _dfea ;};func (_ee *Block )mergeBlocks (_dc *Block )error {_ebb :=_ddg (_ee ._bg ,_ee ._de ,_dc ._bg ,_dc ._de );if _ebb !=nil {return _ebb ;};for _ ,_befg :=range _dc ._bd {_ee .AddAnnotation (_befg );};return nil ;};

// NewImageFromFile creates an Image from a file.
func (_dbag *Creator )NewImageFromFile (path string )(*Image ,error ){return _bff (path )};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_febe *Image )ScaleToWidth (w float64 ){_cagd :=_febe ._fceb /_febe ._abfe ;_febe ._abfe =w ;_febe ._fceb =w *_cagd ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_dfbf *TextChunk )SetAnnotation (annotation *_cbf .PdfAnnotation ){_dfbf ._bfaf =annotation };

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bbec *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _bbec ._aefb [0],_bbec ._aefb [1]};

// Scale scales Image by a constant factor, both width and height.
func (_dead *Image )Scale (xFactor ,yFactor float64 ){_dead ._abfe =xFactor *_dead ._abfe ;_dead ._fceb =yFactor *_dead ._fceb ;};