//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_c "fmt";_ge "github.com/unidoc/unipdf/v3/contentstream";_b "github.com/unidoc/unipdf/v3/core";_cb "github.com/unidoc/unipdf/v3/internal/transform";_ce "github.com/unidoc/unipdf/v3/model";_g "math";);

// AppendCurve appends the specified Bezier curve to the path.
func (_gd CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_gd .Curves =append (_gd .Curves ,curve );return _gd ;};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_agb :=Vector {};_agb .Dx =b .X -a .X ;_agb .Dy =b .Y -a .Y ;return _agb ;};

// GetBoundingBox returns the bounding box of the path.
func (_ggg Path )GetBoundingBox ()BoundingBox {_ab :=BoundingBox {};_fc :=0.0;_cgb :=0.0;_geaf :=0.0;_aea :=0.0;for _ga ,_ad :=range _ggg .Points {if _ga ==0{_fc =_ad .X ;_cgb =_ad .X ;_geaf =_ad .Y ;_aea =_ad .Y ;continue ;};if _ad .X < _fc {_fc =_ad .X ;
};if _ad .X > _cgb {_cgb =_ad .X ;};if _ad .Y < _geaf {_geaf =_ad .Y ;};if _ad .Y > _aea {_aea =_ad .Y ;};};_ab .X =_fc ;_ab .Y =_geaf ;_ab .Width =_cgb -_fc ;_ab .Height =_aea -_geaf ;return _ab ;};

// AddVector adds vector to a point.
func (_ea Point )AddVector (v Vector )Point {_ea .X +=v .Dx ;_ea .Y +=v .Dy ;return _ea };

// Copy returns a clone of the Bezier path.
func (_ca CubicBezierPath )Copy ()CubicBezierPath {_dg :=CubicBezierPath {};_dg .Curves =append (_dg .Curves ,_ca .Curves ...);return _dg ;};

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_aaa CurvePolygon )Draw (gsName string )([]byte ,*_ce .PdfRectangle ,error ){_bgdc :=_ge .NewContentCreator ();_bgdc .Add_q ();_aaa .FillEnabled =_aaa .FillEnabled &&_aaa .FillColor !=nil ;if _aaa .FillEnabled {_bgdc .SetNonStrokingColor (_aaa .FillColor );
};_aaa .BorderEnabled =_aaa .BorderEnabled &&_aaa .BorderColor !=nil ;if _aaa .BorderEnabled {_bgdc .SetStrokingColor (_aaa .BorderColor );_bgdc .Add_w (_aaa .BorderWidth );};if len (gsName )> 1{_bgdc .Add_gs (_b .PdfObjectName (gsName ));};_fgd :=NewCubicBezierPath ();
for _ ,_eb :=range _aaa .Rings {for _gbb ,_df :=range _eb {if _gbb ==0{_bgdc .Add_m (_df .P0 .X ,_df .P0 .Y );}else {_bgdc .Add_l (_df .P0 .X ,_df .P0 .Y );};_bgdc .Add_c (_df .P1 .X ,_df .P1 .Y ,_df .P2 .X ,_df .P2 .Y ,_df .P3 .X ,_df .P3 .Y );_fgd =_fgd .AppendCurve (_df );
};_bgdc .Add_h ();};if _aaa .FillEnabled &&_aaa .BorderEnabled {_bgdc .Add_B ();}else if _aaa .FillEnabled {_bgdc .Add_f ();}else if _aaa .BorderEnabled {_bgdc .Add_S ();};_bgdc .Add_Q ();return _bgdc .Bytes (),_fgd .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_ee Path )GetPointNumber (number int )Point {if number < 1||number > len (_ee .Points ){return Point {};};return _ee .Points [number -1];};

// Scale scales the vector by the specified factor.
func (_fec Vector )Scale (factor float64 )Vector {_ffg :=_fec .Magnitude ();_dddc :=_fec .GetPolarAngle ();_fec .Dx =factor *_ffg *_g .Cos (_dddc );_fec .Dy =factor *_ffg *_g .Sin (_dddc );return _fec ;};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_gdg :=Vector {};_gdg .Dx =length *_g .Cos (theta );_gdg .Dy =length *_g .Sin (theta );return _gdg ;};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _ce .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// GetBounds returns the bounding box of the Bezier curve.
func (_fg CubicBezierCurve )GetBounds ()_ce .PdfRectangle {_da :=_fg .P0 .X ;_gf :=_fg .P0 .X ;_ccf :=_fg .P0 .Y ;_e :=_fg .P0 .Y ;for _bc :=0.0;_bc <=1.0;_bc +=0.001{Rx :=_fg .P0 .X *_g .Pow (1-_bc ,3)+_fg .P1 .X *3*_bc *_g .Pow (1-_bc ,2)+_fg .P2 .X *3*_g .Pow (_bc ,2)*(1-_bc )+_fg .P3 .X *_g .Pow (_bc ,3);
Ry :=_fg .P0 .Y *_g .Pow (1-_bc ,3)+_fg .P1 .Y *3*_bc *_g .Pow (1-_bc ,2)+_fg .P2 .Y *3*_g .Pow (_bc ,2)*(1-_bc )+_fg .P3 .Y *_g .Pow (_bc ,3);if Rx < _da {_da =Rx ;};if Rx > _gf {_gf =Rx ;};if Ry < _ccf {_ccf =Ry ;};if Ry > _e {_e =Ry ;};};_bg :=_ce .PdfRectangle {};
_bg .Llx =_da ;_bg .Lly =_ccf ;_bg .Urx =_gf ;_bg .Ury =_e ;return _bg ;};

// Offset shifts the Bezier path with the specified offsets.
func (_dd CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _gb ,_dc :=range _dd .Curves {_dd .Curves [_gb ]=_dc .AddOffsetXY (offX ,offY );};return _dd ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_eegfe Vector )GetPolarAngle ()float64 {return _g .Atan2 (_eegfe .Dy ,_eegfe .Dx )};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_cc CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_cc .P0 .X +=offX ;_cc .P1 .X +=offX ;_cc .P2 .X +=offX ;_cc .P3 .X +=offX ;_cc .P0 .Y +=offY ;_cc .P1 .Y +=offY ;_cc .P2 .Y +=offY ;_cc .P3 .Y +=offY ;return _cc ;};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _ce .PdfColor ;FillEnabled bool ;FillColor _ce .PdfColor ;};

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_eaac :=Vector {};_eaac .Dx =dx ;_eaac .Dy =dy ;return _eaac };func (_ffa Point )String ()string {return _c .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_ffa .X ,_ffa .Y );};const (LineStyleSolid LineStyle =0;
LineStyleDashed LineStyle =1;);

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_fde PolyBezierCurve )Draw (gsName string )([]byte ,*_ce .PdfRectangle ,error ){if _fde .BorderColor ==nil {_fde .BorderColor =_ce .NewPdfColorDeviceRGB (0,0,0);};_fb :=NewCubicBezierPath ();for _ ,_cege :=range _fde .Curves {_fb =_fb .AppendCurve (_cege );
};_cgg :=_ge .NewContentCreator ();_cgg .Add_q ();_fde .FillEnabled =_fde .FillEnabled &&_fde .FillColor !=nil ;if _fde .FillEnabled {_cgg .SetNonStrokingColor (_fde .FillColor );};_cgg .SetStrokingColor (_fde .BorderColor );_cgg .Add_w (_fde .BorderWidth );
if len (gsName )> 1{_cgg .Add_gs (_b .PdfObjectName (gsName ));};for _bf ,_eaa :=range _fb .Curves {if _bf ==0{_cgg .Add_m (_eaa .P0 .X ,_eaa .P0 .Y );}else {_cgg .Add_l (_eaa .P0 .X ,_eaa .P0 .Y );};_cgg .Add_c (_eaa .P1 .X ,_eaa .P1 .Y ,_eaa .P2 .X ,_eaa .P2 .Y ,_eaa .P3 .X ,_eaa .P3 .Y );
};if _fde .FillEnabled {_cgg .Add_h ();_cgg .Add_B ();}else {_cgg .Add_S ();};_cgg .Add_Q ();return _cgg .Bytes (),_fb .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_eee Polyline )Draw (gsName string )([]byte ,*_ce .PdfRectangle ,error ){if _eee .LineColor ==nil {_eee .LineColor =_ce .NewPdfColorDeviceRGB (0,0,0);};_aca :=NewPath ();for _ ,_fcf :=range _eee .Points {_aca =_aca .AppendPoint (_fcf );};_dae :=_ge .NewContentCreator ();
_dae .Add_q ().SetStrokingColor (_eee .LineColor ).Add_w (_eee .LineWidth );if len (gsName )> 1{_dae .Add_gs (_b .PdfObjectName (gsName ));};DrawPathWithCreator (_aca ,_dae );_dae .Add_S ();_dae .Add_Q ();return _dae .Bytes (),_aca .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_ef Circle )Draw (gsName string )([]byte ,*_ce .PdfRectangle ,error ){_cd :=_ef .Width /2;_cce :=_ef .Height /2;if _ef .BorderEnabled {_cd -=_ef .BorderWidth /2;_cce -=_ef .BorderWidth /2;};_de :=0.551784;_bca :=_cd *_de ;_dcc :=_cce *_de ;_gfe :=NewCubicBezierPath ();
_gfe =_gfe .AppendCurve (NewCubicBezierCurve (-_cd ,0,-_cd ,_dcc ,-_bca ,_cce ,0,_cce ));_gfe =_gfe .AppendCurve (NewCubicBezierCurve (0,_cce ,_bca ,_cce ,_cd ,_dcc ,_cd ,0));_gfe =_gfe .AppendCurve (NewCubicBezierCurve (_cd ,0,_cd ,-_dcc ,_bca ,-_cce ,0,-_cce ));
_gfe =_gfe .AppendCurve (NewCubicBezierCurve (0,-_cce ,-_bca ,-_cce ,-_cd ,-_dcc ,-_cd ,0));_gfe =_gfe .Offset (_cd ,_cce );if _ef .BorderEnabled {_gfe =_gfe .Offset (_ef .BorderWidth /2,_ef .BorderWidth /2);};if _ef .X !=0||_ef .Y !=0{_gfe =_gfe .Offset (_ef .X ,_ef .Y );
};_gfd :=_ge .NewContentCreator ();_gfd .Add_q ();if _ef .FillEnabled {_gfd .SetNonStrokingColor (_ef .FillColor );};if _ef .BorderEnabled {_gfd .SetStrokingColor (_ef .BorderColor );_gfd .Add_w (_ef .BorderWidth );};if len (gsName )> 1{_gfd .Add_gs (_b .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_gfe ,_gfd );_gfd .Add_h ();if _ef .FillEnabled &&_ef .BorderEnabled {_gfd .Add_B ();}else if _ef .FillEnabled {_gfd .Add_f ();}else if _ef .BorderEnabled {_gfd .Add_S ();};_gfd .Add_Q ();_cag :=_gfe .GetBoundingBox ();if _ef .BorderEnabled {_cag .Height +=_ef .BorderWidth ;
_cag .Width +=_ef .BorderWidth ;_cag .X -=_ef .BorderWidth /2;_cag .Y -=_ef .BorderWidth /2;};return _gfd .Bytes (),_cag .ToPdfRectangle (),nil ;};

// Rotate rotates the vector by the specified angle.
func (_gge Vector )Rotate (phi float64 )Vector {_gga :=_gge .Magnitude ();_fba :=_gge .GetPolarAngle ();return NewVectorPolar (_gga ,_fba +phi );};

// Magnitude returns the magnitude of the vector.
func (_add Vector )Magnitude ()float64 {return _g .Sqrt (_g .Pow (_add .Dx ,2.0)+_g .Pow (_add .Dy ,2.0))};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;LineEndingStyleButt LineEndingStyle =2;);

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _ce .PdfColor ;BorderEnabled bool ;BorderColor _ce .PdfColor ;BorderWidth float64 ;};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_cda Polygon )Draw (gsName string )([]byte ,*_ce .PdfRectangle ,error ){_geb :=_ge .NewContentCreator ();_geb .Add_q ();_cda .FillEnabled =_cda .FillEnabled &&_cda .FillColor !=nil ;if _cda .FillEnabled {_geb .SetNonStrokingColor (_cda .FillColor );
};_cda .BorderEnabled =_cda .BorderEnabled &&_cda .BorderColor !=nil ;if _cda .BorderEnabled {_geb .SetStrokingColor (_cda .BorderColor );_geb .Add_w (_cda .BorderWidth );};if len (gsName )> 1{_geb .Add_gs (_b .PdfObjectName (gsName ));};_gef :=NewPath ();
for _ ,_eg :=range _cda .Points {for _bd ,_dccf :=range _eg {_gef =_gef .AppendPoint (_dccf );if _bd ==0{_geb .Add_m (_dccf .X ,_dccf .Y );}else {_geb .Add_l (_dccf .X ,_dccf .Y );};};_geb .Add_h ();};if _cda .FillEnabled &&_cda .BorderEnabled {_geb .Add_B ();
}else if _cda .FillEnabled {_geb .Add_f ();}else if _cda .BorderEnabled {_geb .Add_S ();};_geb .Add_Q ();return _geb .Bytes (),_gef .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Flip changes the sign of the vector: -vector.
func (_fbc Vector )Flip ()Vector {_gda :=_fbc .Magnitude ();_cge :=_fbc .GetPolarAngle ();_fbc .Dx =_gda *_g .Cos (_cge +_g .Pi );_fbc .Dy =_gda *_g .Sin (_cge +_g .Pi );return _fbc ;};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_ceg CubicBezierPath )GetBoundingBox ()Rectangle {_cbb :=Rectangle {};_fgf :=0.0;_gg :=0.0;_ged :=0.0;_fe :=0.0;for _db ,_dgc :=range _ceg .Curves {_dbb :=_dgc .GetBounds ();if _db ==0{_fgf =_dbb .Llx ;_gg =_dbb .Urx ;_ged =_dbb .Lly ;_fe =_dbb .Ury ;
continue ;};if _dbb .Llx < _fgf {_fgf =_dbb .Llx ;};if _dbb .Urx > _gg {_gg =_dbb .Urx ;};if _dbb .Lly < _ged {_ged =_dbb .Lly ;};if _dbb .Ury > _fe {_fe =_dbb .Ury ;};};_cbb .X =_fgf ;_cbb .Y =_ged ;_cbb .Width =_gg -_fgf ;_cbb .Height =_fe -_ged ;return _cbb ;
};

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};

// FlipY flips the sign of the Dy component of the vector.
func (_bb Vector )FlipY ()Vector {_bb .Dy =-_bb .Dy ;return _bb };

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// Draw draws the rectangle. A graphics state can be specified for
// setting additional properties (e.g. opacity). Otherwise pass an empty string
// for the `gsName` parameter. The method returns the content stream as a byte
// array and the bounding box of the shape.
func (_cgd Rectangle )Draw (gsName string )([]byte ,*_ce .PdfRectangle ,error ){_gfec :=_ge .NewContentCreator ();_gfec .Add_q ();if _cgd .FillEnabled {_gfec .SetNonStrokingColor (_cgd .FillColor );};if _cgd .BorderEnabled {_gfec .SetStrokingColor (_cgd .BorderColor );
_gfec .Add_w (_cgd .BorderWidth );};if len (gsName )> 1{_gfec .Add_gs (_b .PdfObjectName (gsName ));};var (_deb ,_eaf =_cgd .X ,_cgd .Y ;_ddd ,_gff =_cgd .Width ,_cgd .Height ;_eac =_g .Abs (_cgd .BorderRadiusTopLeft );_cgbb =_g .Abs (_cgd .BorderRadiusTopRight );
_fbg =_g .Abs (_cgd .BorderRadiusBottomLeft );_bfg =_g .Abs (_cgd .BorderRadiusBottomRight );_ac =0.4477;);_gae :=Path {Points :[]Point {{X :_deb +_ddd -_bfg ,Y :_eaf },{X :_deb +_ddd ,Y :_eaf +_gff -_cgbb },{X :_deb +_eac ,Y :_eaf +_gff },{X :_deb ,Y :_eaf +_fbg }}};
_bfa :=[][7]float64 {{_bfg ,_deb +_ddd -_bfg *_ac ,_eaf ,_deb +_ddd ,_eaf +_bfg *_ac ,_deb +_ddd ,_eaf +_bfg },{_cgbb ,_deb +_ddd ,_eaf +_gff -_cgbb *_ac ,_deb +_ddd -_cgbb *_ac ,_eaf +_gff ,_deb +_ddd -_cgbb ,_eaf +_gff },{_eac ,_deb +_eac *_ac ,_eaf +_gff ,_deb ,_eaf +_gff -_eac *_ac ,_deb ,_eaf +_gff -_eac },{_fbg ,_deb ,_eaf +_fbg *_ac ,_deb +_fbg *_ac ,_eaf ,_deb +_fbg ,_eaf }};
_gfec .Add_m (_deb +_fbg ,_eaf );for _gbe :=0;_gbe < 4;_gbe ++{_ggga :=_gae .Points [_gbe ];_gfec .Add_l (_ggga .X ,_ggga .Y );_eab :=_bfa [_gbe ];if _cbf :=_eab [0];_cbf !=0{_gfec .Add_c (_eab [1],_eab [2],_eab [3],_eab [4],_eab [5],_eab [6]);};};_gfec .Add_h ();
if _cgd .FillEnabled &&_cgd .BorderEnabled {_gfec .Add_B ();}else if _cgd .FillEnabled {_gfec .Add_f ();}else if _cgd .BorderEnabled {_gfec .Add_S ();};_gfec .Add_Q ();return _gfec .Bytes (),_gae .GetBoundingBox ().ToPdfRectangle (),nil ;};

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _ce .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _ce .PdfColor ;Opacity float64 ;};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_gfc Rectangle )ToPdfRectangle ()*_ce .PdfRectangle {return &_ce .PdfRectangle {Llx :_gfc .X ,Lly :_gfc .Y ,Urx :_gfc .X +_gfc .Width ,Ury :_gfc .Y +_gfc .Height };};

// Copy returns a clone of the path.
func (_cae Path )Copy ()Path {_eeg :=Path {};_eeg .Points =append (_eeg .Points ,_cae .Points ...);return _eeg ;};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_f :=CubicBezierCurve {};_f .P0 =NewPoint (x0 ,y0 );_f .P1 =NewPoint (x1 ,y1 );_f .P2 =NewPoint (x2 ,y2 );_f .P3 =NewPoint (x3 ,y3 );return _f ;};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _ce .PdfColor ;LineWidth float64 ;};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{

// Position and size properties.
X float64 ;Y float64 ;Width float64 ;Height float64 ;

// Fill properties.
FillEnabled bool ;FillColor _ce .PdfColor ;

// Border properties.
BorderEnabled bool ;BorderColor _ce .PdfColor ;BorderWidth float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;

// Shape opacity (0-1 interval).
Opacity float64 ;};

// Add adds the specified vector to the current one and returns the result.
func (_bae Vector )Add (other Vector )Vector {_bae .Dx +=other .Dx ;_bae .Dy +=other .Dy ;return _bae };

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_aeg BasicLine )Draw (gsName string )([]byte ,*_ce .PdfRectangle ,error ){_bcaf :=NewPath ();_bcaf =_bcaf .AppendPoint (NewPoint (_aeg .X1 ,_aeg .Y1 ));_bcaf =_bcaf .AppendPoint (NewPoint (_aeg .X2 ,_aeg .Y2 ));_agg :=_ge .NewContentCreator ();_agg .Add_q ().Add_w (_aeg .LineWidth ).SetStrokingColor (_aeg .LineColor );
if _aeg .LineStyle ==LineStyleDashed {if _aeg .DashArray ==nil {_aeg .DashArray =[]int64 {1,1};};_agg .Add_d (_aeg .DashArray ,_aeg .DashPhase );};if len (gsName )> 1{_agg .Add_gs (_b .PdfObjectName (gsName ));};DrawPathWithCreator (_bcaf ,_agg );_agg .Add_S ().Add_Q ();
return _agg .Bytes (),_bcaf .GetBoundingBox ().ToPdfRectangle (),nil ;};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_ge .ContentCreator ){for _bcg ,_gbf :=range path .Points {if _bcg ==0{creator .Add_m (_gbf .X ,_gbf .Y );}else {creator .Add_l (_gbf .X ,_gbf .Y );};};};

// FlipX flips the sign of the Dx component of the vector.
func (_bba Vector )FlipX ()Vector {_bba .Dx =-_bba .Dx ;return _bba };

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_ge .ContentCreator ){for _bfe ,_gec :=range bpath .Curves {if _bfe ==0{creator .Add_m (_gec .P0 .X ,_gec .P0 .Y );};creator .Add_c (_gec .P1 .X ,_gec .P1 .Y ,_gec .P2 .X ,_gec .P2 .Y ,_gec .P3 .X ,_gec .P3 .Y );
};};

// LineStyle refers to how the line will be created.
type LineStyle int ;

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_bgd Point )Add (dx ,dy float64 )Point {_bgd .X +=dx ;_bgd .Y +=dy ;return _bgd };

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_ff Path )RemovePoint (number int )Path {if number < 1||number > len (_ff .Points ){return _ff ;};_ae :=number -1;_ff .Points =append (_ff .Points [:_ae ],_ff .Points [_ae +1:]...);return _ff ;};

// Length returns the number of points in the path.
func (_cf Path )Length ()int {return len (_cf .Points )};

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_dfg Line )Draw (gsName string )([]byte ,*_ce .PdfRectangle ,error ){_gfba ,_be :=_dfg .X1 ,_dfg .X2 ;_ggf ,_fa :=_dfg .Y1 ,_dfg .Y2 ;_cbg :=_fa -_ggf ;_bdc :=_be -_gfba ;_dcf :=_g .Atan2 (_cbg ,_bdc );L :=_g .Sqrt (_g .Pow (_bdc ,2.0)+_g .Pow (_cbg ,2.0));
_eae :=_dfg .LineWidth ;_beg :=_g .Pi ;_cdd :=1.0;if _bdc < 0{_cdd *=-1.0;};if _cbg < 0{_cdd *=-1.0;};VsX :=_cdd *(-_eae /2*_g .Cos (_dcf +_beg /2));VsY :=_cdd *(-_eae /2*_g .Sin (_dcf +_beg /2)+_eae *_g .Sin (_dcf +_beg /2));V1X :=VsX +_eae /2*_g .Cos (_dcf +_beg /2);
V1Y :=VsY +_eae /2*_g .Sin (_dcf +_beg /2);V2X :=VsX +_eae /2*_g .Cos (_dcf +_beg /2)+L *_g .Cos (_dcf );V2Y :=VsY +_eae /2*_g .Sin (_dcf +_beg /2)+L *_g .Sin (_dcf );V3X :=VsX +_eae /2*_g .Cos (_dcf +_beg /2)+L *_g .Cos (_dcf )+_eae *_g .Cos (_dcf -_beg /2);
V3Y :=VsY +_eae /2*_g .Sin (_dcf +_beg /2)+L *_g .Sin (_dcf )+_eae *_g .Sin (_dcf -_beg /2);V4X :=VsX +_eae /2*_g .Cos (_dcf -_beg /2);V4Y :=VsY +_eae /2*_g .Sin (_dcf -_beg /2);_cfe :=NewPath ();_cfe =_cfe .AppendPoint (NewPoint (V1X ,V1Y ));_cfe =_cfe .AppendPoint (NewPoint (V2X ,V2Y ));
_cfe =_cfe .AppendPoint (NewPoint (V3X ,V3Y ));_cfe =_cfe .AppendPoint (NewPoint (V4X ,V4Y ));_cfa :=_dfg .LineEndingStyle1 ;_gc :=_dfg .LineEndingStyle2 ;_bee :=3*_eae ;_faa :=3*_eae ;_af :=(_faa -_eae )/2;if _gc ==LineEndingStyleArrow {_aee :=_cfe .GetPointNumber (2);
_bfd :=NewVectorPolar (_bee ,_dcf +_beg );_aff :=_aee .AddVector (_bfd );_eegf :=NewVectorPolar (_faa /2,_dcf +_beg /2);_aeb :=NewVectorPolar (_bee ,_dcf );_gbd :=NewVectorPolar (_af ,_dcf +_beg /2);_bff :=_aff .AddVector (_gbd );_caed :=_aeb .Add (_eegf .Flip ());
_bed :=_bff .AddVector (_caed );_fgb :=_eegf .Scale (2).Flip ().Add (_caed .Flip ());_gaa :=_bed .AddVector (_fgb );_ace :=_aff .AddVector (NewVectorPolar (_eae ,_dcf -_beg /2));_dee :=NewPath ();_dee =_dee .AppendPoint (_cfe .GetPointNumber (1));_dee =_dee .AppendPoint (_aff );
_dee =_dee .AppendPoint (_bff );_dee =_dee .AppendPoint (_bed );_dee =_dee .AppendPoint (_gaa );_dee =_dee .AppendPoint (_ace );_dee =_dee .AppendPoint (_cfe .GetPointNumber (4));_cfe =_dee ;};if _cfa ==LineEndingStyleArrow {_aae :=_cfe .GetPointNumber (1);
_ec :=_cfe .GetPointNumber (_cfe .Length ());_dbd :=NewVectorPolar (_eae /2,_dcf +_beg +_beg /2);_ba :=_aae .AddVector (_dbd );_cefb :=NewVectorPolar (_bee ,_dcf ).Add (NewVectorPolar (_faa /2,_dcf +_beg /2));_bea :=_ba .AddVector (_cefb );_eea :=NewVectorPolar (_af ,_dcf -_beg /2);
_dbe :=_bea .AddVector (_eea );_dfb :=NewVectorPolar (_bee ,_dcf );_bcd :=_ec .AddVector (_dfb );_egb :=NewVectorPolar (_af ,_dcf +_beg +_beg /2);_cgdf :=_bcd .AddVector (_egb );_fce :=_ba ;_adc :=NewPath ();_adc =_adc .AppendPoint (_ba );_adc =_adc .AppendPoint (_bea );
_adc =_adc .AppendPoint (_dbe );for _ ,_cdag :=range _cfe .Points [1:len (_cfe .Points )-1]{_adc =_adc .AppendPoint (_cdag );};_adc =_adc .AppendPoint (_bcd );_adc =_adc .AppendPoint (_cgdf );_adc =_adc .AppendPoint (_fce );_cfe =_adc ;};_fab :=_ge .NewContentCreator ();
_fab .Add_q ().SetNonStrokingColor (_dfg .LineColor );if len (gsName )> 1{_fab .Add_gs (_b .PdfObjectName (gsName ));};_cfe =_cfe .Offset (_dfg .X1 ,_dfg .Y1 );_aad :=_cfe .GetBoundingBox ();DrawPathWithCreator (_cfe ,_fab );if _dfg .LineStyle ==LineStyleDashed {_fab .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_fab .Add_f ().Add_Q ();};return _fab .Bytes (),_aad .ToPdfRectangle (),nil ;};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _ce .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;DashArray []int64 ;DashPhase int64 ;};

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _ce .PdfColor ;BorderEnabled bool ;BorderColor _ce .PdfColor ;BorderWidth float64 ;};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_cef BoundingBox )ToPdfRectangle ()*_ce .PdfRectangle {return &_ce .PdfRectangle {Llx :_cef .X ,Lly :_cef .Y ,Urx :_cef .X +_cef .Width ,Ury :_cef .Y +_cef .Height };};

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_fd Point )Rotate (theta float64 )Point {_bce :=_cb .NewPoint (_fd .X ,_fd .Y ).Rotate (theta );return NewPoint (_bce .X ,_bce .Y );};

// AppendPoint adds the specified point to the path.
func (_aa Path )AppendPoint (point Point )Path {_aa .Points =append (_aa .Points ,point );return _aa };

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_a :=CubicBezierPath {};_a .Curves =[]CubicBezierCurve {};return _a ;};

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// Offset shifts the path with the specified offsets.
func (_gea Path )Offset (offX ,offY float64 )Path {for _gfb ,_cg :=range _gea .Points {_gea .Points [_gfb ]=_cg .Add (offX ,offY );};return _gea ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};