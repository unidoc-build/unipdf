//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_a "fmt";_ef "github.com/unidoc/unipdf/v3/contentstream";_ed "github.com/unidoc/unipdf/v3/core";_f "github.com/unidoc/unipdf/v3/internal/transform";_ead "github.com/unidoc/unipdf/v3/model";_ea "math";);

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_cga :=Vector {};_cga .Dx =dx ;_cga .Dy =dy ;return _cga };

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_ad :=CubicBezierCurve {};_ad .P0 =NewPoint (x0 ,y0 );_ad .P1 =NewPoint (x1 ,y1 );_ad .P2 =NewPoint (x2 ,y2 );_ad .P3 =NewPoint (x3 ,y3 );return _ad ;};

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_b CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_b .P0 .X +=offX ;_b .P1 .X +=offX ;_b .P2 .X +=offX ;_b .P3 .X +=offX ;_b .P0 .Y +=offY ;_b .P1 .Y +=offY ;_b .P2 .Y +=offY ;_b .P3 .Y +=offY ;return _b ;};

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// Length returns the number of points in the path.
func (_eac Path )Length ()int {return len (_eac .Points )};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_baf :=Vector {};_baf .Dx =b .X -a .X ;_baf .Dy =b .Y -a .Y ;return _baf ;};

// LineStyle refers to how the line will be created.
type LineStyle int ;

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_egaa Point )Rotate (theta float64 )Point {_ee :=_f .NewPoint (_egaa .X ,_egaa .Y ).Rotate (theta );return NewPoint (_ee .X ,_ee .Y );};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_cgf BasicLine )Draw (gsName string )([]byte ,*_ead .PdfRectangle ,error ){_dbg :=_cgf .LineWidth ;_fad :=NewPath ();_fad =_fad .AppendPoint (NewPoint (_cgf .X1 ,_cgf .Y1 ));_fad =_fad .AppendPoint (NewPoint (_cgf .X2 ,_cgf .Y2 ));_dag :=_ef .NewContentCreator ();
_cfbb :=_fad .GetBoundingBox ();DrawPathWithCreator (_fad ,_dag );if _cgf .LineStyle ==LineStyleDashed {_dag .Add_d ([]int64 {1,1},0);};_dag .SetStrokingColor (_cgf .LineColor ).Add_w (_dbg ).Add_S ().Add_Q ();return _dag .Bytes (),_cfbb .ToPdfRectangle (),nil ;
};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_fa Path )RemovePoint (number int )Path {if number < 1||number > len (_fa .Points ){return _fa ;};_fc :=number -1;_fa .Points =append (_fa .Points [:_fc ],_fa .Points [_fc +1:]...);return _fa ;};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor _ead .PdfColor ;BorderEnabled bool ;BorderColor _ead .PdfColor ;BorderWidth float64 ;};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_fe :=CubicBezierPath {};_fe .Curves =[]CubicBezierCurve {};return _fe ;};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_deg :=Vector {};_deg .Dx =length *_ea .Cos (theta );_deg .Dy =length *_ea .Sin (theta );return _deg ;};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _ead .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _ead .PdfColor ;Opacity float64 ;};

// CurvePolygon is a multi-point shape with rings containing curves that can be
// drawn to a PDF content stream.
type CurvePolygon struct{Rings [][]CubicBezierCurve ;FillEnabled bool ;FillColor _ead .PdfColor ;BorderEnabled bool ;BorderColor _ead .PdfColor ;BorderWidth float64 ;};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_ede CubicBezierPath )GetBoundingBox ()Rectangle {_bf :=Rectangle {};_bc :=0.0;_da :=0.0;_ff :=0.0;_ec :=0.0;for _bd ,_ga :=range _ede .Curves {_ac :=_ga .GetBounds ();if _bd ==0{_bc =_ac .Llx ;_da =_ac .Urx ;_ff =_ac .Lly ;_ec =_ac .Ury ;continue ;
};if _ac .Llx < _bc {_bc =_ac .Llx ;};if _ac .Urx > _da {_da =_ac .Urx ;};if _ac .Lly < _ff {_ff =_ac .Lly ;};if _ac .Ury > _ec {_ec =_ac .Ury ;};};_bf .X =_bc ;_bf .Y =_ff ;_bf .Width =_da -_bc ;_bf .Height =_ec -_ff ;return _bf ;};

// FlipY flips the sign of the Dy component of the vector.
func (_bdg Vector )FlipY ()Vector {_bdg .Dy =-_bdg .Dy ;return _bdg };

// Scale scales the vector by the specified factor.
func (_add Vector )Scale (factor float64 )Vector {_gbdd :=_add .Magnitude ();_acf :=_add .GetPolarAngle ();_add .Dx =factor *_gbdd *_ea .Cos (_acf );_add .Dy =factor *_gbdd *_ea .Sin (_acf );return _add ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_gfba Vector )GetPolarAngle ()float64 {return _ea .Atan2 (_gfba .Dy ,_gfba .Dx )};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// Copy returns a clone of the path.
func (_df Path )Copy ()Path {_bb :=Path {};_bb .Points =append (_bb .Points ,_df .Points ...);return _bb ;};

// Draw draws the composite curve polygon. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array
// and the bounding box of the polygon.
func (_deb CurvePolygon )Draw (gsName string )([]byte ,*_ead .PdfRectangle ,error ){_bcf :=_ef .NewContentCreator ();_bcf .Add_q ();_deb .FillEnabled =_deb .FillEnabled &&_deb .FillColor !=nil ;if _deb .FillEnabled {_bcf .SetNonStrokingColor (_deb .FillColor );
};_deb .BorderEnabled =_deb .BorderEnabled &&_deb .BorderColor !=nil ;if _deb .BorderEnabled {_bcf .SetStrokingColor (_deb .BorderColor );_bcf .Add_w (_deb .BorderWidth );};if len (gsName )> 1{_bcf .Add_gs (_ed .PdfObjectName (gsName ));};_daa :=NewCubicBezierPath ();
for _ ,_ffg :=range _deb .Rings {for _ffe ,_aa :=range _ffg {if _ffe ==0{_bcf .Add_m (_aa .P0 .X ,_aa .P0 .Y );}else {_bcf .Add_l (_aa .P0 .X ,_aa .P0 .Y );};_bcf .Add_c (_aa .P1 .X ,_aa .P1 .Y ,_aa .P2 .X ,_aa .P2 .Y ,_aa .P3 .X ,_aa .P3 .Y );_daa =_daa .AppendCurve (_aa );
};_bcf .Add_h ();};if _deb .FillEnabled &&_deb .BorderEnabled {_bcf .Add_B ();}else if _deb .FillEnabled {_bcf .Add_f ();}else if _deb .BorderEnabled {_bcf .Add_S ();};_bcf .Add_Q ();return _bcf .Bytes (),_daa .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_eab PolyBezierCurve )Draw (gsName string )([]byte ,*_ead .PdfRectangle ,error ){if _eab .BorderColor ==nil {_eab .BorderColor =_ead .NewPdfColorDeviceRGB (0,0,0);};_ged :=NewCubicBezierPath ();for _ ,_bae :=range _eab .Curves {_ged =_ged .AppendCurve (_bae );
};_gbge :=_ef .NewContentCreator ();_gbge .Add_q ();_eab .FillEnabled =_eab .FillEnabled &&_eab .FillColor !=nil ;if _eab .FillEnabled {_gbge .SetNonStrokingColor (_eab .FillColor );};_gbge .SetStrokingColor (_eab .BorderColor );_gbge .Add_w (_eab .BorderWidth );
if len (gsName )> 1{_gbge .Add_gs (_ed .PdfObjectName (gsName ));};for _adc ,_dfa :=range _ged .Curves {if _adc ==0{_gbge .Add_m (_dfa .P0 .X ,_dfa .P0 .Y );}else {_gbge .Add_l (_dfa .P0 .X ,_dfa .P0 .Y );};_gbge .Add_c (_dfa .P1 .X ,_dfa .P1 .Y ,_dfa .P2 .X ,_dfa .P2 .Y ,_dfa .P3 .X ,_dfa .P3 .Y );
};if _eab .FillEnabled {_gbge .Add_h ();_gbge .Add_B ();}else {_gbge .Add_S ();};_gbge .Add_Q ();return _gbge .Bytes (),_ged .GetBoundingBox ().ToPdfRectangle (),nil ;};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_cbc BoundingBox )ToPdfRectangle ()*_ead .PdfRectangle {return &_ead .PdfRectangle {Llx :_cbc .X ,Lly :_cbc .Y ,Urx :_cbc .X +_cbc .Width ,Ury :_cbc .Y +_cbc .Height };};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_bag Rectangle )ToPdfRectangle ()*_ead .PdfRectangle {return &_ead .PdfRectangle {Llx :_bag .X ,Lly :_bag .Y ,Urx :_bag .X +_bag .Width ,Ury :_bag .Y +_bag .Height };};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_ef .ContentCreator ){for _efa ,_bdd :=range path .Points {if _efa ==0{creator .Add_m (_bdd .X ,_bdd .Y );}else {creator .Add_l (_bdd .X ,_bdd .Y );};};};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_ca Point )Add (dx ,dy float64 )Point {_ca .X +=dx ;_ca .Y +=dy ;return _ca };

// Offset shifts the Bezier path with the specified offsets.
func (_efc CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _gb ,_ega :=range _efc .Curves {_efc .Curves [_gb ]=_ega .AddOffsetXY (offX ,offY );};return _efc ;};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor _ead .PdfColor ;FillEnabled bool ;FillColor _ead .PdfColor ;};

// Add adds the specified vector to the current one and returns the result.
func (_aec Vector )Add (other Vector )Vector {_aec .Dx +=other .Dx ;_aec .Dy +=other .Dy ;return _aec };

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_gbg Path )GetPointNumber (number int )Point {if number < 1||number > len (_gbg .Points ){return Point {};};return _gbg .Points [number -1];};

// Copy returns a clone of the Bezier path.
func (_cf CubicBezierPath )Copy ()CubicBezierPath {_dg :=CubicBezierPath {};_dg .Curves =append (_dg .Curves ,_cf .Curves ...);return _dg ;};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _ead .PdfColor ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;};

// Magnitude returns the magnitude of the vector.
func (_gcg Vector )Magnitude ()float64 {return _ea .Sqrt (_ea .Pow (_gcg .Dx ,2.0)+_ea .Pow (_gcg .Dy ,2.0));};

// AddVector adds vector to a point.
func (_gfb Point )AddVector (v Vector )Point {_gfb .X +=v .Dx ;_gfb .Y +=v .Dy ;return _gfb };

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_cd Line )Draw (gsName string )([]byte ,*_ead .PdfRectangle ,error ){_eaa ,_aca :=_cd .X1 ,_cd .X2 ;_fag ,_gab :=_cd .Y1 ,_cd .Y2 ;_fab :=_gab -_fag ;_egb :=_aca -_eaa ;_cbf :=_ea .Atan2 (_fab ,_egb );L :=_ea .Sqrt (_ea .Pow (_egb ,2.0)+_ea .Pow (_fab ,2.0));
_be :=_cd .LineWidth ;_geg :=_ea .Pi ;_bced :=1.0;if _egb < 0{_bced *=-1.0;};if _fab < 0{_bced *=-1.0;};VsX :=_bced *(-_be /2*_ea .Cos (_cbf +_geg /2));VsY :=_bced *(-_be /2*_ea .Sin (_cbf +_geg /2)+_be *_ea .Sin (_cbf +_geg /2));V1X :=VsX +_be /2*_ea .Cos (_cbf +_geg /2);
V1Y :=VsY +_be /2*_ea .Sin (_cbf +_geg /2);V2X :=VsX +_be /2*_ea .Cos (_cbf +_geg /2)+L *_ea .Cos (_cbf );V2Y :=VsY +_be /2*_ea .Sin (_cbf +_geg /2)+L *_ea .Sin (_cbf );V3X :=VsX +_be /2*_ea .Cos (_cbf +_geg /2)+L *_ea .Cos (_cbf )+_be *_ea .Cos (_cbf -_geg /2);
V3Y :=VsY +_be /2*_ea .Sin (_cbf +_geg /2)+L *_ea .Sin (_cbf )+_be *_ea .Sin (_cbf -_geg /2);V4X :=VsX +_be /2*_ea .Cos (_cbf -_geg /2);V4Y :=VsY +_be /2*_ea .Sin (_cbf -_geg /2);_ceg :=NewPath ();_ceg =_ceg .AppendPoint (NewPoint (V1X ,V1Y ));_ceg =_ceg .AppendPoint (NewPoint (V2X ,V2Y ));
_ceg =_ceg .AppendPoint (NewPoint (V3X ,V3Y ));_ceg =_ceg .AppendPoint (NewPoint (V4X ,V4Y ));_acg :=_cd .LineEndingStyle1 ;_bfc :=_cd .LineEndingStyle2 ;_aeg :=3*_be ;_fcb :=3*_be ;_cfb :=(_fcb -_be )/2;if _bfc ==LineEndingStyleArrow {_ecc :=_ceg .GetPointNumber (2);
_fef :=NewVectorPolar (_aeg ,_cbf +_geg );_fd :=_ecc .AddVector (_fef );_egaf :=NewVectorPolar (_fcb /2,_cbf +_geg /2);_dab :=NewVectorPolar (_aeg ,_cbf );_cg :=NewVectorPolar (_cfb ,_cbf +_geg /2);_agf :=_fd .AddVector (_cg );_bbf :=_dab .Add (_egaf .Flip ());
_gg :=_agf .AddVector (_bbf );_afe :=_egaf .Scale (2).Flip ().Add (_bbf .Flip ());_cff :=_gg .AddVector (_afe );_acb :=_fd .AddVector (NewVectorPolar (_be ,_cbf -_geg /2));_caf :=NewPath ();_caf =_caf .AppendPoint (_ceg .GetPointNumber (1));_caf =_caf .AppendPoint (_fd );
_caf =_caf .AppendPoint (_agf );_caf =_caf .AppendPoint (_gg );_caf =_caf .AppendPoint (_cff );_caf =_caf .AppendPoint (_acb );_caf =_caf .AppendPoint (_ceg .GetPointNumber (4));_ceg =_caf ;};if _acg ==LineEndingStyleArrow {_dc :=_ceg .GetPointNumber (1);
_fdb :=_ceg .GetPointNumber (_ceg .Length ());_cgd :=NewVectorPolar (_be /2,_cbf +_geg +_geg /2);_dge :=_dc .AddVector (_cgd );_bde :=NewVectorPolar (_aeg ,_cbf ).Add (NewVectorPolar (_fcb /2,_cbf +_geg /2));_fba :=_dge .AddVector (_bde );_cdg :=NewVectorPolar (_cfb ,_cbf -_geg /2);
_daf :=_fba .AddVector (_cdg );_bdf :=NewVectorPolar (_aeg ,_cbf );_bfd :=_fdb .AddVector (_bdf );_fgc :=NewVectorPolar (_cfb ,_cbf +_geg +_geg /2);_cgg :=_bfd .AddVector (_fgc );_cab :=_dge ;_bfdd :=NewPath ();_bfdd =_bfdd .AppendPoint (_dge );_bfdd =_bfdd .AppendPoint (_fba );
_bfdd =_bfdd .AppendPoint (_daf );for _ ,_fce :=range _ceg .Points [1:len (_ceg .Points )-1]{_bfdd =_bfdd .AppendPoint (_fce );};_bfdd =_bfdd .AppendPoint (_bfd );_bfdd =_bfdd .AppendPoint (_cgg );_bfdd =_bfdd .AppendPoint (_cab );_ceg =_bfdd ;};_dabf :=_ef .NewContentCreator ();
_dabf .Add_q ().SetNonStrokingColor (_cd .LineColor );if len (gsName )> 1{_dabf .Add_gs (_ed .PdfObjectName (gsName ));};_ceg =_ceg .Offset (_cd .X1 ,_cd .Y1 );_cbe :=_ceg .GetBoundingBox ();DrawPathWithCreator (_ceg ,_dabf );if _cd .LineStyle ==LineStyleDashed {_dabf .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();
}else {_dabf .Add_f ().Add_Q ();};return _dabf .Bytes (),_cbe .ToPdfRectangle (),nil ;};

// Draw draws the rectangle. Can specify a graphics state (gsName) for setting opacity etc.
// Otherwise leave empty (""). Returns the content stream as a byte array, bounding box and an error on failure.
func (_efe Rectangle )Draw (gsName string )([]byte ,*_ead .PdfRectangle ,error ){_feg :=NewPath ();_feg =_feg .AppendPoint (NewPoint (0,0));_feg =_feg .AppendPoint (NewPoint (0,_efe .Height ));_feg =_feg .AppendPoint (NewPoint (_efe .Width ,_efe .Height ));
_feg =_feg .AppendPoint (NewPoint (_efe .Width ,0));_feg =_feg .AppendPoint (NewPoint (0,0));if _efe .X !=0||_efe .Y !=0{_feg =_feg .Offset (_efe .X ,_efe .Y );};_dfb :=_ef .NewContentCreator ();_dfb .Add_q ();if _efe .FillEnabled {_dfb .SetNonStrokingColor (_efe .FillColor );
};if _efe .BorderEnabled {_dfb .SetStrokingColor (_efe .BorderColor );_dfb .Add_w (_efe .BorderWidth );};if len (gsName )> 1{_dfb .Add_gs (_ed .PdfObjectName (gsName ));};DrawPathWithCreator (_feg ,_dfb );_dfb .Add_h ();if _efe .FillEnabled &&_efe .BorderEnabled {_dfb .Add_B ();
}else if _efe .FillEnabled {_dfb .Add_f ();}else if _efe .BorderEnabled {_dfb .Add_S ();};_dfb .Add_Q ();return _dfb .Bytes (),_feg .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor _ead .PdfColor ;BorderEnabled bool ;BorderWidth float64 ;BorderColor _ead .PdfColor ;Opacity float64 ;};

// AppendCurve appends the specified Bezier curve to the path.
func (_eg CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_eg .Curves =append (_eg .Curves ,curve );return _eg ;};const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;LineEndingStyleButt LineEndingStyle =2;
);

// Flip changes the sign of the vector: -vector.
func (_gdc Vector )Flip ()Vector {_ecb :=_gdc .Magnitude ();_adce :=_gdc .GetPolarAngle ();_gdc .Dx =_ecb *_ea .Cos (_adce +_ea .Pi );_gdc .Dy =_ecb *_ea .Sin (_adce +_ea .Pi );return _gdc ;};

// GetBounds returns the bounding box of the Bezier curve.
func (_fg CubicBezierCurve )GetBounds ()_ead .PdfRectangle {_d :=_fg .P0 .X ;_g :=_fg .P0 .X ;_de :=_fg .P0 .Y ;_c :=_fg .P0 .Y ;for _gf :=0.0;_gf <=1.0;_gf +=0.001{Rx :=_fg .P0 .X *_ea .Pow (1-_gf ,3)+_fg .P1 .X *3*_gf *_ea .Pow (1-_gf ,2)+_fg .P2 .X *3*_ea .Pow (_gf ,2)*(1-_gf )+_fg .P3 .X *_ea .Pow (_gf ,3);
Ry :=_fg .P0 .Y *_ea .Pow (1-_gf ,3)+_fg .P1 .Y *3*_gf *_ea .Pow (1-_gf ,2)+_fg .P2 .Y *3*_ea .Pow (_gf ,2)*(1-_gf )+_fg .P3 .Y *_ea .Pow (_gf ,3);if Rx < _d {_d =Rx ;};if Rx > _g {_g =Rx ;};if Ry < _de {_de =Ry ;};if Ry > _c {_c =Ry ;};};_adg :=_ead .PdfRectangle {};
_adg .Llx =_d ;_adg .Lly =_de ;_adg .Urx =_g ;_adg .Ury =_c ;return _adg ;};

// GetBoundingBox returns the bounding box of the path.
func (_cb Path )GetBoundingBox ()BoundingBox {_ae :=BoundingBox {};_ffc :=0.0;_ce :=0.0;_gff :=0.0;_fb :=0.0;for _ecf ,_ba :=range _cb .Points {if _ecf ==0{_ffc =_ba .X ;_ce =_ba .X ;_gff =_ba .Y ;_fb =_ba .Y ;continue ;};if _ba .X < _ffc {_ffc =_ba .X ;
};if _ba .X > _ce {_ce =_ba .X ;};if _ba .Y < _gff {_gff =_ba .Y ;};if _ba .Y > _fb {_fb =_ba .Y ;};};_ae .X =_ffc ;_ae .Y =_gff ;_ae .Width =_ce -_ffc ;_ae .Height =_fb -_gff ;return _ae ;};

// Offset shifts the path with the specified offsets.
func (_ag Path )Offset (offX ,offY float64 )Path {for _gac ,_bce :=range _ag .Points {_ag .Points [_gac ]=_bce .Add (offX ,offY );};return _ag ;};const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;);

// Rotate rotates the vector by the specified angle.
func (_gc Vector )Rotate (phi float64 )Vector {_bagc :=_gc .Magnitude ();_ece :=_gc .GetPolarAngle ();return NewVectorPolar (_bagc ,_ece +phi );};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor _ead .PdfColor ;LineWidth float64 ;};

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};

// FlipX flips the sign of the Dx component of the vector.
func (_bdb Vector )FlipX ()Vector {_bdb .Dx =-_bdb .Dx ;return _bdb };

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_dagc Polyline )Draw (gsName string )([]byte ,*_ead .PdfRectangle ,error ){if _dagc .LineColor ==nil {_dagc .LineColor =_ead .NewPdfColorDeviceRGB (0,0,0);};_bg :=NewPath ();for _ ,_bgb :=range _dagc .Points {_bg =_bg .AppendPoint (_bgb );};_ecgb :=_ef .NewContentCreator ();
_ecgb .Add_q ().SetStrokingColor (_dagc .LineColor ).Add_w (_dagc .LineWidth );if len (gsName )> 1{_ecgb .Add_gs (_ed .PdfObjectName (gsName ));};DrawPathWithCreator (_bg ,_ecgb );_ecgb .Add_S ();_ecgb .Add_Q ();return _ecgb .Bytes (),_bg .GetBoundingBox ().ToPdfRectangle (),nil ;
};

// AppendPoint adds the specified point to the path.
func (_db Path )AppendPoint (point Point )Path {_db .Points =append (_db .Points ,point );return _db };

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_ef .ContentCreator ){for _agb ,_eadg :=range bpath .Curves {if _agb ==0{creator .Add_m (_eadg .P0 .X ,_eadg .P0 .Y );};creator .Add_c (_eadg .P1 .X ,_eadg .P1 .Y ,_eadg .P2 .X ,_eadg .P2 .Y ,_eadg .P3 .X ,_eadg .P3 .Y );
};};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_gbd Circle )Draw (gsName string )([]byte ,*_ead .PdfRectangle ,error ){_bcd :=_gbd .Width /2;_cbb :=_gbd .Height /2;if _gbd .BorderEnabled {_bcd -=_gbd .BorderWidth /2;_cbb -=_gbd .BorderWidth /2;};_fae :=0.551784;_gbc :=_bcd *_fae ;_cc :=_cbb *_fae ;
_ge :=NewCubicBezierPath ();_ge =_ge .AppendCurve (NewCubicBezierCurve (-_bcd ,0,-_bcd ,_cc ,-_gbc ,_cbb ,0,_cbb ));_ge =_ge .AppendCurve (NewCubicBezierCurve (0,_cbb ,_gbc ,_cbb ,_bcd ,_cc ,_bcd ,0));_ge =_ge .AppendCurve (NewCubicBezierCurve (_bcd ,0,_bcd ,-_cc ,_gbc ,-_cbb ,0,-_cbb ));
_ge =_ge .AppendCurve (NewCubicBezierCurve (0,-_cbb ,-_gbc ,-_cbb ,-_bcd ,-_cc ,-_bcd ,0));_ge =_ge .Offset (_bcd ,_cbb );if _gbd .BorderEnabled {_ge =_ge .Offset (_gbd .BorderWidth /2,_gbd .BorderWidth /2);};if _gbd .X !=0||_gbd .Y !=0{_ge =_ge .Offset (_gbd .X ,_gbd .Y );
};_cae :=_ef .NewContentCreator ();_cae .Add_q ();if _gbd .FillEnabled {_cae .SetNonStrokingColor (_gbd .FillColor );};if _gbd .BorderEnabled {_cae .SetStrokingColor (_gbd .BorderColor );_cae .Add_w (_gbd .BorderWidth );};if len (gsName )> 1{_cae .Add_gs (_ed .PdfObjectName (gsName ));
};DrawBezierPathWithCreator (_ge ,_cae );_cae .Add_h ();if _gbd .FillEnabled &&_gbd .BorderEnabled {_cae .Add_B ();}else if _gbd .FillEnabled {_cae .Add_f ();}else if _gbd .BorderEnabled {_cae .Add_S ();};_cae .Add_Q ();_feb :=_ge .GetBoundingBox ();if _gbd .BorderEnabled {_feb .Height +=_gbd .BorderWidth ;
_feb .Width +=_gbd .BorderWidth ;_feb .X -=_gbd .BorderWidth /2;_feb .Y -=_gbd .BorderWidth /2;};return _cae .Bytes (),_feb .ToPdfRectangle (),nil ;};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_adb Polygon )Draw (gsName string )([]byte ,*_ead .PdfRectangle ,error ){_efg :=_ef .NewContentCreator ();_efg .Add_q ();_adb .FillEnabled =_adb .FillEnabled &&_adb .FillColor !=nil ;if _adb .FillEnabled {_efg .SetNonStrokingColor (_adb .FillColor );
};_adb .BorderEnabled =_adb .BorderEnabled &&_adb .BorderColor !=nil ;if _adb .BorderEnabled {_efg .SetStrokingColor (_adb .BorderColor );_efg .Add_w (_adb .BorderWidth );};if len (gsName )> 1{_efg .Add_gs (_ed .PdfObjectName (gsName ));};_ecg :=NewPath ();
for _ ,_ffd :=range _adb .Points {for _af ,_gd :=range _ffd {_ecg =_ecg .AppendPoint (_gd );if _af ==0{_efg .Add_m (_gd .X ,_gd .Y );}else {_efg .Add_l (_gd .X ,_gd .Y );};};_efg .Add_h ();};if _adb .FillEnabled &&_adb .BorderEnabled {_efg .Add_B ();}else if _adb .FillEnabled {_efg .Add_f ();
}else if _adb .BorderEnabled {_efg .Add_S ();};_efg .Add_Q ();return _efg .Bytes (),_ecg .GetBoundingBox ().ToPdfRectangle (),nil ;};func (_cfd Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_cfd .X ,_cfd .Y );
};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor _ead .PdfColor ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};