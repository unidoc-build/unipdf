//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package draw has handy features for defining paths which can be used to draw content on a PDF page.  Handles
// defining paths as points, vector calculations and conversion to PDF content stream data which can be used in
// page content streams and XObject forms and thus also in annotation appearance streams.
//
// Also defines utility functions for drawing common shapes such as rectangles, lines and circles (ovals).
package draw ;import (_f "fmt";_fc "github.com/unidoc/unipdf/v3/contentstream";_eg "github.com/unidoc/unipdf/v3/core";_fd "github.com/unidoc/unipdf/v3/internal/transform";_a "github.com/unidoc/unipdf/v3/model";_c "math";);

// Add adds the specified vector to the current one and returns the result.
func (_bab Vector )Add (other Vector )Vector {_bab .Dx +=other .Dx ;_bab .Dy +=other .Dy ;return _bab };

// CubicBezierPath represents a collection of cubic Bezier curves.
type CubicBezierPath struct{Curves []CubicBezierCurve ;};

// GetPolarAngle returns the angle the magnitude of the vector forms with the
// positive X-axis going counterclockwise.
func (_bbg Vector )GetPolarAngle ()float64 {return _c .Atan2 (_bbg .Dy ,_bbg .Dx )};

// RemovePoint removes the point at the index specified by number from the
// path. The index is 1-based.
func (_abb Path )RemovePoint (number int )Path {if number < 1||number > len (_abb .Points ){return _abb ;};_gc :=number -1;_abb .Points =append (_abb .Points [:_gc ],_abb .Points [_gc +1:]...);return _abb ;};

// Line defines a line shape between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
type Line struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor *_a .PdfColorDeviceRGB ;Opacity float64 ;LineWidth float64 ;LineEndingStyle1 LineEndingStyle ;LineEndingStyle2 LineEndingStyle ;LineStyle LineStyle ;};

// NewVectorBetween returns a new vector with the direction specified by
// the subtraction of point a from point b (b-a).
func NewVectorBetween (a Point ,b Point )Vector {_bcb :=Vector {};_bcb .Dx =b .X -a .X ;_bcb .Dy =b .Y -a .Y ;return _bcb ;};

// Add shifts the coordinates of the point with dx, dy and returns the result.
func (_ca Point )Add (dx ,dy float64 )Point {_ca .X +=dx ;_ca .Y +=dy ;return _ca };

// Rotate returns a new Point at `p` rotated by `theta` degrees.
func (_ggd Point )Rotate (theta float64 )Point {_gaa :=_fd .NewPoint (_ggd .X ,_ggd .Y ).Rotate (theta );return NewPoint (_gaa .X ,_gaa .Y );};

// NewVectorPolar returns a new vector calculated from the specified
// magnitude and angle.
func NewVectorPolar (length float64 ,theta float64 )Vector {_ebg :=Vector {};_ebg .Dx =length *_c .Cos (theta );_ebg .Dy =length *_c .Sin (theta );return _ebg ;};

// BasicLine defines a line between point 1 (X1,Y1) and point 2 (X2,Y2). The line has a specified width, color and opacity.
type BasicLine struct{X1 float64 ;Y1 float64 ;X2 float64 ;Y2 float64 ;LineColor *_a .PdfColorDeviceRGB ;Opacity float64 ;LineWidth float64 ;LineStyle LineStyle ;};

// AddVector adds vector to a point.
func (_eb Point )AddVector (v Vector )Point {_eb .X +=v .Dx ;_eb .Y +=v .Dy ;return _eb };

// Draw draws the line to PDF contentstream. Generates the content stream which can be used in page contents or
// appearance stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error
// if one occurred.
func (_fbfd Line )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_eaf ,_decd :=_fbfd .X1 ,_fbfd .X2 ;_age ,_gcf :=_fbfd .Y1 ,_fbfd .Y2 ;_bf :=_gcf -_age ;_cc :=_decd -_eaf ;_afb :=_c .Atan2 (_bf ,_cc );L :=_c .Sqrt (_c .Pow (_cc ,2.0)+_c .Pow (_bf ,2.0));_fgb :=_fbfd .LineWidth ;_daece :=_c .Pi ;_agc :=1.0;if _cc < 0{_agc *=-1.0;};if _bf < 0{_agc *=-1.0;};VsX :=_agc *(-_fgb /2*_c .Cos (_afb +_daece /2));VsY :=_agc *(-_fgb /2*_c .Sin (_afb +_daece /2)+_fgb *_c .Sin (_afb +_daece /2));V1X :=VsX +_fgb /2*_c .Cos (_afb +_daece /2);V1Y :=VsY +_fgb /2*_c .Sin (_afb +_daece /2);V2X :=VsX +_fgb /2*_c .Cos (_afb +_daece /2)+L *_c .Cos (_afb );V2Y :=VsY +_fgb /2*_c .Sin (_afb +_daece /2)+L *_c .Sin (_afb );V3X :=VsX +_fgb /2*_c .Cos (_afb +_daece /2)+L *_c .Cos (_afb )+_fgb *_c .Cos (_afb -_daece /2);V3Y :=VsY +_fgb /2*_c .Sin (_afb +_daece /2)+L *_c .Sin (_afb )+_fgb *_c .Sin (_afb -_daece /2);V4X :=VsX +_fgb /2*_c .Cos (_afb -_daece /2);V4Y :=VsY +_fgb /2*_c .Sin (_afb -_daece /2);_ebe :=NewPath ();_ebe =_ebe .AppendPoint (NewPoint (V1X ,V1Y ));_ebe =_ebe .AppendPoint (NewPoint (V2X ,V2Y ));_ebe =_ebe .AppendPoint (NewPoint (V3X ,V3Y ));_ebe =_ebe .AppendPoint (NewPoint (V4X ,V4Y ));_abab :=_fbfd .LineEndingStyle1 ;_aaa :=_fbfd .LineEndingStyle2 ;_adg :=3*_fgb ;_bcf :=3*_fgb ;_dbb :=(_bcf -_fgb )/2;if _aaa ==LineEndingStyleArrow {_bdg :=_ebe .GetPointNumber (2);_bea :=NewVectorPolar (_adg ,_afb +_daece );_gdb :=_bdg .AddVector (_bea );_faf :=NewVectorPolar (_bcf /2,_afb +_daece /2);_cgd :=NewVectorPolar (_adg ,_afb );_dcc :=NewVectorPolar (_dbb ,_afb +_daece /2);_gac :=_gdb .AddVector (_dcc );_dcg :=_cgd .Add (_faf .Flip ());_gda :=_gac .AddVector (_dcg );_fdd :=_faf .Scale (2).Flip ().Add (_dcg .Flip ());_bbc :=_gda .AddVector (_fdd );_ff :=_gdb .AddVector (NewVectorPolar (_fgb ,_afb -_daece /2));_gef :=NewPath ();_gef =_gef .AppendPoint (_ebe .GetPointNumber (1));_gef =_gef .AppendPoint (_gdb );_gef =_gef .AppendPoint (_gac );_gef =_gef .AppendPoint (_gda );_gef =_gef .AppendPoint (_bbc );_gef =_gef .AppendPoint (_ff );_gef =_gef .AppendPoint (_ebe .GetPointNumber (4));_ebe =_gef ;};if _abab ==LineEndingStyleArrow {_bdcc :=_ebe .GetPointNumber (1);_bg :=_ebe .GetPointNumber (_ebe .Length ());_afa :=NewVectorPolar (_fgb /2,_afb +_daece +_daece /2);_eag :=_bdcc .AddVector (_afa );_fga :=NewVectorPolar (_adg ,_afb ).Add (NewVectorPolar (_bcf /2,_afb +_daece /2));_fac :=_eag .AddVector (_fga );_agea :=NewVectorPolar (_dbb ,_afb -_daece /2);_df :=_fac .AddVector (_agea );_bdbb :=NewVectorPolar (_adg ,_afb );_dbbg :=_bg .AddVector (_bdbb );_agb :=NewVectorPolar (_dbb ,_afb +_daece +_daece /2);_gge :=_dbbg .AddVector (_agb );_faad :=_eag ;_adb :=NewPath ();_adb =_adb .AppendPoint (_eag );_adb =_adb .AppendPoint (_fac );_adb =_adb .AppendPoint (_df );for _ ,_eba :=range _ebe .Points [1:len (_ebe .Points )-1]{_adb =_adb .AppendPoint (_eba );};_adb =_adb .AppendPoint (_dbbg );_adb =_adb .AppendPoint (_gge );_adb =_adb .AppendPoint (_faad );_ebe =_adb ;};_cge :=_fc .NewContentCreator ();_cge .Add_q ().Add_rg (_fbfd .LineColor .R (),_fbfd .LineColor .G (),_fbfd .LineColor .B ());if len (gsName )> 1{_cge .Add_gs (_eg .PdfObjectName (gsName ));};_ebe =_ebe .Offset (_fbfd .X1 ,_fbfd .Y1 );_bag :=_ebe .GetBoundingBox ();DrawPathWithCreator (_ebe ,_cge );if _fbfd .LineStyle ==LineStyleDashed {_cge .Add_d ([]int64 {1,1},0).Add_S ().Add_f ().Add_Q ();}else {_cge .Add_f ().Add_Q ();};return _cge .Bytes (),_bag .ToPdfRectangle (),nil ;};

// ToPdfRectangle returns the bounding box as a PDF rectangle.
func (_edg BoundingBox )ToPdfRectangle ()*_a .PdfRectangle {return &_a .PdfRectangle {Llx :_edg .X ,Lly :_edg .Y ,Urx :_edg .X +_edg .Width ,Ury :_edg .Y +_edg .Height };};

// AddOffsetXY adds X,Y offset to all points on a curve.
func (_b CubicBezierCurve )AddOffsetXY (offX ,offY float64 )CubicBezierCurve {_b .P0 .X +=offX ;_b .P1 .X +=offX ;_b .P2 .X +=offX ;_b .P3 .X +=offX ;_b .P0 .Y +=offY ;_b .P1 .Y +=offY ;_b .P2 .Y +=offY ;_b .P3 .Y +=offY ;return _b ;};

// AppendCurve appends the specified Bezier curve to the path.
func (_af CubicBezierPath )AppendCurve (curve CubicBezierCurve )CubicBezierPath {_af .Curves =append (_af .Curves ,curve );return _af ;};

// Rectangle is a shape with a specified Width and Height and a lower left corner at (X,Y) that can be
// drawn to a PDF content stream.  The rectangle can optionally have a border and a filling color.
// The Width/Height includes the border (if any specified), i.e. is positioned inside.
type Rectangle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor *_a .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;BorderColor *_a .PdfColorDeviceRGB ;Opacity float64 ;};

// Draw draws the circle. Can specify a graphics state (gsName) for setting opacity etc.  Otherwise leave empty ("").
// Returns the content stream as a byte array, the bounding box and an error on failure.
func (_ged Circle )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_dec :=_ged .Width /2;_gd :=_ged .Height /2;if _ged .BorderEnabled {_dec -=_ged .BorderWidth /2;_gd -=_ged .BorderWidth /2;};_daf :=0.551784;_geb :=_dec *_daf ;_ea :=_gd *_daf ;_fbf :=NewCubicBezierPath ();_fbf =_fbf .AppendCurve (NewCubicBezierCurve (-_dec ,0,-_dec ,_ea ,-_geb ,_gd ,0,_gd ));_fbf =_fbf .AppendCurve (NewCubicBezierCurve (0,_gd ,_geb ,_gd ,_dec ,_ea ,_dec ,0));_fbf =_fbf .AppendCurve (NewCubicBezierCurve (_dec ,0,_dec ,-_ea ,_geb ,-_gd ,0,-_gd ));_fbf =_fbf .AppendCurve (NewCubicBezierCurve (0,-_gd ,-_geb ,-_gd ,-_dec ,-_ea ,-_dec ,0));_fbf =_fbf .Offset (_dec ,_gd );if _ged .BorderEnabled {_fbf =_fbf .Offset (_ged .BorderWidth /2,_ged .BorderWidth /2);};if _ged .X !=0||_ged .Y !=0{_fbf =_fbf .Offset (_ged .X ,_ged .Y );};_egg :=_fc .NewContentCreator ();_egg .Add_q ();if _ged .FillEnabled {_egg .Add_rg (_ged .FillColor .R (),_ged .FillColor .G (),_ged .FillColor .B ());};if _ged .BorderEnabled {_egg .Add_RG (_ged .BorderColor .R (),_ged .BorderColor .G (),_ged .BorderColor .B ());_egg .Add_w (_ged .BorderWidth );};if len (gsName )> 1{_egg .Add_gs (_eg .PdfObjectName (gsName ));};DrawBezierPathWithCreator (_fbf ,_egg );_egg .Add_h ();if _ged .FillEnabled &&_ged .BorderEnabled {_egg .Add_B ();}else if _ged .FillEnabled {_egg .Add_f ();}else if _ged .BorderEnabled {_egg .Add_S ();};_egg .Add_Q ();_gfd :=_fbf .GetBoundingBox ();if _ged .BorderEnabled {_gfd .Height +=_ged .BorderWidth ;_gfd .Width +=_ged .BorderWidth ;_gfd .X -=_ged .BorderWidth /2;_gfd .Y -=_ged .BorderWidth /2;};return _egg .Bytes (),_gfd .ToPdfRectangle (),nil ;};

// GetBoundingBox returns the bounding box of the Bezier path.
func (_da CubicBezierPath )GetBoundingBox ()Rectangle {_ce :=Rectangle {};_dad :=0.0;_fdb :=0.0;_dc :=0.0;_ag :=0.0;for _ga ,_fb :=range _da .Curves {_aga :=_fb .GetBounds ();if _ga ==0{_dad =_aga .Llx ;_fdb =_aga .Urx ;_dc =_aga .Lly ;_ag =_aga .Ury ;continue ;};if _aga .Llx < _dad {_dad =_aga .Llx ;};if _aga .Urx > _fdb {_fdb =_aga .Urx ;};if _aga .Lly < _dc {_dc =_aga .Lly ;};if _aga .Ury > _ag {_ag =_aga .Ury ;};};_ce .X =_dad ;_ce .Y =_dc ;_ce .Width =_fdb -_dad ;_ce .Height =_ag -_dc ;return _ce ;};

// Copy returns a clone of the path.
func (_aba Path )Copy ()Path {_gg :=Path {};_gg .Points =append (_gg .Points ,_aba .Points ...);return _gg ;};func (_dg Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0031\u0066\u002c\u0025\u002e\u0031\u0066\u0029",_dg .X ,_dg .Y );};

// GetBoundingBox returns the bounding box of the path.
func (_de Path )GetBoundingBox ()BoundingBox {_daec :=BoundingBox {};_ge :=0.0;_bb :=0.0;_ac :=0.0;_bdc :=0.0;for _aa ,_fad :=range _de .Points {if _aa ==0{_ge =_fad .X ;_bb =_fad .X ;_ac =_fad .Y ;_bdc =_fad .Y ;continue ;};if _fad .X < _ge {_ge =_fad .X ;};if _fad .X > _bb {_bb =_fad .X ;};if _fad .Y < _ac {_ac =_fad .Y ;};if _fad .Y > _bdc {_bdc =_fad .Y ;};};_daec .X =_ge ;_daec .Y =_ac ;_daec .Width =_bb -_ge ;_daec .Height =_bdc -_ac ;return _daec ;};

// Draw draws the rectangle. Can specify a graphics state (gsName) for setting opacity etc.
// Otherwise leave empty (""). Returns the content stream as a byte array, bounding box and an error on failure.
func (_ef Rectangle )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_db :=NewPath ();_db =_db .AppendPoint (NewPoint (0,0));_db =_db .AppendPoint (NewPoint (0,_ef .Height ));_db =_db .AppendPoint (NewPoint (_ef .Width ,_ef .Height ));_db =_db .AppendPoint (NewPoint (_ef .Width ,0));_db =_db .AppendPoint (NewPoint (0,0));if _ef .X !=0||_ef .Y !=0{_db =_db .Offset (_ef .X ,_ef .Y );};_dce :=_fc .NewContentCreator ();_dce .Add_q ();if _ef .FillEnabled {_dce .Add_rg (_ef .FillColor .R (),_ef .FillColor .G (),_ef .FillColor .B ());};if _ef .BorderEnabled {_dce .Add_RG (_ef .BorderColor .R (),_ef .BorderColor .G (),_ef .BorderColor .B ());_dce .Add_w (_ef .BorderWidth );};if len (gsName )> 1{_dce .Add_gs (_eg .PdfObjectName (gsName ));};DrawPathWithCreator (_db ,_dce );_dce .Add_h ();if _ef .FillEnabled &&_ef .BorderEnabled {_dce .Add_B ();}else if _ef .FillEnabled {_dce .Add_f ();}else if _ef .BorderEnabled {_dce .Add_S ();};_dce .Add_Q ();return _dce .Bytes (),_db .GetBoundingBox ().ToPdfRectangle (),nil ;};

// AppendPoint adds the specified point to the path.
func (_bd Path )AppendPoint (point Point )Path {_bd .Points =append (_bd .Points ,point );return _bd };

// LineEndingStyle defines the line ending style for lines.
// The currently supported line ending styles are None, Arrow (ClosedArrow) and Butt.
type LineEndingStyle int ;

// NewPath returns a new empty path.
func NewPath ()Path {return Path {}};

// Path consists of straight line connections between each point defined in an array of points.
type Path struct{Points []Point ;};

// FlipY flips the sign of the Dy component of the vector.
func (_dgfc Vector )FlipY ()Vector {_dgfc .Dy =-_dgfc .Dy ;return _dgfc };

// Draw draws the composite Bezier curve. A graphics state name can be
// specified for setting the curve properties (e.g. setting the opacity).
// Otherwise leave empty (""). Returns the content stream as a byte array and
// the curve bounding box.
func (_gga PolyBezierCurve )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){if _gga .BorderColor ==nil {_gga .BorderColor =_a .NewPdfColorDeviceRGB (0,0,0);};_ebd :=NewCubicBezierPath ();for _ ,_faa :=range _gga .Curves {_ebd =_ebd .AppendCurve (_faa );};_cb :=_fc .NewContentCreator ();_cb .Add_q ();_gga .FillEnabled =_gga .FillEnabled &&_gga .FillColor !=nil ;if _gga .FillEnabled {_cb .Add_rg (_gga .FillColor .R (),_gga .FillColor .G (),_gga .FillColor .B ());};_cb .Add_RG (_gga .BorderColor .R (),_gga .BorderColor .G (),_gga .BorderColor .B ());_cb .Add_w (_gga .BorderWidth );if len (gsName )> 1{_cb .Add_gs (_eg .PdfObjectName (gsName ));};for _ ,_bdb :=range _ebd .Curves {_cb .Add_m (_bdb .P0 .X ,_bdb .P0 .Y );_cb .Add_c (_bdb .P1 .X ,_bdb .P1 .Y ,_bdb .P2 .X ,_bdb .P2 .Y ,_bdb .P3 .X ,_bdb .P3 .Y );};if _gga .FillEnabled {_cb .Add_h ();_cb .Add_B ();}else {_cb .Add_S ();};_cb .Add_Q ();return _cb .Bytes (),_ebd .GetBoundingBox ().ToPdfRectangle (),nil ;};

// CubicBezierCurve is defined by:
// R(t) = P0*(1-t)^3 + P1*3*t*(1-t)^2 + P2*3*t^2*(1-t) + P3*t^3
// where P0 is the current point, P1, P2 control points and P3 the final point.
type CubicBezierCurve struct{P0 Point ;P1 Point ;P2 Point ;P3 Point ;};

// Length returns the number of points in the path.
func (_bac Path )Length ()int {return len (_bac .Points )};

// DrawBezierPathWithCreator makes the bezier path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawBezierPathWithCreator (bpath CubicBezierPath ,creator *_fc .ContentCreator ){for _dge ,_efg :=range bpath .Curves {if _dge ==0{creator .Add_m (_efg .P0 .X ,_efg .P0 .Y );};creator .Add_c (_efg .P1 .X ,_efg .P1 .Y ,_efg .P2 .X ,_efg .P2 .Y ,_efg .P3 .X ,_efg .P3 .Y );};};

// ToPdfRectangle returns the rectangle as a PDF rectangle.
func (_bbb Rectangle )ToPdfRectangle ()*_a .PdfRectangle {return &_a .PdfRectangle {Llx :_bbb .X ,Lly :_bbb .Y ,Urx :_bbb .X +_bbb .Width ,Ury :_bbb .Y +_bbb .Height };};

// Copy returns a clone of the Bezier path.
func (_be CubicBezierPath )Copy ()CubicBezierPath {_ad :=CubicBezierPath {};_ad .Curves =append (_ad .Curves ,_be .Curves ...);return _ad ;};

// LineStyle refers to how the line will be created.
type LineStyle int ;

// Rotate rotates the vector by the specified angle.
func (_adbe Vector )Rotate (phi float64 )Vector {_dd :=_adbe .Magnitude ();_cda :=_adbe .GetPolarAngle ();return NewVectorPolar (_dd ,_cda +phi );};

// Offset shifts the Bezier path with the specified offsets.
func (_d CubicBezierPath )Offset (offX ,offY float64 )CubicBezierPath {for _ae ,_gf :=range _d .Curves {_d .Curves [_ae ]=_gf .AddOffsetXY (offX ,offY );};return _d ;};

// Draw draws the basic line to PDF. Generates the content stream which can be used in page contents or appearance
// stream of annotation. Returns the stream content, XForm bounding box (local), bounding box and an error if
// one occurred.
func (_dgf BasicLine )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_dcf :=_dgf .LineWidth ;_cgec :=NewPath ();_cgec =_cgec .AppendPoint (NewPoint (_dgf .X1 ,_dgf .Y1 ));_cgec =_cgec .AppendPoint (NewPoint (_dgf .X2 ,_dgf .Y2 ));_cce :=_fc .NewContentCreator ();_fdde :=_cgec .GetBoundingBox ();DrawPathWithCreator (_cgec ,_cce );if _dgf .LineStyle ==LineStyleDashed {_cce .Add_d ([]int64 {1,1},0);};_cce .Add_RG (_dgf .LineColor .R (),_dgf .LineColor .G (),_dgf .LineColor .B ()).Add_w (_dcf ).Add_S ().Add_Q ();return _cce .Bytes (),_fdde .ToPdfRectangle (),nil ;};

// GetBounds returns the bounding box of the Bezier curve.
func (_ed CubicBezierCurve )GetBounds ()_a .PdfRectangle {_ab :=_ed .P0 .X ;_fg :=_ed .P0 .X ;_ec :=_ed .P0 .Y ;_ba :=_ed .P0 .Y ;for _fe :=0.0;_fe <=1.0;_fe +=0.001{Rx :=_ed .P0 .X *_c .Pow (1-_fe ,3)+_ed .P1 .X *3*_fe *_c .Pow (1-_fe ,2)+_ed .P2 .X *3*_c .Pow (_fe ,2)*(1-_fe )+_ed .P3 .X *_c .Pow (_fe ,3);Ry :=_ed .P0 .Y *_c .Pow (1-_fe ,3)+_ed .P1 .Y *3*_fe *_c .Pow (1-_fe ,2)+_ed .P2 .Y *3*_c .Pow (_fe ,2)*(1-_fe )+_ed .P3 .Y *_c .Pow (_fe ,3);if Rx < _ab {_ab =Rx ;};if Rx > _fg {_fg =Rx ;};if Ry < _ec {_ec =Ry ;};if Ry > _ba {_ba =Ry ;};};_g :=_a .PdfRectangle {};_g .Llx =_ab ;_g .Lly =_ec ;_g .Urx =_fg ;_g .Ury =_ba ;return _g ;};

// NewCubicBezierCurve returns a new cubic Bezier curve.
func NewCubicBezierCurve (x0 ,y0 ,x1 ,y1 ,x2 ,y2 ,x3 ,y3 float64 )CubicBezierCurve {_fa :=CubicBezierCurve {};_fa .P0 =NewPoint (x0 ,y0 );_fa .P1 =NewPoint (x1 ,y1 );_fa .P2 =NewPoint (x2 ,y2 );_fa .P3 =NewPoint (x3 ,y3 );return _fa ;};

// Vector represents a two-dimensional vector.
type Vector struct{Dx float64 ;Dy float64 ;};

// Offset shifts the path with the specified offsets.
func (_dae Path )Offset (offX ,offY float64 )Path {for _agg ,_cf :=range _dae .Points {_dae .Points [_agg ]=_cf .Add (offX ,offY );};return _dae ;};

// BoundingBox represents the smallest rectangular area that encapsulates an object.
type BoundingBox struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;};

// Point represents a two-dimensional point.
type Point struct{X float64 ;Y float64 ;};

// NewPoint returns a new point with the coordinates x, y.
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};

// NewVector returns a new vector with the direction specified by dx and dy.
func NewVector (dx ,dy float64 )Vector {_cbc :=Vector {};_cbc .Dx =dx ;_cbc .Dy =dy ;return _cbc };

// Polyline defines a slice of points that are connected as straight lines.
type Polyline struct{Points []Point ;LineColor *_a .PdfColorDeviceRGB ;LineWidth float64 ;};

// GetPointNumber returns the path point at the index specified by number.
// The index is 1-based.
func (_aed Path )GetPointNumber (number int )Point {if number < 1||number > len (_aed .Points ){return Point {};};return _aed .Points [number -1];};

// FlipX flips the sign of the Dx component of the vector.
func (_feb Vector )FlipX ()Vector {_feb .Dx =-_feb .Dx ;return _feb };const (LineStyleSolid LineStyle =0;LineStyleDashed LineStyle =1;);const (LineEndingStyleNone LineEndingStyle =0;LineEndingStyleArrow LineEndingStyle =1;LineEndingStyleButt LineEndingStyle =2;);

// Magnitude returns the magnitude of the vector.
func (_eea Vector )Magnitude ()float64 {return _c .Sqrt (_c .Pow (_eea .Dx ,2.0)+_c .Pow (_eea .Dy ,2.0))};

// DrawPathWithCreator makes the path with the content creator.
// Adds the PDF commands to draw the path to the creator instance.
func DrawPathWithCreator (path Path ,creator *_fc .ContentCreator ){for _agcd ,_cgdb :=range path .Points {if _agcd ==0{creator .Add_m (_cgdb .X ,_cgdb .Y );}else {creator .Add_l (_cgdb .X ,_cgdb .Y );};};};

// NewCubicBezierPath returns a new empty cubic Bezier path.
func NewCubicBezierPath ()CubicBezierPath {_cg :=CubicBezierPath {};_cg .Curves =[]CubicBezierCurve {};return _cg ;};

// Draw draws the polygon. A graphics state name can be specified for
// setting the polygon properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polygon
// bounding box.
func (_gb Polygon )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){_bc :=_fc .NewContentCreator ();_bc .Add_q ();_gb .FillEnabled =_gb .FillEnabled &&_gb .FillColor !=nil ;if _gb .FillEnabled {_bc .Add_rg (_gb .FillColor .R (),_gb .FillColor .G (),_gb .FillColor .B ());};_gb .BorderEnabled =_gb .BorderEnabled &&_gb .BorderColor !=nil ;if _gb .BorderEnabled {_bc .Add_RG (_gb .BorderColor .R (),_gb .BorderColor .G (),_gb .BorderColor .B ());_bc .Add_w (_gb .BorderWidth );};if len (gsName )> 1{_bc .Add_gs (_eg .PdfObjectName (gsName ));};_fbc :=NewPath ();for _ ,_fae :=range _gb .Points {for _fbb ,_fadd :=range _fae {_fbc =_fbc .AppendPoint (_fadd );if _fbb ==0{_bc .Add_m (_fadd .X ,_fadd .Y );}else {_bc .Add_l (_fadd .X ,_fadd .Y );};};_bc .Add_h ();};if _gb .FillEnabled &&_gb .BorderEnabled {_bc .Add_B ();}else if _gb .FillEnabled {_bc .Add_f ();}else if _gb .BorderEnabled {_bc .Add_S ();};_bc .Add_Q ();return _bc .Bytes (),_fbc .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Draw draws the polyline. A graphics state name can be specified for
// setting the polyline properties (e.g. setting the opacity). Otherwise leave
// empty (""). Returns the content stream as a byte array and the polyline
// bounding box.
func (_cd Polyline )Draw (gsName string )([]byte ,*_a .PdfRectangle ,error ){if _cd .LineColor ==nil {_cd .LineColor =_a .NewPdfColorDeviceRGB (0,0,0);};_ccb :=NewPath ();for _ ,_dbe :=range _cd .Points {_ccb =_ccb .AppendPoint (_dbe );};_agd :=_fc .NewContentCreator ();_agd .Add_q ();_agd .Add_RG (_cd .LineColor .R (),_cd .LineColor .G (),_cd .LineColor .B ());_agd .Add_w (_cd .LineWidth );if len (gsName )> 1{_agd .Add_gs (_eg .PdfObjectName (gsName ));};DrawPathWithCreator (_ccb ,_agd );_agd .Add_S ();_agd .Add_Q ();return _agd .Bytes (),_ccb .GetBoundingBox ().ToPdfRectangle (),nil ;};

// Circle represents a circle shape with fill and border properties that can be drawn to a PDF content stream.
type Circle struct{X float64 ;Y float64 ;Width float64 ;Height float64 ;FillEnabled bool ;FillColor *_a .PdfColorDeviceRGB ;BorderEnabled bool ;BorderWidth float64 ;BorderColor *_a .PdfColorDeviceRGB ;Opacity float64 ;};

// Polygon is a multi-point shape that can be drawn to a PDF content stream.
type Polygon struct{Points [][]Point ;FillEnabled bool ;FillColor *_a .PdfColorDeviceRGB ;BorderEnabled bool ;BorderColor *_a .PdfColorDeviceRGB ;BorderWidth float64 ;};

// PolyBezierCurve represents a composite curve that is the result of
// joining multiple cubic Bezier curves.
type PolyBezierCurve struct{Curves []CubicBezierCurve ;BorderWidth float64 ;BorderColor *_a .PdfColorDeviceRGB ;FillEnabled bool ;FillColor *_a .PdfColorDeviceRGB ;};

// Flip changes the sign of the vector: -vector.
func (_bgc Vector )Flip ()Vector {_aeb :=_bgc .Magnitude ();_fag :=_bgc .GetPolarAngle ();_bgc .Dx =_aeb *_c .Cos (_fag +_c .Pi );_bgc .Dy =_aeb *_c .Sin (_fag +_c .Pi );return _bgc ;};

// Scale scales the vector by the specified factor.
func (_afbb Vector )Scale (factor float64 )Vector {_aad :=_afbb .Magnitude ();_dac :=_afbb .GetPolarAngle ();_afbb .Dx =factor *_aad *_c .Cos (_dac );_afbb .Dy =factor *_aad *_c .Sin (_dac );return _afbb ;};