//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package xmputil provides abstraction used by the pdf document XMP Metadata.
package xmputil ;import (_gb "errors";_a "fmt";_b "github.com/trimmer-io/go-xmp/models/pdf";_cb "github.com/trimmer-io/go-xmp/models/xmp_mm";_c "github.com/trimmer-io/go-xmp/xmp";_ff "github.com/unidoc/unipdf/v3/core";_bg "github.com/unidoc/unipdf/v3/internal/timeutils";
_eg "github.com/unidoc/unipdf/v3/internal/uuid";_bc "github.com/unidoc/unipdf/v3/model/xmputil/pdfaextension";_cf "github.com/unidoc/unipdf/v3/model/xmputil/pdfaid";_g "strconv";_e "time";);

// GetPdfAID gets the pdfaid xmp metadata model.
func (_dgd *Document )GetPdfAID ()(*PdfAID ,bool ){_gbe ,_afg :=_dgd ._eb .FindModel (_cf .Namespace ).(*_cf .Model );if !_afg {return nil ,false ;};return &PdfAID {Part :_gbe .Part ,Conformance :_gbe .Conformance },true ;};

// GetPdfaExtensionSchemas gets a pdfa extension schemas.
func (_fa *Document )GetPdfaExtensionSchemas ()([]_bc .Schema ,error ){_ffa :=_fa ._eb .FindModel (_bc .Namespace );if _ffa ==nil {return nil ,nil ;};_acf ,_cg :=_ffa .(*_bc .Model );if !_cg {return nil ,_a .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u006d\u006f\u0064\u0065l f\u006fr \u0070\u0064\u0066\u0061\u0045\u0078\u0074en\u0073\u0069\u006f\u006e\u0073\u003a\u0020%\u0054",_ffa );
};return _acf .Schemas ,nil ;};

// MediaManagementOptions are the options for the Media management xmp metadata.
type MediaManagementOptions struct{

// OriginalDocumentID  as media is imported and projects is started, an original-document ID
// must be created to identify a new document. This identifies a document as a conceptual entity.
// By default, this value is generated.
OriginalDocumentID string ;

// NewDocumentID is a flag which generates a new Document identifier while setting media management.
// This value should be set to true only if the document is stored and saved as new document.
// Otherwise, if the document is modified and overwrites previous file, it should be set to false.
NewDocumentID bool ;

// DocumentID when a document is copied to a new file path or converted to a new format with
// Save As, another new document ID should usually be assigned. This identifies a general version or
// branch of a document. You can use it to track different versions or extracted portions of a document
// with the same original-document ID.
// By default, this value is generated if NewDocumentID is true or previous doesn't exist.
DocumentID string ;

// InstanceID to track a document’s editing history, you must assign a new instance ID
// whenever a document is saved after any changes. This uniquely identifies an exact version of a
// document. It is used in resource references (to identify both the document or part itself and the
// referenced or referencing documents), and in document-history resource events (to identify the
// document instance that resulted from the change).
// By default, this value is generated.
InstanceID string ;

// DerivedFrom references the source document from which this one is derived,
// typically through a Save As operation that changes the file name or format. It is a minimal reference;
// missing components can be assumed to be unchanged. For example, a new version might only need
// to specify the instance ID and version number of the previous version, or a rendition might only need
// to specify the instance ID and rendition class of the original.
// By default, the derived from structure is filled from previous XMP metadata (if exists).
DerivedFrom string ;

// VersionID are meant to associate the document with a product version that is part of a release process. They can be useful in tracking the
// document history, but should not be used to identify a document uniquely in any context.
// Usually it simply works by incrementing integers 1,2,3...
// By default, this values is incremented or set to the next version number.
VersionID string ;

// ModifyComment is a comment to given modification
ModifyComment string ;

// ModifyDate is a custom modification date for the versions.
// By default, this would be set to time.Now().
ModifyDate _e .Time ;

// Modifier is a person who did the modification.
Modifier string ;};

// Marshal the document into xml byte stream.
func (_cfaa *Document )Marshal ()([]byte ,error ){if _cfaa ._eb .IsDirty (){if _cbf :=_cfaa ._eb .SyncModels ();_cbf !=nil {return nil ,_cbf ;};};return _c .Marshal (_cfaa ._eb );};

// GetPdfInfo gets the document pdf info.
func (_eee *Document )GetPdfInfo ()(*PdfInfo ,bool ){_bgf ,_fg :=_eee ._eb .FindModel (_b .NsPDF ).(*_b .PDFInfo );if !_fg {return nil ,false ;};_bca :=PdfInfo {};var _ccd *_ff .PdfObjectDictionary ;_bca .Copyright =_bgf .Copyright ;_bca .PdfVersion =_bgf .PDFVersion ;
_bca .Marked =bool (_bgf .Marked );_fe :=func (_gg string ,_bfc _ff .PdfObject ){if _ccd ==nil {_ccd =_ff .MakeDict ();};_ccd .Set (_ff .PdfObjectName (_gg ),_bfc );};if len (_bgf .Title )> 0{_fe ("\u0054\u0069\u0074l\u0065",_ff .MakeString (_bgf .Title .Default ()));
};if len (_bgf .Author )> 0{_fe ("\u0041\u0075\u0074\u0068\u006f\u0072",_ff .MakeString (_bgf .Author [0]));};if _bgf .Keywords !=""{_fe ("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073",_ff .MakeString (_bgf .Keywords ));};if len (_bgf .Subject )> 0{_fe ("\u0053u\u0062\u006a\u0065\u0063\u0074",_ff .MakeString (_bgf .Subject .Default ()));
};if _bgf .Creator !=""{_fe ("\u0043r\u0065\u0061\u0074\u006f\u0072",_ff .MakeString (string (_bgf .Creator )));};if _bgf .Producer !=""{_fe ("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072",_ff .MakeString (string (_bgf .Producer )));};if _bgf .Trapped {_fe ("\u0054r\u0061\u0070\u0070\u0065\u0064",_ff .MakeName ("\u0054\u0072\u0075\u0065"));
};if !_bgf .CreationDate .IsZero (){_fe ("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065",_ff .MakeString (_bg .FormatPdfTime (_bgf .CreationDate .Value ())));};if !_bgf .ModifyDate .IsZero (){_fe ("\u004do\u0064\u0044\u0061\u0074\u0065",_ff .MakeString (_bg .FormatPdfTime (_bgf .ModifyDate .Value ())));
};_bca .InfoDict =_ccd ;return &_bca ,true ;};

// MediaManagement are the values from the document media management metadata.
type MediaManagement struct{

// OriginalDocumentID  as media is imported and projects is started, an original-document ID
// must be created to identify a new document. This identifies a document as a conceptual entity.
OriginalDocumentID GUID ;

// DocumentID when a document is copied to a new file path or converted to a new format with
// Save As, another new document ID should usually be assigned. This identifies a general version or
// branch of a document. You can use it to track different versions or extracted portions of a document
// with the same original-document ID.
DocumentID GUID ;

// InstanceID to track a document’s editing history, you must assign a new instance ID
// whenever a document is saved after any changes. This uniquely identifies an exact version of a
// document. It is used in resource references (to identify both the document or part itself and the
// referenced or referencing documents), and in document-history resource events (to identify the
// document instance that resulted from the change).
InstanceID GUID ;

// DerivedFrom references the source document from which this one is derived,
// typically through a Save As operation that changes the file name or format. It is a minimal reference;
// missing components can be assumed to be unchanged. For example, a new version might only need
// to specify the instance ID and version number of the previous version, or a rendition might only need
// to specify the instance ID and rendition class of the original.
DerivedFrom *MediaManagementDerivedFrom ;

// VersionID are meant to associate the document with a product version that is part of a release process. They can be useful in tracking the
// document history, but should not be used to identify a document uniquely in any context.
// Usually it simply works by incrementing integers 1,2,3...
VersionID string ;

// Versions is the history of the document versions along with the comments, timestamps and issuers.
Versions []MediaManagementVersion ;};

// SetPdfAID sets up pdfaid xmp metadata.
// In example: Part: '1' Conformance: 'B' states for PDF/A 1B.
func (_feg *Document )SetPdfAID (part int ,conformance string )error {_ccdg ,_ecbe :=_cf .MakeModel (_feg ._eb );if _ecbe !=nil {return _ecbe ;};_ccdg .Part =part ;_ccdg .Conformance =conformance ;if _da :=_ccdg .SyncToXMP (_feg ._eb );_da !=nil {return _da ;
};return nil ;};

// GetMediaManagement gets the media management metadata from provided xmp document.
func (_dg *Document )GetMediaManagement ()(*MediaManagement ,bool ){_bff :=_cb .FindModel (_dg ._eb );if _bff ==nil {return nil ,false ;};_ca :=make ([]MediaManagementVersion ,len (_bff .Versions ));for _ebc ,_ea :=range _bff .Versions {_ca [_ebc ]=MediaManagementVersion {VersionID :_ea .Version ,ModifyDate :_ea .ModifyDate .Value (),Comments :_ea .Comments ,Modifier :_ea .Modifier };
};_edfa :=&MediaManagement {OriginalDocumentID :GUID (_bff .OriginalDocumentID .Value ()),DocumentID :GUID (_bff .DocumentID .Value ()),InstanceID :GUID (_bff .InstanceID .Value ()),VersionID :_bff .VersionID ,Versions :_ca };if _bff .DerivedFrom !=nil {_edfa .DerivedFrom =&MediaManagementDerivedFrom {OriginalDocumentID :GUID (_bff .DerivedFrom .OriginalDocumentID ),DocumentID :GUID (_bff .DerivedFrom .DocumentID ),InstanceID :GUID (_bff .DerivedFrom .InstanceID ),VersionID :_bff .DerivedFrom .VersionID };
};return _edfa ,true ;};

// PdfAID is the result of the XMP pdfaid metadata.
type PdfAID struct{Part int ;Conformance string ;};

// SetPdfInfo sets the pdf info into selected document.
func (_be *Document )SetPdfInfo (options *PdfInfoOptions )error {if options ==nil {return _gb .New ("\u006ei\u006c\u0020\u0070\u0064\u0066\u0020\u006f\u0070\u0074\u0069\u006fn\u0073\u0020\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064");};_ee ,_d :=_b .MakeModel (_be ._eb );
if _d !=nil {return _d ;};if options .Overwrite {*_ee =_b .PDFInfo {};};if options .InfoDict !=nil {_beg ,_bf :=_ff .GetDict (options .InfoDict );if !_bf {return _a .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0064\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",options .InfoDict );
};var _eed *_ff .PdfObjectString ;for _ ,_ecb :=range _beg .Keys (){switch _ecb {case "\u0054\u0069\u0074l\u0065":_eed ,_bf =_ff .GetString (_beg .Get ("\u0054\u0069\u0074l\u0065"));if _bf {_ee .Title =_c .NewAltString (_eed );};case "\u0041\u0075\u0074\u0068\u006f\u0072":_eed ,_bf =_ff .GetString (_beg .Get ("\u0041\u0075\u0074\u0068\u006f\u0072"));
if _bf {_ee .Author =_c .NewStringList (_eed .String ());};case "\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073":_eed ,_bf =_ff .GetString (_beg .Get ("\u004b\u0065\u0079\u0077\u006f\u0072\u0064\u0073"));if _bf {_ee .Keywords =_eed .String ();};case "\u0043r\u0065\u0061\u0074\u006f\u0072":_eed ,_bf =_ff .GetString (_beg .Get ("\u0043r\u0065\u0061\u0074\u006f\u0072"));
if _bf {_ee .Creator =_c .AgentName (_eed .String ());};case "\u0053u\u0062\u006a\u0065\u0063\u0074":_eed ,_bf =_ff .GetString (_beg .Get ("\u0053u\u0062\u006a\u0065\u0063\u0074"));if _bf {_ee .Subject =_c .NewAltString (_eed .String ());};case "\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072":_eed ,_bf =_ff .GetString (_beg .Get ("\u0050\u0072\u006f\u0064\u0075\u0063\u0065\u0072"));
if _bf {_ee .Producer =_c .AgentName (_eed .String ());};case "\u0054r\u0061\u0070\u0070\u0065\u0064":_ab ,_cfd :=_ff .GetName (_beg .Get ("\u0054r\u0061\u0070\u0070\u0065\u0064"));if _cfd {switch _ab .String (){case "\u0054\u0072\u0075\u0065":_ee .Trapped =true ;
case "\u0046\u0061\u006cs\u0065":_ee .Trapped =false ;default:_ee .Trapped =true ;};};case "\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065":if _ge ,_bfg :=_ff .GetString (_beg .Get ("\u0043\u0072\u0065a\u0074\u0069\u006f\u006e\u0044\u0061\u0074\u0065"));
_bfg &&_ge .String ()!=""{_cc ,_gc :=_bg .ParsePdfTime (_ge .String ());if _gc !=nil {return _a .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0072e\u0061\u0074\u0069\u006f\u006e\u0044\u0061t\u0065\u0020\u0066\u0069\u0065\u006c\u0064\u003a\u0020\u0025\u0077",_gc );
};_ee .CreationDate =_c .NewDate (_cc );};case "\u004do\u0064\u0044\u0061\u0074\u0065":if _geb ,_acfg :=_ff .GetString (_beg .Get ("\u004do\u0064\u0044\u0061\u0074\u0065"));_acfg &&_geb .String ()!=""{_edf ,_aa :=_bg .ParsePdfTime (_geb .String ());if _aa !=nil {return _a .Errorf ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u004d\u006f\u0064\u0044a\u0074e\u0020f\u0069\u0065\u006c\u0064\u003a\u0020\u0025w",_aa );
};_ee .ModifyDate =_c .NewDate (_edf );};};};};if options .PdfVersion !=""{_ee .PDFVersion =options .PdfVersion ;};if options .Marked {_ee .Marked =_c .Bool (options .Marked );};if options .Copyright !=""{_ee .Copyright =options .Copyright ;};if _d =_ee .SyncToXMP (_be ._eb );
_d !=nil {return _d ;};return nil ;};

// PdfInfoOptions are the options used for setting pdf info.
type PdfInfoOptions struct{InfoDict _ff .PdfObject ;PdfVersion string ;Copyright string ;Marked bool ;

// Overwrite if set to true, overwrites all values found in the current pdf info xmp model to the ones provided.
Overwrite bool ;};

// LoadDocument loads up the xmp document from provided input stream.
func LoadDocument (stream []byte )(*Document ,error ){_cfa :=_c .NewDocument ();if _ae :=_c .Unmarshal (stream ,_cfa );_ae !=nil {return nil ,_ae ;};return &Document {_eb :_cfa },nil ;};

// SetPdfAExtension sets the pdfaExtension XMP metadata.
func (_ec *Document )SetPdfAExtension ()error {_fc ,_gfb :=_bc .MakeModel (_ec ._eb );if _gfb !=nil {return _gfb ;};if _gfb =_bc .FillModel (_ec ._eb ,_fc );_gfb !=nil {return _gfb ;};if _gfb =_fc .SyncToXMP (_ec ._eb );_gfb !=nil {return _gfb ;};return nil ;
};

// MediaManagementVersion is the version of the media management xmp metadata.
type MediaManagementVersion struct{VersionID string ;ModifyDate _e .Time ;Comments string ;Modifier string ;};

// Document is an implementation of the xmp document.
// It is a wrapper over go-xmp/xmp.Document that provides some Pdf predefined functionality.
type Document struct{_eb *_c .Document };

// NewDocument creates a new document without any previous xmp information.
func NewDocument ()*Document {_ac :=_c .NewDocument ();return &Document {_eb :_ac }};

// GetGoXmpDocument gets direct access to the go-xmp.Document.
// All changes done to specified document would result in change of this document 'd'.
func (_ed *Document )GetGoXmpDocument ()*_c .Document {return _ed ._eb };

// MarshalIndent the document into xml byte stream with predefined prefix and indent.
func (_gf *Document )MarshalIndent (prefix ,indent string )([]byte ,error ){if _gf ._eb .IsDirty (){if _ce :=_gf ._eb .SyncModels ();_ce !=nil {return nil ,_ce ;};};return _c .MarshalIndent (_gf ._eb ,prefix ,indent );};

// MediaManagementDerivedFrom is a structure that contains references of identifiers and versions
// from which given document was derived.
type MediaManagementDerivedFrom struct{OriginalDocumentID GUID ;DocumentID GUID ;InstanceID GUID ;VersionID string ;};

// SetMediaManagement sets up XMP media management metadata: namespace xmpMM.
func (_ege *Document )SetMediaManagement (options *MediaManagementOptions )error {_eeb ,_ag :=_cb .MakeModel (_ege ._eb );if _ag !=nil {return _ag ;};if options ==nil {options =new (MediaManagementOptions );};_cfaaa :=_cb .ResourceRef {};if _eeb .OriginalDocumentID .IsZero (){if options .OriginalDocumentID !=""{_eeb .OriginalDocumentID =_c .GUID (options .OriginalDocumentID );
}else {_gbc ,_gcd :=_eg .NewUUID ();if _gcd !=nil {return _gcd ;};_eeb .OriginalDocumentID =_c .GUID (_gbc .String ());};}else {_cfaaa .OriginalDocumentID =_eeb .OriginalDocumentID ;};switch {case options .DocumentID !="":_eeb .DocumentID =_c .GUID (options .DocumentID );
case options .NewDocumentID ||_eeb .DocumentID .IsZero ():if !_eeb .DocumentID .IsZero (){_cfaaa .DocumentID =_eeb .DocumentID ;};_bef ,_cfdg :=_eg .NewUUID ();if _cfdg !=nil {return _cfdg ;};_eeb .DocumentID =_c .GUID (_bef .String ());};if !_eeb .InstanceID .IsZero (){_cfaaa .InstanceID =_eeb .InstanceID ;
};_eeb .InstanceID =_c .GUID (options .InstanceID );if _eeb .InstanceID ==""{_af ,_egc :=_eg .NewUUID ();if _egc !=nil {return _egc ;};_eeb .InstanceID =_c .GUID (_af .String ());};if !_cfaaa .IsZero (){_eeb .DerivedFrom =&_cfaaa ;};_edc :=options .VersionID ;
if _eeb .VersionID !=""{_ffg ,_fee :=_g .Atoi (_eeb .VersionID );if _fee !=nil {_edc =_g .Itoa (len (_eeb .Versions )+1);}else {_edc =_g .Itoa (_ffg +1);};};if _edc ==""{_edc ="\u0031";};_eeb .VersionID =_edc ;_agc :=options .ModifyDate ;if _agc .IsZero (){_agc =_e .Now ();
};if _ag =_eeb .SyncToXMP (_ege ._eb );_ag !=nil {return _ag ;};return nil ;};

// GUID is a string representing a globally unique identifier.
type GUID string ;

// PdfInfo is the xmp document pdf info.
type PdfInfo struct{InfoDict _ff .PdfObject ;PdfVersion string ;Copyright string ;Marked bool ;};