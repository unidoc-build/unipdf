//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_dg "bytes";_fcf "crypto";_db "crypto/rand";_ff "crypto/rsa";_ag "crypto/x509";_dgb "crypto/x509/pkix";_fag "encoding/asn1";_a "errors";_c "fmt";_b "github.com/unidoc/pkcs7";_eg "github.com/unidoc/timestamp";_ge "github.com/unidoc/unipdf/v3/core";_ea "github.com/unidoc/unipdf/v3/model";_fa "hash";_g "io";_e "io/ioutil";_fc "net/http";_f "time";);

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _fcf .Hash ,opts *DocTimeStampOpts )(_ea .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_effa :timestampServerURL ,_afd :hashAlgorithm ,_ec :opts .SignatureSize },nil ;};

// Validate validates PdfSignature.
func (_agc *adobePKCS7Detached )Validate (sig *_ea .PdfSignature ,digest _ea .Hasher )(_ea .SignatureValidationResult ,error ){_dgf :=sig .Contents .Bytes ();_aa ,_gf :=_b .Parse (_dgf );if _gf !=nil {return _ea .SignatureValidationResult {},_gf ;};_egb :=digest .(*_dg .Buffer );_aa .Content =_egb .Bytes ();if _gf =_aa .Verify ();_gf !=nil {return _ea .SignatureValidationResult {},_gf ;};return _ea .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};func (_dd *adobeX509RSASHA1 )getCertificate (_aed *_ea .PdfSignature )(*_ag .Certificate ,error ){if _dd ._aeb !=nil {return _dd ._aeb ,nil ;};_dbb ,_eff :=_aed .GetCerts ();if _eff !=nil {return nil ,_eff ;};return _dbb [0],nil ;};

// Validate validates PdfSignature.
func (_ffc *adobeX509RSASHA1 )Validate (sig *_ea .PdfSignature ,digest _ea .Hasher )(_ea .SignatureValidationResult ,error ){_cg ,_dbf :=_ffc .getCertificate (sig );if _dbf !=nil {return _ea .SignatureValidationResult {},_dbf ;};_effg :=sig .Contents .Bytes ();var _de []byte ;if _ ,_ebe :=_fag .Unmarshal (_effg ,&_de );_ebe !=nil {return _ea .SignatureValidationResult {},_ebe ;};_ffea ,_eba :=digest .(_fa .Hash );if !_eba {return _ea .SignatureValidationResult {},_a .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_agg ,_ :=_ebf (_cg .SignatureAlgorithm );if _bg :=_ff .VerifyPKCS1v15 (_cg .PublicKey .(*_ff .PublicKey ),_agg ,_ffea .Sum (nil ),_de );_bg !=nil {return _ea .SignatureValidationResult {},_bg ;};return _ea .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};type adobeX509RSASHA1 struct{_fba *_ff .PrivateKey ;_aeb *_ag .Certificate ;_afg SignFunc ;_gc bool ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gbdc *docTimeStamp )IsApplicable (sig *_ea .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};type adobePKCS7Detached struct{_be *_ff .PrivateKey ;_gb *_ag .Certificate ;_ab bool ;_ca int ;};func (_caf *adobeX509RSASHA1 )sign (_fae *_ea .PdfSignature ,_gg _ea .Hasher ,_gba bool )error {if !_gba {return _caf .Sign (_fae ,_gg );};_bfg ,_fd :=_caf ._aeb .PublicKey .(*_ff .PublicKey );if !_fd {return _c .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_bfg );};_ad ,_dgbg :=_fag .Marshal (make ([]byte ,_bfg .Size ()));if _dgbg !=nil {return _dgbg ;};_fae .Contents =_ge .MakeHexString (string (_ad ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_fb *adobePKCS7Detached )InitSignature (sig *_ea .PdfSignature )error {if !_fb ._ab {if _fb ._gb ==nil {return _a .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _fb ._be ==nil {return _a .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_cc :=*_fb ;sig .Handler =&_cc ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_af ,_ae :=_cc .NewDigest (sig );if _ae !=nil {return _ae ;};_af .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _cc .Sign (sig ,_af );};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_ag .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_ea .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_aeb :certificate ,_afg :signFunc ,_gc :opts .EstimateSize },nil ;};func (_gbc *adobePKCS7Detached )getCertificate (_fg *_ea .PdfSignature )(*_ag .Certificate ,error ){if _gbc ._gb !=nil {return _gbc ._gb ,nil ;};_ba ,_da :=_fg .GetCerts ();if _da !=nil {return nil ,_da ;};return _ba [0],nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_ce *_ea .PdfSignature ,_egc _ea .Hasher )([]byte ,error );

// NewDigest creates a new digest.
func (_bc *adobeX509RSASHA1 )NewDigest (sig *_ea .PdfSignature )(_ea .Hasher ,error ){_gcf ,_gca :=_bc .getCertificate (sig );if _gca !=nil {return nil ,_gca ;};_ed ,_ :=_ebf (_gcf .SignatureAlgorithm );return _ed .New (),nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ff .PrivateKey ,certificate *_ag .Certificate )(_ea .SignatureHandler ,error ){return &adobeX509RSASHA1 {_aeb :certificate ,_fba :privateKey },nil ;};

// InitSignature initialises the PdfSignature.
func (_ebc *docTimeStamp )InitSignature (sig *_ea .PdfSignature )error {_ac :=*_ebc ;sig .Handler =&_ac ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _ebc ._ec > 0{sig .Contents =_ge .MakeHexString (string (make ([]byte ,_ebc ._ec )));}else {_fe ,_ccc :=_ebc .NewDigest (sig );if _ccc !=nil {return _ccc ;};_fe .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _ccc =_ac .Sign (sig ,_fe );_ccc !=nil {return _ccc ;};_ebc ._ec =_ac ._ec ;};return nil ;};

// NewDigest creates a new digest.
func (_gef *docTimeStamp )NewDigest (sig *_ea .PdfSignature )(_ea .Hasher ,error ){return _dg .NewBuffer (nil ),nil ;};

// Validate validates PdfSignature.
func (_bee *docTimeStamp )Validate (sig *_ea .PdfSignature ,digest _ea .Hasher )(_ea .SignatureValidationResult ,error ){_eed :=sig .Contents .Bytes ();_gfe ,_cga :=_b .Parse (_eed );if _cga !=nil {return _ea .SignatureValidationResult {},_cga ;};if _cga =_gfe .Verify ();_cga !=nil {return _ea .SignatureValidationResult {},_cga ;};var _fac timestampInfo ;_ ,_cga =_fag .Unmarshal (_gfe .Content ,&_fac );if _cga !=nil {return _ea .SignatureValidationResult {},_cga ;};_gd ,_cga :=_eag (_fac .MessageImprint .HashAlgorithm .Algorithm );if _cga !=nil {return _ea .SignatureValidationResult {},_cga ;};_ggf :=_gd .New ();_afb :=digest .(*_dg .Buffer );_ggf .Write (_afb .Bytes ());_baa :=_ggf .Sum (nil );_cgb :=_ea .SignatureValidationResult {IsSigned :true ,IsVerified :_dg .Equal (_baa ,_fac .MessageImprint .HashedMessage ),GeneralizedTime :_fac .GeneralizedTime };return _cgb ,nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_bf *adobePKCS7Detached )IsApplicable (sig *_ea .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};func _ebf (_ffe _ag .SignatureAlgorithm )(_fcf .Hash ,bool ){var _cf _fcf .Hash ;switch _ffe {case _ag .SHA1WithRSA :_cf =_fcf .SHA1 ;case _ag .SHA256WithRSA :_cf =_fcf .SHA256 ;case _ag .SHA384WithRSA :_cf =_fcf .SHA384 ;case _ag .SHA512WithRSA :_cf =_fcf .SHA512 ;default:return _fcf .SHA1 ,false ;};return _cf ,true ;};func _eag (_gbd _fag .ObjectIdentifier )(_fcf .Hash ,error ){switch {case _gbd .Equal (_b .OIDDigestAlgorithmSHA1 ),_gbd .Equal (_b .OIDDigestAlgorithmECDSASHA1 ),_gbd .Equal (_b .OIDDigestAlgorithmDSA ),_gbd .Equal (_b .OIDDigestAlgorithmDSASHA1 ),_gbd .Equal (_b .OIDEncryptionAlgorithmRSA ):return _fcf .SHA1 ,nil ;case _gbd .Equal (_b .OIDDigestAlgorithmSHA256 ),_gbd .Equal (_b .OIDDigestAlgorithmECDSASHA256 ):return _fcf .SHA256 ,nil ;case _gbd .Equal (_b .OIDDigestAlgorithmSHA384 ),_gbd .Equal (_b .OIDDigestAlgorithmECDSASHA384 ):return _fcf .SHA384 ,nil ;case _gbd .Equal (_b .OIDDigestAlgorithmSHA512 ),_gbd .Equal (_b .OIDDigestAlgorithmECDSASHA512 ):return _fcf .SHA512 ,nil ;};return _fcf .Hash (0),_b .ErrUnsupportedAlgorithm ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};type timestampInfo struct{Version int ;Policy _fag .RawValue ;MessageImprint struct{HashAlgorithm _dgb .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _fag .RawValue ;GeneralizedTime _f .Time ;};

// NewDigest creates a new digest.
func (_fcg *adobePKCS7Detached )NewDigest (sig *_ea .PdfSignature )(_ea .Hasher ,error ){return _dg .NewBuffer (nil ),nil ;};

// Sign sets the Contents fields.
func (_cb *adobePKCS7Detached )Sign (sig *_ea .PdfSignature ,digest _ea .Hasher )error {if _cb ._ab {_df :=_cb ._ca ;if _df <=0{_df =8192;};sig .Contents =_ge .MakeHexString (string (make ([]byte ,_df )));return nil ;};_aaf :=digest .(*_dg .Buffer );_bag ,_egd :=_b .NewSignedData (_aaf .Bytes ());if _egd !=nil {return _egd ;};if _ged :=_bag .AddSigner (_cb ._gb ,_cb ._be ,_b .SignerInfoConfig {});_ged !=nil {return _ged ;};_bag .Detach ();_eb ,_egd :=_bag .Finish ();if _egd !=nil {return _egd ;};_aef :=make ([]byte ,8192);copy (_aef ,_eb );sig .Contents =_ge .MakeHexString (string (_aef ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_egcc *docTimeStamp )Sign (sig *_ea .PdfSignature ,digest _ea .Hasher )error {_fef :=digest .(*_dg .Buffer );_ade :=_egcc ._afd .New ();if _ ,_agga :=_g .Copy (_ade ,_fef );_agga !=nil {return _agga ;};_bad :=_eg .Request {HashAlgorithm :_egcc ._afd ,HashedMessage :_ade .Sum (nil ),Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_fda ,_cd :=_bad .Marshal ();if _cd !=nil {return _cd ;};_fec ,_cd :=_fc .Post (_egcc ._effa ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_dg .NewBuffer (_fda ));if _cd !=nil {return _cd ;};defer _fec .Body .Close ();_bd ,_cd :=_e .ReadAll (_fec .Body );if _cd !=nil {return _cd ;};if _fec .StatusCode !=_fc .StatusOK {return _c .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_fec .StatusCode );};var _dfa struct{Version _fag .RawValue ;Content _fag .RawValue ;};if _ ,_cd =_fag .Unmarshal (_bd ,&_dfa );_cd !=nil {return _cd ;};_dcg :=len (_dfa .Content .FullBytes );if _egcc ._ec > 0&&_dcg > _egcc ._ec {return _ea .ErrSignNotEnoughSpace ;};if _dcg > 0{_egcc ._ec =_dcg +128;};sig .Contents =_ge .MakeHexString (string (_dfa .Content .FullBytes ));return nil ;};func (_ecg *docTimeStamp )getCertificate (_afa *_ea .PdfSignature )(*_ag .Certificate ,error ){_abb ,_deb :=_afa .GetCerts ();if _deb !=nil {return nil ,_deb ;};return _abb [0],nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_ag .Certificate ,signFunc SignFunc )(_ea .SignatureHandler ,error ){return &adobeX509RSASHA1 {_aeb :certificate ,_afg :signFunc },nil ;};type docTimeStamp struct{_effa string ;_afd _fcf .Hash ;_ec int ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ega *adobeX509RSASHA1 )IsApplicable (sig *_ea .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_ea .SignatureHandler ,error ){return &adobePKCS7Detached {_ab :true ,_ca :signatureLen },nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _fcf .Hash )(_ea .SignatureHandler ,error ){return &docTimeStamp {_effa :timestampServerURL ,_afd :hashAlgorithm },nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ff .PrivateKey ,certificate *_ag .Certificate )(_ea .SignatureHandler ,error ){return &adobePKCS7Detached {_gb :certificate ,_be :privateKey },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_fbc *adobeX509RSASHA1 )Sign (sig *_ea .PdfSignature ,digest _ea .Hasher )error {var _ee []byte ;var _dc error ;if _fbc ._afg !=nil {_ee ,_dc =_fbc ._afg (sig ,digest );if _dc !=nil {return _dc ;};}else {_egbf ,_aab :=digest .(_fa .Hash );if !_aab {return _a .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_eeb ,_ :=_ebf (_fbc ._aeb .SignatureAlgorithm );_ee ,_dc =_ff .SignPKCS1v15 (_db .Reader ,_fbc ._fba ,_eeb ,_egbf .Sum (nil ));if _dc !=nil {return _dc ;};};_ee ,_dc =_fag .Marshal (_ee );if _dc !=nil {return _dc ;};sig .Contents =_ge .MakeHexString (string (_ee ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_bff *adobeX509RSASHA1 )InitSignature (sig *_ea .PdfSignature )error {if _bff ._aeb ==nil {return _a .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _bff ._fba ==nil &&_bff ._afg ==nil {return _a .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_ef :=*_bff ;sig .Handler =&_ef ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_ge .MakeString (string (_ef ._aeb .Raw ));sig .Reference =nil ;_fff ,_eab :=_ef .NewDigest (sig );if _eab !=nil {return _eab ;};_fff .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _ef .sign (sig ,_fff ,_bff ._gc );};