//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_gag "bytes";_egc "crypto";_dc "crypto/rand";_gb "crypto/rsa";_a "crypto/x509";_f "crypto/x509/pkix";_c "encoding/asn1";_eg "encoding/hex";_g "errors";_e "fmt";_ce "github.com/unidoc/pkcs7";_cc "github.com/unidoc/timestamp";
_ae "github.com/unidoc/unipdf/v3/common";_ec "github.com/unidoc/unipdf/v3/core";_fe "github.com/unidoc/unipdf/v3/model";_fc "github.com/unidoc/unipdf/v3/model/mdp";_dba "github.com/unidoc/unipdf/v3/model/sigutil";_be "hash";_b "math/big";_ga "strings";
_db "time";);const _dacf =_egc .SHA1 ;

// NewDigest creates a new digest.
func (_eed *DocMDPHandler )NewDigest (sig *_fe .PdfSignature )(_fe .Hasher ,error ){return _eed ._gf .NewDigest (sig );};func (_edcf *adobeX509RSASHA1 )getHashAlgorithm (_ecbe *_fe .PdfSignature )(_egc .Hash ,error ){_fff ,_bge :=_edcf .getCertificate (_ecbe );
if _bge !=nil {if _edcf ._ead !=0{return _edcf ._ead ,nil ;};return _dacf ,_bge ;};if _ecbe .Contents !=nil {_gccc :=_ecbe .Contents .Bytes ();var _dddb []byte ;if _ ,_gaea :=_c .Unmarshal (_gccc ,&_dddb );_gaea ==nil {_bgce :=_dgda (_fff .PublicKey .(*_gb .PublicKey ),_dddb );
if _bgce > 0{return _bgce ,nil ;};};};if _edcf ._ead !=0{return _edcf ._ead ,nil ;};return _dacf ,nil ;};

// Validate validates PdfSignature.
func (_bgcd *docTimeStamp )Validate (sig *_fe .PdfSignature ,digest _fe .Hasher )(_fe .SignatureValidationResult ,error ){_cdd :=sig .Contents .Bytes ();_affg ,_gcf :=_ce .Parse (_cdd );if _gcf !=nil {return _fe .SignatureValidationResult {},_gcf ;};if _gcf =_affg .Verify ();
_gcf !=nil {return _fe .SignatureValidationResult {},_gcf ;};var _gfa timestampInfo ;_ ,_gcf =_c .Unmarshal (_affg .Content ,&_gfa );if _gcf !=nil {return _fe .SignatureValidationResult {},_gcf ;};_ccbf ,_gcf :=_cbfc (_gfa .MessageImprint .HashAlgorithm .Algorithm );
if _gcf !=nil {return _fe .SignatureValidationResult {},_gcf ;};_aae :=_ccbf .New ();_gfdb ,_bcg :=digest .(*_gag .Buffer );if !_bcg {return _fe .SignatureValidationResult {},_e .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_aae .Write (_gfdb .Bytes ());_dce :=_aae .Sum (nil );_cge :=_fe .SignatureValidationResult {IsSigned :true ,IsVerified :_gag .Equal (_dce ,_gfa .MessageImprint .HashedMessage ),GeneralizedTime :_gfa .GeneralizedTime };return _cge ,nil ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_gf _fe .SignatureHandler ;Permission _fc .DocMDPPermission ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _egc .Hash ,opts *DocTimeStampOpts )(_fe .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_efg :timestampServerURL ,_eda :hashAlgorithm ,_cgg :opts .SignatureSize ,_egda :opts .Client },nil ;
};

// Sign adds a new reference to signature's references array.
func (_bbf *DocMDPHandler )Sign (sig *_fe .PdfSignature ,digest _fe .Hasher )error {return _bbf ._gf .Sign (sig ,digest );};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_gb .PrivateKey ,certificate *_a .Certificate )(_fe .SignatureHandler ,error ){return &adobePKCS7Detached {_adg :certificate ,_fbb :privateKey },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_gcc *adobePKCS7Detached )IsApplicable (sig *_fe .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};func _dgda (_bda *_gb .PublicKey ,_ccca []byte )_egc .Hash {_bgge :=_bda .Size ();if _bgge !=len (_ccca ){return 0;};_affb :=func (_fdfc *_b .Int ,_ebdg *_gb .PublicKey ,_fce *_b .Int )*_b .Int {_ada :=_b .NewInt (int64 (_ebdg .E ));_fdfc .Exp (_fce ,_ada ,_ebdg .N );
return _fdfc ;};_dcdb :=new (_b .Int ).SetBytes (_ccca );_daaa :=_affb (new (_b .Int ),_bda ,_dcdb );_fbd :=_agb (_daaa .Bytes (),_bgge );if _fbd [0]!=0||_fbd [1]!=1{return 0;};_fbf :=[]struct{Hash _egc .Hash ;Prefix []byte ;}{{Hash :_egc .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_egc .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_egc .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_egc .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_egc .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_fcd :=range _fbf {_ebe :=_fcd .Hash .Size ();_ccd :=len (_fcd .Prefix )+_ebe ;if _gag .Equal (_fbd [_bgge -_ccd :_bgge -_ebe ],_fcd .Prefix ){return _fcd .Hash ;};};return 0;};

// InitSignature initialization of the DocMDP signature.
func (_da *DocMDPHandler )InitSignature (sig *_fe .PdfSignature )error {_fge :=_da ._gf .InitSignature (sig );if _fge !=nil {return _fge ;};sig .Handler =_da ;if sig .Reference ==nil {sig .Reference =_ec .MakeArray ();};sig .Reference .Append (_fe .NewPdfSignatureReferenceDocMDP (_fe .NewPdfTransformParamsDocMDP (_da .Permission )).ToPdfObject ());
return nil ;};

// Sign sets the Contents fields.
func (_gba *adobePKCS7Detached )Sign (sig *_fe .PdfSignature ,digest _fe .Hasher )error {if _gba ._gade {_ecf :=_gba ._aef ;if _ecf <=0{_ecf =8192;};sig .Contents =_ec .MakeHexString (string (make ([]byte ,_ecf )));return nil ;};_bea ,_dgd :=digest .(*_gag .Buffer );
if !_dgd {return _e .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_egcg ,_edce :=_ce .NewSignedData (_bea .Bytes ());if _edce !=nil {return _edce ;};if _dag :=_egcg .AddSigner (_gba ._adg ,_gba ._fbb ,_ce .SignerInfoConfig {});
_dag !=nil {return _dag ;};_egcg .Detach ();_daac ,_edce :=_egcg .Finish ();if _edce !=nil {return _edce ;};_fbg :=make ([]byte ,8192);copy (_fbg ,_daac );sig .Contents =_ec .MakeHexString (string (_fbg ));return nil ;};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_gb .PrivateKey ,certificate *_a .Certificate ,caCert *_a .Certificate ,certificateTimestampServerURL string ,appender *_fe .PdfAppender )(_fe .SignatureHandler ,error ){_eefb :=appender .Reader .DSS ;if _eefb ==nil {_eefb =_fe .NewDSS ();
};if _efd :=_eefb .GenerateHashMaps ();_efd !=nil {return nil ,_efd ;};return &etsiPAdES {_fdb :certificate ,_eefg :privateKey ,_ccg :caCert ,_bed :certificateTimestampServerURL ,CertClient :_dba .NewCertClient (),OCSPClient :_dba .NewOCSPClient (),CRLClient :_dba .NewCRLClient (),_fac :appender ,_eec :_eefb },nil ;
};func (_ecc *adobeX509RSASHA1 )getCertificate (_ecb *_fe .PdfSignature )(*_a .Certificate ,error ){if _ecc ._gdfe !=nil {return _ecc ._gdfe ,nil ;};_cbf ,_egac :=_ecb .GetCerts ();if _egac !=nil {return nil ,_egac ;};return _cbf [0],nil ;};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _fe .SignatureHandler ,permission _fc .DocMDPPermission )(_fe .SignatureHandler ,error ){return &DocMDPHandler {_gf :handler ,Permission :permission },nil ;};func (_dgg *docTimeStamp )getCertificate (_aeaa *_fe .PdfSignature )(*_a .Certificate ,error ){_edeg ,_edcb :=_aeaa .GetCerts ();
if _edcb !=nil {return nil ,_edcb ;};return _edeg [0],nil ;};

// Validate validates PdfSignature.
func (_gdf *etsiPAdES )Validate (sig *_fe .PdfSignature ,digest _fe .Hasher )(_fe .SignatureValidationResult ,error ){_acf :=sig .Contents .Bytes ();_fgd ,_bd :=_ce .Parse (_acf );if _bd !=nil {return _fe .SignatureValidationResult {},_bd ;};_fged ,_dbac :=digest .(*_gag .Buffer );
if !_dbac {return _fe .SignatureValidationResult {},_e .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_fgd .Content =_fged .Bytes ();if _bd =_fgd .Verify ();_bd !=nil {return _fe .SignatureValidationResult {},_bd ;
};_dec :=false ;_fadd :=false ;var _bf _db .Time ;for _ ,_bac :=range _fgd .Signers {_gbbg :=_bac .EncryptedDigest ;var _fde RevocationInfoArchival ;_bd =_fgd .UnmarshalSignedAttribute (_ce .OIDAttributeAdobeRevocation ,&_fde );if _bd ==nil {if len (_fde .Crl )> 0{_fadd =true ;
};if len (_fde .Ocsp )> 0{_dec =true ;};};for _ ,_cbba :=range _bac .UnauthenticatedAttributes {if _cbba .Type .Equal (_ce .OIDAttributeTimeStampToken ){_bbff ,_ddf :=_cc .Parse (_cbba .Value .Bytes );if _ddf !=nil {return _fe .SignatureValidationResult {},_ddf ;
};_bf =_bbff .Time ;_gad :=_bbff .HashAlgorithm .New ();_gad .Write (_gbbg );if !_gag .Equal (_gad .Sum (nil ),_bbff .HashedMessage ){return _fe .SignatureValidationResult {},_e .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_dac :=_fe .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_fadd ,IsOcspFound :_dec ,GeneralizedTime :_bf };return _dac ,nil ;};func (_ddg *etsiPAdES )getCRLs (_gdd []*_a .Certificate )([][]byte ,error ){_aad :=make ([][]byte ,0,len (_gdd ));
for _ ,_abc :=range _gdd {for _ ,_afde :=range _abc .CRLDistributionPoints {if _ddg .CertClient .IsCA (_abc ){continue ;};_ega ,_eca :=_ddg .CRLClient .MakeRequest (_afde ,_abc );if _eca !=nil {_ae .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_eca );
continue ;};_aad =append (_aad ,_ega );};};return _aad ,nil ;};type adobeX509RSASHA1 struct{_ceg *_gb .PrivateKey ;_gdfe *_a .Certificate ;_cfg SignFunc ;_ddbce bool ;_ead _egc .Hash ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _egc .Hash ;};func (_fegf *etsiPAdES )getCerts (_cf []*_a .Certificate )([][]byte ,error ){_fgbca :=make ([][]byte ,0,len (_cf ));for _ ,_dbf :=range _cf {_fgbca =append (_fgbca ,_dbf .Raw );};return _fgbca ,nil ;};

// InitSignature initialises the PdfSignature.
func (_eefgd *docTimeStamp )InitSignature (sig *_fe .PdfSignature )error {_bbe :=*_eefgd ;sig .Type =_ec .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_bbe ;sig .Filter =_ec .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_ec .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _eefgd ._cgg > 0{sig .Contents =_ec .MakeHexString (string (make ([]byte ,_eefgd ._cgg )));}else {_gef ,_gabb :=_eefgd .NewDigest (sig );
if _gabb !=nil {return _gabb ;};_gef .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _gabb =_bbe .Sign (sig ,_gef );
_gabb !=nil {return _gabb ;};_eefgd ._cgg =_bbe ._cgg ;};return nil ;};func (_gbg *etsiPAdES )addDss (_cfa ,_fb []*_a .Certificate ,_edd *RevocationInfoArchival )(int ,error ){_ffc ,_gbf ,_cba :=_gbg .buildCertChain (_cfa ,_fb );if _cba !=nil {return 0,_cba ;
};_ddd ,_cba :=_gbg .getCerts (_ffc );if _cba !=nil {return 0,_cba ;};var _ddba ,_gce [][]byte ;if _gbg .OCSPClient !=nil {_ddba ,_cba =_gbg .getOCSPs (_ffc ,_gbf );if _cba !=nil {return 0,_cba ;};};if _gbg .CRLClient !=nil {_gce ,_cba =_gbg .getCRLs (_ffc );
if _cba !=nil {return 0,_cba ;};};if !_gbg ._ad {_ ,_cba =_gbg ._eec .AddCerts (_ddd );if _cba !=nil {return 0,_cba ;};_ ,_cba =_gbg ._eec .AddOCSPs (_ddba );if _cba !=nil {return 0,_cba ;};_ ,_cba =_gbg ._eec .AddCRLs (_gce );if _cba !=nil {return 0,_cba ;
};};_dcfg :=0;for _ ,_cfad :=range _gce {_dcfg +=len (_cfad );_edd .Crl =append (_edd .Crl ,_c .RawValue {FullBytes :_cfad });};for _ ,_cbg :=range _ddba {_dcfg +=len (_cbg );_edd .Ocsp =append (_edd .Ocsp ,_c .RawValue {FullBytes :_cbg });};return _dcfg ,nil ;
};

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_c .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_c .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_c .RawValue `asn1:"explicit,tag:2,optional"`;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cca *docTimeStamp )IsApplicable (sig *_fe .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// InitSignature initialises the PdfSignature.
func (_dad *etsiPAdES )InitSignature (sig *_fe .PdfSignature )error {if !_dad ._dg {if _dad ._fdb ==nil {return _g .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _dad ._eefg ==nil {return _g .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_bc :=*_dad ;sig .Handler =&_bc ;sig .Filter =_ec .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_ec .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ceb ,_fgbc :=_bc .NewDigest (sig );if _fgbc !=nil {return _fgbc ;};_ ,_fgbc =_ceb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _fgbc !=nil {return _fgbc ;};_bc ._ad =true ;_fgbc =_bc .Sign (sig ,_ceb );_bc ._ad =false ;return _fgbc ;};func (_adde *adobeX509RSASHA1 )sign (_bbd *_fe .PdfSignature ,_fgab _fe .Hasher ,_bff bool )error {if !_bff {return _adde .Sign (_bbd ,_fgab );
};_bgfg ,_faeg :=_adde ._gdfe .PublicKey .(*_gb .PublicKey );if !_faeg {return _e .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_bgfg );};_bfca ,_bbge :=_c .Marshal (make ([]byte ,_bgfg .Size ()));
if _bbge !=nil {return _bbge ;};_bbd .Contents =_ec .MakeHexString (string (_bfca ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_efa *adobeX509RSASHA1 )Sign (sig *_fe .PdfSignature ,digest _fe .Hasher )error {var _adc []byte ;var _edbd error ;if _efa ._cfg !=nil {_adc ,_edbd =_efa ._cfg (sig ,digest );if _edbd !=nil {return _edbd ;};}else {_acg ,_gde :=digest .(_be .Hash );
if !_gde {return _g .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dca :=_dacf ;if _efa ._ead !=0{_dca =_efa ._ead ;};_adc ,_edbd =_gb .SignPKCS1v15 (_dc .Reader ,_efa ._ceg ,_dca ,_acg .Sum (nil ));if _edbd !=nil {return _edbd ;
};};_adc ,_edbd =_c .Marshal (_adc );if _edbd !=nil {return _edbd ;};sig .Contents =_ec .MakeHexString (string (_adc ));return nil ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_ab *DocMDPHandler )ValidateWithOpts (sig *_fe .PdfSignature ,digest _fe .Hasher ,params _fe .SignatureHandlerDocMDPParams )(_fe .SignatureValidationResult ,error ){_fa ,_ed :=_ab ._gf .Validate (sig ,digest );if _ed !=nil {return _fa ,_ed ;};_fgb :=params .Parser ;
if _fgb ==nil {return _fe .SignatureValidationResult {},_g .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_fa .IsVerified {return _fa ,nil ;};_ea :=params .DiffPolicy ;if _ea ==nil {_ea =_fc .NewDefaultDiffPolicy ();
};for _cec :=0;_cec <=_fgb .GetRevisionNumber ();_cec ++{_afd ,_egd :=_fgb .GetRevision (_cec );if _egd !=nil {return _fe .SignatureValidationResult {},_egd ;};_gbe :=_afd .GetTrailer ();if _gbe ==nil {return _fe .SignatureValidationResult {},_g .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_gd ,_bb :=_ec .GetDict (_gbe .Get ("\u0052\u006f\u006f\u0074"));if !_bb {return _fe .SignatureValidationResult {},_g .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");};
_fae ,_bb :=_ec .GetDict (_gd .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_bb {continue ;};_ede ,_bb :=_ec .GetArray (_fae .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_bb {continue ;};for _ ,_ff :=range _ede .Elements (){_bg ,_aea :=_ec .GetDict (_ff );
if !_aea {continue ;};_dcd ,_aea :=_ec .GetDict (_bg .Get ("\u0056"));if !_aea {continue ;};if _ec .EqualObjects (_dcd .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_fa .DiffResults ,_egd =_ea .ReviewFile (_afd ,_fgb ,&_fc .MDPParameters {DocMDPLevel :_ab .Permission });
if _egd !=nil {return _fe .SignatureValidationResult {},_egd ;};_fa .IsVerified =_fa .DiffResults .IsPermitted ();return _fa ,nil ;};};};return _fe .SignatureValidationResult {},_g .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};func (_eb *etsiPAdES )makeTimestampRequest (_gg string ,_cce []byte )(_c .RawValue ,error ){_bcb :=_egc .SHA512 .New ();_bcb .Write (_cce );_eeb :=_bcb .Sum (nil );_fga :=_cc .Request {HashAlgorithm :_egc .SHA512 ,HashedMessage :_eeb ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };
_fgg :=_dba .NewTimestampClient ();_fdf ,_feg :=_fgg .GetEncodedToken (_gg ,&_fga );if _feg !=nil {return _c .NullRawValue ,_feg ;};return _c .RawValue {FullBytes :_fdf },nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_dba .TimestampClient ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gfb *etsiPAdES )IsApplicable (sig *_fe .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// Sign sets the Contents fields for the PdfSignature.
func (_eac *etsiPAdES )Sign (sig *_fe .PdfSignature ,digest _fe .Hasher )error {_gfd ,_cd :=digest .(*_gag .Buffer );if !_cd {return _e .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ac ,_gga :=_ce .NewSignedData (_gfd .Bytes ());
if _gga !=nil {return _gga ;};_ac .SetDigestAlgorithm (_ce .OIDDigestAlgorithmSHA256 );_eefe :=_ce .SignerInfoConfig {};_ebd :=_egc .SHA256 .New ();_ebd .Write (_eac ._fdb .Raw );var _gc struct{Seq struct{Seq struct{Value []byte ;};};};_gc .Seq .Seq .Value =_ebd .Sum (nil );
var _edg []*_a .Certificate ;var _adb []*_a .Certificate ;if _eac ._ccg !=nil {_adb =[]*_a .Certificate {_eac ._ccg };};_gfc :=RevocationInfoArchival {Crl :[]_c .RawValue {},Ocsp :[]_c .RawValue {},OtherRevInfo :[]_c .RawValue {}};_ccga :=0;if _eac ._fac !=nil &&len (_eac ._bed )> 0{_egg ,_bgfa :=_eac .makeTimestampRequest (_eac ._bed ,([]byte )(""));
if _bgfa !=nil {return _bgfa ;};_dcc ,_bgfa :=_cc .Parse (_egg .FullBytes );if _bgfa !=nil {return _bgfa ;};_edg =append (_edg ,_dcc .Certificates ...);};if _eac ._fac !=nil {_fgc ,_edea :=_eac .addDss ([]*_a .Certificate {_eac ._fdb },_adb ,&_gfc );if _edea !=nil {return _edea ;
};_ccga +=_fgc ;if len (_edg )> 0{_fgc ,_edea =_eac .addDss (_edg ,nil ,&_gfc );if _edea !=nil {return _edea ;};_ccga +=_fgc ;};if !_eac ._ad {_eac ._fac .SetDSS (_eac ._eec );};};_eefe .ExtraSignedAttributes =append (_eefe .ExtraSignedAttributes ,_ce .Attribute {Type :_ce .OIDAttributeSigningCertificateV2 ,Value :_gc },_ce .Attribute {Type :_ce .OIDAttributeAdobeRevocation ,Value :_gfc });
if _fad :=_ac .AddSignerChainPAdES (_eac ._fdb ,_eac ._eefg ,_adb ,_eefe );_fad !=nil {return _fad ;};_ac .Detach ();if len (_eac ._bed )> 0{_efc :=_ac .GetSignedData ().SignerInfos [0].EncryptedDigest ;_bgb ,_ccb :=_eac .makeTimestampRequest (_eac ._bed ,_efc );
if _ccb !=nil {return _ccb ;};_ccb =_ac .AddTimestampTokenToSigner (0,_bgb .FullBytes );if _ccb !=nil {return _ccb ;};};_cbb ,_gga :=_ac .Finish ();if _gga !=nil {return _gga ;};_aee :=make ([]byte ,len (_cbb )+1024*2+_ccga );copy (_aee ,_cbb );sig .Contents =_ec .MakeHexString (string (_aee ));
if !_eac ._ad &&_eac ._eec !=nil {_ebd =_egc .SHA1 .New ();_ebd .Write (_aee );_afb :=_ga .ToUpper (_eg .EncodeToString (_ebd .Sum (nil )));if _afb !=""{_eac ._eec .VRI [_afb ]=&_fe .VRI {Cert :_eac ._eec .Certs ,OCSP :_eac ._eec .OCSPs ,CRL :_eac ._eec .CRLs };
};_eac ._fac .SetDSS (_eac ._eec );};return nil ;};

// InitSignature initialises the PdfSignature.
func (_edc *adobePKCS7Detached )InitSignature (sig *_fe .PdfSignature )error {if !_edc ._gade {if _edc ._adg ==nil {return _g .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _edc ._fbb ==nil {return _g .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fdd :=*_edc ;sig .Handler =&_fdd ;sig .Filter =_ec .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_ec .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ecd ,_edgf :=_fdd .NewDigest (sig );if _edgf !=nil {return _edgf ;};_ecd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fdd .Sign (sig ,_ecd );};type etsiPAdES struct{_eefg *_gb .PrivateKey ;_fdb *_a .Certificate ;_dg bool ;_ad bool ;_ccg *_a .Certificate ;_bed string ;

// CertClient is the client used to retrieve certificates.
CertClient *_dba .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_dba .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_dba .CRLClient ;_fac *_fe .PdfAppender ;_eec *_fe .DSS ;};

// NewDigest creates a new digest.
func (_aeb *adobePKCS7Detached )NewDigest (sig *_fe .PdfSignature )(_fe .Hasher ,error ){return _gag .NewBuffer (nil ),nil ;};

// Validate validates PdfSignature.
func (_fee *adobePKCS7Detached )Validate (sig *_fe .PdfSignature ,digest _fe .Hasher )(_fe .SignatureValidationResult ,error ){_bbg :=sig .Contents .Bytes ();_ddbc ,_eacb :=_ce .Parse (_bbg );if _eacb !=nil {return _fe .SignatureValidationResult {},_eacb ;
};_begg ,_fdbg :=digest .(*_gag .Buffer );if !_fdbg {return _fe .SignatureValidationResult {},_e .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ddbc .Content =_begg .Bytes ();if _eacb =_ddbc .Verify ();
_eacb !=nil {return _fe .SignatureValidationResult {},_eacb ;};return _fe .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_a .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_fe .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_gdfe :certificate ,_cfg :signFunc ,_ddbce :opts .EstimateSize ,_ead :opts .Algorithm },nil ;
};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_gb .PrivateKey ,certificate *_a .Certificate ,caCert *_a .Certificate )(_fe .SignatureHandler ,error ){return &etsiPAdES {_fdb :certificate ,_eefg :privateKey ,_ccg :caCert },nil ;};func (_bgg *etsiPAdES )getOCSPs (_gda []*_a .Certificate ,_eeg map[string ]*_a .Certificate )([][]byte ,error ){_cb :=make ([][]byte ,0,len (_gda ));
for _ ,_gbb :=range _gda {for _ ,_dade :=range _gbb .OCSPServer {if _bgg .CertClient .IsCA (_gbb ){continue ;};_gaf ,_cecg :=_eeg [_gbb .Issuer .CommonName ];if !_cecg {_ae .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_cee ,_gae :=_bgg .OCSPClient .MakeRequest (_dade ,_gbb ,_gaf );if _gae !=nil {_ae .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_gae );
continue ;};_cb =append (_cb ,_cee );};};return _cb ,nil ;};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_gb .PrivateKey ,certificate *_a .Certificate ,caCert *_a .Certificate ,certificateTimestampServerURL string )(_fe .SignatureHandler ,error ){return &etsiPAdES {_fdb :certificate ,_eefg :privateKey ,_ccg :caCert ,_bed :certificateTimestampServerURL },nil ;
};type adobePKCS7Detached struct{_fbb *_gb .PrivateKey ;_adg *_a .Certificate ;_gade bool ;_aef int ;};type docTimeStamp struct{_efg string ;_eda _egc .Hash ;_cgg int ;_egda *_dba .TimestampClient ;};

// Validate validates PdfSignature.
func (_eab *adobeX509RSASHA1 )Validate (sig *_fe .PdfSignature ,digest _fe .Hasher )(_fe .SignatureValidationResult ,error ){_adbd ,_ccf :=_eab .getCertificate (sig );if _ccf !=nil {return _fe .SignatureValidationResult {},_ccf ;};_ebdf :=sig .Contents .Bytes ();
var _feb []byte ;if _ ,_agg :=_c .Unmarshal (_ebdf ,&_feb );_agg !=nil {return _fe .SignatureValidationResult {},_agg ;};_abd ,_eafc :=digest .(_be .Hash );if !_eafc {return _fe .SignatureValidationResult {},_g .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ded ,_ :=_eab .getHashAlgorithm (sig );if _ded ==0{_ded =_dacf ;};if _cg :=_gb .VerifyPKCS1v15 (_adbd .PublicKey .(*_gb .PublicKey ),_ded ,_abd .Sum (nil ),_feb );_cg !=nil {return _fe .SignatureValidationResult {},_cg ;};return _fe .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_bdc *_fe .PdfSignature ,_dgb _fe .Hasher )([]byte ,error );func (_bgfc *adobePKCS7Detached )getCertificate (_faee *_fe .PdfSignature )(*_a .Certificate ,error ){if _bgfc ._adg !=nil {return _bgfc ._adg ,nil ;};_add ,_fgcg :=_faee .GetCerts ();
if _fgcg !=nil {return nil ,_fgcg ;};return _add [0],nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_gb .PrivateKey ,certificate *_a .Certificate )(_fe .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gdfe :certificate ,_ceg :privateKey },nil ;};

// NewDigest creates a new digest.
func (_gafb *adobeX509RSASHA1 )NewDigest (sig *_fe .PdfSignature )(_fe .Hasher ,error ){if _eefc ,_ccc :=_gafb .getHashAlgorithm (sig );_eefc !=0&&_ccc ==nil {return _eefc .New (),nil ;};return _dacf .New (),nil ;};

// NewDigest creates a new digest.
func (_ffce *etsiPAdES )NewDigest (_ *_fe .PdfSignature )(_fe .Hasher ,error ){return _gag .NewBuffer (nil ),nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_eacg *docTimeStamp )Sign (sig *_fe .PdfSignature ,digest _fe .Hasher )error {_cag ,_bdf :=_dba .NewTimestampRequest (digest .(*_gag .Buffer ),&_cc .RequestOptions {Hash :_eacg ._eda ,Certificates :true });if _bdf !=nil {return _bdf ;};_eeba :=_eacg ._egda ;
if _eeba ==nil {_eeba =_dba .NewTimestampClient ();};_gcfg ,_bdf :=_eeba .GetEncodedToken (_eacg ._efg ,_cag );if _bdf !=nil {return _bdf ;};_dfg :=len (_gcfg );if _eacg ._cgg > 0&&_dfg > _eacg ._cgg {return _fe .ErrSignNotEnoughSpace ;};if _dfg > 0{_eacg ._cgg =_dfg +128;
};if sig .Contents !=nil {_bdca :=sig .Contents .Bytes ();copy (_bdca ,_gcfg );_gcfg =_bdca ;};sig .Contents =_ec .MakeHexString (string (_gcfg ));return nil ;};

// NewDigest creates a new digest.
func (_fbga *docTimeStamp )NewDigest (sig *_fe .PdfSignature )(_fe .Hasher ,error ){return _gag .NewBuffer (nil ),nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_acfg *adobeX509RSASHA1 )IsApplicable (sig *_fe .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};type timestampInfo struct{Version int ;Policy _c .RawValue ;MessageImprint struct{HashAlgorithm _f .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _c .RawValue ;GeneralizedTime _db .Time ;};func _cbfc (_gdc _c .ObjectIdentifier )(_egc .Hash ,error ){switch {case _gdc .Equal (_ce .OIDDigestAlgorithmSHA1 ),_gdc .Equal (_ce .OIDDigestAlgorithmECDSASHA1 ),_gdc .Equal (_ce .OIDDigestAlgorithmDSA ),_gdc .Equal (_ce .OIDDigestAlgorithmDSASHA1 ),_gdc .Equal (_ce .OIDEncryptionAlgorithmRSA ):return _egc .SHA1 ,nil ;
case _gdc .Equal (_ce .OIDDigestAlgorithmSHA256 ),_gdc .Equal (_ce .OIDDigestAlgorithmECDSASHA256 ):return _egc .SHA256 ,nil ;case _gdc .Equal (_ce .OIDDigestAlgorithmSHA384 ),_gdc .Equal (_ce .OIDDigestAlgorithmECDSASHA384 ):return _egc .SHA384 ,nil ;
case _gdc .Equal (_ce .OIDDigestAlgorithmSHA512 ),_gdc .Equal (_ce .OIDDigestAlgorithmECDSASHA512 ):return _egc .SHA512 ,nil ;};return _egc .Hash (0),_ce .ErrUnsupportedAlgorithm ;};func (_aff *etsiPAdES )buildCertChain (_afc ,_beg []*_a .Certificate )([]*_a .Certificate ,map[string ]*_a .Certificate ,error ){_ddc :=map[string ]*_a .Certificate {};
for _ ,_ecag :=range _afc {_ddc [_ecag .Subject .CommonName ]=_ecag ;};_faf :=_afc ;for _ ,_bgf :=range _beg {_afg :=_bgf .Subject .CommonName ;if _ ,_df :=_ddc [_afg ];_df {continue ;};_ddc [_afg ]=_bgf ;_faf =append (_faf ,_bgf );};if len (_faf )==0{return nil ,nil ,_fe .ErrSignNoCertificates ;
};var _dadb error ;for _fab :=_faf [0];_fab !=nil &&!_aff .CertClient .IsCA (_fab );{var _eee *_a .Certificate ;_ ,_ddb :=_ddc [_fab .Issuer .CommonName ];if !_ddb {if _eee ,_dadb =_aff .CertClient .GetIssuer (_fab );_dadb !=nil {_ae .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_dadb );
break ;};_ddc [_fab .Issuer .CommonName ]=_eee ;_faf =append (_faf ,_eee );}else {break ;};_fab =_eee ;};return _faf ,_ddc ,nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_a .Certificate ,signFunc SignFunc )(_fe .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gdfe :certificate ,_cfg :signFunc },nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _egc .Hash )(_fe .SignatureHandler ,error ){return &docTimeStamp {_efg :timestampServerURL ,_eda :hashAlgorithm },nil ;};

// InitSignature initialises the PdfSignature.
func (_bfc *adobeX509RSASHA1 )InitSignature (sig *_fe .PdfSignature )error {if _bfc ._gdfe ==nil {return _g .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _bfc ._ceg ==nil &&_bfc ._cfg ==nil {return _g .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_fdg :=*_bfc ;sig .Handler =&_fdg ;sig .Filter =_ec .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ec .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_ec .MakeString (string (_fdg ._gdfe .Raw ));sig .Reference =nil ;_gabe ,_ffcf :=_fdg .NewDigest (sig );if _ffcf !=nil {return _ffcf ;};_gabe .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fdg .sign (sig ,_gabe ,_bfc ._ddbce );};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ee *DocMDPHandler )IsApplicable (sig *_fe .PdfSignature )bool {_cea :=false ;for _ ,_ef :=range sig .Reference .Elements (){if _fd ,_fg :=_ec .GetDict (_ef );_fg {if _af ,_de :=_ec .GetNameVal (_fd .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_de {if _af !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _ba ,_dd :=_ec .GetDict (_fd .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_dd {_ ,_eef :=_ec .GetNumberAsInt64 (_ba .Get ("\u0050"));if _eef !=nil {return false ;
};_cea =true ;break ;};};};};return _cea &&_ee ._gf .IsApplicable (sig );};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_fe .SignatureHandler ,error ){return &adobePKCS7Detached {_gade :true ,_aef :signatureLen },nil ;};func _agb (_ge []byte ,_afdc int )(_bae []byte ){_afe :=len (_ge );if _afe > _afdc {_afe =_afdc ;};_bae =make ([]byte ,_afdc );
copy (_bae [len (_bae )-_afe :],_ge );return ;};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_daa *DocMDPHandler )Validate (sig *_fe .PdfSignature ,digest _fe .Hasher )(_fe .SignatureValidationResult ,error ){return _fe .SignatureValidationResult {},_g .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};