//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_cd "bytes";_e "crypto";_ce "crypto/rand";_cg "crypto/rsa";_ga "crypto/x509";_ac "crypto/x509/pkix";_dg "encoding/asn1";_aa "errors";_bf "fmt";_acg "github.com/unidoc/pkcs7";_af "github.com/unidoc/timestamp";_bc "github.com/unidoc/unipdf/v3/core";_ba "github.com/unidoc/unipdf/v3/model";_b "hash";_f "io";_g "io/ioutil";_a "net/http";_d "time";);

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_ec *_ba .PdfSignature ,_dge _ba .Hasher )([]byte ,error );

// Sign sets the Contents fields.
func (_gf *adobePKCS7Detached )Sign (sig *_ba .PdfSignature ,digest _ba .Hasher )error {if _gf ._df {_cde :=_gf ._fc ;if _cde <=0{_cde =8192;};sig .Contents =_bc .MakeHexString (string (make ([]byte ,_cde )));return nil ;};_afe :=digest .(*_cd .Buffer );_bg ,_cgb :=_acg .NewSignedData (_afe .Bytes ());if _cgb !=nil {return _cgb ;};if _fb :=_bg .AddSigner (_gf ._ag ,_gf ._ad ,_acg .SignerInfoConfig {});_fb !=nil {return _fb ;};_bg .Detach ();_dc ,_cgb :=_bg .Finish ();if _cgb !=nil {return _cgb ;};_fdb :=make ([]byte ,8192);copy (_fdb ,_dc );sig .Contents =_bc .MakeHexString (string (_fdb ));return nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_ga .Certificate ,signFunc SignFunc )(_ba .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bge :certificate ,_gc :signFunc },nil ;};func _adfd (_bgec _dg .ObjectIdentifier )(_e .Hash ,error ){switch {case _bgec .Equal (_acg .OIDDigestAlgorithmSHA1 ),_bgec .Equal (_acg .OIDDigestAlgorithmECDSASHA1 ),_bgec .Equal (_acg .OIDDigestAlgorithmDSA ),_bgec .Equal (_acg .OIDDigestAlgorithmDSASHA1 ),_bgec .Equal (_acg .OIDEncryptionAlgorithmRSA ):return _e .SHA1 ,nil ;case _bgec .Equal (_acg .OIDDigestAlgorithmSHA256 ),_bgec .Equal (_acg .OIDDigestAlgorithmECDSASHA256 ):return _e .SHA256 ,nil ;case _bgec .Equal (_acg .OIDDigestAlgorithmSHA384 ),_bgec .Equal (_acg .OIDDigestAlgorithmECDSASHA384 ):return _e .SHA384 ,nil ;case _bgec .Equal (_acg .OIDDigestAlgorithmSHA512 ),_bgec .Equal (_acg .OIDDigestAlgorithmECDSASHA512 ):return _e .SHA512 ,nil ;};return _e .Hash (0),_acg .ErrUnsupportedAlgorithm ;};type docTimeStamp struct{_ecgd string ;_abg _e .Hash ;_gcc int ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_ba .SignatureHandler ,error ){return &adobePKCS7Detached {_df :true ,_fc :signatureLen },nil ;};

// Validate validates PdfSignature.
func (_fa *adobePKCS7Detached )Validate (sig *_ba .PdfSignature ,digest _ba .Hasher )(_ba .SignatureValidationResult ,error ){_ee :=sig .Contents .Bytes ();_cdd ,_bb :=_acg .Parse (_ee );if _bb !=nil {return _ba .SignatureValidationResult {},_bb ;};_efc :=digest .(*_cd .Buffer );_cdd .Content =_efc .Bytes ();if _bb =_cdd .Verify ();_bb !=nil {return _ba .SignatureValidationResult {},_bb ;};return _ba .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// Validate validates PdfSignature.
func (_adf *adobeX509RSASHA1 )Validate (sig *_ba .PdfSignature ,digest _ba .Hasher )(_ba .SignatureValidationResult ,error ){_ebb ,_ge :=_adf .getCertificate (sig );if _ge !=nil {return _ba .SignatureValidationResult {},_ge ;};_bda :=sig .Contents .Bytes ();var _gdf []byte ;if _ ,_fec :=_dg .Unmarshal (_bda ,&_gdf );_fec !=nil {return _ba .SignatureValidationResult {},_fec ;};_dga ,_baf :=digest .(_b .Hash );if !_baf {return _ba .SignatureValidationResult {},_aa .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_acb ,_ :=_gcf (_ebb .SignatureAlgorithm );if _bfd :=_cg .VerifyPKCS1v15 (_ebb .PublicKey .(*_cg .PublicKey ),_acb ,_dga .Sum (nil ),_gdf );_bfd !=nil {return _ba .SignatureValidationResult {},_bfd ;};return _ba .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// InitSignature initialises the PdfSignature.
func (_db *adobeX509RSASHA1 )InitSignature (sig *_ba .PdfSignature )error {if _db ._bge ==nil {return _aa .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _db ._abf ==nil &&_db ._gc ==nil {return _aa .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_dbd :=*_db ;sig .Handler =&_dbd ;sig .Filter =_bc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bc .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_bc .MakeString (string (_dbd ._bge .Raw ));sig .Reference =nil ;_dd ,_eeg :=_dbd .NewDigest (sig );if _eeg !=nil {return _eeg ;};_dd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _dbd .sign (sig ,_dd ,_db ._bd );};

// Validate validates PdfSignature.
func (_ebc *docTimeStamp )Validate (sig *_ba .PdfSignature ,digest _ba .Hasher )(_ba .SignatureValidationResult ,error ){_gaf :=sig .Contents .Bytes ();_dgaf ,_aaf :=_acg .Parse (_gaf );if _aaf !=nil {return _ba .SignatureValidationResult {},_aaf ;};if _aaf =_dgaf .Verify ();_aaf !=nil {return _ba .SignatureValidationResult {},_aaf ;};var _dca timestampInfo ;_ ,_aaf =_dg .Unmarshal (_dgaf .Content ,&_dca );if _aaf !=nil {return _ba .SignatureValidationResult {},_aaf ;};_cce ,_aaf :=_adfd (_dca .MessageImprint .HashAlgorithm .Algorithm );if _aaf !=nil {return _ba .SignatureValidationResult {},_aaf ;};_ebbb :=_cce .New ();_gba :=digest .(*_cd .Buffer );_ebbb .Write (_gba .Bytes ());_gda :=_ebbb .Sum (nil );_ebf :=_ba .SignatureValidationResult {IsSigned :true ,IsVerified :_cd .Equal (_gda ,_dca .MessageImprint .HashedMessage ),GeneralizedTime :_dca .GeneralizedTime };return _ebf ,nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_cg .PrivateKey ,certificate *_ga .Certificate )(_ba .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bge :certificate ,_abf :privateKey },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ca *adobeX509RSASHA1 )IsApplicable (sig *_ba .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// InitSignature initialises the PdfSignature.
func (_bae *adobePKCS7Detached )InitSignature (sig *_ba .PdfSignature )error {if !_bae ._df {if _bae ._ag ==nil {return _aa .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _bae ._ad ==nil {return _aa .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_bcg :=*_bae ;sig .Handler =&_bcg ;sig .Filter =_bc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bc .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ab ,_gg :=_bcg .NewDigest (sig );if _gg !=nil {return _gg ;};_ab .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _bcg .Sign (sig ,_ab );};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_cg .PrivateKey ,certificate *_ga .Certificate )(_ba .SignatureHandler ,error ){return &adobePKCS7Detached {_ag :certificate ,_ad :privateKey },nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_ga .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_ba .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_bge :certificate ,_gc :signFunc ,_bd :opts .EstimateSize },nil ;};type adobePKCS7Detached struct{_ad *_cg .PrivateKey ;_ag *_ga .Certificate ;_df bool ;_fc int ;};type timestampInfo struct{Version int ;Policy _dg .RawValue ;MessageImprint struct{HashAlgorithm _ac .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _dg .RawValue ;GeneralizedTime _d .Time ;};type adobeX509RSASHA1 struct{_abf *_cg .PrivateKey ;_bge *_ga .Certificate ;_gc SignFunc ;_bd bool ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_ace *adobePKCS7Detached )IsApplicable (sig *_ba .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};

// InitSignature initialises the PdfSignature.
func (_dfg *docTimeStamp )InitSignature (sig *_ba .PdfSignature )error {_eda :=*_dfg ;sig .Handler =&_eda ;sig .Filter =_bc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bc .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _dfg ._gcc > 0{sig .Contents =_bc .MakeHexString (string (make ([]byte ,_dfg ._gcc )));}else {_dbb ,_afc :=_dfg .NewDigest (sig );if _afc !=nil {return _afc ;};_dbb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _afc =_eda .Sign (sig ,_dbb );_afc !=nil {return _afc ;};_dfg ._gcc =_eda ._gcc ;};return nil ;};func _gcf (_bbf _ga .SignatureAlgorithm )(_e .Hash ,bool ){var _bfa _e .Hash ;switch _bbf {case _ga .SHA1WithRSA :_bfa =_e .SHA1 ;case _ga .SHA256WithRSA :_bfa =_e .SHA256 ;case _ga .SHA384WithRSA :_bfa =_e .SHA384 ;case _ga .SHA512WithRSA :_bfa =_e .SHA512 ;default:return _e .SHA1 ,false ;};return _bfa ,true ;};func (_eg *adobeX509RSASHA1 )sign (_geb *_ba .PdfSignature ,_bcb _ba .Hasher ,_bcbg bool )error {if !_bcbg {return _eg .Sign (_geb ,_bcb );};_dea ,_gb :=_eg ._bge .PublicKey .(*_cg .PublicKey );if !_gb {return _bf .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_dea );};_gcg ,_adb :=_dg .Marshal (make ([]byte ,_dea .Size ()));if _adb !=nil {return _adb ;};_geb .Contents =_bc .MakeHexString (string (_gcg ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gad *docTimeStamp )IsApplicable (sig *_ba .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};func (_aba *adobeX509RSASHA1 )getCertificate (_ed *_ba .PdfSignature )(*_ga .Certificate ,error ){if _aba ._bge !=nil {return _aba ._bge ,nil ;};_de ,_eb :=_ed .GetCerts ();if _eb !=nil {return nil ,_eb ;};return _de [0],nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _e .Hash )(_ba .SignatureHandler ,error ){return &docTimeStamp {_ecgd :timestampServerURL ,_abg :hashAlgorithm },nil ;};func (_ebe *docTimeStamp )getCertificate (_ccg *_ba .PdfSignature )(*_ga .Certificate ,error ){_bdad ,_feb :=_ccg .GetCerts ();if _feb !=nil {return nil ,_feb ;};return _bdad [0],nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// NewDigest creates a new digest.
func (_egd *docTimeStamp )NewDigest (sig *_ba .PdfSignature )(_ba .Hasher ,error ){return _cd .NewBuffer (nil ),nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_agb *adobeX509RSASHA1 )Sign (sig *_ba .PdfSignature ,digest _ba .Hasher )error {var _dff []byte ;var _cb error ;if _agb ._gc !=nil {_dff ,_cb =_agb ._gc (sig ,digest );if _cb !=nil {return _cb ;};}else {_fecd ,_ea :=digest .(_b .Hash );if !_ea {return _aa .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dae ,_ :=_gcf (_agb ._bge .SignatureAlgorithm );_dff ,_cb =_cg .SignPKCS1v15 (_ce .Reader ,_agb ._abf ,_dae ,_fecd .Sum (nil ));if _cb !=nil {return _cb ;};};_dff ,_cb =_dg .Marshal (_dff );if _cb !=nil {return _cb ;};sig .Contents =_bc .MakeHexString (string (_dff ));return nil ;};func (_ef *adobePKCS7Detached )getCertificate (_da *_ba .PdfSignature )(*_ga .Certificate ,error ){if _ef ._ag !=nil {return _ef ._ag ,nil ;};_aad ,_fd :=_da .GetCerts ();if _fd !=nil {return nil ,_fd ;};return _aad [0],nil ;};

// NewDigest creates a new digest.
func (_fe *adobeX509RSASHA1 )NewDigest (sig *_ba .PdfSignature )(_ba .Hasher ,error ){_gd ,_cga :=_fe .getCertificate (sig );if _cga !=nil {return nil ,_cga ;};_bdd ,_ :=_gcf (_gd .SignatureAlgorithm );return _bdd .New (),nil ;};

// NewDigest creates a new digest.
func (_aff *adobePKCS7Detached )NewDigest (sig *_ba .PdfSignature )(_ba .Hasher ,error ){return _cd .NewBuffer (nil ),nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _e .Hash ,opts *DocTimeStampOpts )(_ba .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_ecgd :timestampServerURL ,_abg :hashAlgorithm ,_gcc :opts .SignatureSize },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_bdb *docTimeStamp )Sign (sig *_ba .PdfSignature ,digest _ba .Hasher )error {_cf :=digest .(*_cd .Buffer );_ecd :=_bdb ._abg .New ();if _ ,_ebff :=_f .Copy (_ecd ,_cf );_ebff !=nil {return _ebff ;};_eaa :=_af .Request {HashAlgorithm :_bdb ._abg ,HashedMessage :_ecd .Sum (nil ),Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_ddg ,_bfc :=_eaa .Marshal ();if _bfc !=nil {return _bfc ;};_fdd ,_bfc :=_a .Post (_bdb ._ecgd ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_cd .NewBuffer (_ddg ));if _bfc !=nil {return _bfc ;};defer _fdd .Body .Close ();_dbbe ,_bfc :=_g .ReadAll (_fdd .Body );if _bfc !=nil {return _bfc ;};if _fdd .StatusCode !=_a .StatusOK {return _bf .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_fdd .StatusCode );};var _dce struct{Version _dg .RawValue ;Content _dg .RawValue ;};if _ ,_bfc =_dg .Unmarshal (_dbbe ,&_dce );_bfc !=nil {return _bfc ;};_bafb :=len (_dce .Content .FullBytes );if _bdb ._gcc > 0&&_bafb > _bdb ._gcc {return _ba .ErrSignNotEnoughSpace ;};if _bafb > 0{_bdb ._gcc =_bafb +128;};sig .Contents =_bc .MakeHexString (string (_dce .Content .FullBytes ));return nil ;};