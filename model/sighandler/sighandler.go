//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_gd "bytes";_ba "crypto";_ea "crypto/rand";_f "crypto/rsa";_aa "crypto/x509";_e "crypto/x509/pkix";_gf "encoding/asn1";_g "errors";_dg "fmt";_cc "github.com/unidoc/pkcs7";_eb "github.com/unidoc/timestamp";_ge "github.com/unidoc/unipdf/v3/core";
_dc "github.com/unidoc/unipdf/v3/model";_fa "github.com/unidoc/unipdf/v3/model/mdp";_eae "github.com/unidoc/unipdf/v3/model/sigutil";_d "hash";_c "math/big";_a "time";);type timestampInfo struct{Version int ;Policy _gf .RawValue ;MessageImprint struct{HashAlgorithm _e .AlgorithmIdentifier ;
HashedMessage []byte ;};SerialNumber _gf .RawValue ;GeneralizedTime _a .Time ;};func (_bgg *adobePKCS7Detached )getCertificate (_df *_dc .PdfSignature )(*_aa .Certificate ,error ){if _bgg ._fg !=nil {return _bgg ._fg ,nil ;};_cef ,_bgb :=_df .GetCerts ();
if _bgb !=nil {return nil ,_bgb ;};return _cef [0],nil ;};

// InitSignature initialises the PdfSignature.
func (_bged *docTimeStamp )InitSignature (sig *_dc .PdfSignature )error {_ddf :=*_bged ;sig .Handler =&_ddf ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");
sig .Reference =nil ;if _bged ._fddb > 0{sig .Contents =_ge .MakeHexString (string (make ([]byte ,_bged ._fddb )));}else {_dbg ,_gcae :=_bged .NewDigest (sig );if _gcae !=nil {return _gcae ;};_dbg .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _gcae =_ddf .Sign (sig ,_dbg );_gcae !=nil {return _gcae ;};_bged ._fddb =_ddf ._fddb ;};return nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_f .PrivateKey ,certificate *_aa .Certificate )(_dc .SignatureHandler ,error ){return &adobePKCS7Detached {_fg :certificate ,_ec :privateKey },nil ;};

// Sign sets the Contents fields.
func (_ab *adobePKCS7Detached )Sign (sig *_dc .PdfSignature ,digest _dc .Hasher )error {if _ab ._cee {_bbc :=_ab ._cf ;if _bbc <=0{_bbc =8192;};sig .Contents =_ge .MakeHexString (string (make ([]byte ,_bbc )));return nil ;};_dbc :=digest .(*_gd .Buffer );
_fba ,_fef :=_cc .NewSignedData (_dbc .Bytes ());if _fef !=nil {return _fef ;};if _cbd :=_fba .AddSigner (_ab ._fg ,_ab ._ec ,_cc .SignerInfoConfig {});_cbd !=nil {return _cbd ;};_fba .Detach ();_cce ,_fef :=_fba .Finish ();if _fef !=nil {return _fef ;
};_gfg :=make ([]byte ,8192);copy (_gfg ,_cce );sig .Contents =_ge .MakeHexString (string (_gfg ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fc *DocMDPHandler )IsApplicable (sig *_dc .PdfSignature )bool {_faf :=false ;for _ ,_cb :=range sig .Reference .Elements (){if _ce ,_dgc :=_ge .GetDict (_cb );_dgc {if _ga ,_gec :=_ge .GetNameVal (_ce .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_gec {if _ga !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _eac ,_ac :=_ge .GetDict (_ce .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_ac {_ ,_ebd :=_ge .GetNumberAsInt64 (_eac .Get ("\u0050"));
if _ebd !=nil {return false ;};_faf =true ;break ;};};};};return _faf &&_fc ._fb .IsApplicable (sig );};func _adb (_bda *_f .PublicKey ,_afg []byte )_ba .Hash {_eff :=_bda .Size ();if _eff !=len (_afg ){return 0;};_ggg :=func (_faae *_c .Int ,_afa *_f .PublicKey ,_eed *_c .Int )*_c .Int {_bbg :=_c .NewInt (int64 (_afa .E ));
_faae .Exp (_eed ,_bbg ,_afa .N );return _faae ;};_fcbf :=new (_c .Int ).SetBytes (_afg );_fdc :=_ggg (new (_c .Int ),_bda ,_fcbf );_ddd :=_feg (_fdc .Bytes (),_eff );if _ddd [0]!=0||_ddd [1]!=1{return 0;};_eca :=[]struct{Hash _ba .Hash ;Prefix []byte ;
}{{Hash :_ba .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_ba .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_ba .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_ba .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_ba .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_fdd :=range _eca {_gbd :=_fdd .Hash .Size ();_bad :=len (_fdd .Prefix )+_gbd ;if _gd .Equal (_ddd [_eff -_bad :_eff -_gbd ],_fdd .Prefix ){return _fdd .Hash ;};};return 0;};

// Validate validates PdfSignature.
func (_gc *adobePKCS7Detached )Validate (sig *_dc .PdfSignature ,digest _dc .Hasher )(_dc .SignatureValidationResult ,error ){_cbb :=sig .Contents .Bytes ();_cg ,_geb :=_cc .Parse (_cbb );if _geb !=nil {return _dc .SignatureValidationResult {},_geb ;};
_fff :=digest .(*_gd .Buffer );_cg .Content =_fff .Bytes ();if _geb =_cg .Verify ();_geb !=nil {return _dc .SignatureValidationResult {},_geb ;};return _dc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};func _feg (_gge []byte ,_ceee int )(_ccec []byte ){_gde :=len (_gge );
if _gde > _ceee {_gde =_ceee ;};_ccec =make ([]byte ,_ceee );copy (_ccec [len (_ccec )-_gde :],_gge );return ;};

// InitSignature initialization of the DocMDP signature.
func (_ad *DocMDPHandler )InitSignature (sig *_dc .PdfSignature )error {_ced :=_ad ._fb .InitSignature (sig );if _ced !=nil {return _ced ;};sig .Handler =_ad ;if sig .Reference ==nil {sig .Reference =_ge .MakeArray ();};sig .Reference .Append (_dc .NewPdfSignatureReferenceDocMDP (_dc .NewPdfTransformParamsDocMDP (_ad .Permission )).ToPdfObject ());
return nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_aa .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_dc .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_gfc :certificate ,_gbef :signFunc ,_cbc :opts .EstimateSize ,_fcb :opts .Algorithm },nil ;
};func (_edf *docTimeStamp )getCertificate (_acef *_dc .PdfSignature )(*_aa .Certificate ,error ){_bbde ,_ece :=_acef .GetCerts ();if _ece !=nil {return nil ,_ece ;};return _bbde [0],nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_ef *adobeX509RSASHA1 )Sign (sig *_dc .PdfSignature ,digest _dc .Hasher )error {var _eaa []byte ;var _gab error ;if _ef ._gbef !=nil {_eaa ,_gab =_ef ._gbef (sig ,digest );if _gab !=nil {return _gab ;};}else {_cdb ,_gcc :=digest .(_d .Hash );if !_gcc {return _g .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ebgc :=_abb ;if _ef ._fcb !=0{_ebgc =_ef ._fcb ;};_eaa ,_gab =_f .SignPKCS1v15 (_ea .Reader ,_ef ._bce ,_ebgc ,_cdb .Sum (nil ));if _gab !=nil {return _gab ;};};_eaa ,_gab =_gf .Marshal (_eaa );if _gab !=nil {return _gab ;};sig .Contents =_ge .MakeHexString (string (_eaa ));
return nil ;};const _abb =_ba .SHA1 ;

// NewDigest creates a new digest.
func (_fe *DocMDPHandler )NewDigest (sig *_dc .PdfSignature )(_dc .Hasher ,error ){return _fe ._fb .NewDigest (sig );};type docTimeStamp struct{_efd string ;_gca _ba .Hash ;_fddb int ;};

// InitSignature initialises the PdfSignature.
func (_bg *adobePKCS7Detached )InitSignature (sig *_dc .PdfSignature )error {if !_bg ._cee {if _bg ._fg ==nil {return _g .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _bg ._ec ==nil {return _g .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_gfee :=*_bg ;sig .Handler =&_gfee ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_ge .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_gbe ,_bf :=_gfee .NewDigest (sig );if _bf !=nil {return _bf ;};_gbe .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _gfee .Sign (sig ,_gbe );};type adobePKCS7Detached struct{_ec *_f .PrivateKey ;_fg *_aa .Certificate ;_cee bool ;_cf int ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// InitSignature initialises the PdfSignature.
func (_bd *adobeX509RSASHA1 )InitSignature (sig *_dc .PdfSignature )error {if _bd ._gfc ==nil {return _g .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _bd ._bce ==nil &&_bd ._gbef ==nil {return _g .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_eg :=*_bd ;sig .Handler =&_eg ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_ge .MakeString (string (_eg ._gfc .Raw ));sig .Reference =nil ;_dgf ,_cdd :=_eg .NewDigest (sig );if _cdd !=nil {return _cdd ;};_dgf .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _eg .sign (sig ,_dgf ,_bd ._cbc );};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_f .PrivateKey ,certificate *_aa .Certificate )(_dc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gfc :certificate ,_bce :privateKey },nil ;};

// NewDigest creates a new digest.
func (_fd *adobeX509RSASHA1 )NewDigest (sig *_dc .PdfSignature )(_dc .Hasher ,error ){if _ee ,_cefc :=_fd .getHashAlgorithm (sig );_ee !=0&&_cefc ==nil {return _ee .New (),nil ;};return _abb .New (),nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _ba .Hash ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _ba .Hash ,opts *DocTimeStampOpts )(_dc .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_efd :timestampServerURL ,_gca :hashAlgorithm ,_fddb :opts .SignatureSize },nil ;
};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _ba .Hash )(_dc .SignatureHandler ,error ){return &docTimeStamp {_efd :timestampServerURL ,_gca :hashAlgorithm },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gga *adobeX509RSASHA1 )IsApplicable (sig *_dc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// NewDigest creates a new digest.
func (_fcga *docTimeStamp )NewDigest (sig *_dc .PdfSignature )(_dc .Hasher ,error ){return _gd .NewBuffer (nil ),nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_ed *_dc .PdfSignature ,_gg _dc .Hasher )([]byte ,error );

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_dc .SignatureHandler ,error ){return &adobePKCS7Detached {_cee :true ,_cf :signatureLen },nil ;};func _cdg (_gece _gf .ObjectIdentifier )(_ba .Hash ,error ){switch {case _gece .Equal (_cc .OIDDigestAlgorithmSHA1 ),_gece .Equal (_cc .OIDDigestAlgorithmECDSASHA1 ),_gece .Equal (_cc .OIDDigestAlgorithmDSA ),_gece .Equal (_cc .OIDDigestAlgorithmDSASHA1 ),_gece .Equal (_cc .OIDEncryptionAlgorithmRSA ):return _ba .SHA1 ,nil ;
case _gece .Equal (_cc .OIDDigestAlgorithmSHA256 ),_gece .Equal (_cc .OIDDigestAlgorithmECDSASHA256 ):return _ba .SHA256 ,nil ;case _gece .Equal (_cc .OIDDigestAlgorithmSHA384 ),_gece .Equal (_cc .OIDDigestAlgorithmECDSASHA384 ):return _ba .SHA384 ,nil ;
case _gece .Equal (_cc .OIDDigestAlgorithmSHA512 ),_gece .Equal (_cc .OIDDigestAlgorithmECDSASHA512 ):return _ba .SHA512 ,nil ;};return _ba .Hash (0),_cc .ErrUnsupportedAlgorithm ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_faag *docTimeStamp )IsApplicable (sig *_dc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_bb *DocMDPHandler )Validate (sig *_dc .PdfSignature ,digest _dc .Hasher )(_dc .SignatureValidationResult ,error ){return _dc .SignatureValidationResult {},_g .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_aa .Certificate ,signFunc SignFunc )(_dc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gfc :certificate ,_gbef :signFunc },nil ;};type adobeX509RSASHA1 struct{_bce *_f .PrivateKey ;_gfc *_aa .Certificate ;
_gbef SignFunc ;_cbc bool ;_fcb _ba .Hash ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_fcg *DocMDPHandler )ValidateWithOpts (sig *_dc .PdfSignature ,digest _dc .Hasher ,params _dc .SignatureHandlerDocMDPParams )(_dc .SignatureValidationResult ,error ){_bac ,_ca :=_fcg ._fb .Validate (sig ,digest );if _ca !=nil {return _bac ,_ca ;};
_be :=params .Parser ;if _be ==nil {return _dc .SignatureValidationResult {},_g .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_bac .IsVerified {return _bac ,nil ;};_de :=params .DiffPolicy ;
if _de ==nil {_de =_fa .NewDefaultDiffPolicy ();};for _aaa :=0;_aaa <=_be .GetRevisionNumber ();_aaa ++{_ebg ,_bc :=_be .GetRevision (_aaa );if _bc !=nil {return _dc .SignatureValidationResult {},_bc ;};_bef :=_ebg .GetTrailer ();if _bef ==nil {return _dc .SignatureValidationResult {},_g .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_ag ,_ebc :=_ge .GetDict (_bef .Get ("\u0052\u006f\u006f\u0074"));if !_ebc {return _dc .SignatureValidationResult {},_g .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_cbe ,_ebc :=_ge .GetDict (_ag .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_ebc {continue ;};_dcb ,_ebc :=_ge .GetArray (_cbe .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_ebc {continue ;};for _ ,_gfd :=range _dcb .Elements (){_dec ,_da :=_ge .GetDict (_gfd );
if !_da {continue ;};_ff ,_da :=_ge .GetDict (_dec .Get ("\u0056"));if !_da {continue ;};if _ge .EqualObjects (_ff .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_bac .DiffResults ,_bc =_de .ReviewFile (_ebg ,_be ,&_fa .MDPParameters {DocMDPLevel :_fcg .Permission });
if _bc !=nil {return _dc .SignatureValidationResult {},_bc ;};_bac .IsVerified =_bac .DiffResults .IsPermitted ();return _bac ,nil ;};};};return _dc .SignatureValidationResult {},_g .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _dc .SignatureHandler ,permission _fa .DocMDPPermission )(_dc .SignatureHandler ,error ){return &DocMDPHandler {_fb :handler ,Permission :permission },nil ;};func (_ace *adobeX509RSASHA1 )getCertificate (_dgb *_dc .PdfSignature )(*_aa .Certificate ,error ){if _ace ._gfc !=nil {return _ace ._gfc ,nil ;
};_bfa ,_abd :=_dgb .GetCerts ();if _abd !=nil {return nil ,_abd ;};return _bfa [0],nil ;};

// Validate validates PdfSignature.
func (_gcb *adobeX509RSASHA1 )Validate (sig *_dc .PdfSignature ,digest _dc .Hasher )(_dc .SignatureValidationResult ,error ){_ebga ,_cad :=_gcb .getCertificate (sig );if _cad !=nil {return _dc .SignatureValidationResult {},_cad ;};_gdb :=sig .Contents .Bytes ();
var _bgbe []byte ;if _ ,_dd :=_gf .Unmarshal (_gdb ,&_bgbe );_dd !=nil {return _dc .SignatureValidationResult {},_dd ;};_cddc ,_dbf :=digest .(_d .Hash );if !_dbf {return _dc .SignatureValidationResult {},_g .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_dad ,_ :=_gcb .getHashAlgorithm (sig );if _dad ==0{_dad =_abb ;};if _bba :=_f .VerifyPKCS1v15 (_ebga .PublicKey .(*_f .PublicKey ),_dad ,_cddc .Sum (nil ),_bgbe );_bba !=nil {return _dc .SignatureValidationResult {},_bba ;};return _dc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_fb _dc .SignatureHandler ;Permission _fa .DocMDPPermission ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_cd *adobePKCS7Detached )IsApplicable (sig *_dc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// Validate validates PdfSignature.
func (_cgg *docTimeStamp )Validate (sig *_dc .PdfSignature ,digest _dc .Hasher )(_dc .SignatureValidationResult ,error ){_cbf :=sig .Contents .Bytes ();_fac ,_ggb :=_cc .Parse (_cbf );if _ggb !=nil {return _dc .SignatureValidationResult {},_ggb ;};if _ggb =_fac .Verify ();
_ggb !=nil {return _dc .SignatureValidationResult {},_ggb ;};var _gbf timestampInfo ;_ ,_ggb =_gf .Unmarshal (_fac .Content ,&_gbf );if _ggb !=nil {return _dc .SignatureValidationResult {},_ggb ;};_cadd ,_ggb :=_cdg (_gbf .MessageImprint .HashAlgorithm .Algorithm );
if _ggb !=nil {return _dc .SignatureValidationResult {},_ggb ;};_gbc :=_cadd .New ();_edb :=digest .(*_gd .Buffer );_gbc .Write (_edb .Bytes ());_cceb :=_gbc .Sum (nil );_dab :=_dc .SignatureValidationResult {IsSigned :true ,IsVerified :_gd .Equal (_cceb ,_gbf .MessageImprint .HashedMessage ),GeneralizedTime :_gbf .GeneralizedTime };
return _dab ,nil ;};

// Sign adds a new reference to signature's references array.
func (_gfe *DocMDPHandler )Sign (sig *_dc .PdfSignature ,digest _dc .Hasher )error {return _gfe ._fb .Sign (sig ,digest );};

// Sign sets the Contents fields for the PdfSignature.
func (_eee *docTimeStamp )Sign (sig *_dc .PdfSignature ,digest _dc .Hasher )error {_gaf ,_cfb :=_eae .NewTimestampRequest (digest .(*_gd .Buffer ),&_eb .RequestOptions {Hash :_eee ._gca ,Certificates :true });if _cfb !=nil {return _cfb ;};_faac :=_eae .NewTimestampClient ();
_gfdf ,_cfb :=_faac .GetEncodedToken (_eee ._efd ,_gaf );if _cfb !=nil {return _cfb ;};_ceg :=len (_gfdf );if _eee ._fddb > 0&&_ceg > _eee ._fddb {return _dc .ErrSignNotEnoughSpace ;};if _ceg > 0{_eee ._fddb =_ceg +128;};sig .Contents =_ge .MakeHexString (string (_gfdf ));
return nil ;};func (_ceeg *adobeX509RSASHA1 )getHashAlgorithm (_fed *_dc .PdfSignature )(_ba .Hash ,error ){_gag ,_af :=_ceeg .getCertificate (_fed );if _af !=nil {if _ceeg ._fcb !=0{return _ceeg ._fcb ,nil ;};return _abb ,_af ;};if _fed .Contents !=nil {_aaf :=_fed .Contents .Bytes ();
var _acc []byte ;if _ ,_ded :=_gf .Unmarshal (_aaf ,&_acc );_ded ==nil {_dfg :=_adb (_gag .PublicKey .(*_f .PublicKey ),_acc );if _dfg > 0{return _dfg ,nil ;};};};if _ceeg ._fcb !=0{return _ceeg ._fcb ,nil ;};return _abb ,nil ;};func (_bbd *adobeX509RSASHA1 )sign (_gecd *_dc .PdfSignature ,_gdg _dc .Hasher ,_dce bool )error {if !_dce {return _bbd .Sign (_gecd ,_gdg );
};_bee ,_ede :=_bbd ._gfc .PublicKey .(*_f .PublicKey );if !_ede {return _dg .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_bee );};_eaca ,_dbfa :=_gf .Marshal (make ([]byte ,_bee .Size ()));
if _dbfa !=nil {return _dbfa ;};_gecd .Contents =_ge .MakeHexString (string (_eaca ));return nil ;};

// NewDigest creates a new digest.
func (_eag *adobePKCS7Detached )NewDigest (sig *_dc .PdfSignature )(_dc .Hasher ,error ){return _gd .NewBuffer (nil ),nil ;};