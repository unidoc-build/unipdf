//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_c "bytes";_g "crypto";_df "crypto/rand";_fg "crypto/rsa";_dd "crypto/x509";_bg "crypto/x509/pkix";_cg "encoding/asn1";_bb "errors";_eg "fmt";_dc "github.com/unidoc/pkcs7";_dcc "github.com/unidoc/timestamp";_fb "github.com/unidoc/unipdf/v3/core";_ad "github.com/unidoc/unipdf/v3/model";_b "hash";_f "io";_ed "io/ioutil";_d "net/http";_a "time";);

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_fg .PrivateKey ,certificate *_dd .Certificate )(_ad .SignatureHandler ,error ){return &adobeX509RSASHA1 {_ga :certificate ,_bec :privateKey },nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_ad .SignatureHandler ,error ){return &adobePKCS7Detached {_ddf :true ,_ef :signatureLen },nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_dd .Certificate ,signFunc SignFunc )(_ad .SignatureHandler ,error ){return &adobeX509RSASHA1 {_ga :certificate ,_dfc :signFunc },nil ;};

// Validate validates PdfSignature.
func (_fe *adobePKCS7Detached )Validate (sig *_ad .PdfSignature ,digest _ad .Hasher )(_ad .SignatureValidationResult ,error ){_bbb :=sig .Contents .Bytes ();_ge ,_gb :=_dc .Parse (_bbb );if _gb !=nil {return _ad .SignatureValidationResult {},_gb ;};_fc :=digest .(*_c .Buffer );_ge .Content =_fc .Bytes ();if _gb =_ge .Verify ();_gb !=nil {return _ad .SignatureValidationResult {},_gb ;};return _ad .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};func (_adg *adobeX509RSASHA1 )getCertificate (_aab *_ad .PdfSignature )(*_dd .Certificate ,error ){if _adg ._ga !=nil {return _adg ._ga ,nil ;};_ace ,_ea :=_aab .GetCerts ();if _ea !=nil {return nil ,_ea ;};return _ace [0],nil ;};func _aga (_faf _cg .ObjectIdentifier )(_g .Hash ,error ){switch {case _faf .Equal (_dc .OIDDigestAlgorithmSHA1 ),_faf .Equal (_dc .OIDDigestAlgorithmECDSASHA1 ),_faf .Equal (_dc .OIDDigestAlgorithmDSA ),_faf .Equal (_dc .OIDDigestAlgorithmDSASHA1 ),_faf .Equal (_dc .OIDEncryptionAlgorithmRSA ):return _g .SHA1 ,nil ;case _faf .Equal (_dc .OIDDigestAlgorithmSHA256 ),_faf .Equal (_dc .OIDDigestAlgorithmECDSASHA256 ):return _g .SHA256 ,nil ;case _faf .Equal (_dc .OIDDigestAlgorithmSHA384 ),_faf .Equal (_dc .OIDDigestAlgorithmECDSASHA384 ):return _g .SHA384 ,nil ;case _faf .Equal (_dc .OIDDigestAlgorithmSHA512 ),_faf .Equal (_dc .OIDDigestAlgorithmECDSASHA512 ):return _g .SHA512 ,nil ;};return _g .Hash (0),_dc .ErrUnsupportedAlgorithm ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bbc *docTimeStamp )IsApplicable (sig *_ad .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};type timestampInfo struct{Version int ;Policy _cg .RawValue ;MessageImprint struct{HashAlgorithm _bg .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _cg .RawValue ;GeneralizedTime _a .Time ;};

// InitSignature initialises the PdfSignature.
func (_daa *adobeX509RSASHA1 )InitSignature (sig *_ad .PdfSignature )error {if _daa ._ga ==nil {return _bb .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _daa ._bec ==nil &&_daa ._dfc ==nil {return _bb .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_dcb :=*_daa ;sig .Handler =&_dcb ;sig .Filter =_fb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_fb .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_fb .MakeString (string (_dcb ._ga .Raw ));sig .Reference =nil ;_cfd ,_eeb :=_dcb .NewDigest (sig );if _eeb !=nil {return _eeb ;};_cfd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _dcb .sign (sig ,_cfd ,_daa ._beg );};

// Sign sets the Contents fields for the PdfSignature.
func (_efd *adobeX509RSASHA1 )Sign (sig *_ad .PdfSignature ,digest _ad .Hasher )error {var _aeb []byte ;var _ebg error ;if _efd ._dfc !=nil {_aeb ,_ebg =_efd ._dfc (sig ,digest );if _ebg !=nil {return _ebg ;};}else {_cb ,_dea :=digest .(_b .Hash );if !_dea {return _bb .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dfb ,_ :=_fa (_efd ._ga .SignatureAlgorithm );_aeb ,_ebg =_fg .SignPKCS1v15 (_df .Reader ,_efd ._bec ,_dfb ,_cb .Sum (nil ));if _ebg !=nil {return _ebg ;};};_aeb ,_ebg =_cg .Marshal (_aeb );if _ebg !=nil {return _ebg ;};sig .Contents =_fb .MakeHexString (string (_aeb ));return nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_fg .PrivateKey ,certificate *_dd .Certificate )(_ad .SignatureHandler ,error ){return &adobePKCS7Detached {_eb :certificate ,_fgg :privateKey },nil ;};

// NewDigest creates a new digest.
func (_fdg *docTimeStamp )NewDigest (sig *_ad .PdfSignature )(_ad .Hasher ,error ){return _c .NewBuffer (nil ),nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _g .Hash )(_ad .SignatureHandler ,error ){return &docTimeStamp {_eae :timestampServerURL ,_ged :hashAlgorithm },nil ;};func (_de *adobePKCS7Detached )getCertificate (_ff *_ad .PdfSignature )(*_dd .Certificate ,error ){if _de ._eb !=nil {return _de ._eb ,nil ;};_efe ,_ae :=_ff .GetCerts ();if _ae !=nil {return nil ,_ae ;};return _efe [0],nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_fge *adobePKCS7Detached )IsApplicable (sig *_ad .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};type docTimeStamp struct{_eae string ;_ged _g .Hash ;_fae int ;};

// Sign sets the Contents fields.
func (_ac *adobePKCS7Detached )Sign (sig *_ad .PdfSignature ,digest _ad .Hasher )error {if _ac ._ddf {_db :=_ac ._ef ;if _db <=0{_db =8192;};sig .Contents =_fb .MakeHexString (string (make ([]byte ,_db )));return nil ;};_cf :=digest .(*_c .Buffer );_gd ,_da :=_dc .NewSignedData (_cf .Bytes ());if _da !=nil {return _da ;};if _gg :=_gd .AddSigner (_ac ._eb ,_ac ._fgg ,_dc .SignerInfoConfig {});_gg !=nil {return _gg ;};_gd .Detach ();_gc ,_da :=_gd .Finish ();if _da !=nil {return _da ;};_ffb :=make ([]byte ,8192);copy (_ffb ,_gc );sig .Contents =_fb .MakeHexString (string (_ffb ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_fbd *docTimeStamp )InitSignature (sig *_ad .PdfSignature )error {_dbc :=*_fbd ;sig .Handler =&_dbc ;sig .Filter =_fb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_fb .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _fbd ._fae > 0{sig .Contents =_fb .MakeHexString (string (make ([]byte ,_fbd ._fae )));}else {_gaf ,_fag :=_fbd .NewDigest (sig );if _fag !=nil {return _fag ;};_gaf .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _fag =_dbc .Sign (sig ,_gaf );_fag !=nil {return _fag ;};_fbd ._fae =_dbc ._fae ;};return nil ;};func _fa (_aag _dd .SignatureAlgorithm )(_g .Hash ,bool ){var _dda _g .Hash ;switch _aag {case _dd .SHA1WithRSA :_dda =_g .SHA1 ;case _dd .SHA256WithRSA :_dda =_g .SHA256 ;case _dd .SHA384WithRSA :_dda =_g .SHA384 ;case _dd .SHA512WithRSA :_dda =_g .SHA512 ;default:return _g .SHA1 ,false ;};return _dda ,true ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_dd .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_ad .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_ga :certificate ,_dfc :signFunc ,_beg :opts .EstimateSize },nil ;};

// NewDigest creates a new digest.
func (_bd *adobePKCS7Detached )NewDigest (sig *_ad .PdfSignature )(_ad .Hasher ,error ){return _c .NewBuffer (nil ),nil ;};type adobePKCS7Detached struct{_fgg *_fg .PrivateKey ;_eb *_dd .Certificate ;_ddf bool ;_ef int ;};

// Validate validates PdfSignature.
func (_fda *docTimeStamp )Validate (sig *_ad .PdfSignature ,digest _ad .Hasher )(_ad .SignatureValidationResult ,error ){_cbd :=sig .Contents .Bytes ();_gbd ,_eba :=_dc .Parse (_cbd );if _eba !=nil {return _ad .SignatureValidationResult {},_eba ;};if _eba =_gbd .Verify ();_eba !=nil {return _ad .SignatureValidationResult {},_eba ;};var _gbe timestampInfo ;_ ,_eba =_cg .Unmarshal (_gbd .Content ,&_gbe );if _eba !=nil {return _ad .SignatureValidationResult {},_eba ;};_aad ,_eba :=_aga (_gbe .MessageImprint .HashAlgorithm .Algorithm );if _eba !=nil {return _ad .SignatureValidationResult {},_eba ;};_gga :=_aad .New ();_dbb :=digest .(*_c .Buffer );_gga .Write (_dbb .Bytes ());_cc :=_gga .Sum (nil );_eacg :=_ad .SignatureValidationResult {IsSigned :true ,IsVerified :_c .Equal (_cc ,_gbe .MessageImprint .HashedMessage ),GeneralizedTime :_gbe .GeneralizedTime };return _eacg ,nil ;};type adobeX509RSASHA1 struct{_bec *_fg .PrivateKey ;_ga *_dd .Certificate ;_dfc SignFunc ;_beg bool ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_bba *_ad .PdfSignature ,_ee _ad .Hasher )([]byte ,error );

// NewDigest creates a new digest.
func (_edb *adobeX509RSASHA1 )NewDigest (sig *_ad .PdfSignature )(_ad .Hasher ,error ){_eac ,_eeg :=_edb .getCertificate (sig );if _eeg !=nil {return nil ,_eeg ;};_ggf ,_ :=_fa (_eac .SignatureAlgorithm );return _ggf .New (),nil ;};func (_adge *docTimeStamp )getCertificate (_cd *_ad .PdfSignature )(*_dd .Certificate ,error ){_eacc ,_aebf :=_cd .GetCerts ();if _aebf !=nil {return nil ,_aebf ;};return _eacc [0],nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _g .Hash ,opts *DocTimeStampOpts )(_ad .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_eae :timestampServerURL ,_ged :hashAlgorithm ,_fae :opts .SignatureSize },nil ;};

// Validate validates PdfSignature.
func (_ede *adobeX509RSASHA1 )Validate (sig *_ad .PdfSignature ,digest _ad .Hasher )(_ad .SignatureValidationResult ,error ){_gab ,_fdb :=_ede .getCertificate (sig );if _fdb !=nil {return _ad .SignatureValidationResult {},_fdb ;};_ffc :=sig .Contents .Bytes ();var _dfcd []byte ;if _ ,_ba :=_cg .Unmarshal (_ffc ,&_dfcd );_ba !=nil {return _ad .SignatureValidationResult {},_ba ;};_baa ,_dec :=digest .(_b .Hash );if !_dec {return _ad .SignatureValidationResult {},_bb .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bgb ,_ :=_fa (_gab .SignatureAlgorithm );if _acg :=_fg .VerifyPKCS1v15 (_gab .PublicKey .(*_fg .PublicKey ),_bgb ,_baa .Sum (nil ),_dfcd );_acg !=nil {return _ad .SignatureValidationResult {},_acg ;};return _ad .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// InitSignature initialises the PdfSignature.
func (_fbf *adobePKCS7Detached )InitSignature (sig *_ad .PdfSignature )error {if !_fbf ._ddf {if _fbf ._eb ==nil {return _bb .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _fbf ._fgg ==nil {return _bb .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_aa :=*_fbf ;sig .Handler =&_aa ;sig .Filter =_fb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_fb .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_dg ,_be :=_aa .NewDigest (sig );if _be !=nil {return _be ;};_dg .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _aa .Sign (sig ,_dg );};func (_becd *adobeX509RSASHA1 )sign (_efec *_ad .PdfSignature ,_bc _ad .Hasher ,_efa bool )error {if !_efa {return _becd .Sign (_efec ,_bc );};_bf ,_bcf :=_becd ._ga .PublicKey .(*_fg .PublicKey );if !_bcf {return _eg .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_bf );};_fca ,_bdc :=_cg .Marshal (make ([]byte ,_bf .Size ()));if _bdc !=nil {return _bdc ;};_efec .Contents =_fb .MakeHexString (string (_fca ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_bga *docTimeStamp )Sign (sig *_ad .PdfSignature ,digest _ad .Hasher )error {_cbdc :=digest .(*_c .Buffer );_deb :=_bga ._ged .New ();if _ ,_af :=_f .Copy (_deb ,_cbdc );_af !=nil {return _af ;};_fbe :=_dcc .Request {HashAlgorithm :_bga ._ged ,HashedMessage :_deb .Sum (nil ),Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_cab ,_gee :=_fbe .Marshal ();if _gee !=nil {return _gee ;};_ccb ,_gee :=_d .Post (_bga ._eae ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_c .NewBuffer (_cab ));if _gee !=nil {return _gee ;};defer _ccb .Body .Close ();_add ,_gee :=_ed .ReadAll (_ccb .Body );if _gee !=nil {return _gee ;};if _ccb .StatusCode !=_d .StatusOK {return _eg .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_ccb .StatusCode );};var _bgbb struct{Version _cg .RawValue ;Content _cg .RawValue ;};if _ ,_gee =_cg .Unmarshal (_add ,&_bgbb );_gee !=nil {return _gee ;};_ggd :=len (_bgbb .Content .FullBytes );if _bga ._fae > 0&&_ggd > _bga ._fae {return _ad .ErrSignNotEnoughSpace ;};if _ggd > 0{_bga ._fae =_ggd +128;};sig .Contents =_fb .MakeHexString (string (_bgbb .Content .FullBytes ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ag *adobeX509RSASHA1 )IsApplicable (sig *_ad .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;};