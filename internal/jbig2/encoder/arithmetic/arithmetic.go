//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_f "github.com/unidoc/unipdf/v3/common";_gc "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_b "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func New ()*Encoder {_eaf :=&Encoder {};_eaf .Init ();return _eaf };func (_baf *Encoder )setBits (){_gfe :=_baf ._cg +uint32 (_baf ._bb );_baf ._cg |=0xffff;if _baf ._cg >=_gfe {_baf ._cg -=0x8000;};};func (_bae *Encoder )encodeBit (_ccg *codingContext ,_dfg uint32 ,_ggf uint8 )error {const _fgg ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_bae ._ee ++;if _dfg >=uint32 (len (_ccg ._ad )){return _b .Errorf (_fgg ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dfg );};_fbga :=_ccg ._ad [_dfg ];_gdf :=_ccg .mps (_dfg );_ggbf :=_abd [_fbga ]._cbf ;_f .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bae ._ee ,_ggf ,_fbga ,_gdf ,_ggbf ,_bae ._bb ,_bae ._cg ,_bae ._bg ,_bae ._df ,_bae ._gg );if _ggf ==0{_bae .code0 (_ccg ,_dfg ,_ggbf ,_fbga );}else {_bae .code1 (_ccg ,_dfg ,_ggbf ,_fbga );};return nil ;};func (_fc *Encoder )flush (){_fc .setBits ();_fc ._cg <<=_fc ._bg ;_fc .byteOut ();_fc ._cg <<=_fc ._bg ;_fc .byteOut ();_fc .emit ();if _fc ._df !=0xff{_fc ._gg ++;_fc ._df =0xff;_fc .emit ();};_fc ._gg ++;_fc ._df =0xac;_fc ._gg ++;_fc .emit ();};func (_cb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gga error ){_f .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _gga =_cb .encodeIAID (symbolCodeLength ,value );_gga !=nil {return _b .Wrap (_gga ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_ead *Encoder )Init (){_ead ._ec =_ga (_fddf );_ead ._bb =0x8000;_ead ._cg =0;_ead ._bg =12;_ead ._gg =-1;_ead ._df =0;_ead ._db =0;_ead ._fd =make ([]byte ,_edee );for _eed :=0;_eed < len (_ead ._cd );_eed ++{_ead ._cd [_eed ]=_ga (512);};_ead ._ag =nil ;};func (_dec *Encoder )code1 (_ggbd *codingContext ,_fbg uint32 ,_cbe uint16 ,_dfe byte ){if _ggbd .mps (_fbg )==1{_dec .codeMPS (_ggbd ,_fbg ,_cbe ,_dfe );}else {_dec .codeLPS (_ggbd ,_fbg ,_cbe ,_dfe );};};type Encoder struct{_cg uint32 ;_bb uint16 ;_bg ,_df uint8 ;_gg int ;_ee int ;_dab [][]byte ;_fd []byte ;_db int ;_ec *codingContext ;_cd [13]*codingContext ;_ag *codingContext ;};func (_gcf *codingContext )flipMps (_ae uint32 ){_gcf ._fg [_ae ]=1-_gcf ._fg [_ae ]};func (_a Class )String ()string {switch _a {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_cea *Encoder )codeMPS (_aeb *codingContext ,_eef uint32 ,_gae uint16 ,_eg byte ){_cea ._bb -=_gae ;if _cea ._bb &0x8000!=0{_cea ._cg +=uint32 (_gae );return ;};if _cea ._bb < _gae {_cea ._bb =_gae ;}else {_cea ._cg +=uint32 (_gae );};_aeb ._ad [_eef ]=_abd [_eg ]._bbcc ;_cea .renormalize ();};func (_gbe *Encoder )EncodeBitmap (bm *_gc .Bitmap ,duplicateLineRemoval bool )error {_f .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_ecc ,_af uint8 ;_ab ,_bf ,_aa uint16 ;_ff ,_bba ,_ed byte ;_dc ,_eae ,_agg int ;_edd ,_adg []byte ;);for _bgc :=0;_bgc < bm .Height ;_bgc ++{_ff ,_bba =0,0;if _bgc >=2{_ff =bm .Data [(_bgc -2)*bm .RowStride ];};if _bgc >=1{_bba =bm .Data [(_bgc -1)*bm .RowStride ];if duplicateLineRemoval {_eae =_bgc *bm .RowStride ;_edd =bm .Data [_eae :_eae +bm .RowStride ];_agg =(_bgc -1)*bm .RowStride ;_adg =bm .Data [_agg :_agg +bm .RowStride ];if _g .Equal (_edd ,_adg ){_af =_ecc ^1;_ecc =1;}else {_af =_ecc ;_ecc =0;};};};if duplicateLineRemoval {if _ca :=_gbe .encodeBit (_gbe ._ec ,_fac ,_af );_ca !=nil {return _ca ;};if _ecc !=0{continue ;};};_ed =bm .Data [_bgc *bm .RowStride ];_ab =uint16 (_ff >>5);_bf =uint16 (_bba >>4);_ff <<=3;_bba <<=4;_aa =0;for _dc =0;_dc < bm .Width ;_dc ++{_dfc :=uint32 (_ab <<11|_bf <<4|_aa );_bc :=(_ed &0x80)>>7;_dce :=_gbe .encodeBit (_gbe ._ec ,_dfc ,_bc );if _dce !=nil {return _dce ;};_ab <<=1;_bf <<=1;_aa <<=1;_ab |=uint16 ((_ff &0x80)>>7);_bf |=uint16 ((_bba &0x80)>>7);_aa |=uint16 (_bc );_dabb :=_dc %8;_gd :=_dc /8+1;if _dabb ==4&&_bgc >=2{_ff =0;if _gd < bm .RowStride {_ff =bm .Data [(_bgc -2)*bm .RowStride +_gd ];};}else {_ff <<=1;};if _dabb ==3&&_bgc >=1{_bba =0;if _gd < bm .RowStride {_bba =bm .Data [(_bgc -1)*bm .RowStride +_gd ];};}else {_bba <<=1;};if _dabb ==7{_ed =0;if _gd < bm .RowStride {_ed =bm .Data [_bgc *bm .RowStride +_gd ];};}else {_ed <<=1;};_ab &=31;_bf &=127;_aa &=15;};};return nil ;};const _fac =0x9b25;func (_gbc *Encoder )EncodeInteger (proc Class ,value int )(_fga error ){_f .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _fga =_gbc .encodeInteger (proc ,value );_fga !=nil {return _b .Wrap (_fga ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_ede *Encoder )EncodeOOB (proc Class )(_dd error ){_f .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _dd =_ede .encodeOOB (proc );_dd !=nil {return _b .Wrap (_dd ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};var _ac =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};type codingContext struct{_ad []byte ;_fg []byte ;};func (_ggb *Encoder )Reset (){_ggb ._bb =0x8000;_ggb ._cg =0;_ggb ._bg =12;_ggb ._gg =-1;_ggb ._df =0;_ggb ._ag =nil ;_ggb ._ec =_ga (_fddf );};type intEncRangeS struct{_fa ,_ea int ;_d ,_cc uint8 ;_da uint16 ;_faa uint8 ;};func _ga (_faf int )*codingContext {return &codingContext {_ad :make ([]byte ,_faf ),_fg :make ([]byte ,_faf )};};func (_ffb *Encoder )renormalize (){for {_ffb ._bb <<=1;_ffb ._cg <<=1;_ffb ._bg --;if _ffb ._bg ==0{_ffb .byteOut ();};if (_ffb ._bb &0x8000)!=0{break ;};};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_egf *Encoder )codeLPS (_aee *codingContext ,_egg uint32 ,_bbaf uint16 ,_cbb byte ){_egf ._bb -=_bbaf ;if _egf ._bb < _bbaf {_egf ._cg +=uint32 (_bbaf );}else {_egf ._bb =_bbaf ;};if _abd [_cbb ]._cba ==1{_aee .flipMps (_egg );};_aee ._ad [_egg ]=_abd [_cbb ]._bdb ;_egf .renormalize ();};func (_gb *codingContext )mps (_de uint32 )int {return int (_gb ._fg [_de ])};var _abd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_bbc *Encoder )encodeInteger (_cfa Class ,_acd int )error {const _dege ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _acd > 2000000000||_acd < -2000000000{return _b .Errorf (_dege ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_acd );};_bfcd :=_bbc ._cd [_cfa ];_ffa :=uint32 (1);var _fdg int ;for ;;_fdg ++{if _ac [_fdg ]._fa <=_acd &&_ac [_fdg ]._ea >=_acd {break ;};};if _acd < 0{_acd =-_acd ;};_acd -=int (_ac [_fdg ]._da );_gbb :=_ac [_fdg ]._d ;for _bca :=uint8 (0);_bca < _ac [_fdg ]._cc ;_bca ++{_dcg :=_gbb &1;if _ded :=_bbc .encodeBit (_bfcd ,_ffa ,_dcg );_ded !=nil {return _b .Wrap (_ded ,_dege ,"");};_gbb >>=1;if _ffa &0x100> 0{_ffa =(((_ffa <<1)|uint32 (_dcg ))&0x1ff)|0x100;}else {_ffa =(_ffa <<1)|uint32 (_dcg );};};_acd <<=32-_ac [_fdg ]._faa ;for _ef :=uint8 (0);_ef < _ac [_fdg ]._faa ;_ef ++{_cgg :=uint8 ((uint32 (_acd )&0x80000000)>>31);if _cbg :=_bbc .encodeBit (_bfcd ,_ffa ,_cgg );_cbg !=nil {return _b .Wrap (_cbg ,_dege ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_acd <<=1;if _ffa &0x100!=0{_ffa =(((_ffa <<1)|uint32 (_cgg ))&0x1ff)|0x100;}else {_ffa =(_ffa <<1)|uint32 (_cgg );};};return nil ;};func (_gf *Encoder )Final (){_gf .flush ()};func (_ggfa *Encoder )encodeOOB (_dbb Class )error {_fbe :=_ggfa ._cd [_dbb ];_ccf :=_ggfa .encodeBit (_fbe ,1,1);if _ccf !=nil {return _ccf ;};_ccf =_ggfa .encodeBit (_fbe ,3,0);if _ccf !=nil {return _ccf ;};_ccf =_ggfa .encodeBit (_fbe ,6,0);if _ccf !=nil {return _ccf ;};_ccf =_ggfa .encodeBit (_fbe ,12,0);if _ccf !=nil {return _ccf ;};return nil ;};func (_fdf *Encoder )Flush (){_fdf ._db =0;_fdf ._dab =nil ;_fdf ._gg =-1};func (_be *Encoder )code0 (_afc *codingContext ,_abb uint32 ,_gde uint16 ,_ba byte ){if _afc .mps (_abb )==0{_be .codeMPS (_afc ,_abb ,_gde ,_ba );}else {_be .codeLPS (_afc ,_abb ,_gde ,_ba );};};func (_dece *Encoder )encodeIAID (_ffd ,_edg int )error {if _dece ._ag ==nil {_dece ._ag =_ga (1<<uint (_ffd ));};_bbb :=uint32 (1<<uint32 (_ffd +1))-1;_edg <<=uint (32-_ffd );_cgb :=uint32 (1);for _edde :=0;_edde < _ffd ;_edde ++{_aab :=_cgb &_bbb ;_eag :=uint8 ((uint32 (_edg )&0x80000000)>>31);if _cfd :=_dece .encodeBit (_dece ._ag ,_aab ,_eag );_cfd !=nil {return _cfd ;};_cgb =(_cgb <<1)|uint32 (_eag );_edg <<=1;};return nil ;};func (_fcf *Encoder )rBlock (){if _fcf ._gg >=0{_fcf .emit ();};_fcf ._gg ++;_fcf ._df =uint8 (_fcf ._cg >>20);_fcf ._cg &=0xfffff;_fcf ._bg =7;};var _ _c .WriterTo =&Encoder {};func (_dcd *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _deg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _cfe int64 ;for _dcf ,_gac :=range _dcd ._dab {_ggg ,_bd :=w .Write (_gac );if _bd !=nil {return 0,_b .Wrapf (_bd ,_deg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_dcf );};_cfe +=int64 (_ggg );};_dcd ._fd =_dcd ._fd [:_dcd ._db ];_fbd ,_fdd :=w .Write (_dcd ._fd );if _fdd !=nil {return 0,_b .Wrap (_fdd ,_deg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cfe +=int64 (_fbd );return _cfe ,nil ;};func (_gdd *Encoder )emit (){if _gdd ._db ==_edee {_gdd ._dab =append (_gdd ._dab ,_gdd ._fd );_gdd ._fd =make ([]byte ,_edee );_gdd ._db =0;};_gdd ._fd [_gdd ._db ]=_gdd ._df ;_gdd ._db ++;};type Class int ;type state struct{_cbf uint16 ;_bbcc ,_bdb uint8 ;_cba uint8 ;};const (_fddf =65536;_edee =20*1024;);func (_agb *Encoder )byteOut (){if _agb ._df ==0xff{_agb .rBlock ();return ;};if _agb ._cg < 0x8000000{_agb .lBlock ();return ;};_agb ._df ++;if _agb ._df !=0xff{_agb .lBlock ();return ;};_agb ._cg &=0x7ffffff;_agb .rBlock ();};func (_ccb *Encoder )DataSize ()int {return _ccb .dataSize ()};func (_eeg *Encoder )Refine (iTemp ,iTarget *_gc .Bitmap ,ox ,oy int )error {for _fae :=0;_fae < iTarget .Height ;_fae ++{var _cf int ;_eccf :=_fae +oy ;var (_cgc ,_fb ,_ce ,_gfb ,_bgf uint16 ;_cga ,_gfd ,_ecf ,_bga ,_aaf byte ;);if _eccf >=1&&(_eccf -1)< iTemp .Height {_cga =iTemp .Data [(_eccf -1)*iTemp .RowStride ];};if _eccf >=0&&_eccf < iTemp .Height {_gfd =iTemp .Data [_eccf *iTemp .RowStride ];};if _eccf >=-1&&_eccf +1< iTemp .Height {_ecf =iTemp .Data [(_eccf +1)*iTemp .RowStride ];};if _fae >=1{_bga =iTarget .Data [(_fae -1)*iTarget .RowStride ];};_aaf =iTarget .Data [_fae *iTarget .RowStride ];_cec :=uint (6+ox );_cgc =uint16 (_cga >>_cec );_fb =uint16 (_gfd >>_cec );_ce =uint16 (_ecf >>_cec );_gfb =uint16 (_bga >>6);_ffg :=uint (2-ox );_cga <<=_ffg ;_gfd <<=_ffg ;_ecf <<=_ffg ;_bga <<=2;for _cf =0;_cf < iTarget .Width ;_cf ++{_dag :=(_cgc <<10)|(_fb <<7)|(_ce <<4)|(_gfb <<1)|_bgf ;_bfc :=_aaf >>7;_bfb :=_eeg .encodeBit (_eeg ._ec ,uint32 (_dag ),_bfc );if _bfb !=nil {return _bfb ;};_cgc <<=1;_fb <<=1;_ce <<=1;_gfb <<=1;_cgc |=uint16 (_cga >>7);_fb |=uint16 (_gfd >>7);_ce |=uint16 (_ecf >>7);_gfb |=uint16 (_bga >>7);_bgf =uint16 (_bfc );_cdf :=_cf %8;_dcc :=_cf /8+1;if _cdf ==5+ox {_cga ,_gfd ,_ecf =0,0,0;if _dcc < iTemp .RowStride &&_eccf >=1&&(_eccf -1)< iTemp .Height {_cga =iTemp .Data [(_eccf -1)*iTemp .RowStride +_dcc ];};if _dcc < iTemp .RowStride &&_eccf >=0&&_eccf < iTemp .Height {_gfd =iTemp .Data [_eccf *iTemp .RowStride +_dcc ];};if _dcc < iTemp .RowStride &&_eccf >=-1&&(_eccf +1)< iTemp .Height {_ecf =iTemp .Data [(_eccf +1)*iTemp .RowStride +_dcc ];};}else {_cga <<=1;_gfd <<=1;_ecf <<=1;};if _cdf ==5&&_fae >=1{_bga =0;if _dcc < iTarget .RowStride {_bga =iTarget .Data [(_fae -1)*iTarget .RowStride +_dcc ];};}else {_bga <<=1;};if _cdf ==7{_aaf =0;if _dcc < iTarget .RowStride {_aaf =iTarget .Data [_fae *iTarget .RowStride +_dcc ];};}else {_aaf <<=1;};_cgc &=7;_fb &=7;_ce &=7;_gfb &=7;};};return nil ;};func (_agc *Encoder )lBlock (){if _agc ._gg >=0{_agc .emit ();};_agc ._gg ++;_agc ._df =uint8 (_agc ._cg >>19);_agc ._cg &=0x7ffff;_agc ._bg =8;};func (_ge *Encoder )dataSize ()int {return _edee *len (_ge ._dab )+_ge ._db };