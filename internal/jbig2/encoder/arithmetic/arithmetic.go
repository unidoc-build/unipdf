//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "bytes";_e "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_d "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gc "io";);type codingContext struct{_bc []byte ;_fg []byte ;};
func (_gcf *Encoder )DataSize ()int {return _gcf .dataSize ()};var _ _gc .WriterTo =&Encoder {};const (_cag =65536;_fdg =20*1024;);func (_cc *Encoder )Flush (){_cc ._dd =0;_cc ._eb =nil ;_cc ._af =-1};func _fgf (_bd int )*codingContext {return &codingContext {_bc :make ([]byte ,_bd ),_fg :make ([]byte ,_bd )};
};const _ace =0x9b25;func (_fa *codingContext )flipMps (_db uint32 ){_fa ._fg [_db ]=1-_fa ._fg [_db ]};func New ()*Encoder {_ce :=&Encoder {};_ce .Init ();return _ce };func (_dbf *Encoder )flush (){_dbf .setBits ();_dbf ._gca <<=_dbf ._bbb ;_dbf .byteOut ();
_dbf ._gca <<=_dbf ._bbb ;_dbf .byteOut ();_dbf .emit ();if _dbf ._a !=0xff{_dbf ._af ++;_dbf ._a =0xff;_dbf .emit ();};_dbf ._af ++;_dbf ._a =0xac;_dbf ._af ++;_dbf .emit ();};type intEncRangeS struct{_ed ,_b int ;_ga ,_ee uint8 ;_bb uint16 ;_eeg uint8 ;
};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_bdb *Encoder )EncodeBitmap (bm *_f .Bitmap ,duplicateLineRemoval bool )error {_e .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_ddg ,_cd uint8 ;_cdf ,_acg ,_ab uint16 ;_ebb ,_ddb ,_ad byte ;_gg ,_bdbg ,_gf int ;_eee ,_cb []byte ;);for _be :=0;_be < bm .Height ;_be ++{_ebb ,_ddb =0,0;if _be >=2{_ebb =bm .Data [(_be -2)*bm .RowStride ];};if _be >=1{_ddb =bm .Data [(_be -1)*bm .RowStride ];
if duplicateLineRemoval {_bdbg =_be *bm .RowStride ;_eee =bm .Data [_bdbg :_bdbg +bm .RowStride ];_gf =(_be -1)*bm .RowStride ;_cb =bm .Data [_gf :_gf +bm .RowStride ];if _c .Equal (_eee ,_cb ){_cd =_ddg ^1;_ddg =1;}else {_cd =_ddg ;_ddg =0;};};};if duplicateLineRemoval {if _fca :=_bdb .encodeBit (_bdb ._ac ,_ace ,_cd );
_fca !=nil {return _fca ;};if _ddg !=0{continue ;};};_ad =bm .Data [_be *bm .RowStride ];_cdf =uint16 (_ebb >>5);_acg =uint16 (_ddb >>4);_ebb <<=3;_ddb <<=4;_ab =0;for _gg =0;_gg < bm .Width ;_gg ++{_ge :=uint32 (_cdf <<11|_acg <<4|_ab );_fga :=(_ad &0x80)>>7;
_faa :=_bdb .encodeBit (_bdb ._ac ,_ge ,_fga );if _faa !=nil {return _faa ;};_cdf <<=1;_acg <<=1;_ab <<=1;_cdf |=uint16 ((_ebb &0x80)>>7);_acg |=uint16 ((_ddb &0x80)>>7);_ab |=uint16 (_fga );_cgb :=_gg %8;_fe :=_gg /8+1;if _cgb ==4&&_be >=2{_ebb =0;if _fe < bm .RowStride {_ebb =bm .Data [(_be -2)*bm .RowStride +_fe ];
};}else {_ebb <<=1;};if _cgb ==3&&_be >=1{_ddb =0;if _fe < bm .RowStride {_ddb =bm .Data [(_be -1)*bm .RowStride +_fe ];};}else {_ddb <<=1;};if _cgb ==7{_ad =0;if _fe < bm .RowStride {_ad =bm .Data [_be *bm .RowStride +_fe ];};}else {_ad <<=1;};_cdf &=31;
_acg &=127;_ab &=15;};};return nil ;};func (_bcb *Encoder )code0 (_gfd *codingContext ,_fge uint32 ,_ag uint16 ,_fd byte ){if _gfd .mps (_fge )==0{_bcb .codeMPS (_gfd ,_fge ,_ag ,_fd );}else {_bcb .codeLPS (_gfd ,_fge ,_ag ,_fd );};};func (_aa *Encoder )Refine (iTemp ,iTarget *_f .Bitmap ,ox ,oy int )error {for _cdb :=0;
_cdb < iTarget .Height ;_cdb ++{var _cbc int ;_df :=_cdb +oy ;var (_gcb ,_eg ,_dec ,_bed ,_dg uint16 ;_dc ,_cbg ,_fed ,_afd ,_bec byte ;);if _df >=1&&(_df -1)< iTemp .Height {_dc =iTemp .Data [(_df -1)*iTemp .RowStride ];};if _df >=0&&_df < iTemp .Height {_cbg =iTemp .Data [_df *iTemp .RowStride ];
};if _df >=-1&&_df +1< iTemp .Height {_fed =iTemp .Data [(_df +1)*iTemp .RowStride ];};if _cdb >=1{_afd =iTarget .Data [(_cdb -1)*iTarget .RowStride ];};_bec =iTarget .Data [_cdb *iTarget .RowStride ];_ebc :=uint (6+ox );_gcb =uint16 (_dc >>_ebc );_eg =uint16 (_cbg >>_ebc );
_dec =uint16 (_fed >>_ebc );_bed =uint16 (_afd >>6);_gfc :=uint (2-ox );_dc <<=_gfc ;_cbg <<=_gfc ;_fed <<=_gfc ;_afd <<=2;for _cbc =0;_cbc < iTarget .Width ;_cbc ++{_ae :=(_gcb <<10)|(_eg <<7)|(_dec <<4)|(_bed <<1)|_dg ;_fcab :=_bec >>7;_da :=_aa .encodeBit (_aa ._ac ,uint32 (_ae ),_fcab );
if _da !=nil {return _da ;};_gcb <<=1;_eg <<=1;_dec <<=1;_bed <<=1;_gcb |=uint16 (_dc >>7);_eg |=uint16 (_cbg >>7);_dec |=uint16 (_fed >>7);_bed |=uint16 (_afd >>7);_dg =uint16 (_fcab );_gbb :=_cbc %8;_fb :=_cbc /8+1;if _gbb ==5+ox {_dc ,_cbg ,_fed =0,0,0;
if _fb < iTemp .RowStride &&_df >=1&&(_df -1)< iTemp .Height {_dc =iTemp .Data [(_df -1)*iTemp .RowStride +_fb ];};if _fb < iTemp .RowStride &&_df >=0&&_df < iTemp .Height {_cbg =iTemp .Data [_df *iTemp .RowStride +_fb ];};if _fb < iTemp .RowStride &&_df >=-1&&(_df +1)< iTemp .Height {_fed =iTemp .Data [(_df +1)*iTemp .RowStride +_fb ];
};}else {_dc <<=1;_cbg <<=1;_fed <<=1;};if _gbb ==5&&_cdb >=1{_afd =0;if _fb < iTarget .RowStride {_afd =iTarget .Data [(_cdb -1)*iTarget .RowStride +_fb ];};}else {_afd <<=1;};if _gbb ==7{_bec =0;if _fb < iTarget .RowStride {_bec =iTarget .Data [_cdb *iTarget .RowStride +_fb ];
};}else {_bec <<=1;};_gcb &=7;_eg &=7;_dec &=7;_bed &=7;};};return nil ;};func (_ddgd *Encoder )EncodeOOB (proc Class )(_gfe error ){_e .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _gfe =_ddgd .encodeOOB (proc );_gfe !=nil {return _d .Wrap (_gfe ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};var _ba =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
var _ede =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_cf *Encoder )EncodeInteger (proc Class ,value int )(_deb error ){_e .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _deb =_cf .encodeInteger (proc ,value );_deb !=nil {return _d .Wrap (_deb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_fgdcg *Encoder )encodeOOB (_bga Class )error {_gcac :=_fgdcg ._fadb [_bga ];
_gac :=_fgdcg .encodeBit (_gcac ,1,1);if _gac !=nil {return _gac ;};_gac =_fgdcg .encodeBit (_gcac ,3,0);if _gac !=nil {return _gac ;};_gac =_fgdcg .encodeBit (_gcac ,6,0);if _gac !=nil {return _gac ;};_gac =_fgdcg .encodeBit (_gcac ,12,0);if _gac !=nil {return _gac ;
};return nil ;};func (_ff *codingContext )mps (_edc uint32 )int {return int (_ff ._fg [_edc ])};func (_gb Class )String ()string {switch _gb {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";
case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";
case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_bg *Encoder )Init (){_bg ._ac =_fgf (_cag );
_bg ._fc =0x8000;_bg ._gca =0;_bg ._bbb =12;_bg ._af =-1;_bg ._a =0;_bg ._dd =0;_bg ._fad =make ([]byte ,_fdg );for _cg :=0;_cg < len (_bg ._fadb );_cg ++{_bg ._fadb [_cg ]=_fgf (512);};_bg ._gaa =nil ;};func (_bdg *Encoder )codeMPS (_aeg *codingContext ,_gaaa uint32 ,_bge uint16 ,_egc byte ){_bdg ._fc -=_bge ;
if _bdg ._fc &0x8000!=0{_bdg ._gca +=uint32 (_bge );return ;};if _bdg ._fc < _bge {_bdg ._fc =_bge ;}else {_bdg ._gca +=uint32 (_bge );};_aeg ._bc [_gaaa ]=_ede [_egc ]._ccb ;_bdg .renormalize ();};func (_dcd *Encoder )lBlock (){if _dcd ._af >=0{_dcd .emit ();
};_dcd ._af ++;_dcd ._a =uint8 (_dcd ._gca >>19);_dcd ._gca &=0x7ffff;_dcd ._bbb =8;};func (_fab *Encoder )code1 (_efb *codingContext ,_ddc uint32 ,_feb uint16 ,_egf byte ){if _efb .mps (_ddc )==1{_fab .codeMPS (_efb ,_ddc ,_feb ,_egf );}else {_fab .codeLPS (_efb ,_ddc ,_feb ,_egf );
};};func (_fbf *Encoder )setBits (){_fcae :=_fbf ._gca +uint32 (_fbf ._fc );_fbf ._gca |=0xffff;if _fbf ._gca >=_fcae {_fbf ._gca -=0x8000;};};func (_daf *Encoder )WriteTo (w _gc .Writer )(int64 ,error ){const _dfg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _ec int64 ;for _bfe ,_ca :=range _daf ._eb {_dfc ,_eca :=w .Write (_ca );if _eca !=nil {return 0,_d .Wrapf (_eca ,_dfg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_bfe );
};_ec +=int64 (_dfc );};_daf ._fad =_daf ._fad [:_daf ._dd ];_fcb ,_beg :=w .Write (_daf ._fad );if _beg !=nil {return 0,_d .Wrap (_beg ,_dfg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ec +=int64 (_fcb );return _ec ,nil ;
};func (_gcbf *Encoder )byteOut (){if _gcbf ._a ==0xff{_gcbf .rBlock ();return ;};if _gcbf ._gca < 0x8000000{_gcbf .lBlock ();return ;};_gcbf ._a ++;if _gcbf ._a !=0xff{_gcbf .lBlock ();return ;};_gcbf ._gca &=0x7ffffff;_gcbf .rBlock ();};func (_fedc *Encoder )encodeInteger (_dgc Class ,_gfa int )error {const _cgbc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _gfa > 2000000000||_gfa < -2000000000{return _d .Errorf (_cgbc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gfa );
};_cge :=_fedc ._fadb [_dgc ];_abf :=uint32 (1);var _afe int ;for ;;_afe ++{if _ba [_afe ]._ed <=_gfa &&_ba [_afe ]._b >=_gfa {break ;};};if _gfa < 0{_gfa =-_gfa ;};_gfa -=int (_ba [_afe ]._bb );_bac :=_ba [_afe ]._ga ;for _fea :=uint8 (0);_fea < _ba [_afe ]._ee ;
_fea ++{_fgdc :=_bac &1;if _gcfe :=_fedc .encodeBit (_cge ,_abf ,_fgdc );_gcfe !=nil {return _d .Wrap (_gcfe ,_cgbc ,"");};_bac >>=1;if _abf &0x100> 0{_abf =(((_abf <<1)|uint32 (_fgdc ))&0x1ff)|0x100;}else {_abf =(_abf <<1)|uint32 (_fgdc );};};_gfa <<=32-_ba [_afe ]._eeg ;
for _bgb :=uint8 (0);_bgb < _ba [_afe ]._eeg ;_bgb ++{_ecg :=uint8 ((uint32 (_gfa )&0x80000000)>>31);if _ddf :=_fedc .encodeBit (_cge ,_abf ,_ecg );_ddf !=nil {return _d .Wrap (_ddf ,_cgbc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_gfa <<=1;if _abf &0x100!=0{_abf =(((_abf <<1)|uint32 (_ecg ))&0x1ff)|0x100;}else {_abf =(_abf <<1)|uint32 (_ecg );};};return nil ;};func (_gfda *Encoder )dataSize ()int {return _fdg *len (_gfda ._eb )+_gfda ._dd };func (_gga *Encoder )encodeBit (_gbc *codingContext ,_fgd uint32 ,_cgbg uint8 )error {const _edgd ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_gga ._de ++;if _fgd >=uint32 (len (_gbc ._bc )){return _d .Errorf (_edgd ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fgd );
};_fcc :=_gbc ._bc [_fgd ];_egd :=_gbc .mps (_fgd );_gdf :=_ede [_fcc ]._fce ;_e .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gga ._de ,_cgbg ,_fcc ,_egd ,_gdf ,_gga ._fc ,_gga ._gca ,_gga ._bbb ,_gga ._a ,_gga ._af );
if _cgbg ==0{_gga .code0 (_gbc ,_fgd ,_gdf ,_fcc );}else {_gga .code1 (_gbc ,_fgd ,_gdf ,_fcc );};return nil ;};type Encoder struct{_gca uint32 ;_fc uint16 ;_bbb ,_a uint8 ;_af int ;_de int ;_eb [][]byte ;_fad []byte ;_dd int ;_ac *codingContext ;_fadb [13]*codingContext ;
_gaa *codingContext ;};func (_ef *Encoder )Final (){_ef .flush ()};func (_gag *Encoder )rBlock (){if _gag ._af >=0{_gag .emit ();};_gag ._af ++;_gag ._a =uint8 (_gag ._gca >>20);_gag ._gca &=0xfffff;_gag ._bbb =7;};func (_dfa *Encoder )renormalize (){for {_dfa ._fc <<=1;
_dfa ._gca <<=1;_dfa ._bbb --;if _dfa ._bbb ==0{_dfa .byteOut ();};if (_dfa ._fc &0x8000)!=0{break ;};};};func (_bf *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gab error ){_e .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gab =_bf .encodeIAID (symbolCodeLength ,value );_gab !=nil {return _d .Wrap (_gab ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_edg *Encoder )emit (){if _edg ._dd ==_fdg {_edg ._eb =append (_edg ._eb ,_edg ._fad );
_edg ._fad =make ([]byte ,_fdg );_edg ._dd =0;};_edg ._fad [_edg ._dd ]=_edg ._a ;_edg ._dd ++;};type state struct{_fce uint16 ;_ccb ,_bbc uint8 ;_daa uint8 ;};func (_gd *Encoder )codeLPS (_ded *codingContext ,_bdf uint32 ,_ade uint16 ,_gad byte ){_gd ._fc -=_ade ;
if _gd ._fc < _ade {_gd ._gca +=uint32 (_ade );}else {_gd ._fc =_ade ;};if _ede [_gad ]._daa ==1{_ded .flipMps (_bdf );};_ded ._bc [_bdf ]=_ede [_gad ]._bbc ;_gd .renormalize ();};func (_fedf *Encoder )encodeIAID (_ggc ,_cba int )error {if _fedf ._gaa ==nil {_fedf ._gaa =_fgf (1<<uint (_ggc ));
};_dad :=uint32 (1<<uint32 (_ggc +1))-1;_cba <<=uint (32-_ggc );_dba :=uint32 (1);for _efg :=0;_efg < _ggc ;_efg ++{_gef :=_dba &_dad ;_ffa :=uint8 ((uint32 (_cba )&0x80000000)>>31);if _age :=_fedf .encodeBit (_fedf ._gaa ,_gef ,_ffa );_age !=nil {return _age ;
};_dba =(_dba <<1)|uint32 (_ffa );_cba <<=1;};return nil ;};func (_cgf *Encoder )Reset (){_cgf ._fc =0x8000;_cgf ._gca =0;_cgf ._bbb =12;_cgf ._af =-1;_cgf ._a =0;_cgf ._gaa =nil ;_cgf ._ac =_fgf (_cag );};type Class int ;