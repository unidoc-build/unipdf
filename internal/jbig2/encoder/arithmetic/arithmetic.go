//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_b "github.com/unidoc/unipdf/v3/common";_bb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ec "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gg "io";);func (_fec *Encoder )EncodeBitmap (bm *_bb .Bitmap ,duplicateLineRemoval bool )error {_b .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_gb ,_fg uint8 ;_bbf ,_ba ,_bdg uint16 ;_ea ,_bee ,_dgf byte ;_cad ,_ee ,_ecf int ;_gfc ,_eeb []byte ;);for _bbb :=0;_bbb < bm .Height ;_bbb ++{_ea ,_bee =0,0;if _bbb >=2{_ea =bm .Data [(_bbb -2)*bm .RowStride ];};if _bbb >=1{_bee =bm .Data [(_bbb -1)*bm .RowStride ];if duplicateLineRemoval {_ee =_bbb *bm .RowStride ;_gfc =bm .Data [_ee :_ee +bm .RowStride ];_ecf =(_bbb -1)*bm .RowStride ;_eeb =bm .Data [_ecf :_ecf +bm .RowStride ];if _e .Equal (_gfc ,_eeb ){_fg =_gb ^1;_gb =1;}else {_fg =_gb ;_gb =0;};};};if duplicateLineRemoval {if _aa :=_fec .encodeBit (_fec ._bd ,_bdb ,_fg );_aa !=nil {return _aa ;};if _gb !=0{continue ;};};_dgf =bm .Data [_bbb *bm .RowStride ];_bbf =uint16 (_ea >>5);_ba =uint16 (_bee >>4);_ea <<=3;_bee <<=4;_bdg =0;for _cad =0;_cad < bm .Width ;_cad ++{_gfbc :=uint32 (_bbf <<11|_ba <<4|_bdg );_cc :=(_dgf &0x80)>>7;_ad :=_fec .encodeBit (_fec ._bd ,_gfbc ,_cc );if _ad !=nil {return _ad ;};_bbf <<=1;_ba <<=1;_bdg <<=1;_bbf |=uint16 ((_ea &0x80)>>7);_ba |=uint16 ((_bee &0x80)>>7);_bdg |=uint16 (_cc );_dad :=_cad %8;_ccd :=_cad /8+1;if _dad ==4&&_bbb >=2{_ea =0;if _ccd < bm .RowStride {_ea =bm .Data [(_bbb -2)*bm .RowStride +_ccd ];};}else {_ea <<=1;};if _dad ==3&&_bbb >=1{_bee =0;if _ccd < bm .RowStride {_bee =bm .Data [(_bbb -1)*bm .RowStride +_ccd ];};}else {_bee <<=1;};if _dad ==7{_dgf =0;if _ccd < bm .RowStride {_dgf =bm .Data [_bbb *bm .RowStride +_ccd ];};}else {_dgf <<=1;};_bbf &=31;_ba &=127;_bdg &=15;};};return nil ;};func _fe (_fee int )*codingContext {return &codingContext {_cb :make ([]byte ,_fee ),_cg :make ([]byte ,_fee )};};func New ()*Encoder {_cgb :=&Encoder {};_cgb .Init ();return _cgb };func (_bea *Encoder )flush (){_bea .setBits ();_bea ._fc <<=_bea ._db ;_bea .byteOut ();_bea ._fc <<=_bea ._db ;_bea .byteOut ();_bea .emit ();if _bea ._ca !=0xff{_bea ._fad ++;_bea ._ca =0xff;_bea .emit ();};_bea ._fad ++;_bea ._ca =0xac;_bea ._fad ++;_bea .emit ();};func (_eee *Encoder )encodeBit (_cff *codingContext ,_dbc uint32 ,_fea uint8 )error {const _gcg ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_eee ._ecd ++;if _dbc >=uint32 (len (_cff ._cb )){return _ec .Errorf (_gcg ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dbc );};_eab :=_cff ._cb [_dbc ];_dada :=_cff .mps (_dbc );_bbg :=_ccf [_eab ]._cgd ;_b .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_eee ._ecd ,_fea ,_eab ,_dada ,_bbg ,_eee ._gfb ,_eee ._fc ,_eee ._db ,_eee ._ca ,_eee ._fad );if _fea ==0{_eee .code0 (_cff ,_dbc ,_bbg ,_eab );}else {_eee .code1 (_cff ,_dbc ,_bbg ,_eab );};return nil ;};func (_aefe *Encoder )lBlock (){if _aefe ._fad >=0{_aefe .emit ();};_aefe ._fad ++;_aefe ._ca =uint8 (_aefe ._fc >>19);_aefe ._fc &=0x7ffff;_aefe ._db =8;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);const _bdb =0x9b25;func (_aded *Encoder )encodeOOB (_bde Class )error {_acf :=_aded ._dd [_bde ];_cfg :=_aded .encodeBit (_acf ,1,1);if _cfg !=nil {return _cfg ;};_cfg =_aded .encodeBit (_acf ,3,0);if _cfg !=nil {return _cfg ;};_cfg =_aded .encodeBit (_acf ,6,0);if _cfg !=nil {return _cfg ;};_cfg =_aded .encodeBit (_acf ,12,0);if _cfg !=nil {return _cfg ;};return nil ;};func (_da *codingContext )flipMps (_be uint32 ){_da ._cg [_be ]=1-_da ._cg [_be ]};func (_ecda *Encoder )code0 (_dga *codingContext ,_de uint32 ,_abc uint16 ,_fga byte ){if _dga .mps (_de )==0{_ecda .codeMPS (_dga ,_de ,_abc ,_fga );}else {_ecda .codeLPS (_dga ,_de ,_abc ,_fga );};};func (_ce *Encoder )rBlock (){if _ce ._fad >=0{_ce .emit ();};_ce ._fad ++;_ce ._ca =uint8 (_ce ._fc >>20);_ce ._fc &=0xfffff;_ce ._db =7;};var _gge =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};type codingContext struct{_cb []byte ;_cg []byte ;};func (_gd Class )String ()string {switch _gd {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ag *Encoder )DataSize ()int {return _ag .dataSize ()};func (_ggc *Encoder )codeLPS (_bc *codingContext ,_baf uint32 ,_cbb uint16 ,_bef byte ){_ggc ._gfb -=_cbb ;if _ggc ._gfb < _cbb {_ggc ._fc +=uint32 (_cbb );}else {_ggc ._gfb =_cbb ;};if _ccf [_bef ]._gccd ==1{_bc .flipMps (_baf );};_bc ._cb [_baf ]=_ccf [_bef ]._eeaa ;_ggc .renormalize ();};func (_ecdd *Encoder )codeMPS (_cda *codingContext ,_aeg uint32 ,_geg uint16 ,_ggf byte ){_ecdd ._gfb -=_geg ;if _ecdd ._gfb &0x8000!=0{_ecdd ._fc +=uint32 (_geg );return ;};if _ecdd ._gfb < _geg {_ecdd ._gfb =_geg ;}else {_ecdd ._fc +=uint32 (_geg );};_cda ._cb [_aeg ]=_ccf [_ggf ]._gcf ;_ecdd .renormalize ();};type intEncRangeS struct{_f ,_d int ;_dc ,_eb uint8 ;_a uint16 ;_c uint8 ;};func (_gf *codingContext )mps (_fa uint32 )int {return int (_gf ._cg [_fa ])};func (_cce *Encoder )code1 (_ggb *codingContext ,_bg uint32 ,_gfe uint16 ,_cfc byte ){if _ggb .mps (_bg )==1{_cce .codeMPS (_ggb ,_bg ,_gfe ,_cfc );}else {_cce .codeLPS (_ggb ,_bg ,_gfe ,_cfc );};};const (_efc =65536;_aecc =20*1024;);func (_gbb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_dge error ){_b .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _dge =_gbb .encodeIAID (symbolCodeLength ,value );_dge !=nil {return _ec .Wrap (_dge ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_caf *Encoder )EncodeInteger (proc Class ,value int )(_aec error ){_b .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _aec =_caf .encodeInteger (proc ,value );_aec !=nil {return _ec .Wrap (_aec ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_dcb *Encoder )Init (){_dcb ._bd =_fe (_efc );_dcb ._gfb =0x8000;_dcb ._fc =0;_dcb ._db =12;_dcb ._fad =-1;_dcb ._ca =0;_dcb ._ga =0;_dcb ._ae =make ([]byte ,_aecc );for _dg :=0;_dg < len (_dcb ._dd );_dg ++{_dcb ._dd [_dg ]=_fe (512);};_dcb ._ac =nil ;};func (_eef *Encoder )WriteTo (w _gg .Writer )(int64 ,error ){const _dgg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _dgd int64 ;for _abe ,_eeg :=range _eef ._ef {_ffc ,_cd :=w .Write (_eeg );if _cd !=nil {return 0,_ec .Wrapf (_cd ,_dgg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_abe );};_dgd +=int64 (_ffc );};_eef ._ae =_eef ._ae [:_eef ._ga ];_gae ,_aef :=w .Write (_eef ._ae );if _aef !=nil {return 0,_ec .Wrap (_aef ,_dgg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_dgd +=int64 (_gae );return _dgd ,nil ;};type state struct{_cgd uint16 ;_gcf ,_eeaa uint8 ;_gccd uint8 ;};var _ccf =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};type Encoder struct{_fc uint32 ;_gfb uint16 ;_db ,_ca uint8 ;_fad int ;_ecd int ;_ef [][]byte ;_ae []byte ;_ga int ;_bd *codingContext ;_dd [13]*codingContext ;_ac *codingContext ;};var _ _gg .WriterTo =&Encoder {};func (_efb *Encoder )encodeInteger (_efe Class ,_bda int )error {const _dbcf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _bda > 2000000000||_bda < -2000000000{return _ec .Errorf (_dbcf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_bda );};_cac :=_efb ._dd [_efe ];_eea :=uint32 (1);var _adc int ;for ;;_adc ++{if _gge [_adc ]._f <=_bda &&_gge [_adc ]._d >=_bda {break ;};};if _bda < 0{_bda =-_bda ;};_bda -=int (_gge [_adc ]._a );_ade :=_gge [_adc ]._dc ;for _eg :=uint8 (0);_eg < _gge [_adc ]._eb ;_eg ++{_aga :=_ade &1;if _add :=_efb .encodeBit (_cac ,_eea ,_aga );_add !=nil {return _ec .Wrap (_add ,_dbcf ,"");};_ade >>=1;if _eea &0x100> 0{_eea =(((_eea <<1)|uint32 (_aga ))&0x1ff)|0x100;}else {_eea =(_eea <<1)|uint32 (_aga );};};_bda <<=32-_gge [_adc ]._c ;for _dccf :=uint8 (0);_dccf < _gge [_adc ]._c ;_dccf ++{_gcc :=uint8 ((uint32 (_bda )&0x80000000)>>31);if _ega :=_efb .encodeBit (_cac ,_eea ,_gcc );_ega !=nil {return _ec .Wrap (_ega ,_dbcf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_bda <<=1;if _eea &0x100!=0{_eea =(((_eea <<1)|uint32 (_gcc ))&0x1ff)|0x100;}else {_eea =(_eea <<1)|uint32 (_gcc );};};return nil ;};func (_ff *Encoder )EncodeOOB (proc Class )(_cbf error ){_b .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _cbf =_ff .encodeOOB (proc );_cbf !=nil {return _ec .Wrap (_cbf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_efd *Encoder )Refine (iTemp ,iTarget *_bb .Bitmap ,ox ,oy int )error {for _ffe :=0;_ffe < iTarget .Height ;_ffe ++{var _acd int ;_ed :=_ffe +oy ;var (_bf ,_ebd ,_fgg ,_dgb ,_cf uint16 ;_df ,_gc ,_dcc ,_ab ,_ecfd byte ;);if _ed >=1&&(_ed -1)< iTemp .Height {_df =iTemp .Data [(_ed -1)*iTemp .RowStride ];};if _ed >=0&&_ed < iTemp .Height {_gc =iTemp .Data [_ed *iTemp .RowStride ];};if _ed >=-1&&_ed +1< iTemp .Height {_dcc =iTemp .Data [(_ed +1)*iTemp .RowStride ];};if _ffe >=1{_ab =iTarget .Data [(_ffe -1)*iTarget .RowStride ];};_ecfd =iTarget .Data [_ffe *iTarget .RowStride ];_adg :=uint (6+ox );_bf =uint16 (_df >>_adg );_ebd =uint16 (_gc >>_adg );_fgg =uint16 (_dcc >>_adg );_dgb =uint16 (_ab >>6);_ge :=uint (2-ox );_df <<=_ge ;_gc <<=_ge ;_dcc <<=_ge ;_ab <<=2;for _acd =0;_acd < iTarget .Width ;_acd ++{_feg :=(_bf <<10)|(_ebd <<7)|(_fgg <<4)|(_dgb <<1)|_cf ;_gee :=_ecfd >>7;_fgd :=_efd .encodeBit (_efd ._bd ,uint32 (_feg ),_gee );if _fgd !=nil {return _fgd ;};_bf <<=1;_ebd <<=1;_fgg <<=1;_dgb <<=1;_bf |=uint16 (_df >>7);_ebd |=uint16 (_gc >>7);_fgg |=uint16 (_dcc >>7);_dgb |=uint16 (_ab >>7);_cf =uint16 (_gee );_fb :=_acd %8;_eae :=_acd /8+1;if _fb ==5+ox {_df ,_gc ,_dcc =0,0,0;if _eae < iTemp .RowStride &&_ed >=1&&(_ed -1)< iTemp .Height {_df =iTemp .Data [(_ed -1)*iTemp .RowStride +_eae ];};if _eae < iTemp .RowStride &&_ed >=0&&_ed < iTemp .Height {_gc =iTemp .Data [_ed *iTemp .RowStride +_eae ];};if _eae < iTemp .RowStride &&_ed >=-1&&(_ed +1)< iTemp .Height {_dcc =iTemp .Data [(_ed +1)*iTemp .RowStride +_eae ];};}else {_df <<=1;_gc <<=1;_dcc <<=1;};if _fb ==5&&_ffe >=1{_ab =0;if _eae < iTarget .RowStride {_ab =iTarget .Data [(_ffe -1)*iTarget .RowStride +_eae ];};}else {_ab <<=1;};if _fb ==7{_ecfd =0;if _eae < iTarget .RowStride {_ecfd =iTarget .Data [_ffe *iTarget .RowStride +_eae ];};}else {_ecfd <<=1;};_bf &=7;_ebd &=7;_fgg &=7;_dgb &=7;};};return nil ;};type Class int ;func (_gef *Encoder )Reset (){_gef ._gfb =0x8000;_gef ._fc =0;_gef ._db =12;_gef ._fad =-1;_gef ._ca =0;_gef ._ac =nil ;_gef ._bd =_fe (_efc );};func (_cae *Encoder )renormalize (){for {_cae ._gfb <<=1;_cae ._fc <<=1;_cae ._db --;if _cae ._db ==0{_cae .byteOut ();};if (_cae ._gfb &0x8000)!=0{break ;};};};func (_ede *Encoder )encodeIAID (_afb ,_fff int )error {if _ede ._ac ==nil {_ede ._ac =_fe (1<<uint (_afb ));};_edeb :=uint32 (1<<uint32 (_afb +1))-1;_fff <<=uint (32-_afb );_gfee :=uint32 (1);for _fef :=0;_fef < _afb ;_fef ++{_beeg :=_gfee &_edeb ;_ddb :=uint8 ((uint32 (_fff )&0x80000000)>>31);if _beb :=_ede .encodeBit (_ede ._ac ,_beeg ,_ddb );_beb !=nil {return _beb ;};_gfee =(_gfee <<1)|uint32 (_ddb );_fff <<=1;};return nil ;};func (_faf *Encoder )dataSize ()int {return _aecc *len (_faf ._ef )+_faf ._ga };func (_af *Encoder )Final (){_af .flush ()};func (_efg *Encoder )Flush (){_efg ._ga =0;_efg ._ef =nil ;_efg ._fad =-1};func (_dcbc *Encoder )emit (){if _dcbc ._ga ==_aecc {_dcbc ._ef =append (_dcbc ._ef ,_dcbc ._ae );_dcbc ._ae =make ([]byte ,_aecc );_dcbc ._ga =0;};_dcbc ._ae [_dcbc ._ga ]=_dcbc ._ca ;_dcbc ._ga ++;};func (_fcc *Encoder )setBits (){_cdc :=_fcc ._fc +uint32 (_fcc ._gfb );_fcc ._fc |=0xffff;if _fcc ._fc >=_cdc {_fcc ._fc -=0x8000;};};func (_cbfc *Encoder )byteOut (){if _cbfc ._ca ==0xff{_cbfc .rBlock ();return ;};if _cbfc ._fc < 0x8000000{_cbfc .lBlock ();return ;};_cbfc ._ca ++;if _cbfc ._ca !=0xff{_cbfc .lBlock ();return ;};_cbfc ._fc &=0x7ffffff;_cbfc .rBlock ();};