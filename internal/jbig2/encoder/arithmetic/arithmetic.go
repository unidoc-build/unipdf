//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_f "bytes";_ee "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_d "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_dc Class )String ()string {switch _dc {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ge *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gc error ){_ee .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gc =_ge .encodeIAID (symbolCodeLength ,value );_gc !=nil {return _d .Wrap (_gc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_fbff *Encoder )emit (){if _fbff ._df ==_ceb {_fbff ._ega =append (_fbff ._ega ,_fbff ._bee );
_fbff ._bee =make ([]byte ,_ceb );_fbff ._df =0;};_fbff ._bee [_fbff ._df ]=_fbff ._gg ;_fbff ._df ++;};func (_fcaf *Encoder )code1 (_fcd *codingContext ,_eeb uint32 ,_gbc uint16 ,_aca byte ){if _fcd .mps (_eeb )==1{_fcaf .codeMPS (_fcd ,_eeb ,_gbc ,_aca );
}else {_fcaf .codeLPS (_fcd ,_eeb ,_gbc ,_aca );};};var _ _e .WriterTo =&Encoder {};func _gdc (_fe int )*codingContext {return &codingContext {_cg :make ([]byte ,_fe ),_eg :make ([]byte ,_fe )};};func (_gea *Encoder )byteOut (){if _gea ._gg ==0xff{_gea .rBlock ();
return ;};if _gea ._b < 0x8000000{_gea .lBlock ();return ;};_gea ._gg ++;if _gea ._gg !=0xff{_gea .lBlock ();return ;};_gea ._b &=0x7ffffff;_gea .rBlock ();};const _eea =0x9b25;func (_egg *Encoder )Reset (){_egg ._cd =0x8000;_egg ._b =0;_egg ._be =12;_egg ._af =-1;
_egg ._gg =0;_egg ._cde =nil ;_egg ._ecd =_gdc (_cgf );};func (_adg *Encoder )encodeBit (_gbg *codingContext ,_gbga uint32 ,_eec uint8 )error {const _fcg ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_adg ._gb ++;if _gbga >=uint32 (len (_gbg ._cg )){return _d .Errorf (_fcg ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_gbga );
};_bba :=_gbg ._cg [_gbga ];_ffc :=_gbg .mps (_gbga );_eegd :=_cgbd [_bba ]._bgga ;_ee .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_adg ._gb ,_eec ,_bba ,_ffc ,_eegd ,_adg ._cd ,_adg ._b ,_adg ._be ,_adg ._gg ,_adg ._af );
if _eec ==0{_adg .code0 (_gbg ,_gbga ,_eegd ,_bba );}else {_adg .code1 (_gbg ,_gbga ,_eegd ,_bba );};return nil ;};func (_ce *Encoder )codeMPS (_abf *codingContext ,_edg uint32 ,_dcg uint16 ,_fee byte ){_ce ._cd -=_dcg ;if _ce ._cd &0x8000!=0{_ce ._b +=uint32 (_dcg );
return ;};if _ce ._cd < _dcg {_ce ._cd =_dcg ;}else {_ce ._b +=uint32 (_dcg );};_abf ._cg [_edg ]=_cgbd [_fee ]._bgd ;_ce .renormalize ();};func (_dff *Encoder )flush (){_dff .setBits ();_dff ._b <<=_dff ._be ;_dff .byteOut ();_dff ._b <<=_dff ._be ;_dff .byteOut ();
_dff .emit ();if _dff ._gg !=0xff{_dff ._af ++;_dff ._gg =0xff;_dff .emit ();};_dff ._af ++;_dff ._gg =0xac;_dff ._af ++;_dff .emit ();};type Encoder struct{_b uint32 ;_cd uint16 ;_be ,_gg uint8 ;_af int ;_gb int ;_ega [][]byte ;_bee []byte ;_df int ;_ecd *codingContext ;
_fa [13]*codingContext ;_cde *codingContext ;};func (_dfde *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _egd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _cbf int64 ;for _gba ,_ad :=range _dfde ._ega {_ggg ,_fga :=w .Write (_ad );
if _fga !=nil {return 0,_d .Wrapf (_fga ,_egd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gba );};_cbf +=int64 (_ggg );};_dfde ._bee =_dfde ._bee [:_dfde ._df ];
_bb ,_cgb :=w .Write (_dfde ._bee );if _cgb !=nil {return 0,_d .Wrap (_cgb ,_egd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cbf +=int64 (_bb );return _cbf ,nil ;};func (_a *codingContext )mps (_eb uint32 )int {return int (_a ._eg [_eb ])};
func (_afa *Encoder )codeLPS (_aff *codingContext ,_ead uint32 ,_fd uint16 ,_baa byte ){_afa ._cd -=_fd ;if _afa ._cd < _fd {_afa ._b +=uint32 (_fd );}else {_afa ._cd =_fd ;};if _cgbd [_baa ]._dd ==1{_aff .flipMps (_ead );};_aff ._cg [_ead ]=_cgbd [_baa ]._cbe ;
_afa .renormalize ();};func (_edb *Encoder )encodeIAID (_cdce ,_aea int )error {if _edb ._cde ==nil {_edb ._cde =_gdc (1<<uint (_cdce ));};_gcf :=uint32 (1<<uint32 (_cdce +1))-1;_aea <<=uint (32-_cdce );_eff :=uint32 (1);for _fdf :=0;_fdf < _cdce ;_fdf ++{_bd :=_eff &_gcf ;
_cga :=uint8 ((uint32 (_aea )&0x80000000)>>31);if _gca :=_edb .encodeBit (_edb ._cde ,_bd ,_cga );_gca !=nil {return _gca ;};_eff =(_eff <<1)|uint32 (_cga );_aea <<=1;};return nil ;};func (_edbc *Encoder )lBlock (){if _edbc ._af >=0{_edbc .emit ();};_edbc ._af ++;
_edbc ._gg =uint8 (_edbc ._b >>19);_edbc ._b &=0x7ffff;_edbc ._be =8;};func (_cf *Encoder )Refine (iTemp ,iTarget *_c .Bitmap ,ox ,oy int )error {for _ea :=0;_ea < iTarget .Height ;_ea ++{var _bgb int ;_ff :=_ea +oy ;var (_ca ,_feg ,_ebb ,_dfd ,_de uint16 ;
_ffa ,_ffd ,_cbg ,_aa ,_eead byte ;);if _ff >=1&&(_ff -1)< iTemp .Height {_ffa =iTemp .Data [(_ff -1)*iTemp .RowStride ];};if _ff >=0&&_ff < iTemp .Height {_ffd =iTemp .Data [_ff *iTemp .RowStride ];};if _ff >=-1&&_ff +1< iTemp .Height {_cbg =iTemp .Data [(_ff +1)*iTemp .RowStride ];
};if _ea >=1{_aa =iTarget .Data [(_ea -1)*iTarget .RowStride ];};_eead =iTarget .Data [_ea *iTarget .RowStride ];_fed :=uint (6+ox );_ca =uint16 (_ffa >>_fed );_feg =uint16 (_ffd >>_fed );_ebb =uint16 (_cbg >>_fed );_dfd =uint16 (_aa >>6);_eab :=uint (2-ox );
_ffa <<=_eab ;_ffd <<=_eab ;_cbg <<=_eab ;_aa <<=2;for _bgb =0;_bgb < iTarget .Width ;_bgb ++{_afe :=(_ca <<10)|(_feg <<7)|(_ebb <<4)|(_dfd <<1)|_de ;_ecdf :=_eead >>7;_fg :=_cf .encodeBit (_cf ._ecd ,uint32 (_afe ),_ecdf );if _fg !=nil {return _fg ;};
_ca <<=1;_feg <<=1;_ebb <<=1;_dfd <<=1;_ca |=uint16 (_ffa >>7);_feg |=uint16 (_ffd >>7);_ebb |=uint16 (_cbg >>7);_dfd |=uint16 (_aa >>7);_de =uint16 (_ecdf );_ba :=_bgb %8;_fbf :=_bgb /8+1;if _ba ==5+ox {_ffa ,_ffd ,_cbg =0,0,0;if _fbf < iTemp .RowStride &&_ff >=1&&(_ff -1)< iTemp .Height {_ffa =iTemp .Data [(_ff -1)*iTemp .RowStride +_fbf ];
};if _fbf < iTemp .RowStride &&_ff >=0&&_ff < iTemp .Height {_ffd =iTemp .Data [_ff *iTemp .RowStride +_fbf ];};if _fbf < iTemp .RowStride &&_ff >=-1&&(_ff +1)< iTemp .Height {_cbg =iTemp .Data [(_ff +1)*iTemp .RowStride +_fbf ];};}else {_ffa <<=1;_ffd <<=1;
_cbg <<=1;};if _ba ==5&&_ea >=1{_aa =0;if _fbf < iTarget .RowStride {_aa =iTarget .Data [(_ea -1)*iTarget .RowStride +_fbf ];};}else {_aa <<=1;};if _ba ==7{_eead =0;if _fbf < iTarget .RowStride {_eead =iTarget .Data [_ea *iTarget .RowStride +_fbf ];};}else {_eead <<=1;
};_ca &=7;_feg &=7;_ebb &=7;_dfd &=7;};};return nil ;};func (_cdg *Encoder )rBlock (){if _cdg ._af >=0{_cdg .emit ();};_cdg ._af ++;_cdg ._gg =uint8 (_cdg ._b >>20);_cdg ._b &=0xfffff;_cdg ._be =7;};func (_dbc *Encoder )encodeInteger (_ae Class ,_dbb int )error {const _eebf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _dbb > 2000000000||_dbb < -2000000000{return _d .Errorf (_eebf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_dbb );
};_bf :=_dbc ._fa [_ae ];_cdc :=uint32 (1);var _ccb int ;for ;;_ccb ++{if _gd [_ccb ]._ec <=_dbb &&_gd [_ccb ]._fc >=_dbb {break ;};};if _dbb < 0{_dbb =-_dbb ;};_dbb -=int (_gd [_ccb ]._db );_bbe :=_gd [_ccb ]._ef ;for _fegc :=uint8 (0);_fegc < _gd [_ccb ]._cb ;
_fegc ++{_bec :=_bbe &1;if _bag :=_dbc .encodeBit (_bf ,_cdc ,_bec );_bag !=nil {return _d .Wrap (_bag ,_eebf ,"");};_bbe >>=1;if _cdc &0x100> 0{_cdc =(((_cdc <<1)|uint32 (_bec ))&0x1ff)|0x100;}else {_cdc =(_cdc <<1)|uint32 (_bec );};};_dbb <<=32-_gd [_ccb ]._dbf ;
for _bab :=uint8 (0);_bab < _gd [_ccb ]._dbf ;_bab ++{_dab :=uint8 ((uint32 (_dbb )&0x80000000)>>31);if _abg :=_dbc .encodeBit (_bf ,_cdc ,_dab );_abg !=nil {return _d .Wrap (_abg ,_eebf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_dbb <<=1;if _cdc &0x100!=0{_cdc =(((_cdc <<1)|uint32 (_dab ))&0x1ff)|0x100;}else {_cdc =(_cdc <<1)|uint32 (_dab );};};return nil ;};func (_ede *Encoder )DataSize ()int {return _ede .dataSize ()};type Class int ;const (_cgf =65536;_ceb =20*1024;);type intEncRangeS struct{_ec ,_fc int ;
_ef ,_cb uint8 ;_db uint16 ;_dbf uint8 ;};var _cgbd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_cc *codingContext )flipMps (_ac uint32 ){_cc ._eg [_ac ]=1-_cc ._eg [_ac ]};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_bg *Encoder )EncodeOOB (proc Class )(_egc error ){_ee .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _egc =_bg .encodeOOB (proc );_egc !=nil {return _d .Wrap (_egc ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};var _gd =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_bcg *Encoder )renormalize (){for {_bcg ._cd <<=1;_bcg ._b <<=1;_bcg ._be --;if _bcg ._be ==0{_bcg .byteOut ();};if (_bcg ._cd &0x8000)!=0{break ;};};};func (_eda *Encoder )EncodeInteger (proc Class ,value int )(_da error ){_ee .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _da =_eda .encodeInteger (proc ,value );_da !=nil {return _d .Wrap (_da ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func New ()*Encoder {_fce :=&Encoder {};_fce .Init ();return _fce };func (_bfg *Encoder )encodeOOB (_bc Class )error {_bgg :=_bfg ._fa [_bc ];
_fgf :=_bfg .encodeBit (_bgg ,1,1);if _fgf !=nil {return _fgf ;};_fgf =_bfg .encodeBit (_bgg ,3,0);if _fgf !=nil {return _fgf ;};_fgf =_bfg .encodeBit (_bgg ,6,0);if _fgf !=nil {return _fgf ;};_fgf =_bfg .encodeBit (_bgg ,12,0);if _fgf !=nil {return _fgf ;
};return nil ;};type codingContext struct{_cg []byte ;_eg []byte ;};func (_ccbe *Encoder )setBits (){_cgg :=_ccbe ._b +uint32 (_ccbe ._cd );_ccbe ._b |=0xffff;if _ccbe ._b >=_cgg {_ccbe ._b -=0x8000;};};func (_dg *Encoder )EncodeBitmap (bm *_c .Bitmap ,duplicateLineRemoval bool )error {_ee .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_acc ,_afb uint8 ;_edea ,_gdcf ,_ebc uint16 ;_ecc ,_eeg ,_gbf byte ;_gde ,_ag ,_fcea int ;_ccf ,_ggf []byte ;);for _beef :=0;_beef < bm .Height ;_beef ++{_ecc ,_eeg =0,0;if _beef >=2{_ecc =bm .Data [(_beef -2)*bm .RowStride ];};if _beef >=1{_eeg =bm .Data [(_beef -1)*bm .RowStride ];
if duplicateLineRemoval {_ag =_beef *bm .RowStride ;_ccf =bm .Data [_ag :_ag +bm .RowStride ];_fcea =(_beef -1)*bm .RowStride ;_ggf =bm .Data [_fcea :_fcea +bm .RowStride ];if _f .Equal (_ccf ,_ggf ){_afb =_acc ^1;_acc =1;}else {_afb =_acc ;_acc =0;};};
};if duplicateLineRemoval {if _faf :=_dg .encodeBit (_dg ._ecd ,_eea ,_afb );_faf !=nil {return _faf ;};if _acc !=0{continue ;};};_gbf =bm .Data [_beef *bm .RowStride ];_edea =uint16 (_ecc >>5);_gdcf =uint16 (_eeg >>4);_ecc <<=3;_eeg <<=4;_ebc =0;for _gde =0;
_gde < bm .Width ;_gde ++{_fb :=uint32 (_edea <<11|_gdcf <<4|_ebc );_gbfc :=(_gbf &0x80)>>7;_fca :=_dg .encodeBit (_dg ._ecd ,_fb ,_gbfc );if _fca !=nil {return _fca ;};_edea <<=1;_gdcf <<=1;_ebc <<=1;_edea |=uint16 ((_ecc &0x80)>>7);_gdcf |=uint16 ((_eeg &0x80)>>7);
_ebc |=uint16 (_gbfc );_cba :=_gde %8;_gf :=_gde /8+1;if _cba ==4&&_beef >=2{_ecc =0;if _gf < bm .RowStride {_ecc =bm .Data [(_beef -2)*bm .RowStride +_gf ];};}else {_ecc <<=1;};if _cba ==3&&_beef >=1{_eeg =0;if _gf < bm .RowStride {_eeg =bm .Data [(_beef -1)*bm .RowStride +_gf ];
};}else {_eeg <<=1;};if _cba ==7{_gbf =0;if _gf < bm .RowStride {_gbf =bm .Data [_beef *bm .RowStride +_gf ];};}else {_gbf <<=1;};_edea &=31;_gdcf &=127;_ebc &=15;};};return nil ;};func (_edc *Encoder )Final (){_edc .flush ()};func (_afc *Encoder )code0 (_ab *codingContext ,_eba uint32 ,_edf uint16 ,_cge byte ){if _ab .mps (_eba )==0{_afc .codeMPS (_ab ,_eba ,_edf ,_cge );
}else {_afc .codeLPS (_ab ,_eba ,_edf ,_cge );};};func (_ed *Encoder )Init (){_ed ._ecd =_gdc (_cgf );_ed ._cd =0x8000;_ed ._b =0;_ed ._be =12;_ed ._af =-1;_ed ._gg =0;_ed ._df =0;_ed ._bee =make ([]byte ,_ceb );for _dfb :=0;_dfb < len (_ed ._fa );_dfb ++{_ed ._fa [_dfb ]=_gdc (512);
};_ed ._cde =nil ;};func (_egb *Encoder )Flush (){_egb ._df =0;_egb ._ega =nil ;_egb ._af =-1};func (_abc *Encoder )dataSize ()int {return _ceb *len (_abc ._ega )+_abc ._df };type state struct{_bgga uint16 ;_bgd ,_cbe uint8 ;_dd uint8 ;};