//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_d "github.com/unidoc/unipdf/v3/common";_cd "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_bge *Encoder )Refine (iTemp ,iTarget *_cd .Bitmap ,ox ,oy int )error {for _fac :=0;
_fac < iTarget .Height ;_fac ++{var _aeea int ;_gfcb :=_fac +oy ;var (_ba ,_gga ,_bcg ,_cee ,_feaf uint16 ;_ffa ,_cdea ,_cb ,_df ,_dfa byte ;);if _gfcb >=1&&(_gfcb -1)< iTemp .Height {_ffa =iTemp .Data [(_gfcb -1)*iTemp .RowStride ];};if _gfcb >=0&&_gfcb < iTemp .Height {_cdea =iTemp .Data [_gfcb *iTemp .RowStride ];
};if _gfcb >=-1&&_gfcb +1< iTemp .Height {_cb =iTemp .Data [(_gfcb +1)*iTemp .RowStride ];};if _fac >=1{_df =iTarget .Data [(_fac -1)*iTarget .RowStride ];};_dfa =iTarget .Data [_fac *iTarget .RowStride ];_fcc :=uint (6+ox );_ba =uint16 (_ffa >>_fcc );
_gga =uint16 (_cdea >>_fcc );_bcg =uint16 (_cb >>_fcc );_cee =uint16 (_df >>6);_efc :=uint (2-ox );_ffa <<=_efc ;_cdea <<=_efc ;_cb <<=_efc ;_df <<=2;for _aeea =0;_aeea < iTarget .Width ;_aeea ++{_cc :=(_ba <<10)|(_gga <<7)|(_bcg <<4)|(_cee <<1)|_feaf ;
_aef :=_dfa >>7;_da :=_bge .encodeBit (_bge ._de ,uint32 (_cc ),_aef );if _da !=nil {return _da ;};_ba <<=1;_gga <<=1;_bcg <<=1;_cee <<=1;_ba |=uint16 (_ffa >>7);_gga |=uint16 (_cdea >>7);_bcg |=uint16 (_cb >>7);_cee |=uint16 (_df >>7);_feaf =uint16 (_aef );
_bca :=_aeea %8;_ccd :=_aeea /8+1;if _bca ==5+ox {_ffa ,_cdea ,_cb =0,0,0;if _ccd < iTemp .RowStride &&_gfcb >=1&&(_gfcb -1)< iTemp .Height {_ffa =iTemp .Data [(_gfcb -1)*iTemp .RowStride +_ccd ];};if _ccd < iTemp .RowStride &&_gfcb >=0&&_gfcb < iTemp .Height {_cdea =iTemp .Data [_gfcb *iTemp .RowStride +_ccd ];
};if _ccd < iTemp .RowStride &&_gfcb >=-1&&(_gfcb +1)< iTemp .Height {_cb =iTemp .Data [(_gfcb +1)*iTemp .RowStride +_ccd ];};}else {_ffa <<=1;_cdea <<=1;_cb <<=1;};if _bca ==5&&_fac >=1{_df =0;if _ccd < iTarget .RowStride {_df =iTarget .Data [(_fac -1)*iTarget .RowStride +_ccd ];
};}else {_df <<=1;};if _bca ==7{_dfa =0;if _ccd < iTarget .RowStride {_dfa =iTarget .Data [_fac *iTarget .RowStride +_ccd ];};}else {_dfa <<=1;};_ba &=7;_gga &=7;_bcg &=7;_cee &=7;};};return nil ;};func (_geb *Encoder )codeLPS (_ffaa *codingContext ,_aeg uint32 ,_ece uint16 ,_fab byte ){_geb ._bb -=_ece ;
if _geb ._bb < _ece {_geb ._ae +=uint32 (_ece );}else {_geb ._bb =_ece ;};if _ggbe [_fab ]._gbc ==1{_ffaa .flipMps (_aeg );};_ffaa ._dgf [_aeg ]=_ggbe [_fab ]._fgb ;_geb .renormalize ();};func (_daa *Encoder )code1 (_dd *codingContext ,_dee uint32 ,_aad uint16 ,_cdg byte ){if _dd .mps (_dee )==1{_daa .codeMPS (_dd ,_dee ,_aad ,_cdg );
}else {_daa .codeLPS (_dd ,_dee ,_aad ,_cdg );};};func (_dec *Encoder )Init (){_dec ._de =_cde (_ebb );_dec ._bb =0x8000;_dec ._ae =0;_dec ._eg =12;_dec ._gc =-1;_dec ._ff =0;_dec ._eff =0;_dec ._aa =make ([]byte ,_bdc );for _ffc :=0;_ffc < len (_dec ._ec );
_ffc ++{_dec ._ec [_ffc ]=_cde (512);};_dec ._efe =nil ;};func (_ab Class )String ()string {switch _ab {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_fea *Encoder )EncodeIAID (symbolCodeLength ,value int )(_bbf error ){_d .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _bbf =_fea .encodeIAID (symbolCodeLength ,value );_bbf !=nil {return _f .Wrap (_bbf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_ddg *Encoder )encodeOOB (_fbb Class )error {_dfe :=_ddg ._ec [_fbb ];_eee :=_ddg .encodeBit (_dfe ,1,1);
if _eee !=nil {return _eee ;};_eee =_ddg .encodeBit (_dfe ,3,0);if _eee !=nil {return _eee ;};_eee =_ddg .encodeBit (_dfe ,6,0);if _eee !=nil {return _eee ;};_eee =_ddg .encodeBit (_dfe ,12,0);if _eee !=nil {return _eee ;};return nil ;};func (_ca *Encoder )emit (){if _ca ._eff ==_bdc {_ca ._ef =append (_ca ._ef ,_ca ._aa );
_ca ._aa =make ([]byte ,_bdc );_ca ._eff =0;};_ca ._aa [_ca ._eff ]=_ca ._ff ;_ca ._eff ++;};func (_abe *Encoder )byteOut (){if _abe ._ff ==0xff{_abe .rBlock ();return ;};if _abe ._ae < 0x8000000{_abe .lBlock ();return ;};_abe ._ff ++;if _abe ._ff !=0xff{_abe .lBlock ();
return ;};_abe ._ae &=0x7ffffff;_abe .rBlock ();};type codingContext struct{_dgf []byte ;_gf []byte ;};func (_gdd *Encoder )lBlock (){if _gdd ._gc >=0{_gdd .emit ();};_gdd ._gc ++;_gdd ._ff =uint8 (_gdd ._ae >>19);_gdd ._ae &=0x7ffff;_gdd ._eg =8;};func (_bfe *Encoder )EncodeInteger (proc Class ,value int )(_bcbb error ){_d .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bcbb =_bfe .encodeInteger (proc ,value );_bcbb !=nil {return _f .Wrap (_bcbb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type state struct{_eda uint16 ;_ebbd ,_fgb uint8 ;_gbc uint8 ;};var _ _e .WriterTo =&Encoder {};
func (_bgcc *Encoder )rBlock (){if _bgcc ._gc >=0{_bgcc .emit ();};_bgcc ._gc ++;_bgcc ._ff =uint8 (_bgcc ._ae >>20);_bgcc ._ae &=0xfffff;_bgcc ._eg =7;};func (_dc *Encoder )Reset (){_dc ._bb =0x8000;_dc ._ae =0;_dc ._eg =12;_dc ._gc =-1;_dc ._ff =0;_dc ._efe =nil ;
_dc ._de =_cde (_ebb );};func New ()*Encoder {_bbg :=&Encoder {};_bbg .Init ();return _bbg };func (_ce *Encoder )Final (){_ce .flush ()};func (_fccf *Encoder )encodeInteger (_degd Class ,_bec int )error {const _bab ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _bec > 2000000000||_bec < -2000000000{return _f .Errorf (_bab ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_bec );
};_ggae :=_fccf ._ec [_degd ];_dac :=uint32 (1);var _aegc int ;for ;;_aegc ++{if _gb [_aegc ]._g <=_bec &&_gb [_aegc ]._b >=_bec {break ;};};if _bec < 0{_bec =-_bec ;};_bec -=int (_gb [_aegc ]._cg );_eag :=_gb [_aegc ]._ac ;for _aefgd :=uint8 (0);_aefgd < _gb [_aegc ]._bc ;
_aefgd ++{_aea :=_eag &1;if _aac :=_fccf .encodeBit (_ggae ,_dac ,_aea );_aac !=nil {return _f .Wrap (_aac ,_bab ,"");};_eag >>=1;if _dac &0x100> 0{_dac =(((_dac <<1)|uint32 (_aea ))&0x1ff)|0x100;}else {_dac =(_dac <<1)|uint32 (_aea );};};_bec <<=32-_gb [_aegc ]._dg ;
for _bd :=uint8 (0);_bd < _gb [_aegc ]._dg ;_bd ++{_bae :=uint8 ((uint32 (_bec )&0x80000000)>>31);if _gaf :=_fccf .encodeBit (_ggae ,_dac ,_bae );_gaf !=nil {return _f .Wrap (_gaf ,_bab ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_bec <<=1;if _dac &0x100!=0{_dac =(((_dac <<1)|uint32 (_bae ))&0x1ff)|0x100;}else {_dac =(_dac <<1)|uint32 (_bae );};};return nil ;};func (_bcb *codingContext )flipMps (_bg uint32 ){_bcb ._gf [_bg ]=1-_bcb ._gf [_bg ]};const (IAAI Class =iota ;IADH ;
IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);const (_ebb =65536;_bdc =20*1024;);func (_afd *Encoder )dataSize ()int {return _bdc *len (_afd ._ef )+_afd ._eff };var _gb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_gdc *Encoder )EncodeBitmap (bm *_cd .Bitmap ,duplicateLineRemoval bool )error {_d .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_ed ,_efed uint8 ;_bf ,_gg ,_cgc uint16 ;_fe ,_af ,_ee byte ;_effd ,_ad ,_cf int ;_ag ,_gfc []byte ;);for _efeg :=0;_efeg < bm .Height ;_efeg ++{_fe ,_af =0,0;if _efeg >=2{_fe =bm .Data [(_efeg -2)*bm .RowStride ];};if _efeg >=1{_af =bm .Data [(_efeg -1)*bm .RowStride ];
if duplicateLineRemoval {_ad =_efeg *bm .RowStride ;_ag =bm .Data [_ad :_ad +bm .RowStride ];_cf =(_efeg -1)*bm .RowStride ;_gfc =bm .Data [_cf :_cf +bm .RowStride ];if _a .Equal (_ag ,_gfc ){_efed =_ed ^1;_ed =1;}else {_efed =_ed ;_ed =0;};};};if duplicateLineRemoval {if _gcg :=_gdc .encodeBit (_gdc ._de ,_gfb ,_efed );
_gcg !=nil {return _gcg ;};if _ed !=0{continue ;};};_ee =bm .Data [_efeg *bm .RowStride ];_bf =uint16 (_fe >>5);_gg =uint16 (_af >>4);_fe <<=3;_af <<=4;_cgc =0;for _effd =0;_effd < bm .Width ;_effd ++{_deg :=uint32 (_bf <<11|_gg <<4|_cgc );_aee :=(_ee &0x80)>>7;
_gce :=_gdc .encodeBit (_gdc ._de ,_deg ,_aee );if _gce !=nil {return _gce ;};_bf <<=1;_gg <<=1;_cgc <<=1;_bf |=uint16 ((_fe &0x80)>>7);_gg |=uint16 ((_af &0x80)>>7);_cgc |=uint16 (_aee );_efb :=_effd %8;_efeb :=_effd /8+1;if _efb ==4&&_efeg >=2{_fe =0;
if _efeb < bm .RowStride {_fe =bm .Data [(_efeg -2)*bm .RowStride +_efeb ];};}else {_fe <<=1;};if _efb ==3&&_efeg >=1{_af =0;if _efeb < bm .RowStride {_af =bm .Data [(_efeg -1)*bm .RowStride +_efeb ];};}else {_af <<=1;};if _efb ==7{_ee =0;if _efeb < bm .RowStride {_ee =bm .Data [_efeg *bm .RowStride +_efeb ];
};}else {_ee <<=1;};_bf &=31;_gg &=127;_cgc &=15;};};return nil ;};func (_ggd *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _aefg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _ebg int64 ;for _ebc ,_cfc :=range _ggd ._ef {_bff ,_ceb :=w .Write (_cfc );
if _ceb !=nil {return 0,_f .Wrapf (_ceb ,_aefg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ebc );};_ebg +=int64 (_bff );};_ggd ._aa =_ggd ._aa [:_ggd ._eff ];
_fga ,_ga :=w .Write (_ggd ._aa );if _ga !=nil {return 0,_f .Wrap (_ga ,_aefg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ebg +=int64 (_fga );return _ebg ,nil ;};func (_ada *Encoder )codeMPS (_ea *codingContext ,_fb uint32 ,_eca uint16 ,_bgf byte ){_ada ._bb -=_eca ;
if _ada ._bb &0x8000!=0{_ada ._ae +=uint32 (_eca );return ;};if _ada ._bb < _eca {_ada ._bb =_eca ;}else {_ada ._ae +=uint32 (_eca );};_ea ._dgf [_fb ]=_ggbe [_bgf ]._ebbd ;_ada .renormalize ();};func (_gde *Encoder )EncodeOOB (proc Class )(_eeg error ){_d .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _eeg =_gde .encodeOOB (proc );_eeg !=nil {return _f .Wrap (_eeg ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};const _gfb =0x9b25;func (_fedd *Encoder )flush (){_fedd .setBits ();_fedd ._ae <<=_fedd ._eg ;_fedd .byteOut ();_fedd ._ae <<=_fedd ._eg ;
_fedd .byteOut ();_fedd .emit ();if _fedd ._ff !=0xff{_fedd ._gc ++;_fedd ._ff =0xff;_fedd .emit ();};_fedd ._gc ++;_fedd ._ff =0xac;_fedd ._gc ++;_fedd .emit ();};func (_agf *Encoder )encodeIAID (_gdg ,_faa int )error {if _agf ._efe ==nil {_agf ._efe =_cde (1<<uint (_gdg ));
};_gdf :=uint32 (1<<uint32 (_gdg +1))-1;_faa <<=uint (32-_gdg );_afdb :=uint32 (1);for _fcd :=0;_fcd < _gdg ;_fcd ++{_ggbb :=_afdb &_gdf ;_dgc :=uint8 ((uint32 (_faa )&0x80000000)>>31);if _dfc :=_agf .encodeBit (_agf ._efe ,_ggbb ,_dgc );_dfc !=nil {return _dfc ;
};_afdb =(_afdb <<1)|uint32 (_dgc );_faa <<=1;};return nil ;};type intEncRangeS struct{_g ,_b int ;_ac ,_bc uint8 ;_cg uint16 ;_dg uint8 ;};func (_bgc *Encoder )code0 (_ge *codingContext ,_bcbf uint32 ,_fec uint16 ,_bba byte ){if _ge .mps (_bcbf )==0{_bgc .codeMPS (_ge ,_bcbf ,_fec ,_bba );
}else {_bgc .codeLPS (_ge ,_bcbf ,_fec ,_bba );};};func (_cdb *codingContext )mps (_be uint32 )int {return int (_cdb ._gf [_be ])};var _ggbe =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_dda *Encoder )encodeBit (_gcb *codingContext ,_cce uint32 ,_fef uint8 )error {const _ggb ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_dda ._gd ++;if _cce >=uint32 (len (_gcb ._dgf )){return _f .Errorf (_ggb ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_cce );
};_ebgc :=_gcb ._dgf [_cce ];_fed :=_gcb .mps (_cce );_ccef :=_ggbe [_ebgc ]._eda ;_d .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dda ._gd ,_fef ,_ebgc ,_fed ,_ccef ,_dda ._bb ,_dda ._ae ,_dda ._eg ,_dda ._ff ,_dda ._gc );
if _fef ==0{_dda .code0 (_gcb ,_cce ,_ccef ,_ebgc );}else {_dda .code1 (_gcb ,_cce ,_ccef ,_ebgc );};return nil ;};func (_cfa *Encoder )renormalize (){for {_cfa ._bb <<=1;_cfa ._ae <<=1;_cfa ._eg --;if _cfa ._eg ==0{_cfa .byteOut ();};if (_cfa ._bb &0x8000)!=0{break ;
};};};func (_cdef *Encoder )setBits (){_gfe :=_cdef ._ae +uint32 (_cdef ._bb );_cdef ._ae |=0xffff;if _cdef ._ae >=_gfe {_cdef ._ae -=0x8000;};};type Encoder struct{_ae uint32 ;_bb uint16 ;_eg ,_ff uint8 ;_gc int ;_gd int ;_ef [][]byte ;_aa []byte ;_eff int ;
_de *codingContext ;_ec [13]*codingContext ;_efe *codingContext ;};func (_fa *Encoder )DataSize ()int {return _fa .dataSize ()};func (_eb *Encoder )Flush (){_eb ._eff =0;_eb ._ef =nil ;_eb ._gc =-1};type Class int ;func _cde (_fc int )*codingContext {return &codingContext {_dgf :make ([]byte ,_fc ),_gf :make ([]byte ,_fc )};
};