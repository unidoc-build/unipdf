//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "bytes";_g "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_gc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_bb "io";);func (_afd *Encoder )rBlock (){if _afd ._cdg >=0{_afd .emit ();
};_afd ._cdg ++;_afd ._cg =uint8 (_afd ._ae >>20);_afd ._ae &=0xfffff;_afd ._ce =7;};var _e =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_f *codingContext )mps (_bcf uint32 )int {return int (_f ._ag [_bcf ])};func (_bef *Encoder )EncodeInteger (proc Class ,value int )(_adc error ){_g .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _adc =_bef .encodeInteger (proc ,value );_adc !=nil {return _gc .Wrap (_adc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type state struct{_baa uint16 ;_dcf ,_fga uint8 ;_dad uint8 ;};func (_gd Class )String ()string {switch _gd {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_aeg *Encoder )setBits (){_eddd :=_aeg ._ae +uint32 (_aeg ._be );_aeg ._ae |=0xffff;if _aeg ._ae >=_eddd {_aeg ._ae -=0x8000;};};func New ()*Encoder {_fff :=&Encoder {};_fff .Init ();return _fff };
const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_gcg *Encoder )Reset (){_gcg ._be =0x8000;_gcg ._ae =0;_gcg ._ce =12;_gcg ._cdg =-1;_gcg ._cg =0;_gcg ._ed =nil ;_gcg ._age =_ba (_afg );};const _ee =0x9b25;
func (_cafb *Encoder )codeMPS (_efb *codingContext ,_dca uint32 ,_dce uint16 ,_fcga byte ){_cafb ._be -=_dce ;if _cafb ._be &0x8000!=0{_cafb ._ae +=uint32 (_dce );return ;};if _cafb ._be < _dce {_cafb ._be =_dce ;}else {_cafb ._ae +=uint32 (_dce );};_efb ._ea [_dca ]=_eddg [_fcga ]._dcf ;
_cafb .renormalize ();};func (_af *Encoder )Flush (){_af ._ffg =0;_af ._gcb =nil ;_af ._cdg =-1};func (_cfg *Encoder )emit (){if _cfg ._ffg ==_gae {_cfg ._gcb =append (_cfg ._gcb ,_cfg ._eaf );_cfg ._eaf =make ([]byte ,_gae );_cfg ._ffg =0;};_cfg ._eaf [_cfg ._ffg ]=_cfg ._cg ;
_cfg ._ffg ++;};func (_eb *Encoder )code0 (_caf *codingContext ,_agg uint32 ,_da uint16 ,_cdgd byte ){if _caf .mps (_agg )==0{_eb .codeMPS (_caf ,_agg ,_da ,_cdgd );}else {_eb .codeLPS (_caf ,_agg ,_da ,_cdgd );};};type Encoder struct{_ae uint32 ;_be uint16 ;
_ce ,_cg uint8 ;_cdg int ;_cc int ;_gcb [][]byte ;_eaf []byte ;_ffg int ;_age *codingContext ;_faf [13]*codingContext ;_ed *codingContext ;};func (_fcg *Encoder )Refine (iTemp ,iTarget *_a .Bitmap ,ox ,oy int )error {for _agf :=0;_agf < iTarget .Height ;
_agf ++{var _bbc int ;_dfa :=_agf +oy ;var (_adg ,_bbb ,_adb ,_fgb ,_ef uint16 ;_efc ,_gf ,_geb ,_cae ,_cag byte ;);if _dfa >=1&&(_dfa -1)< iTemp .Height {_efc =iTemp .Data [(_dfa -1)*iTemp .RowStride ];};if _dfa >=0&&_dfa < iTemp .Height {_gf =iTemp .Data [_dfa *iTemp .RowStride ];
};if _dfa >=-1&&_dfa +1< iTemp .Height {_geb =iTemp .Data [(_dfa +1)*iTemp .RowStride ];};if _agf >=1{_cae =iTarget .Data [(_agf -1)*iTarget .RowStride ];};_cag =iTarget .Data [_agf *iTarget .RowStride ];_fdd :=uint (6+ox );_adg =uint16 (_efc >>_fdd );
_bbb =uint16 (_gf >>_fdd );_adb =uint16 (_geb >>_fdd );_fgb =uint16 (_cae >>6);_bdd :=uint (2-ox );_efc <<=_bdd ;_gf <<=_bdd ;_geb <<=_bdd ;_cae <<=2;for _bbc =0;_bbc < iTarget .Width ;_bbc ++{_fb :=(_adg <<10)|(_bbb <<7)|(_adb <<4)|(_fgb <<1)|_ef ;_bee :=_cag >>7;
_bbe :=_fcg .encodeBit (_fcg ._age ,uint32 (_fb ),_bee );if _bbe !=nil {return _bbe ;};_adg <<=1;_bbb <<=1;_adb <<=1;_fgb <<=1;_adg |=uint16 (_efc >>7);_bbb |=uint16 (_gf >>7);_adb |=uint16 (_geb >>7);_fgb |=uint16 (_cae >>7);_ef =uint16 (_bee );_cf :=_bbc %8;
_dc :=_bbc /8+1;if _cf ==5+ox {_efc ,_gf ,_geb =0,0,0;if _dc < iTemp .RowStride &&_dfa >=1&&(_dfa -1)< iTemp .Height {_efc =iTemp .Data [(_dfa -1)*iTemp .RowStride +_dc ];};if _dc < iTemp .RowStride &&_dfa >=0&&_dfa < iTemp .Height {_gf =iTemp .Data [_dfa *iTemp .RowStride +_dc ];
};if _dc < iTemp .RowStride &&_dfa >=-1&&(_dfa +1)< iTemp .Height {_geb =iTemp .Data [(_dfa +1)*iTemp .RowStride +_dc ];};}else {_efc <<=1;_gf <<=1;_geb <<=1;};if _cf ==5&&_agf >=1{_cae =0;if _dc < iTarget .RowStride {_cae =iTarget .Data [(_agf -1)*iTarget .RowStride +_dc ];
};}else {_cae <<=1;};if _cf ==7{_cag =0;if _dc < iTarget .RowStride {_cag =iTarget .Data [_agf *iTarget .RowStride +_dc ];};}else {_cag <<=1;};_adg &=7;_bbb &=7;_adb &=7;_fgb &=7;};};return nil ;};func _ba (_cd int )*codingContext {return &codingContext {_ea :make ([]byte ,_cd ),_ag :make ([]byte ,_cd )};
};const (_afg =65536;_gae =20*1024;);type Class int ;func (_df *Encoder )EncodeIAID (symbolCodeLength ,value int )(_bfa error ){_g .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _bfa =_df .encodeIAID (symbolCodeLength ,value );_bfa !=nil {return _gc .Wrap (_bfa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_fddd *Encoder )codeLPS (_cca *codingContext ,_de uint32 ,_abcg uint16 ,_cdd byte ){_fddd ._be -=_abcg ;
if _fddd ._be < _abcg {_fddd ._ae +=uint32 (_abcg );}else {_fddd ._be =_abcg ;};if _eddg [_cdd ]._dad ==1{_cca .flipMps (_de );};_cca ._ea [_de ]=_eddg [_cdd ]._fga ;_fddd .renormalize ();};func (_bbca *Encoder )encodeInteger (_adf Class ,_bfd int )error {const _aca ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _bfd > 2000000000||_bfd < -2000000000{return _gc .Errorf (_aca ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_bfd );
};_gca :=_bbca ._faf [_adf ];_edd :=uint32 (1);var _gfc int ;for ;;_gfc ++{if _e [_gfc ]._ac <=_bfd &&_e [_gfc ]._bd >=_bfd {break ;};};if _bfd < 0{_bfd =-_bfd ;};_bfd -=int (_e [_gfc ]._ca );_acg :=_e [_gfc ]._bc ;for _gde :=uint8 (0);_gde < _e [_gfc ]._ge ;
_gde ++{_gega :=_acg &1;if _bffb :=_bbca .encodeBit (_gca ,_edd ,_gega );_bffb !=nil {return _gc .Wrap (_bffb ,_aca ,"");};_acg >>=1;if _edd &0x100> 0{_edd =(((_edd <<1)|uint32 (_gega ))&0x1ff)|0x100;}else {_edd =(_edd <<1)|uint32 (_gega );};};_bfd <<=32-_e [_gfc ]._geg ;
for _gfd :=uint8 (0);_gfd < _e [_gfc ]._geg ;_gfd ++{_gbf :=uint8 ((uint32 (_bfd )&0x80000000)>>31);if _dee :=_bbca .encodeBit (_gca ,_edd ,_gbf );_dee !=nil {return _gc .Wrap (_dee ,_aca ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_bfd <<=1;if _edd &0x100!=0{_edd =(((_edd <<1)|uint32 (_gbf ))&0x1ff)|0x100;}else {_edd =(_edd <<1)|uint32 (_gbf );};};return nil ;};func (_ab *Encoder )Init (){_ab ._age =_ba (_afg );_ab ._be =0x8000;_ab ._ae =0;_ab ._ce =12;_ab ._cdg =-1;_ab ._cg =0;
_ab ._ffg =0;_ab ._eaf =make ([]byte ,_gae );for _fd :=0;_fd < len (_ab ._faf );_fd ++{_ab ._faf [_fd ]=_ba (512);};_ab ._ed =nil ;};type intEncRangeS struct{_ac ,_bd int ;_bc ,_ge uint8 ;_ca uint16 ;_geg uint8 ;};func (_dbg *Encoder )encodeIAID (_dcg ,_bab int )error {if _dbg ._ed ==nil {_dbg ._ed =_ba (1<<uint (_dcg ));
};_gac :=uint32 (1<<uint32 (_dcg +1))-1;_bab <<=uint (32-_dcg );_bcg :=uint32 (1);for _eabc :=0;_eabc < _dcg ;_eabc ++{_ade :=_bcg &_gac ;_ggd :=uint8 ((uint32 (_bab )&0x80000000)>>31);if _efbe :=_dbg .encodeBit (_dbg ._ed ,_ade ,_ggd );_efbe !=nil {return _efbe ;
};_bcg =(_bcg <<1)|uint32 (_ggd );_bab <<=1;};return nil ;};func (_dec *Encoder )flush (){_dec .setBits ();_dec ._ae <<=_dec ._ce ;_dec .byteOut ();_dec ._ae <<=_dec ._ce ;_dec .byteOut ();_dec .emit ();if _dec ._cg !=0xff{_dec ._cdg ++;_dec ._cg =0xff;
_dec .emit ();};_dec ._cdg ++;_dec ._cg =0xac;_dec ._cdg ++;_dec .emit ();};func (_ccb *Encoder )DataSize ()int {return _ccb .dataSize ()};func (_edab *Encoder )dataSize ()int {return _gae *len (_edab ._gcb )+_edab ._ffg };type codingContext struct{_ea []byte ;
_ag []byte ;};var _ _bb .WriterTo =&Encoder {};func (_cgg *Encoder )EncodeOOB (proc Class )(_ga error ){_g .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _ga =_cgg .encodeOOB (proc );_ga !=nil {return _gc .Wrap (_ga ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_abb *Encoder )Final (){_abb .flush ()};func (_caea *Encoder )encodeOOB (_cde Class )error {_dfg :=_caea ._faf [_cde ];
_ffc :=_caea .encodeBit (_dfg ,1,1);if _ffc !=nil {return _ffc ;};_ffc =_caea .encodeBit (_dfg ,3,0);if _ffc !=nil {return _ffc ;};_ffc =_caea .encodeBit (_dfg ,6,0);if _ffc !=nil {return _ffc ;};_ffc =_caea .encodeBit (_dfg ,12,0);if _ffc !=nil {return _ffc ;
};return nil ;};func (_cff *Encoder )code1 (_cce *codingContext ,_bcd uint32 ,_cdb uint16 ,_dd byte ){if _cce .mps (_bcd )==1{_cff .codeMPS (_cce ,_bcd ,_cdb ,_dd );}else {_cff .codeLPS (_cce ,_bcd ,_cdb ,_dd );};};func (_fa *codingContext )flipMps (_ff uint32 ){_fa ._ag [_ff ]=1-_fa ._ag [_ff ]};
func (_feba *Encoder )renormalize (){for {_feba ._be <<=1;_feba ._ae <<=1;_feba ._ce --;if _feba ._ce ==0{_feba .byteOut ();};if (_feba ._be &0x8000)!=0{break ;};};};func (_aff *Encoder )lBlock (){if _aff ._cdg >=0{_aff .emit ();};_aff ._cdg ++;_aff ._cg =uint8 (_aff ._ae >>19);
_aff ._ae &=0x7ffff;_aff ._ce =8;};var _eddg =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_d *Encoder )EncodeBitmap (bm *_a .Bitmap ,duplicateLineRemoval bool )error {_g .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_aed ,_db uint8 ;
_ec ,_fc ,_fe uint16 ;_feb ,_bg ,_cgf byte ;_bgg ,_bf ,_bff int ;_fg ,_ede []byte ;);for _ecd :=0;_ecd < bm .Height ;_ecd ++{_feb ,_bg =0,0;if _ecd >=2{_feb =bm .Data [(_ecd -2)*bm .RowStride ];};if _ecd >=1{_bg =bm .Data [(_ecd -1)*bm .RowStride ];if duplicateLineRemoval {_bf =_ecd *bm .RowStride ;
_fg =bm .Data [_bf :_bf +bm .RowStride ];_bff =(_ecd -1)*bm .RowStride ;_ede =bm .Data [_bff :_bff +bm .RowStride ];if _c .Equal (_fg ,_ede ){_db =_aed ^1;_aed =1;}else {_db =_aed ;_aed =0;};};};if duplicateLineRemoval {if _gg :=_d .encodeBit (_d ._age ,_ee ,_db );
_gg !=nil {return _gg ;};if _aed !=0{continue ;};};_cgf =bm .Data [_ecd *bm .RowStride ];_ec =uint16 (_feb >>5);_fc =uint16 (_bg >>4);_feb <<=3;_bg <<=4;_fe =0;for _bgg =0;_bgg < bm .Width ;_bgg ++{_eg :=uint32 (_ec <<11|_fc <<4|_fe );_ad :=(_cgf &0x80)>>7;
_abc :=_d .encodeBit (_d ._age ,_eg ,_ad );if _abc !=nil {return _abc ;};_ec <<=1;_fc <<=1;_fe <<=1;_ec |=uint16 ((_feb &0x80)>>7);_fc |=uint16 ((_bg &0x80)>>7);_fe |=uint16 (_ad );_gea :=_bgg %8;_gcbf :=_bgg /8+1;if _gea ==4&&_ecd >=2{_feb =0;if _gcbf < bm .RowStride {_feb =bm .Data [(_ecd -2)*bm .RowStride +_gcbf ];
};}else {_feb <<=1;};if _gea ==3&&_ecd >=1{_bg =0;if _gcbf < bm .RowStride {_bg =bm .Data [(_ecd -1)*bm .RowStride +_gcbf ];};}else {_bg <<=1;};if _gea ==7{_cgf =0;if _gcbf < bm .RowStride {_cgf =bm .Data [_ecd *bm .RowStride +_gcbf ];};}else {_cgf <<=1;
};_ec &=31;_fc &=127;_fe &=15;};};return nil ;};func (_aeb *Encoder )encodeBit (_acc *codingContext ,_fcgad uint32 ,_gb uint8 )error {const _fgd ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_aeb ._cc ++;
if _fcgad >=uint32 (len (_acc ._ea )){return _gc .Errorf (_fgd ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fcgad );
};_gfg :=_acc ._ea [_fcgad ];_cga :=_acc .mps (_fcgad );_cgaa :=_eddg [_gfg ]._baa ;_g .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_aeb ._cc ,_gb ,_gfg ,_cga ,_cgaa ,_aeb ._be ,_aeb ._ae ,_aeb ._ce ,_aeb ._cg ,_aeb ._cdg );
if _gb ==0{_aeb .code0 (_acc ,_fcgad ,_cgaa ,_gfg );}else {_aeb .code1 (_acc ,_fcgad ,_cgaa ,_gfg );};return nil ;};func (_ead *Encoder )WriteTo (w _bb .Writer )(int64 ,error ){const _cfb ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _bde int64 ;for _eda ,_gfb :=range _ead ._gcb {_ecdc ,_eab :=w .Write (_gfb );if _eab !=nil {return 0,_gc .Wrapf (_eab ,_cfb ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_eda );
};_bde +=int64 (_ecdc );};_ead ._eaf =_ead ._eaf [:_ead ._ffg ];_dba ,_abd :=w .Write (_ead ._eaf );if _abd !=nil {return 0,_gc .Wrap (_abd ,_cfb ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bde +=int64 (_dba );
return _bde ,nil ;};func (_fea *Encoder )byteOut (){if _fea ._cg ==0xff{_fea .rBlock ();return ;};if _fea ._ae < 0x8000000{_fea .lBlock ();return ;};_fea ._cg ++;if _fea ._cg !=0xff{_fea .lBlock ();return ;};_fea ._ae &=0x7ffffff;_fea .rBlock ();};