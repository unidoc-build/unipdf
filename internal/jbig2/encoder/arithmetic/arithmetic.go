//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_dc "bytes";_b "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ca "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func _ee (_ad int )*codingContext {return &codingContext {_fe :make ([]byte ,_ad ),_be :make ([]byte ,_ad )};};func (_fad *Encoder )code0 (_aab *codingContext ,_ebc uint32 ,_acf uint16 ,_ebd byte ){if _aab .mps (_ebc )==0{_fad .codeMPS (_aab ,_ebc ,_acf ,_ebd );}else {_fad .codeLPS (_aab ,_ebc ,_acf ,_ebd );};};type state struct{_egeb uint16 ;_cae ,_gge uint8 ;_acec uint8 ;};func (_fa *codingContext )mps (_fb uint32 )int {return int (_fa ._be [_fb ])};func (_de *Encoder )DataSize ()int {return _de .dataSize ()};func (_ac *codingContext )flipMps (_gb uint32 ){_ac ._be [_gb ]=1-_ac ._be [_gb ]};var _ _a .WriterTo =&Encoder {};func (_bed *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _gcb ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _ef int64 ;for _ea ,_aaff :=range _bed ._ceg {_baf ,_df :=w .Write (_aaff );if _df !=nil {return 0,_ca .Wrapf (_df ,_gcb ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ea );};_ef +=int64 (_baf );};_bed ._aed =_bed ._aed [:_bed ._aaf ];_gbd ,_bggb :=w .Write (_bed ._aed );if _bggb !=nil {return 0,_ca .Wrap (_bggb ,_gcb ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ef +=int64 (_gbd );return _ef ,nil ;};const _gg =0x9b25;func (_eab *Encoder )byteOut (){if _eab ._ccg ==0xff{_eab .rBlock ();return ;};if _eab ._cc < 0x8000000{_eab .lBlock ();return ;};_eab ._ccg ++;if _eab ._ccg !=0xff{_eab .lBlock ();return ;};_eab ._cc &=0x7ffffff;_eab .rBlock ();};func (_aaa *Encoder )setBits (){_ede :=_aaa ._cc +uint32 (_aaa ._aa );_aaa ._cc |=0xffff;if _aaa ._cc >=_ede {_aaa ._cc -=0x8000;};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);type intEncRangeS struct{_ba ,_bb int ;_bc ,_f uint8 ;_ce uint16 ;_e uint8 ;};func (_ed *Encoder )Reset (){_ed ._aa =0x8000;_ed ._cc =0;_ed ._ae =12;_ed ._gf =-1;_ed ._ccg =0;_ed ._bagd =nil ;_ed ._bag =_ee (_bac );};func (_dbd *Encoder )codeLPS (_beb *codingContext ,_aeb uint32 ,_eec uint16 ,_efe byte ){_dbd ._aa -=_eec ;if _dbd ._aa < _eec {_dbd ._cc +=uint32 (_eec );}else {_dbd ._aa =_eec ;};if _dbf [_efe ]._acec ==1{_beb .flipMps (_aeb );};_beb ._fe [_aeb ]=_dbf [_efe ]._gge ;_dbd .renormalize ();};func (_ccd *Encoder )Final (){_ccd .flush ()};var _dbf =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_ga *Encoder )EncodeInteger (proc Class ,value int )(_dd error ){_b .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _dd =_ga .encodeInteger (proc ,value );_dd !=nil {return _ca .Wrap (_dd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_cbe *Encoder )rBlock (){if _cbe ._gf >=0{_cbe .emit ();};_cbe ._gf ++;_cbe ._ccg =uint8 (_cbe ._cc >>20);_cbe ._cc &=0xfffff;_cbe ._ae =7;};func (_bbf *Encoder )Flush (){_bbf ._aaf =0;_bbf ._ceg =nil ;_bbf ._gf =-1};func (_dgg *Encoder )encodeBit (_ddc *codingContext ,_ec uint32 ,_dcbe uint8 )error {const _baab ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_dgg ._bee ++;if _ec >=uint32 (len (_ddc ._fe )){return _ca .Errorf (_baab ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_ec );};_bge :=_ddc ._fe [_ec ];_ebb :=_ddc .mps (_ec );_cab :=_dbf [_bge ]._egeb ;_b .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dgg ._bee ,_dcbe ,_bge ,_ebb ,_cab ,_dgg ._aa ,_dgg ._cc ,_dgg ._ae ,_dgg ._ccg ,_dgg ._gf );if _dcbe ==0{_dgg .code0 (_ddc ,_ec ,_cab ,_bge );}else {_dgg .code1 (_ddc ,_ec ,_cab ,_bge );};return nil ;};func (_gc *Encoder )EncodeBitmap (bm *_c .Bitmap ,duplicateLineRemoval bool )error {_b .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_eb ,_baa uint8 ;_eg ,_ag ,_cb uint16 ;_caa ,_af ,_fgc byte ;_da ,_fbg ,_bg int ;_fac ,_bgg []byte ;);for _gfa :=0;_gfa < bm .Height ;_gfa ++{_caa ,_af =0,0;if _gfa >=2{_caa =bm .Data [(_gfa -2)*bm .RowStride ];};if _gfa >=1{_af =bm .Data [(_gfa -1)*bm .RowStride ];if duplicateLineRemoval {_fbg =_gfa *bm .RowStride ;_fac =bm .Data [_fbg :_fbg +bm .RowStride ];_bg =(_gfa -1)*bm .RowStride ;_bgg =bm .Data [_bg :_bg +bm .RowStride ];if _dc .Equal (_fac ,_bgg ){_baa =_eb ^1;_eb =1;}else {_baa =_eb ;_eb =0;};};};if duplicateLineRemoval {if _ggc :=_gc .encodeBit (_gc ._bag ,_gg ,_baa );_ggc !=nil {return _ggc ;};if _eb !=0{continue ;};};_fgc =bm .Data [_gfa *bm .RowStride ];_eg =uint16 (_caa >>5);_ag =uint16 (_af >>4);_caa <<=3;_af <<=4;_cb =0;for _da =0;_da < bm .Width ;_da ++{_ace :=uint32 (_eg <<11|_ag <<4|_cb );_dac :=(_fgc &0x80)>>7;_cce :=_gc .encodeBit (_gc ._bag ,_ace ,_dac );if _cce !=nil {return _cce ;};_eg <<=1;_ag <<=1;_cb <<=1;_eg |=uint16 ((_caa &0x80)>>7);_ag |=uint16 ((_af &0x80)>>7);_cb |=uint16 (_dac );_cea :=_da %8;_ade :=_da /8+1;if _cea ==4&&_gfa >=2{_caa =0;if _ade < bm .RowStride {_caa =bm .Data [(_gfa -2)*bm .RowStride +_ade ];};}else {_caa <<=1;};if _cea ==3&&_gfa >=1{_af =0;if _ade < bm .RowStride {_af =bm .Data [(_gfa -1)*bm .RowStride +_ade ];};}else {_af <<=1;};if _cea ==7{_fgc =0;if _ade < bm .RowStride {_fgc =bm .Data [_gfa *bm .RowStride +_ade ];};}else {_fgc <<=1;};_eg &=31;_ag &=127;_cb &=15;};};return nil ;};func (_ge *Encoder )code1 (_dcb *codingContext ,_bf uint32 ,_gff uint16 ,_efg byte ){if _dcb .mps (_bf )==1{_ge .codeMPS (_dcb ,_bf ,_gff ,_efg );}else {_ge .codeLPS (_dcb ,_bf ,_gff ,_efg );};};func (_egc *Encoder )Refine (iTemp ,iTarget *_c .Bitmap ,ox ,oy int )error {for _fc :=0;_fc < iTarget .Height ;_fc ++{var _gcc int ;_ada :=_fc +oy ;var (_faf ,_cfe ,_ab ,_fag ,_bgf uint16 ;_gfe ,_gcf ,_bgd ,_ggb ,_dee byte ;);if _ada >=1&&(_ada -1)< iTemp .Height {_gfe =iTemp .Data [(_ada -1)*iTemp .RowStride ];};if _ada >=0&&_ada < iTemp .Height {_gcf =iTemp .Data [_ada *iTemp .RowStride ];};if _ada >=-1&&_ada +1< iTemp .Height {_bgd =iTemp .Data [(_ada +1)*iTemp .RowStride ];};if _fc >=1{_ggb =iTarget .Data [(_fc -1)*iTarget .RowStride ];};_dee =iTarget .Data [_fc *iTarget .RowStride ];_aff :=uint (6+ox );_faf =uint16 (_gfe >>_aff );_cfe =uint16 (_gcf >>_aff );_ab =uint16 (_bgd >>_aff );_fag =uint16 (_ggb >>6);_fcg :=uint (2-ox );_gfe <<=_fcg ;_gcf <<=_fcg ;_bgd <<=_fcg ;_ggb <<=2;for _gcc =0;_gcc < iTarget .Width ;_gcc ++{_dg :=(_faf <<10)|(_cfe <<7)|(_ab <<4)|(_fag <<1)|_bgf ;_abf :=_dee >>7;_ege :=_egc .encodeBit (_egc ._bag ,uint32 (_dg ),_abf );if _ege !=nil {return _ege ;};_faf <<=1;_cfe <<=1;_ab <<=1;_fag <<=1;_faf |=uint16 (_gfe >>7);_cfe |=uint16 (_gcf >>7);_ab |=uint16 (_bgd >>7);_fag |=uint16 (_ggb >>7);_bgf =uint16 (_abf );_ggd :=_gcc %8;_feb :=_gcc /8+1;if _ggd ==5+ox {_gfe ,_gcf ,_bgd =0,0,0;if _feb < iTemp .RowStride &&_ada >=1&&(_ada -1)< iTemp .Height {_gfe =iTemp .Data [(_ada -1)*iTemp .RowStride +_feb ];};if _feb < iTemp .RowStride &&_ada >=0&&_ada < iTemp .Height {_gcf =iTemp .Data [_ada *iTemp .RowStride +_feb ];};if _feb < iTemp .RowStride &&_ada >=-1&&(_ada +1)< iTemp .Height {_bgd =iTemp .Data [(_ada +1)*iTemp .RowStride +_feb ];};}else {_gfe <<=1;_gcf <<=1;_bgd <<=1;};if _ggd ==5&&_fc >=1{_ggb =0;if _feb < iTarget .RowStride {_ggb =iTarget .Data [(_fc -1)*iTarget .RowStride +_feb ];};}else {_ggb <<=1;};if _ggd ==7{_dee =0;if _feb < iTarget .RowStride {_dee =iTarget .Data [_fc *iTarget .RowStride +_feb ];};}else {_dee <<=1;};_faf &=7;_cfe &=7;_ab &=7;_fag &=7;};};return nil ;};func (_fede *Encoder )flush (){_fede .setBits ();_fede ._cc <<=_fede ._ae ;_fede .byteOut ();_fede ._cc <<=_fede ._ae ;_fede .byteOut ();_fede .emit ();if _fede ._ccg !=0xff{_fede ._gf ++;_fede ._ccg =0xff;_fede .emit ();};_fede ._gf ++;_fede ._ccg =0xac;_fede ._gf ++;_fede .emit ();};func New ()*Encoder {_db :=&Encoder {};_db .Init ();return _db };func (_bcd *Encoder )lBlock (){if _bcd ._gf >=0{_bcd .emit ();};_bcd ._gf ++;_bcd ._ccg =uint8 (_bcd ._cc >>19);_bcd ._cc &=0x7ffff;_bcd ._ae =8;};func (_dbdd *Encoder )encodeOOB (_dggc Class )error {_bfb :=_dbdd ._aede [_dggc ];_bcg :=_dbdd .encodeBit (_bfb ,1,1);if _bcg !=nil {return _bcg ;};_bcg =_dbdd .encodeBit (_bfb ,3,0);if _bcg !=nil {return _bcg ;};_bcg =_dbdd .encodeBit (_bfb ,6,0);if _bcg !=nil {return _bcg ;};_bcg =_dbdd .encodeBit (_bfb ,12,0);if _bcg !=nil {return _bcg ;};return nil ;};var _fg =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_g Class )String ()string {switch _g {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_acb *Encoder )Init (){_acb ._bag =_ee (_bac );_acb ._aa =0x8000;_acb ._cc =0;_acb ._ae =12;_acb ._gf =-1;_acb ._ccg =0;_acb ._aaf =0;_acb ._aed =make ([]byte ,_bae );for _fed :=0;_fed < len (_acb ._aede );_fed ++{_acb ._aede [_fed ]=_ee (512);};_acb ._bagd =nil ;};const (_bac =65536;_bae =20*1024;);type Class int ;func (_dfg *Encoder )codeMPS (_ccdc *codingContext ,_fga uint32 ,_fbc uint16 ,_fgad byte ){_dfg ._aa -=_fbc ;if _dfg ._aa &0x8000!=0{_dfg ._cc +=uint32 (_fbc );return ;};if _dfg ._aa < _fbc {_dfg ._aa =_fbc ;}else {_dfg ._cc +=uint32 (_fbc );};_ccdc ._fe [_fga ]=_dbf [_fgad ]._cae ;_dfg .renormalize ();};func (_fgg *Encoder )EncodeIAID (symbolCodeLength ,value int )(_adg error ){_b .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _adg =_fgg .encodeIAID (symbolCodeLength ,value );_adg !=nil {return _ca .Wrap (_adg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_dbc *Encoder )EncodeOOB (proc Class )(_cf error ){_b .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _cf =_dbc .encodeOOB (proc );_cf !=nil {return _ca .Wrap (_cf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};type codingContext struct{_fe []byte ;_be []byte ;};func (_ebe *Encoder )encodeIAID (_aef ,_cg int )error {if _ebe ._bagd ==nil {_ebe ._bagd =_ee (1<<uint (_aef ));};_bga :=uint32 (1<<uint32 (_aef +1))-1;_cg <<=uint (32-_aef );_bede :=uint32 (1);for _cdd :=0;_cdd < _aef ;_cdd ++{_fce :=_bede &_bga ;_ddg :=uint8 ((uint32 (_cg )&0x80000000)>>31);if _adf :=_ebe .encodeBit (_ebe ._bagd ,_fce ,_ddg );_adf !=nil {return _adf ;};_bede =(_bede <<1)|uint32 (_ddg );_cg <<=1;};return nil ;};func (_gfd *Encoder )dataSize ()int {return _bae *len (_gfd ._ceg )+_gfd ._aaf };func (_cfc *Encoder )emit (){if _cfc ._aaf ==_bae {_cfc ._ceg =append (_cfc ._ceg ,_cfc ._aed );_cfc ._aed =make ([]byte ,_bae );_cfc ._aaf =0;};_cfc ._aed [_cfc ._aaf ]=_cfc ._ccg ;_cfc ._aaf ++;};func (_bdg *Encoder )encodeInteger (_gfc Class ,_efd int )error {const _cca ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _efd > 2000000000||_efd < -2000000000{return _ca .Errorf (_cca ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_efd );};_deed :=_bdg ._aede [_gfc ];_ff :=uint32 (1);var _fef int ;for ;;_fef ++{if _fg [_fef ]._ba <=_efd &&_fg [_fef ]._bb >=_efd {break ;};};if _efd < 0{_efd =-_efd ;};_efd -=int (_fg [_fef ]._ce );_gbf :=_fg [_fef ]._bc ;for _cbd :=uint8 (0);_cbd < _fg [_fef ]._f ;_cbd ++{_eef :=_gbf &1;if _eae :=_bdg .encodeBit (_deed ,_ff ,_eef );_eae !=nil {return _ca .Wrap (_eae ,_cca ,"");};_gbf >>=1;if _ff &0x100> 0{_ff =(((_ff <<1)|uint32 (_eef ))&0x1ff)|0x100;}else {_ff =(_ff <<1)|uint32 (_eef );};};_efd <<=32-_fg [_fef ]._e ;for _fggg :=uint8 (0);_fggg < _fg [_fef ]._e ;_fggg ++{_cd :=uint8 ((uint32 (_efd )&0x80000000)>>31);if _egf :=_bdg .encodeBit (_deed ,_ff ,_cd );_egf !=nil {return _ca .Wrap (_egf ,_cca ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_efd <<=1;if _ff &0x100!=0{_ff =(((_ff <<1)|uint32 (_cd ))&0x1ff)|0x100;}else {_ff =(_ff <<1)|uint32 (_cd );};};return nil ;};func (_egcd *Encoder )renormalize (){for {_egcd ._aa <<=1;_egcd ._cc <<=1;_egcd ._ae --;if _egcd ._ae ==0{_egcd .byteOut ();};if (_egcd ._aa &0x8000)!=0{break ;};};};type Encoder struct{_cc uint32 ;_aa uint16 ;_ae ,_ccg uint8 ;_gf int ;_bee int ;_ceg [][]byte ;_aed []byte ;_aaf int ;_bag *codingContext ;_aede [13]*codingContext ;_bagd *codingContext ;};