//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "fmt";_bg "github.com/unidoc/unipdf/v3/common";_ca "github.com/unidoc/unipdf/v3/internal/bitwise";_de "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_e "io";_c "strings";);func (_fc *DecoderStats )cx ()byte {return _fc ._fe [_fc ._ff ]};
func New (r *_ca .Reader )(*Decoder ,error ){_gb :=&Decoder {_g :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _dab :=_gb .init ();_dab !=nil {return nil ,_dab ;};return _gb ,nil ;};func (_ag *DecoderStats )getMps ()byte {return _ag ._cba [_ag ._ff ]};
func (_bac *DecoderStats )Overwrite (dNew *DecoderStats ){for _gd :=0;_gd < len (_bac ._fe );_gd ++{_bac ._fe [_gd ]=dNew ._fe [_gd ];_bac ._cba [_gd ]=dNew ._cba [_gd ];};};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_ff :index ,_gg :contextSize ,_fe :make ([]byte ,contextSize ),_cba :make ([]byte ,contextSize )};
};func (_abaa *DecoderStats )String ()string {_cge :=&_c .Builder {};_cge .WriteString (_d .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_abaa ._fe )));for _aea ,_acg :=range _abaa ._fe {if _acg !=0{_cge .WriteString (_d .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_aea ,_acg ));
};};return _cge .String ();};func (_gf *Decoder )init ()error {_gf ._ga =_gf ._g .AbsolutePosition ();_cc ,_ceg :=_gf ._g .ReadByte ();if _ceg !=nil {_bg .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_ceg );
return _ceg ;};_gf ._cag =_cc ;_gf ._bc =uint64 (_cc )<<16;if _ceg =_gf .readByte ();_ceg !=nil {return _ceg ;};_gf ._bc <<=7;_gf ._cd -=7;_gf ._ba =0x8000;_gf ._db ++;return nil ;};func (_ae *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ab ,_cb int32 ;
_cgf ,_f ,_eab int ;_ad error ;);if stats ==nil {stats =NewStats (512,1);};_ae ._da =1;_f ,_ad =_ae .decodeIntBit (stats );if _ad !=nil {return 0,_ad ;};_cgf ,_ad =_ae .decodeIntBit (stats );if _ad !=nil {return 0,_ad ;};if _cgf ==1{_cgf ,_ad =_ae .decodeIntBit (stats );
if _ad !=nil {return 0,_ad ;};if _cgf ==1{_cgf ,_ad =_ae .decodeIntBit (stats );if _ad !=nil {return 0,_ad ;};if _cgf ==1{_cgf ,_ad =_ae .decodeIntBit (stats );if _ad !=nil {return 0,_ad ;};if _cgf ==1{_cgf ,_ad =_ae .decodeIntBit (stats );if _ad !=nil {return 0,_ad ;
};if _cgf ==1{_eab =32;_cb =4436;}else {_eab =12;_cb =340;};}else {_eab =8;_cb =84;};}else {_eab =6;_cb =20;};}else {_eab =4;_cb =4;};}else {_eab =2;_cb =0;};for _fb :=0;_fb < _eab ;_fb ++{_cgf ,_ad =_ae .decodeIntBit (stats );if _ad !=nil {return 0,_ad ;
};_ab =(_ab <<1)|int32 (_cgf );};_ab +=_cb ;if _f ==0{return _ab ,nil ;}else if _f ==1&&_ab > 0{return -_ab ,nil ;};return 0,_de .ErrOOB ;};func (_gfd *DecoderStats )Reset (){for _fba :=0;_fba < len (_gfd ._fe );_fba ++{_gfd ._fe [_fba ]=0;_gfd ._cba [_fba ]=0;
};};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_g *_ca .Reader ;_cag uint8 ;_bc uint64 ;_ba uint32 ;_da int64 ;_cd int32 ;_db int32 ;_ga int64 ;};func (_gc *Decoder )lpsExchange (_dg *DecoderStats ,_gbg int32 ,_dfg uint32 )int {_bgc :=_dg .getMps ();
if _gc ._ba < _dfg {_dg .setEntry (int (_df [_gbg ][1]));_gc ._ba =_dfg ;return int (_bgc );};if _df [_gbg ][3]==1{_dg .toggleMps ();};_dg .setEntry (int (_df [_gbg ][2]));_gc ._ba =_dfg ;return int (1-_bgc );};type DecoderStats struct{_ff int32 ;_gg int32 ;
_fe []byte ;_cba []byte ;};func (_bb *Decoder )readByte ()error {if _bb ._g .AbsolutePosition ()> _bb ._ga {if _ ,_dc :=_bb ._g .Seek (-1,_e .SeekCurrent );_dc !=nil {return _dc ;};};_dfb ,_daf :=_bb ._g .ReadByte ();if _daf !=nil {return _daf ;};_bb ._cag =_dfb ;
if _bb ._cag ==0xFF{_bgb ,_fbe :=_bb ._g .ReadByte ();if _fbe !=nil {return _fbe ;};if _bgb > 0x8F{_bb ._bc +=0xFF00;_bb ._cd =8;if _ ,_bf :=_bb ._g .Seek (-2,_e .SeekCurrent );_bf !=nil {return _bf ;};}else {_bb ._bc +=uint64 (_bgb )<<9;_bb ._cd =7;};
}else {_dfb ,_daf =_bb ._g .ReadByte ();if _daf !=nil {return _daf ;};_bb ._cag =_dfb ;_bb ._bc +=uint64 (_bb ._cag )<<8;_bb ._cd =8;};_bb ._bc &=0xFFFFFFFFFF;return nil ;};var (_df =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func (_ec *DecoderStats )toggleMps (){_ec ._cba [_ec ._ff ]^=1};func (_gfc *DecoderStats )SetIndex (index int32 ){_gfc ._ff =index };func (_bbb *Decoder )renormalize ()error {for {if _bbb ._cd ==0{if _ed :=_bbb .readByte ();_ed !=nil {return _ed ;};};
_bbb ._ba <<=1;_bbb ._bc <<=1;_bbb ._cd --;if (_bbb ._ba &0x8000)!=0{break ;};};_bbb ._bc &=0xffffffff;return nil ;};func (_cgc *Decoder )decodeIntBit (_fad *DecoderStats )(int ,error ){_fad .SetIndex (int32 (_cgc ._da ));_ac ,_bbbb :=_cgc .DecodeBit (_fad );
if _bbbb !=nil {_bg .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_bbbb );
return _ac ,_bbbb ;};if _cgc ._da < 256{_cgc ._da =((_cgc ._da <<uint64 (1))|int64 (_ac ))&0x1ff;}else {_cgc ._da =(((_cgc ._da <<uint64 (1)|int64 (_ac ))&511)|256)&0x1ff;};return _ac ,nil ;};func (_fbf *Decoder )mpsExchange (_ccc *DecoderStats ,_abc int32 )int {_fbg :=_ccc ._cba [_ccc ._ff ];
if _fbf ._ba < _df [_abc ][0]{if _df [_abc ][3]==1{_ccc .toggleMps ();};_ccc .setEntry (int (_df [_abc ][2]));return int (1-_fbg );};_ccc .setEntry (int (_df [_abc ][1]));return int (_fbg );};func (_fa *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_fa ._da =1;
var _cdd uint64 ;for _cdd =0;_cdd < codeLen ;_cdd ++{stats .SetIndex (int32 (_fa ._da ));_ce ,_gaf :=_fa .DecodeBit (stats );if _gaf !=nil {return 0,_gaf ;};_fa ._da =(_fa ._da <<1)|int64 (_ce );};_ef :=_fa ._da -(1<<codeLen );return _ef ,nil ;};func (_fg *DecoderStats )setEntry (_dbg int ){_cgce :=byte (_dbg &0x7f);
_fg ._fe [_fg ._ff ]=_cgce };func (_dea *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_cg int ;_a =_df [stats .cx ()][0];_cf =int32 (stats .cx ()););defer func (){_dea ._db ++}();_dea ._ba -=_a ;if (_dea ._bc >>16)< uint64 (_a ){_cg =_dea .lpsExchange (stats ,_cf ,_a );
if _ea :=_dea .renormalize ();_ea !=nil {return 0,_ea ;};}else {_dea ._bc -=uint64 (_a )<<16;if (_dea ._ba &0x8000)==0{_cg =_dea .mpsExchange (stats ,_cf );if _caf :=_dea .renormalize ();_caf !=nil {return 0,_caf ;};}else {_cg =int (stats .getMps ());};
};return _cg ,nil ;};func (_efb *DecoderStats )Copy ()*DecoderStats {_bbe :=&DecoderStats {_gg :_efb ._gg ,_fe :make ([]byte ,_efb ._gg )};copy (_bbe ._fe ,_efb ._fe );return _bbe ;};