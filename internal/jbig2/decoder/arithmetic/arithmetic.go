//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "fmt";_b "github.com/unidoc/unipdf/v3/common";_ga "github.com/unidoc/unipdf/v3/internal/bitwise";_eb "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_aa "io";_e "strings";);func (_ef *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ef ._bd =1;
var _eca uint64 ;for _eca =0;_eca < codeLen ;_eca ++{stats .SetIndex (int32 (_ef ._bd ));_caf ,_cd :=_ef .DecodeBit (stats );if _cd !=nil {return 0,_cd ;};_ef ._bd =(_ef ._bd <<1)|int64 (_caf );};_fdb :=_ef ._bd -(1<<codeLen );return _fdb ,nil ;};func (_fg *Decoder )renormalize ()error {for {if _fg ._c ==0{if _ded :=_fg .readByte ();
_ded !=nil {return _ded ;};};_fg ._ad <<=1;_fg ._d <<=1;_fg ._c --;if (_fg ._ad &0x8000)!=0{break ;};};_fg ._d &=0xffffffff;return nil ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_f _ga .StreamReader ;_fe uint8 ;_d uint64 ;
_ad uint32 ;_bd int64 ;_c int32 ;_cc int32 ;_ab int64 ;};func (_fd *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ebb ,_fb int32 ;_df ,_ee ,_gb int ;_ec error ;);if stats ==nil {stats =NewStats (512,1);};_fd ._bd =1;_ee ,_ec =_fd .decodeIntBit (stats );
if _ec !=nil {return 0,_ec ;};_df ,_ec =_fd .decodeIntBit (stats );if _ec !=nil {return 0,_ec ;};if _df ==1{_df ,_ec =_fd .decodeIntBit (stats );if _ec !=nil {return 0,_ec ;};if _df ==1{_df ,_ec =_fd .decodeIntBit (stats );if _ec !=nil {return 0,_ec ;};
if _df ==1{_df ,_ec =_fd .decodeIntBit (stats );if _ec !=nil {return 0,_ec ;};if _df ==1{_df ,_ec =_fd .decodeIntBit (stats );if _ec !=nil {return 0,_ec ;};if _df ==1{_gb =32;_fb =4436;}else {_gb =12;_fb =340;};}else {_gb =8;_fb =84;};}else {_gb =6;_fb =20;
};}else {_gb =4;_fb =4;};}else {_gb =2;_fb =0;};for _de :=0;_de < _gb ;_de ++{_df ,_ec =_fd .decodeIntBit (stats );if _ec !=nil {return 0,_ec ;};_ebb =(_ebb <<1)|int32 (_df );};_ebb +=_fb ;if _ee ==0{return _ebb ,nil ;}else if _ee ==1&&_ebb > 0{return -_ebb ,nil ;
};return 0,_eb .ErrOOB ;};func (_da *Decoder )readByte ()error {if _da ._f .StreamPosition ()> _da ._ab {if _ ,_dfa :=_da ._f .Seek (-1,_aa .SeekCurrent );_dfa !=nil {return _dfa ;};};_ac ,_dd :=_da ._f .ReadByte ();if _dd !=nil {return _dd ;};_da ._fe =_ac ;
if _da ._fe ==0xFF{_cga ,_aac :=_da ._f .ReadByte ();if _aac !=nil {return _aac ;};if _cga > 0x8F{_da ._d +=0xFF00;_da ._c =8;if _ ,_ddg :=_da ._f .Seek (-2,_aa .SeekCurrent );_ddg !=nil {return _ddg ;};}else {_da ._d +=uint64 (_cga )<<9;_da ._c =7;};}else {_ac ,_dd =_da ._f .ReadByte ();
if _dd !=nil {return _dd ;};_da ._fe =_ac ;_da ._d +=uint64 (_da ._fe )<<8;_da ._c =8;};_da ._d &=0xFFFFFFFFFF;return nil ;};func (_ed *Decoder )decodeIntBit (_ccd *DecoderStats )(int ,error ){_ccd .SetIndex (int32 (_ed ._bd ));_ce ,_fba :=_ed .DecodeBit (_ccd );
if _fba !=nil {_b .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_fba );
return _ce ,_fba ;};if _ed ._bd < 256{_ed ._bd =((_ed ._bd <<uint64 (1))|int64 (_ce ))&0x1ff;}else {_ed ._bd =(((_ed ._bd <<uint64 (1)|int64 (_ce ))&511)|256)&0x1ff;};return _ce ,nil ;};func (_cg *Decoder )init ()error {_cg ._ab =_cg ._f .StreamPosition ();
_dc ,_ebg :=_cg ._f .ReadByte ();if _ebg !=nil {_b .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_ebg );return _ebg ;};_cg ._fe =_dc ;_cg ._d =uint64 (_dc )<<16;
if _ebg =_cg .readByte ();_ebg !=nil {return _ebg ;};_cg ._d <<=7;_cg ._c -=7;_cg ._ad =0x8000;_cg ._cc ++;return nil ;};func (_def *DecoderStats )Copy ()*DecoderStats {_ccf :=&DecoderStats {_fc :_def ._fc ,_ceg :make ([]byte ,_def ._fc )};for _gac :=0;
_gac < len (_def ._ceg );_gac ++{_ccf ._ceg [_gac ]=_def ._ceg [_gac ];};return _ccf ;};func (_cgf *DecoderStats )cx ()byte {return _cgf ._ceg [_cgf ._cggf ]};func (_ddc *DecoderStats )Overwrite (dNew *DecoderStats ){for _age :=0;_age < len (_ddc ._ceg );
_age ++{_ddc ._ceg [_age ]=dNew ._ceg [_age ];_ddc ._agf [_age ]=dNew ._agf [_age ];};};type DecoderStats struct{_cggf int32 ;_fc int32 ;_ceg []byte ;_agf []byte ;};func (_bb *DecoderStats )Reset (){for _dff :=0;_dff < len (_bb ._ceg );_dff ++{_bb ._ceg [_dff ]=0;
_bb ._agf [_dff ]=0;};};func (_cab *DecoderStats )String ()string {_fbb :=&_e .Builder {};_fbb .WriteString (_g .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_cab ._ceg )));for _gd ,_ffb :=range _cab ._ceg {if _ffb !=0{_fbb .WriteString (_g .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_gd ,_ffb ));
};};return _fbb .String ();};func (_aaee *Decoder )mpsExchange (_fdg *DecoderStats ,_ff int32 )int {_fa :=_fdg ._agf [_fdg ._cggf ];if _aaee ._ad < _ge [_ff ][0]{if _ge [_ff ][3]==1{_fdg .toggleMps ();};_fdg .setEntry (int (_ge [_ff ][2]));return int (1-_fa );
};_fdg .setEntry (int (_ge [_ff ][1]));return int (_fa );};func (_cdc *DecoderStats )setEntry (_caa int ){_eec :=byte (_caa &0x7f);_cdc ._ceg [_cdc ._cggf ]=_eec };func (_eg *DecoderStats )getMps ()byte {return _eg ._agf [_eg ._cggf ]};func (_gcc *DecoderStats )SetIndex (index int32 ){_gcc ._cggf =index };
func (_dg *Decoder )lpsExchange (_dfe *DecoderStats ,_dgg int32 ,_faa uint32 )int {_cgg :=_dfe .getMps ();if _dg ._ad < _faa {_dfe .setEntry (int (_ge [_dgg ][1]));_dg ._ad =_faa ;return int (_cgg );};if _ge [_dgg ][3]==1{_dfe .toggleMps ();};_dfe .setEntry (int (_ge [_dgg ][2]));
_dg ._ad =_faa ;return int (1-_cgg );};func New (r _ga .StreamReader )(*Decoder ,error ){_ca :=&Decoder {_f :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _bg :=_ca .init ();_bg !=nil {return nil ,_bg ;};return _ca ,nil ;
};func (_geg *DecoderStats )toggleMps (){_geg ._agf [_geg ._cggf ]^=1};func (_geb *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_gg int ;_ag =_ge [stats .cx ()][0];_ae =int32 (stats .cx ()););defer func (){_geb ._cc ++}();_geb ._ad -=_ag ;
if (_geb ._d >>16)< uint64 (_ag ){_gg =_geb .lpsExchange (stats ,_ae ,_ag );if _gc :=_geb .renormalize ();_gc !=nil {return 0,_gc ;};}else {_geb ._d -=uint64 (_ag )<<16;if (_geb ._ad &0x8000)==0{_gg =_geb .mpsExchange (stats ,_ae );if _gca :=_geb .renormalize ();
_gca !=nil {return 0,_gca ;};}else {_gg =int (stats .getMps ());};};return _gg ,nil ;};var (_ge =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_cggf :index ,_fc :contextSize ,_ceg :make ([]byte ,contextSize ),_agf :make ([]byte ,contextSize )};};