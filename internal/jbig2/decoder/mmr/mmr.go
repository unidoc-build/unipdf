//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_dg "errors";_d "fmt";_a "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_dc "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_eg "io";);type mmrCode int ;func (_dbd *Decoder )fillBitmap (_fde *_dc .Bitmap ,_efb int ,_gc []int ,_dfg int )error {var _aca byte ;_edg :=0;_cg :=_fde .GetByteIndex (_edg ,_efb );for _aef :=0;_aef < _dfg ;_aef ++{_bee :=byte (1);_gg :=_gc [_aef ];if (_aef &1)==0{_bee =0;};for _edg < _gg {_aca =(_aca <<1)|_bee ;_edg ++;if (_edg &7)==0{if _ccb :=_fde .SetByte (_cg ,_aca );_ccb !=nil {return _ccb ;};_cg ++;_aca =0;};};};if (_edg &7)!=0{_aca <<=uint (8-(_edg &7));if _bc :=_fde .SetByte (_cg ,_aca );_bc !=nil {return _bc ;};};return nil ;};func (_fge *Decoder )createLittleEndianTable (_bed [][3]int )([]*code ,error ){_gba :=make ([]*code ,_dgbd +1);for _acb :=0;_acb < len (_bed );_acb ++{_cc :=_c (_bed [_acb ]);if _cc ._ec <=_aae {_fdb :=_aae -_cc ._ec ;_fggb :=_cc ._aa <<uint (_fdb );for _bec :=(1<<uint (_fdb ))-1;_bec >=0;_bec --{_gbad :=_fggb |_bec ;_gba [_gbad ]=_cc ;};}else {_daa :=_cc ._aa >>uint (_cc ._ec -_aae );if _gba [_daa ]==nil {var _dae =_c ([3]int {});_dae ._f =make ([]*code ,_fgg +1);_gba [_daa ]=_dae ;};if _cc ._ec <=_aae +_da {_af :=_aae +_da -_cc ._ec ;_bdgg :=(_cc ._aa <<uint (_af ))&_fgg ;_gba [_daa ]._ac =true ;for _eeb :=(1<<uint (_af ))-1;_eeb >=0;_eeb --{_gba [_daa ]._f [_bdgg |_eeb ]=_cc ;};}else {return nil ,_dg .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _gba ,nil ;};func (_bgg *Decoder )detectAndSkipEOL ()error {for {_dbe ,_bb :=_bgg ._gb .uncompressGetCode (_bgg ._ab );if _bb !=nil {return _bb ;};if _dbe !=nil &&_dbe ._egf ==EOL {_bgg ._gb ._aac +=_dbe ._ec ;}else {return nil ;};};};type Decoder struct{_fdc ,_de int ;_gb *runData ;_ga []*code ;_dcb []*code ;_ab []*code ;};var (_bg =[][3]int {{4,0x1,int (_bd )},{3,0x1,int (_fa )},{1,0x1,int (_fg )},{3,0x3,int (_gf )},{6,0x3,int (_ef )},{7,0x3,int (_cf )},{3,0x2,int (_ba )},{6,0x2,int (_bdg )},{7,0x2,int (_bf )},{10,0xf,int (_fc )},{12,0xf,int (_ea )},{12,0x1,int (EOL )}};_ce =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_dd },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_dd },{11,0x01,_dd },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};_baf =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_dd },{9,0x18,15},{10,0x01,_dd },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_dd },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};);func _gdc (_b ,_dgb int )int {if _b > _dgb {return _dgb ;};return _b ;};type code struct{_ec int ;_aa int ;_egf int ;_f []*code ;_ac bool ;};func (_eda *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_ffgc :=_eda ._aac -_eda ._cag ;if _ffgc < 0||_ffgc > 24{_ece :=(_eda ._aac >>3)-_eda ._agd ;if _ece >=_eda ._aaf {_ece +=_eda ._agd ;if _ffdf :=_eda .fillBuffer (_ece );_ffdf !=nil {return 0,_ffdf ;};_ece -=_eda ._agd ;};_dgc :=(uint32 (_eda ._dee [_ece ]&0xFF)<<16)|(uint32 (_eda ._dee [_ece +1]&0xFF)<<8)|(uint32 (_eda ._dee [_ece +2]&0xFF));_cgec :=uint32 (_eda ._aac &7);_dgc <<=_cgec ;_eda ._gac =int (_dgc );}else {_gab :=_eda ._cag &7;_ggge :=7-_gab ;if _ffgc <=_ggge {_eda ._gac <<=uint (_ffgc );}else {_eaa :=(_eda ._cag >>3)+3-_eda ._agd ;if _eaa >=_eda ._aaf {_eaa +=_eda ._agd ;if _cdd :=_eda .fillBuffer (_eaa );_cdd !=nil {return 0,_cdd ;};_eaa -=_eda ._agd ;};_gab =8-_gab ;for {_eda ._gac <<=uint (_gab );_eda ._gac |=int (uint (_eda ._dee [_eaa ])&0xFF);_ffgc -=_gab ;_eaa ++;_gab =8;if !(_ffgc >=8){break ;};};_eda ._gac <<=uint (_ffgc );};};_eda ._cag =_eda ._aac ;return _eda ._gac ,nil ;};const (_cbg int =1024<<7;_ffd int =3;_fgc uint =24;);func (_dcd *code )String ()string {return _d .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_dcd ._ec ,_dcd ._aa ,_dcd ._egf );};const (_bd mmrCode =iota ;_fa ;_fg ;_gf ;_ef ;_cf ;_ba ;_bdg ;_bf ;_fc ;_ea ;);const (EOF =-3;_dd =-2;EOL =-1;_aae =8;_dgbd =(1<<_aae )-1;_da =5;_fgg =(1<<_da )-1;);func New (r _g .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_ddg :=&Decoder {_fdc :width ,_de :height };_df ,_fdd :=_g .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _fdd !=nil {return nil ,_fdd ;};_gad ,_fdd :=_cecg (_df );if _fdd !=nil {return nil ,_fdd ;};_ddg ._gb =_gad ;if _dcdf :=_ddg .initTables ();_dcdf !=nil {return nil ,_dcdf ;};return _ddg ,nil ;};func (_bab *Decoder )uncompress1d (_ge *runData ,_afe []int ,_beed int )(int ,error ){var (_bfg =true ;_bbf int ;_ccf *code ;_bge int ;_ccd error ;);_gfb :for _bbf < _beed {_bgd :for {if _bfg {_ccf ,_ccd =_ge .uncompressGetCode (_bab ._ga );if _ccd !=nil {return 0,_ccd ;};}else {_ccf ,_ccd =_ge .uncompressGetCode (_bab ._dcb );if _ccd !=nil {return 0,_ccd ;};};_ge ._aac +=_ccf ._ec ;if _ccf ._egf < 0{break _gfb ;};_bbf +=_ccf ._egf ;if _ccf ._egf < 64{_bfg =!_bfg ;_afe [_bge ]=_bbf ;_bge ++;break _bgd ;};};};if _afe [_bge ]!=_beed {_afe [_bge ]=_beed ;};_cd :=EOL ;if _ccf !=nil &&_ccf ._egf !=EOL {_cd =_bge ;};return _cd ,nil ;};type runData struct{_bga *_g .SubstreamReader ;_aac int ;_cag int ;_gac int ;_dee []byte ;_agd int ;_aaf int ;};func _fd (_gd ,_ae int )int {if _gd < _ae {return _ae ;};return _gd ;};func (_cfc *runData )uncompressGetCodeLittleEndian (_egg []*code )(*code ,error ){_gcb ,_fef :=_cfc .uncompressGetNextCodeLittleEndian ();if _fef !=nil {_a .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_fef );return nil ,_fef ;};_gcb &=0xffffff;_ccg :=_gcb >>(_fgc -_aae );_bgc :=_egg [_ccg ];if _bgc !=nil &&_bgc ._ac {_ccg =(_gcb >>(_fgc -_aae -_da ))&_fgg ;_bgc =_bgc ._f [_ccg ];};return _bgc ,nil ;};func _c (_ca [3]int )*code {return &code {_ec :_ca [0],_aa :_ca [1],_egf :_ca [2]}};func (_ff *Decoder )UncompressMMR ()(_be *_dc .Bitmap ,_ed error ){_be =_dc .New (_ff ._fdc ,_ff ._de );_ddgb :=make ([]int ,_be .Width +5);_ee :=make ([]int ,_be .Width +5);_ee [0]=_be .Width ;_db :=1;var _ecg int ;for _ffg :=0;_ffg < _be .Height ;_ffg ++{_ecg ,_ed =_ff .uncompress2d (_ff ._gb ,_ee ,_db ,_ddgb ,_be .Width );if _ed !=nil {return nil ,_ed ;};if _ecg ==EOF {break ;};if _ecg > 0{_ed =_ff .fillBitmap (_be ,_ffg ,_ddgb ,_ecg );if _ed !=nil {return nil ,_ed ;};};_ee ,_ddgb =_ddgb ,_ee ;_db =_ecg ;};if _ed =_ff .detectAndSkipEOL ();_ed !=nil {return nil ,_ed ;};_ff ._gb .align ();return _be ,nil ;};func (_bdb *runData )fillBuffer (_dcbf int )error {_bdb ._agd =_dcbf ;_ ,_bac :=_bdb ._bga .Seek (int64 (_dcbf ),_eg .SeekStart );if _bac !=nil {if _bac ==_eg .EOF {_a .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_bdb ._aaf =-1;}else {return _bac ;};};if _bac ==nil {_bdb ._aaf ,_bac =_bdb ._bga .Read (_bdb ._dee );if _bac !=nil {if _bac ==_eg .EOF {_a .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_bdb ._aaf =-1;}else {return _bac ;};};};if _bdb ._aaf > -1&&_bdb ._aaf < 3{for _bdb ._aaf < 3{_fga ,_edd :=_bdb ._bga .ReadByte ();if _edd !=nil {if _edd ==_eg .EOF {_bdb ._dee [_bdb ._aaf ]=0;}else {return _edd ;};}else {_bdb ._dee [_bdb ._aaf ]=_fga &0xFF;};_bdb ._aaf ++;};};_bdb ._aaf -=3;if _bdb ._aaf < 0{_bdb ._dee =make ([]byte ,len (_bdb ._dee ));_bdb ._aaf =len (_bdb ._dee )-3;};return nil ;};func (_fe *Decoder )initTables ()(_bda error ){if _fe ._ga ==nil {_fe ._ga ,_bda =_fe .createLittleEndianTable (_ce );if _bda !=nil {return ;};_fe ._dcb ,_bda =_fe .createLittleEndianTable (_baf );if _bda !=nil {return ;};_fe ._ab ,_bda =_fe .createLittleEndianTable (_bg );if _bda !=nil {return ;};};return nil ;};func (_bfb *Decoder )uncompress2d (_ced *runData ,_ggg []int ,_bbc int ,_cec []int ,_gdb int )(int ,error ){var (_ag int ;_gbc int ;_dga int ;_cb =true ;_efa error ;_bgf *code ;);_ggg [_bbc ]=_gdb ;_ggg [_bbc +1]=_gdb ;_ggg [_bbc +2]=_gdb +1;_ggg [_bbc +3]=_gdb +1;_bef :for _dga < _gdb {_bgf ,_efa =_ced .uncompressGetCode (_bfb ._ab );if _efa !=nil {return EOL ,nil ;};if _bgf ==nil {_ced ._aac ++;break _bef ;};_ced ._aac +=_bgf ._ec ;switch mmrCode (_bgf ._egf ){case _fg :_dga =_ggg [_ag ];case _gf :_dga =_ggg [_ag ]+1;case _ba :_dga =_ggg [_ag ]-1;case _fa :for {var _dea []*code ;if _cb {_dea =_bfb ._ga ;}else {_dea =_bfb ._dcb ;};_bgf ,_efa =_ced .uncompressGetCode (_dea );if _efa !=nil {return 0,_efa ;};if _bgf ==nil {break _bef ;};_ced ._aac +=_bgf ._ec ;if _bgf ._egf < 64{if _bgf ._egf < 0{_cec [_gbc ]=_dga ;_gbc ++;_bgf =nil ;break _bef ;};_dga +=_bgf ._egf ;_cec [_gbc ]=_dga ;_gbc ++;break ;};_dga +=_bgf ._egf ;};_cac :=_dga ;_ecb :for {var _eb []*code ;if !_cb {_eb =_bfb ._ga ;}else {_eb =_bfb ._dcb ;};_bgf ,_efa =_ced .uncompressGetCode (_eb );if _efa !=nil {return 0,_efa ;};if _bgf ==nil {break _bef ;};_ced ._aac +=_bgf ._ec ;if _bgf ._egf < 64{if _bgf ._egf < 0{_cec [_gbc ]=_dga ;_gbc ++;break _bef ;};_dga +=_bgf ._egf ;if _dga < _gdb ||_dga !=_cac {_cec [_gbc ]=_dga ;_gbc ++;};break _ecb ;};_dga +=_bgf ._egf ;};for _dga < _gdb &&_ggg [_ag ]<=_dga {_ag +=2;};continue _bef ;case _bd :_ag ++;_dga =_ggg [_ag ];_ag ++;continue _bef ;case _ef :_dga =_ggg [_ag ]+2;case _bdg :_dga =_ggg [_ag ]-2;case _cf :_dga =_ggg [_ag ]+3;case _bf :_dga =_ggg [_ag ]-3;default:if _ced ._aac ==12&&_bgf ._egf ==EOL {_ced ._aac =0;if _ ,_efa =_bfb .uncompress1d (_ced ,_ggg ,_gdb );_efa !=nil {return 0,_efa ;};_ced ._aac ++;if _ ,_efa =_bfb .uncompress1d (_ced ,_cec ,_gdb );_efa !=nil {return 0,_efa ;};_gdd ,_ege :=_bfb .uncompress1d (_ced ,_ggg ,_gdb );if _ege !=nil {return EOF ,_ege ;};_ced ._aac ++;return _gdd ,nil ;};_dga =_gdb ;continue _bef ;};if _dga <=_gdb {_cb =!_cb ;_cec [_gbc ]=_dga ;_gbc ++;if _ag > 0{_ag --;}else {_ag ++;};for _dga < _gdb &&_ggg [_ag ]<=_dga {_ag +=2;};};};if _cec [_gbc ]!=_gdb {_cec [_gbc ]=_gdb ;};if _bgf ==nil {return EOL ,nil ;};return _gbc ,nil ;};func _cecg (_fag *_g .SubstreamReader )(*runData ,error ){_edb :=&runData {_bga :_fag ,_aac :0,_cag :1};_fgeb :=_gdc (_fd (_ffd ,int (_fag .Length ())),_cbg );_edb ._dee =make ([]byte ,_fgeb );if _ccc :=_edb .fillBuffer (0);_ccc !=nil {if _ccc ==_eg .EOF {_edb ._dee =make ([]byte ,10);_a .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_ccc );}else {return nil ,_ccc ;};};return _edb ,nil ;};func (_eca *runData )align (){_eca ._aac =((_eca ._aac +7)>>3)<<3};func (_gggd *runData )uncompressGetCode (_cgb []*code )(*code ,error ){return _gggd .uncompressGetCodeLittleEndian (_cgb );};