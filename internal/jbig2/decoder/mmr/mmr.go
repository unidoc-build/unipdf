//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_c "errors";_e "fmt";_dg "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_eb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_f "io";);func _da (_a [3]int )*code {return &code {_g :_a [0],_dc :_a [1],_ce :_a [2]}};
var (_bf =[][3]int {{4,0x1,int (_ef )},{3,0x1,int (_dad )},{1,0x1,int (_ae )},{3,0x3,int (_fa )},{6,0x3,int (_ge )},{7,0x3,int (_fc )},{3,0x2,int (_ebg )},{6,0x2,int (_db )},{7,0x2,int (_de )},{10,0xf,int (_cc )},{12,0xf,int (_dbg )},{12,0x1,int (EOL )}};
_bdf =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_ed },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_ed },{11,0x01,_ed },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_ceg =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_ed },{9,0x18,15},{10,0x01,_ed },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_ed },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func _bc (_cf ,_dgb int )int {if _cf < _dgb {return _dgb ;};return _cf ;};func (_bg *Decoder )detectAndSkipEOL ()error {for {_aa ,_egf :=_bg ._fd .uncompressGetCode (_bg ._fe );if _egf !=nil {return _egf ;};if _aa !=nil &&_aa ._ce ==EOL {_bg ._fd ._aba +=_aa ._g ;
}else {return nil ;};};};func _bfd (_aca *_b .SubstreamReader )(*runData ,error ){_dbe :=&runData {_ecf :_aca ,_aba :0,_ecba :1};_bca :=_cff (_bc (_caf ,int (_aca .Length ())),_ace );_dbe ._bgf =make ([]byte ,_bca );if _bbe :=_dbe .fillBuffer (0);_bbe !=nil {if _bbe ==_f .EOF {_dbe ._bgf =make ([]byte ,10);
_dg .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_bbe );}else {return nil ,_bbe ;};};return _dbe ,nil ;};const (_ace int =1024<<7;_caf int =3;_cd uint =24;);func (_cfc *runData )align (){_cfc ._aba =((_cfc ._aba +7)>>3)<<3};
func (_eg *code )String ()string {return _e .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_eg ._g ,_eg ._dc ,_eg ._ce );};type mmrCode int ;func (_ag *Decoder )uncompress2d (_fed *runData ,_fafc []int ,_cedc int ,_dgba []int ,_ac int )(int ,error ){var (_eed int ;
_abb int ;_ddc int ;_bef =true ;_ecb error ;_ccgg *code ;);_fafc [_cedc ]=_ac ;_fafc [_cedc +1]=_ac ;_fafc [_cedc +2]=_ac +1;_fafc [_cedc +3]=_ac +1;_adc :for _ddc < _ac {_ccgg ,_ecb =_fed .uncompressGetCode (_ag ._fe );if _ecb !=nil {return EOL ,nil ;
};if _ccgg ==nil {_fed ._aba ++;break _adc ;};_fed ._aba +=_ccgg ._g ;switch mmrCode (_ccgg ._ce ){case _ae :_ddc =_fafc [_eed ];case _fa :_ddc =_fafc [_eed ]+1;case _ebg :_ddc =_fafc [_eed ]-1;case _dad :for {var _edc []*code ;if _bef {_edc =_ag ._ff ;
}else {_edc =_ag ._ea ;};_ccgg ,_ecb =_fed .uncompressGetCode (_edc );if _ecb !=nil {return 0,_ecb ;};if _ccgg ==nil {break _adc ;};_fed ._aba +=_ccgg ._g ;if _ccgg ._ce < 64{if _ccgg ._ce < 0{_dgba [_abb ]=_ddc ;_abb ++;_ccgg =nil ;break _adc ;};_ddc +=_ccgg ._ce ;
_dgba [_abb ]=_ddc ;_abb ++;break ;};_ddc +=_ccgg ._ce ;};_aeca :=_ddc ;_aaad :for {var _aaaa []*code ;if !_bef {_aaaa =_ag ._ff ;}else {_aaaa =_ag ._ea ;};_ccgg ,_ecb =_fed .uncompressGetCode (_aaaa );if _ecb !=nil {return 0,_ecb ;};if _ccgg ==nil {break _adc ;
};_fed ._aba +=_ccgg ._g ;if _ccgg ._ce < 64{if _ccgg ._ce < 0{_dgba [_abb ]=_ddc ;_abb ++;break _adc ;};_ddc +=_ccgg ._ce ;if _ddc < _ac ||_ddc !=_aeca {_dgba [_abb ]=_ddc ;_abb ++;};break _aaad ;};_ddc +=_ccgg ._ce ;};for _ddc < _ac &&_fafc [_eed ]<=_ddc {_eed +=2;
};continue _adc ;case _ef :_eed ++;_ddc =_fafc [_eed ];_eed ++;continue _adc ;case _ge :_ddc =_fafc [_eed ]+2;case _db :_ddc =_fafc [_eed ]-2;case _fc :_ddc =_fafc [_eed ]+3;case _de :_ddc =_fafc [_eed ]-3;default:if _fed ._aba ==12&&_ccgg ._ce ==EOL {_fed ._aba =0;
if _ ,_ecb =_ag .uncompress1d (_fed ,_fafc ,_ac );_ecb !=nil {return 0,_ecb ;};_fed ._aba ++;if _ ,_ecb =_ag .uncompress1d (_fed ,_dgba ,_ac );_ecb !=nil {return 0,_ecb ;};_dec ,_ddb :=_ag .uncompress1d (_fed ,_fafc ,_ac );if _ddb !=nil {return EOF ,_ddb ;
};_fed ._aba ++;return _dec ,nil ;};_ddc =_ac ;continue _adc ;};if _ddc <=_ac {_bef =!_bef ;_dgba [_abb ]=_ddc ;_abb ++;if _eed > 0{_eed --;}else {_eed ++;};for _ddc < _ac &&_fafc [_eed ]<=_ddc {_eed +=2;};};};if _dgba [_abb ]!=_ac {_dgba [_abb ]=_ac ;
};if _ccgg ==nil {return EOL ,nil ;};return _abb ,nil ;};func (_efd *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_edcb :=_efd ._aba -_efd ._ecba ;if _edcb < 0||_edcb > 24{_gaaa :=(_efd ._aba >>3)-_efd ._afc ;if _gaaa >=_efd ._bbb {_gaaa +=_efd ._afc ;
if _fbb :=_efd .fillBuffer (_gaaa );_fbb !=nil {return 0,_fbb ;};_gaaa -=_efd ._afc ;};_fcf :=(uint32 (_efd ._bgf [_gaaa ]&0xFF)<<16)|(uint32 (_efd ._bgf [_gaaa +1]&0xFF)<<8)|(uint32 (_efd ._bgf [_gaaa +2]&0xFF));_aae :=uint32 (_efd ._aba &7);_fcf <<=_aae ;
_efd ._ded =int (_fcf );}else {_adcc :=_efd ._ecba &7;_afa :=7-_adcc ;if _edcb <=_afa {_efd ._ded <<=uint (_edcb );}else {_gedd :=(_efd ._ecba >>3)+3-_efd ._afc ;if _gedd >=_efd ._bbb {_gedd +=_efd ._afc ;if _dcb :=_efd .fillBuffer (_gedd );_dcb !=nil {return 0,_dcb ;
};_gedd -=_efd ._afc ;};_adcc =8-_adcc ;for {_efd ._ded <<=uint (_adcc );_efd ._ded |=int (uint (_efd ._bgf [_gedd ])&0xFF);_edcb -=_adcc ;_gedd ++;_adcc =8;if !(_edcb >=8){break ;};};_efd ._ded <<=uint (_edcb );};};_efd ._ecba =_efd ._aba ;return _efd ._ded ,nil ;
};type code struct{_g int ;_dc int ;_ce int ;_ga []*code ;_cg bool ;};type runData struct{_ecf *_b .SubstreamReader ;_aba int ;_ecba int ;_ded int ;_bgf []byte ;_afc int ;_bbb int ;};func (_gd *runData )uncompressGetCodeLittleEndian (_fegf []*code )(*code ,error ){_feag ,_fgb :=_gd .uncompressGetNextCodeLittleEndian ();
if _fgb !=nil {_dg .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_fgb );
return nil ,_fgb ;};_feag &=0xffffff;_dabd :=_feag >>(_cd -_efc );_eec :=_fegf [_dabd ];if _eec !=nil &&_eec ._cg {_dabd =(_feag >>(_cd -_efc -_efb ))&_ad ;_eec =_eec ._ga [_dabd ];};return _eec ,nil ;};func _cff (_gf ,_ec int )int {if _gf > _ec {return _ec ;
};return _gf ;};func (_cffg *Decoder )initTables ()(_dca error ){if _cffg ._ff ==nil {_cffg ._ff ,_dca =_cffg .createLittleEndianTable (_bdf );if _dca !=nil {return ;};_cffg ._ea ,_dca =_cffg .createLittleEndianTable (_ceg );if _dca !=nil {return ;};_cffg ._fe ,_dca =_cffg .createLittleEndianTable (_bf );
if _dca !=nil {return ;};};return nil ;};func (_bcb *Decoder )uncompress1d (_af *runData ,_dage []int ,_eee int )(int ,error ){var (_faa =true ;_cedf int ;_efgf *code ;_aab int ;_aabe error ;);_aaa :for _cedf < _eee {_gcc :for {if _faa {_efgf ,_aabe =_af .uncompressGetCode (_bcb ._ff );
if _aabe !=nil {return 0,_aabe ;};}else {_efgf ,_aabe =_af .uncompressGetCode (_bcb ._ea );if _aabe !=nil {return 0,_aabe ;};};_af ._aba +=_efgf ._g ;if _efgf ._ce < 0{break _aaa ;};_cedf +=_efgf ._ce ;if _efgf ._ce < 64{_faa =!_faa ;_dage [_aab ]=_cedf ;
_aab ++;break _gcc ;};};};if _dage [_aab ]!=_eee {_dage [_aab ]=_eee ;};_afg :=EOL ;if _efgf !=nil &&_efgf ._ce !=EOL {_afg =_aab ;};return _afg ,nil ;};const (EOF =-3;_ed =-2;EOL =-1;_efc =8;_bd =(1<<_efc )-1;_efb =5;_ad =(1<<_efb )-1;);type Decoder struct{_df ,_ced int ;
_fd *runData ;_ff []*code ;_ea []*code ;_fe []*code ;};func (_age *runData )uncompressGetCode (_ged []*code )(*code ,error ){return _age .uncompressGetCodeLittleEndian (_ged );};const (_ef mmrCode =iota ;_dad ;_ae ;_fa ;_ge ;_fc ;_ebg ;_db ;_de ;_cc ;_dbg ;
);func (_fca *Decoder )UncompressMMR ()(_be *_eb .Bitmap ,_bb error ){_be =_eb .New (_fca ._df ,_fca ._ced );_bcf :=make ([]int ,_be .Width +5);_dd :=make ([]int ,_be .Width +5);_dd [0]=_be .Width ;_fb :=1;var _dag int ;for _cb :=0;_cb < _be .Height ;_cb ++{_dag ,_bb =_fca .uncompress2d (_fca ._fd ,_dd ,_fb ,_bcf ,_be .Width );
if _bb !=nil {return nil ,_bb ;};if _dag ==EOF {break ;};if _dag > 0{_bb =_fca .fillBitmap (_be ,_cb ,_bcf ,_dag );if _bb !=nil {return nil ,_bb ;};};_dd ,_bcf =_bcf ,_dd ;_fb =_dag ;};if _bb =_fca .detectAndSkipEOL ();_bb !=nil {return nil ,_bb ;};_fca ._fd .align ();
return _be ,nil ;};func (_bbg *Decoder )createLittleEndianTable (_bdff [][3]int )([]*code ,error ){_fea :=make ([]*code ,_bd +1);for _dab :=0;_dab < len (_bdff );_dab ++{_fcd :=_da (_bdff [_dab ]);if _fcd ._g <=_efc {_efg :=_efc -_fcd ._g ;_dadg :=_fcd ._dc <<uint (_efg );
for _eaa :=(1<<uint (_efg ))-1;_eaa >=0;_eaa --{_ccg :=_dadg |_eaa ;_fea [_ccg ]=_fcd ;};}else {_gea :=_fcd ._dc >>uint (_fcd ._g -_efc );if _fea [_gea ]==nil {var _efe =_da ([3]int {});_efe ._ga =make ([]*code ,_ad +1);_fea [_gea ]=_efe ;};if _fcd ._g <=_efc +_efb {_gc :=_efc +_efb -_fcd ._g ;
_cfa :=(_fcd ._dc <<uint (_gc ))&_ad ;_fea [_gea ]._cg =true ;for _faf :=(1<<uint (_gc ))-1;_faf >=0;_faf --{_fea [_gea ]._ga [_cfa |_faf ]=_fcd ;};}else {return nil ,_c .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _fea ,nil ;};func (_ccf *runData )fillBuffer (_eaac int )error {_ccf ._afc =_eaac ;_ ,_gb :=_ccf ._ecf .Seek (int64 (_eaac ),_f .SeekStart );if _gb !=nil {if _gb ==_f .EOF {_dg .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_ccf ._bbb =-1;}else {return _gb ;};};if _gb ==nil {_ccf ._bbb ,_gb =_ccf ._ecf .Read (_ccf ._bgf );if _gb !=nil {if _gb ==_f .EOF {_dg .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_ccf ._bbb =-1;}else {return _gb ;};};};if _ccf ._bbb > -1&&_ccf ._bbb < 3{for _ccf ._bbb < 3{_ecd ,_bgc :=_ccf ._ecf .ReadByte ();
if _bgc !=nil {if _bgc ==_f .EOF {_ccf ._bgf [_ccf ._bbb ]=0;}else {return _bgc ;};}else {_ccf ._bgf [_ccf ._bbb ]=_ecd &0xFF;};_ccf ._bbb ++;};};_ccf ._bbb -=3;if _ccf ._bbb < 0{_ccf ._bgf =make ([]byte ,len (_ccf ._bgf ));_ccf ._bbb =len (_ccf ._bgf )-3;
};return nil ;};func (_dfe *Decoder )fillBitmap (_gag *_eb .Bitmap ,_ee int ,_dcd []int ,_fce int )error {var _dce byte ;_ca :=0;_gaa :=_gag .GetByteIndex (_ca ,_ee );for _fg :=0;_fg < _fce ;_fg ++{_dfb :=byte (1);_aec :=_dcd [_fg ];if (_fg &1)==0{_dfb =0;
};for _ca < _aec {_dce =(_dce <<1)|_dfb ;_ca ++;if (_ca &7)==0{if _bed :=_gag .SetByte (_gaa ,_dce );_bed !=nil {return _bed ;};_gaa ++;_dce =0;};};};if (_ca &7)!=0{_dce <<=uint (8-(_ca &7));if _efgg :=_gag .SetByte (_gaa ,_dce );_efgg !=nil {return _efgg ;
};};return nil ;};func New (r _b .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_fae :=&Decoder {_df :width ,_ced :height };_ebf ,_feg :=_b .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _feg !=nil {return nil ,_feg ;
};_fcg ,_feg :=_bfd (_ebf );if _feg !=nil {return nil ,_feg ;};_fae ._fd =_fcg ;if _ab :=_fae .initTables ();_ab !=nil {return nil ,_ab ;};return _fae ,nil ;};