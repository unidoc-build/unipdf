//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_bd "errors";_e "fmt";_cg "github.com/unidoc/unipdf/v3/common";_d "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_b "io";);func (_dbe *Decoder )UncompressMMR ()(_bce *_f .Bitmap ,_cfc error ){_bce =_f .New (_dbe ._dbf ,_dbe ._cd );_ef :=make ([]int ,_bce .Width +5);_ced :=make ([]int ,_bce .Width +5);_ced [0]=_bce .Width ;_dab :=1;var _daa int ;for _bf :=0;_bf < _bce .Height ;_bf ++{_daa ,_cfc =_dbe .uncompress2d (_dbe ._bg ,_ced ,_dab ,_ef ,_bce .Width );if _cfc !=nil {return nil ,_cfc ;};if _daa ==EOF {break ;};if _daa > 0{_cfc =_dbe .fillBitmap (_bce ,_bf ,_ef ,_daa );if _cfc !=nil {return nil ,_cfc ;};};_ced ,_ef =_ef ,_ced ;_dab =_daa ;};if _cfc =_dbe .detectAndSkipEOL ();_cfc !=nil {return nil ,_cfc ;};_dbe ._bg .align ();return _bce ,nil ;};func (_fec *Decoder )initTables ()(_eca error ){if _fec ._fad ==nil {_fec ._fad ,_eca =_fec .createLittleEndianTable (_ag );if _eca !=nil {return ;};_fec ._ca ,_eca =_fec .createLittleEndianTable (_deg );if _eca !=nil {return ;};_fec ._bgd ,_eca =_fec .createLittleEndianTable (_cfb );if _eca !=nil {return ;};};return nil ;};type code struct{_ee int ;_db int ;_cf int ;_fa []*code ;_ea bool ;};func (_cb *Decoder )createLittleEndianTable (_afa [][3]int )([]*code ,error ){_gaa :=make ([]*code ,_acf +1);for _fb :=0;_fb < len (_afa );_fb ++{_ec :=_g (_afa [_fb ]);if _ec ._ee <=_dd {_bgf :=_dd -_ec ._ee ;_cgc :=_ec ._db <<uint (_bgf );for _faf :=(1<<uint (_bgf ))-1;_faf >=0;_faf --{_gf :=_cgc |_faf ;_gaa [_gf ]=_ec ;};}else {_bbc :=_ec ._db >>uint (_ec ._ee -_dd );if _gaa [_bbc ]==nil {var _bfd =_g ([3]int {});_bfd ._fa =make ([]*code ,_ga +1);_gaa [_bbc ]=_bfd ;};if _ec ._ee <=_dd +_ab {_ceaf :=_dd +_ab -_ec ._ee ;_fe :=(_ec ._db <<uint (_ceaf ))&_ga ;_gaa [_bbc ]._ea =true ;for _cbb :=(1<<uint (_ceaf ))-1;_cbb >=0;_cbb --{_gaa [_bbc ]._fa [_fe |_cbb ]=_ec ;};}else {return nil ,_bd .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _gaa ,nil ;};func (_def *Decoder )uncompress2d (_gcb *runData ,_feg []int ,_cfef int ,_bda []int ,_bfb int )(int ,error ){var (_fab int ;_dad int ;_cbca int ;_dcc =true ;_egbg error ;_efe *code ;);_feg [_cfef ]=_bfb ;_feg [_cfef +1]=_bfb ;_feg [_cfef +2]=_bfb +1;_feg [_cfef +3]=_bfb +1;_fecg :for _cbca < _bfb {_efe ,_egbg =_gcb .uncompressGetCode (_def ._bgd );if _egbg !=nil {return EOL ,nil ;};if _efe ==nil {_gcb ._dce ++;break _fecg ;};_gcb ._dce +=_efe ._ee ;switch mmrCode (_efe ._cf ){case _dg :_cbca =_feg [_fab ];case _cea :_cbca =_feg [_fab ]+1;case _da :_cbca =_feg [_fab ]-1;case _bde :for {var _bddd []*code ;if _dcc {_bddd =_def ._fad ;}else {_bddd =_def ._ca ;};_efe ,_egbg =_gcb .uncompressGetCode (_bddd );if _egbg !=nil {return 0,_egbg ;};if _efe ==nil {break _fecg ;};_gcb ._dce +=_efe ._ee ;if _efe ._cf < 64{if _efe ._cf < 0{_bda [_dad ]=_cbca ;_dad ++;_efe =nil ;break _fecg ;};_cbca +=_efe ._cf ;_bda [_dad ]=_cbca ;_dad ++;break ;};_cbca +=_efe ._cf ;};_egg :=_cbca ;_acg :for {var _afg []*code ;if !_dcc {_afg =_def ._fad ;}else {_afg =_def ._ca ;};_efe ,_egbg =_gcb .uncompressGetCode (_afg );if _egbg !=nil {return 0,_egbg ;};if _efe ==nil {break _fecg ;};_gcb ._dce +=_efe ._ee ;if _efe ._cf < 64{if _efe ._cf < 0{_bda [_dad ]=_cbca ;_dad ++;break _fecg ;};_cbca +=_efe ._cf ;if _cbca < _bfb ||_cbca !=_egg {_bda [_dad ]=_cbca ;_dad ++;};break _acg ;};_cbca +=_efe ._cf ;};for _cbca < _bfb &&_feg [_fab ]<=_cbca {_fab +=2;};continue _fecg ;case _af :_fab ++;_cbca =_feg [_fab ];_fab ++;continue _fecg ;case _ffa :_cbca =_feg [_fab ]+2;case _bdd :_cbca =_feg [_fab ]-2;case _cfd :_cbca =_feg [_fab ]+3;case _eea :_cbca =_feg [_fab ]-3;default:if _gcb ._dce ==12&&_efe ._cf ==EOL {_gcb ._dce =0;if _ ,_egbg =_def .uncompress1d (_gcb ,_feg ,_bfb );_egbg !=nil {return 0,_egbg ;};_gcb ._dce ++;if _ ,_egbg =_def .uncompress1d (_gcb ,_bda ,_bfb );_egbg !=nil {return 0,_egbg ;};_aga ,_gcg :=_def .uncompress1d (_gcb ,_feg ,_bfb );if _gcg !=nil {return EOF ,_gcg ;};_gcb ._dce ++;return _aga ,nil ;};_cbca =_bfb ;continue _fecg ;};if _cbca <=_bfb {_dcc =!_dcc ;_bda [_dad ]=_cbca ;_dad ++;if _fab > 0{_fab --;}else {_fab ++;};for _cbca < _bfb &&_feg [_fab ]<=_cbca {_fab +=2;};};};if _bda [_dad ]!=_bfb {_bda [_dad ]=_bfb ;};if _efe ==nil {return EOL ,nil ;};return _dad ,nil ;};type runData struct{_gda *_d .SubstreamReader ;_dce int ;_ace int ;_ecb int ;_cgcc []byte ;_be int ;_efeg int ;};var (_cfb =[][3]int {{4,0x1,int (_af )},{3,0x1,int (_bde )},{1,0x1,int (_dg )},{3,0x3,int (_cea )},{6,0x3,int (_ffa )},{7,0x3,int (_cfd )},{3,0x2,int (_da )},{6,0x2,int (_bdd )},{7,0x2,int (_eea )},{10,0xf,int (_gb )},{12,0xf,int (_de )},{12,0x1,int (EOL )}};_ag =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_ac },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_ac },{11,0x01,_ac },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};_deg =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_ac },{9,0x18,15},{10,0x01,_ac },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_ac },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};);const (EOF =-3;_ac =-2;EOL =-1;_dd =8;_acf =(1<<_dd )-1;_ab =5;_ga =(1<<_ab )-1;);func (_eac *code )String ()string {return _e .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_eac ._ee ,_eac ._db ,_eac ._cf );};const (_af mmrCode =iota ;_bde ;_dg ;_cea ;_ffa ;_cfd ;_da ;_bdd ;_eea ;_gb ;_de ;);func _g (_dbb [3]int )*code {return &code {_ee :_dbb [0],_db :_dbb [1],_cf :_dbb [2]}};func (_fca *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_ega :=_fca ._dce -_fca ._ace ;if _ega < 0||_ega > 24{_gdc :=(_fca ._dce >>3)-_fca ._be ;if _gdc >=_fca ._efeg {_gdc +=_fca ._be ;if _aa :=_fca .fillBuffer (_gdc );_aa !=nil {return 0,_aa ;};_gdc -=_fca ._be ;};_cdg :=(uint32 (_fca ._cgcc [_gdc ]&0xFF)<<16)|(uint32 (_fca ._cgcc [_gdc +1]&0xFF)<<8)|(uint32 (_fca ._cgcc [_gdc +2]&0xFF));_fda :=uint32 (_fca ._dce &7);_cdg <<=_fda ;_fca ._ecb =int (_cdg );}else {_aea :=_fca ._ace &7;_dfd :=7-_aea ;if _ega <=_dfd {_fca ._ecb <<=uint (_ega );}else {_egad :=(_fca ._ace >>3)+3-_fca ._be ;if _egad >=_fca ._efeg {_egad +=_fca ._be ;if _bbb :=_fca .fillBuffer (_egad );_bbb !=nil {return 0,_bbb ;};_egad -=_fca ._be ;};_aea =8-_aea ;for {_fca ._ecb <<=uint (_aea );_fca ._ecb |=int (uint (_fca ._cgcc [_egad ])&0xFF);_ega -=_aea ;_egad ++;_aea =8;if !(_ega >=8){break ;};};_fca ._ecb <<=uint (_ega );};};_fca ._ace =_fca ._dce ;return _fca ._ecb ,nil ;};func (_ddd *runData )align (){_ddd ._dce =((_ddd ._dce +7)>>3)<<3};type mmrCode int ;func New (r _d .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_aca :=&Decoder {_dbf :width ,_cd :height };_agb ,_bc :=_d .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _bc !=nil {return nil ,_bc ;};_gc ,_bc :=_afc (_agb );if _bc !=nil {return nil ,_bc ;};_aca ._bg =_gc ;if _bb :=_aca .initTables ();_bb !=nil {return nil ,_bb ;};return _aca ,nil ;};type Decoder struct{_dbf ,_cd int ;_bg *runData ;_fad []*code ;_ca []*code ;_bgd []*code ;};func _afc (_daf *_d .SubstreamReader )(*runData ,error ){_dcg :=&runData {_gda :_daf ,_dce :0,_ace :1};_baaa :=_dfa (_ce (_bfbg ,int (_daf .Length ())),_gfg );_dcg ._cgcc =make ([]byte ,_baaa );if _abb :=_dcg .fillBuffer (0);_abb !=nil {if _abb ==_b .EOF {_dcg ._cgcc =make ([]byte ,10);_cg .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_abb );}else {return nil ,_abb ;};};return _dcg ,nil ;};func (_cbc *Decoder )detectAndSkipEOL ()error {for {_eg ,_dgb :=_cbc ._bg .uncompressGetCode (_cbc ._bgd );if _dgb !=nil {return _dgb ;};if _eg !=nil &&_eg ._cf ==EOL {_cbc ._bg ._dce +=_eg ._ee ;}else {return nil ;};};};func (_bfbf *runData )uncompressGetCode (_ebd []*code )(*code ,error ){return _bfbf .uncompressGetCodeLittleEndian (_ebd );};const (_gfg int =1024<<7;_bfbg int =3;_eb uint =24;);func (_fc *Decoder )uncompress1d (_bab *runData ,_abf []int ,_gg int )(int ,error ){var (_cfe =true ;_dae int ;_faff *code ;_agbb int ;_aee error ;);_gd :for _dae < _gg {_ecg :for {if _cfe {_faff ,_aee =_bab .uncompressGetCode (_fc ._fad );if _aee !=nil {return 0,_aee ;};}else {_faff ,_aee =_bab .uncompressGetCode (_fc ._ca );if _aee !=nil {return 0,_aee ;};};_bab ._dce +=_faff ._ee ;if _faff ._cf < 0{break _gd ;};_dae +=_faff ._cf ;if _faff ._cf < 64{_cfe =!_cfe ;_abf [_agbb ]=_dae ;_agbb ++;break _ecg ;};};};if _abf [_agbb ]!=_gg {_abf [_agbb ]=_gg ;};_bdea :=EOL ;if _faff !=nil &&_faff ._cf !=EOL {_bdea =_agbb ;};return _bdea ,nil ;};func _dfa (_ba ,_ff int )int {if _ba > _ff {return _ff ;};return _ba ;};func _ce (_df ,_a int )int {if _df < _a {return _a ;};return _df ;};func (_gcc *Decoder )fillBitmap (_dc *_f .Bitmap ,_aba int ,_baa []int ,_cbg int )error {var _ae byte ;_abe :=0;_egb :=_dc .GetByteIndex (_abe ,_aba );for _cgf :=0;_cgf < _cbg ;_cgf ++{_cbd :=byte (1);_fbb :=_baa [_cgf ];if (_cgf &1)==0{_cbd =0;};for _abe < _fbb {_ae =(_ae <<1)|_cbd ;_abe ++;if (_abe &7)==0{if _ed :=_dc .SetByte (_egb ,_ae );_ed !=nil {return _ed ;};_egb ++;_ae =0;};};};if (_abe &7)!=0{_ae <<=uint (8-(_abe &7));if _bbd :=_dc .SetByte (_egb ,_ae );_bbd !=nil {return _bbd ;};};return nil ;};func (_gga *runData )fillBuffer (_dda int )error {_gga ._be =_dda ;_ ,_bca :=_gga ._gda .Seek (int64 (_dda ),_b .SeekStart );if _bca !=nil {if _bca ==_b .EOF {_cg .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_gga ._efeg =-1;}else {return _bca ;};};if _bca ==nil {_gga ._efeg ,_bca =_gga ._gda .Read (_gga ._cgcc );if _bca !=nil {if _bca ==_b .EOF {_cg .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_gga ._efeg =-1;}else {return _bca ;};};};if _gga ._efeg > -1&&_gga ._efeg < 3{for _gga ._efeg < 3{_gba ,_fg :=_gga ._gda .ReadByte ();if _fg !=nil {if _fg ==_b .EOF {_gga ._cgcc [_gga ._efeg ]=0;}else {return _fg ;};}else {_gga ._cgcc [_gga ._efeg ]=_gba &0xFF;};_gga ._efeg ++;};};_gga ._efeg -=3;if _gga ._efeg < 0{_gga ._cgcc =make ([]byte ,len (_gga ._cgcc ));_gga ._efeg =len (_gga ._cgcc )-3;};return nil ;};func (_fd *runData )uncompressGetCodeLittleEndian (_ecd []*code )(*code ,error ){_gfa ,_gcd :=_fd .uncompressGetNextCodeLittleEndian ();if _gcd !=nil {_cg .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_gcd );return nil ,_gcd ;};_gfa &=0xffffff;_cgcf :=_gfa >>(_eb -_dd );_cfcd :=_ecd [_cgcf ];if _cfcd !=nil &&_cfcd ._ea {_cgcf =(_gfa >>(_eb -_dd -_ab ))&_ga ;_cfcd =_cfcd ._fa [_cgcf ];};return _cfcd ,nil ;};