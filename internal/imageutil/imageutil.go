//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_dae "encoding/binary";_d "errors";_g "fmt";_gg "github.com/unidoc/unipdf/v3/common";_ba "github.com/unidoc/unipdf/v3/internal/bitwise";_cg "image";_b "image/color";_da "image/draw";_e "math";);func (_daffe *ImageBase )setByte (_afgb int ,_beaca byte )error {if _afgb > len (_daffe .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_daffe .Data [_afgb ]=_beaca ;return nil ;};func (_bff *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_bff .copy ()}};func _bacc (_bgca NRGBA ,_egb CMYK ,_ddc _cg .Rectangle ){for _bbee :=0;_bbee < _ddc .Max .X ;_bbee ++{for _gggac :=0;_gggac < _ddc .Max .Y ;
_gggac ++{_gdf :=_bgca .NRGBAAt (_bbee ,_gggac );_egb .SetCMYK (_bbee ,_gggac ,_dga (_gdf ));};};};func (_bde *Monochrome )GrayAt (x ,y int )_b .Gray {_cga ,_ :=ColorAtGray1BPC (x ,y ,_bde .BytesPerLine ,_bde .Data ,_bde .Decode );return _cga ;};func (_dbgd *Monochrome )Set (x ,y int ,c _b .Color ){_bfa :=y *_dbgd .BytesPerLine +x >>3;
if _bfa > len (_dbgd .Data )-1{return ;};_gafg :=_dbgd .ColorModel ().Convert (c ).(_b .Gray );_dbgd .setGray (x ,_gafg ,_bfa );};func (_fged *NRGBA16 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_fged .Width ,Y :_fged .Height }};
};type ColorConverter interface{Convert (_cgff _cg .Image )(Image ,error );};func (_bcfa *ImageBase )setEightBytes (_baee int ,_ggdc uint64 )error {_gcdb :=_bcfa .BytesPerLine -(_baee %_bcfa .BytesPerLine );if _bcfa .BytesPerLine !=_bcfa .Width >>3{_gcdb --;
};if _gcdb >=8{return _bcfa .setEightFullBytes (_baee ,_ggdc );};return _bcfa .setEightPartlyBytes (_baee ,_gcdb ,_ggdc );};func _gfe (_eaeb _b .NYCbCrA )_b .NRGBA {_bcc :=int32 (_eaeb .Y )*0x10101;_ged :=int32 (_eaeb .Cb )-128;_bbfa :=int32 (_eaeb .Cr )-128;
_cbac :=_bcc +91881*_bbfa ;if uint32 (_cbac )&0xff000000==0{_cbac >>=8;}else {_cbac =^(_cbac >>31)&0xffff;};_bgcc :=_bcc -22554*_ged -46802*_bbfa ;if uint32 (_bgcc )&0xff000000==0{_bgcc >>=8;}else {_bgcc =^(_bgcc >>31)&0xffff;};_edb :=_bcc +116130*_ged ;
if uint32 (_edb )&0xff000000==0{_edb >>=8;}else {_edb =^(_edb >>31)&0xffff;};return _b .NRGBA {R :uint8 (_cbac >>8),G :uint8 (_bgcc >>8),B :uint8 (_edb >>8),A :_eaeb .A };};func (_fff *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_g .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _dgc (_fff ,factor );};func (_ebed *ImageBase )getByte (_gefa int )(byte ,error ){if _gefa > len (_ebed .Data )-1||_gefa < 0{return 0,_g .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_gefa );
};return _ebed .Data [_gefa ],nil ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_b .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_g .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_aaeb *NRGBA32 )Set (x ,y int ,c _b .Color ){_ebegg :=y *_aaeb .Width +x ;_dcfde :=3*_ebegg ;if _dcfde +2>=len (_aaeb .Data ){return ;};_efdf :=_b .NRGBAModel .Convert (c ).(_b .NRGBA );_aaeb .setRGBA (_ebegg ,_efdf );};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_dcf :=y *bytesPerLine +x >>3;
if _dcf >=len (data ){return _b .Gray {},_g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_baba :=data [_dcf ]>>uint (7-(x &7))&1;if len (decode )==2{_baba =uint8 (LinearInterpolate (float64 (_baba ),0.0,1.0,decode [0],decode [1]))&1;};return _b .Gray {Y :_baba *255},nil ;};func (_acffb *ImageBase )setEightFullBytes (_efcdg int ,_cefb uint64 )error {if _efcdg +7> len (_acffb .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_acffb .Data [_efcdg ]=byte ((_cefb &0xff00000000000000)>>56);_acffb .Data [_efcdg +1]=byte ((_cefb &0xff000000000000)>>48);_acffb .Data [_efcdg +2]=byte ((_cefb &0xff0000000000)>>40);_acffb .Data [_efcdg +3]=byte ((_cefb &0xff00000000)>>32);_acffb .Data [_efcdg +4]=byte ((_cefb &0xff000000)>>24);
_acffb .Data [_efcdg +5]=byte ((_cefb &0xff0000)>>16);_acffb .Data [_efcdg +6]=byte ((_cefb &0xff00)>>8);_acffb .Data [_efcdg +7]=byte (_cefb &0xff);return nil ;};const (_babag shift =iota ;_dggca ;);func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;
};return 1<<(_edee (n )+1);};func _bgee (_ggggb _b .Color )_b .Color {_acca :=_b .NRGBAModel .Convert (_ggggb ).(_b .NRGBA );return _debd (_acca );};func (_bfge *Monochrome )SetGray (x ,y int ,g _b .Gray ){_cef :=y *_bfge .BytesPerLine +x >>3;if _cef > len (_bfge .Data )-1{return ;
};g =_dde (g ,monochromeModel (_bfge .ModelThreshold ));_bfge .setGray (x ,g ,_cef );};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_f :=BytesPerLine (width ,8,1);if len (data )< _f *height {return nil ,nil ;};_fc :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};
_a ,_dg :=MonochromeConverter .Convert (_fc );if _dg !=nil {return nil ,_dg ;};return _a .Base ().Data ,nil ;};func (_fbfa *NRGBA32 )setRGBA (_gcabb int ,_ddba _b .NRGBA ){_ffga :=3*_gcabb ;_fbfa .Data [_ffga ]=_ddba .R ;_fbfa .Data [_ffga +1]=_ddba .G ;
_fbfa .Data [_ffga +2]=_ddba .B ;if _gcabb < len (_fbfa .Alpha ){_fbfa .Alpha [_gcabb ]=_ddba .A ;};};func (_bbfd *NRGBA32 )ColorModel ()_b .Model {return _b .NRGBAModel };func (_aec *ImageBase )setFourBytes (_dced int ,_gcba uint32 )error {if _dced +3> len (_aec .Data )-1{return _g .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_dced );
};_aec .Data [_dced ]=byte ((_gcba &0xff000000)>>24);_aec .Data [_dced +1]=byte ((_gcba &0xff0000)>>16);_aec .Data [_dced +2]=byte ((_gcba &0xff00)>>8);_aec .Data [_dced +3]=byte (_gcba &0xff);return nil ;};func (_egf *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _bffd bool ;
_gafc :=scale ;if scale < 1{_gafc =1/scale ;_bffd =true ;};_efc :=NextPowerOf2 (uint (_gafc ));if InDelta (float64 (_efc ),_gafc ,0.001){if _bffd {return _egf .ReduceBinary (_gafc );};return _egf .ExpandBinary (int (_efc ));};_facg :=int (_e .RoundToEven (float64 (_egf .Width )*scale ));
_cbbc :=int (_e .RoundToEven (float64 (_egf .Height )*scale ));return _egf .ScaleLow (_facg ,_cbbc );};func _gfa (_fgge RGBA ,_cec CMYK ,_fadd _cg .Rectangle ){for _eaa :=0;_eaa < _fadd .Max .X ;_eaa ++{for _acb :=0;_acb < _fadd .Max .Y ;_acb ++{_gde :=_fgge .RGBAAt (_eaa ,_acb );
_cec .SetCMYK (_eaa ,_acb ,_ecc (_gde ));};};};func (_afac *ImageBase )Pix ()[]byte {return _afac .Data };func _ffa (_daba ,_gea CMYK ,_aaa _cg .Rectangle ){for _dgcb :=0;_dgcb < _aaa .Max .X ;_dgcb ++{for _geba :=0;_geba < _aaa .Max .Y ;_geba ++{_gea .SetCMYK (_dgcb ,_geba ,_daba .CMYKAt (_dgcb ,_geba ));
};};};func (_aac *Gray4 )Histogram ()(_aaf [256]int ){for _acdff :=0;_acdff < _aac .Width ;_acdff ++{for _aggg :=0;_aggg < _aac .Height ;_aggg ++{_aaf [_aac .GrayAt (_acdff ,_aggg ).Y ]++;};};return _aaf ;};func _fdb (_bdd _b .NRGBA64 )_b .NRGBA {return _b .NRGBA {R :uint8 (_bdd .R >>8),G :uint8 (_bdd .G >>8),B :uint8 (_bdd .B >>8),A :uint8 (_bdd .A >>8)};
};var _ Image =&Gray2 {};func AutoThresholdTriangle (histogram [256]int )uint8 {var _dbcfa ,_ffcc ,_cgae ,_gfb int ;for _ffbc :=0;_ffbc < len (histogram );_ffbc ++{if histogram [_ffbc ]> 0{_dbcfa =_ffbc ;break ;};};if _dbcfa > 0{_dbcfa --;};for _ecadf :=255;
_ecadf > 0;_ecadf --{if histogram [_ecadf ]> 0{_gfb =_ecadf ;break ;};};if _gfb < 255{_gfb ++;};for _bdad :=0;_bdad < 256;_bdad ++{if histogram [_bdad ]> _ffcc {_cgae =_bdad ;_ffcc =histogram [_bdad ];};};var _cbbcb bool ;if (_cgae -_dbcfa )< (_gfb -_cgae ){_cbbcb =true ;
var _cdfg int ;_cfaa :=255;for _cdfg < _cfaa {_cddb :=histogram [_cdfg ];histogram [_cdfg ]=histogram [_cfaa ];histogram [_cfaa ]=_cddb ;_cdfg ++;_cfaa --;};_dbcfa =255-_gfb ;_cgae =255-_cgae ;};if _dbcfa ==_cgae {return uint8 (_dbcfa );};_fcac :=float64 (histogram [_cgae ]);
_dfcb :=float64 (_dbcfa -_cgae );_dfbg :=_e .Sqrt (_fcac *_fcac +_dfcb *_dfcb );_fcac /=_dfbg ;_dfcb /=_dfbg ;_dfbg =_fcac *float64 (_dbcfa )+_dfcb *float64 (histogram [_dbcfa ]);_ddfb :=_dbcfa ;var _gffac float64 ;for _gfcdd :=_dbcfa +1;_gfcdd <=_cgae ;
_gfcdd ++{_dgdbb :=_fcac *float64 (_gfcdd )+_dfcb *float64 (histogram [_gfcdd ])-_dfbg ;if _dgdbb > _gffac {_ddfb =_gfcdd ;_gffac =_dgdbb ;};};_ddfb --;if _cbbcb {var _fcec int ;_bfed :=255;for _fcec < _bfed {_egefe :=histogram [_fcec ];histogram [_fcec ]=histogram [_bfed ];
histogram [_bfed ]=_egefe ;_fcec ++;_bfed --;};return uint8 (255-_ddfb );};return uint8 (_ddfb );};func (_feaa *ImageBase )GetAlpha ()[]byte {return _feaa .Alpha };func (_abdab *Gray8 )Base ()*ImageBase {return &_abdab .ImageBase };func (_gggf *Gray16 )SetGray (x ,y int ,g _b .Gray ){_efca :=(y *_gggf .BytesPerLine /2+x )*2;
if _efca +1>=len (_gggf .Data ){return ;};_gggf .Data [_efca ]=g .Y ;_gggf .Data [_efca +1]=g .Y ;};var _ _cg .Image =&NRGBA64 {};func (_fae *Gray8 )GrayAt (x ,y int )_b .Gray {_agda ,_ :=ColorAtGray8BPC (x ,y ,_fae .BytesPerLine ,_fae .Data ,_fae .Decode );
return _agda ;};var _ Image =&NRGBA16 {};func (_dfcf *monochromeThresholdConverter )Convert (img _cg .Image )(Image ,error ){if _ggbb ,_cea :=img .(*Monochrome );_cea {return _ggbb .Copy (),nil ;};_bbggb :=img .Bounds ();_egbe ,_gefe :=NewImage (_bbggb .Max .X ,_bbggb .Max .Y ,1,1,nil ,nil ,nil );
if _gefe !=nil {return nil ,_gefe ;};_egbe .(*Monochrome ).ModelThreshold =_dfcf .Threshold ;for _agbg :=0;_agbg < _bbggb .Max .X ;_agbg ++{for _bca :=0;_bca < _bbggb .Max .Y ;_bca ++{_cbca :=img .At (_agbg ,_bca );_egbe .Set (_agbg ,_bca ,_cbca );};};
return _egbe ,nil ;};type CMYK32 struct{ImageBase };func (_fabf *NRGBA16 )NRGBAAt (x ,y int )_b .NRGBA {_dbebd ,_ :=ColorAtNRGBA16 (x ,y ,_fabf .Width ,_fabf .BytesPerLine ,_fabf .Data ,_fabf .Alpha ,_fabf .Decode );return _dbebd ;};func (_gegd *CMYK32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtCMYK (x ,y ,_gegd .Width ,_gegd .Data ,_gegd .Decode );
};func _ebeg (_ecfg _b .Gray )_b .Gray {_ecfg .Y >>=4;_ecfg .Y |=_ecfg .Y <<4;return _ecfg };func _fgbb (_adgc _b .Gray )_b .Gray {_ffe :=_adgc .Y >>6;_ffe |=_ffe <<2;_adgc .Y =_ffe |_ffe <<4;return _adgc ;};var _ Gray =&Gray2 {};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_b .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_g .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _cgba (_dcge ,_bebe ,_bddba byte )byte {return (_dcge &^(_bddba ))|(_bebe &_bddba )};func (_cdag *Gray8 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_cdag .Width ,Y :_cdag .Height }};};func (_dfca *Gray2 )At (x ,y int )_b .Color {_fbfc ,_ :=_dfca .ColorAt (x ,y );
return _fbfc };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _e .Abs (xmax -xmin )< 0.000001{return ymin ;};_gabg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _gabg ;};func (_dfae *Gray16 )GrayAt (x ,y int )_b .Gray {_gagg ,_ :=_dfae .ColorAt (x ,y );
return _b .Gray {Y :uint8 (_gagg .(_b .Gray16 ).Y >>8)};};func (_agdaa *NRGBA16 )ColorModel ()_b .Model {return NRGBA16Model };func _ag (_ega *Monochrome ,_cf int ,_eb []uint )(*Monochrome ,error ){_ef :=_cf *_ega .Width ;_fa :=_cf *_ega .Height ;_ege :=_bae (_ef ,_fa );
for _fe ,_bg :=range _eb {var _daf error ;switch _bg {case 2:_daf =_db (_ege ,_ega );case 4:_daf =_bga (_ege ,_ega );case 8:_daf =_ggde (_ege ,_ega );};if _daf !=nil {return nil ,_daf ;};if _fe !=len (_eb )-1{_ega =_ege .copy ();};};return _ege ,nil ;};
type shift int ;func _bbb (_ca *Monochrome ,_ebd ,_ge int )(*Monochrome ,error ){if _ca ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _ebd <=0||_ge <=0{return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _ebd ==_ge {if _ebd ==1{return _ca .copy (),nil ;};if _ebd ==2||_ebd ==4||_ebd ==8{_bdc ,_gf :=_dgc (_ca ,_ebd );if _gf !=nil {return nil ,_gf ;};return _bdc ,nil ;};};_fbc :=_ebd *_ca .Width ;_bfb :=_ge *_ca .Height ;_bgf :=_bae (_fbc ,_bfb );_fca :=_bgf .BytesPerLine ;
var (_be ,_gb ,_bgb ,_dcc ,_de int ;_cc byte ;_gd error ;);for _gb =0;_gb < _ca .Height ;_gb ++{_be =_ge *_gb *_fca ;for _bgb =0;_bgb < _ca .Width ;_bgb ++{if _bdfa :=_ca .getBitAt (_bgb ,_gb );_bdfa {_de =_ebd *_bgb ;for _dcc =0;_dcc < _ebd ;_dcc ++{_bgf .setIndexedBit (_be *8+_de +_dcc );
};};};for _dcc =1;_dcc < _ge ;_dcc ++{_bceb :=_be +_dcc *_fca ;for _gbd :=0;_gbd < _fca ;_gbd ++{if _cc ,_gd =_bgf .getByte (_be +_gbd );_gd !=nil {return nil ,_gd ;};if _gd =_bgf .setByte (_bceb +_gbd ,_cc );_gd !=nil {return nil ,_gd ;};};};};return _bgf ,nil ;
};func _fcge (_cbacg NRGBA ,_cge Gray ,_cdef _cg .Rectangle ){for _ffc :=0;_ffc < _cdef .Max .X ;_ffc ++{for _cagf :=0;_cagf < _cdef .Max .Y ;_cagf ++{_bda :=_eed (_cbacg .NRGBAAt (_ffc ,_cagf ));_cge .SetGray (_ffc ,_cagf ,_bda );};};};func (_gae *Gray4 )GrayAt (x ,y int )_b .Gray {_ddg ,_ :=ColorAtGray4BPC (x ,y ,_gae .BytesPerLine ,_gae .Data ,_gae .Decode );
return _ddg ;};var _ _cg .Image =&Gray4 {};func _badb (_efad _cg .Image ,_feb int )(_cg .Rectangle ,bool ,[]byte ){_bgcbd :=_efad .Bounds ();var (_feddg bool ;_fgff []byte ;);switch _cbcb :=_efad .(type ){case SMasker :_feddg =_cbcb .HasAlpha ();case NRGBA ,RGBA ,*_cg .RGBA64 ,nrgba64 ,*_cg .NYCbCrA :_fgff =make ([]byte ,_bgcbd .Max .X *_bgcbd .Max .Y *_feb );
case *_cg .Paletted :var _bgbc bool ;for _ ,_babg :=range _cbcb .Palette {_afbcf ,_fafg ,_ffcd ,_bbfbe :=_babg .RGBA ();if _afbcf ==0&&_fafg ==0&&_ffcd ==0&&_bbfbe !=0{_bgbc =true ;break ;};};if _bgbc {_fgff =make ([]byte ,_bgcbd .Max .X *_bgcbd .Max .Y *_feb );
};};return _bgcbd ,_feddg ,_fgff ;};func _fgd (_agcg CMYK ,_gagfc NRGBA ,_dada _cg .Rectangle ){for _bcdg :=0;_bcdg < _dada .Max .X ;_bcdg ++{for _eabd :=0;_eabd < _dada .Max .Y ;_eabd ++{_ecgd :=_agcg .CMYKAt (_bcdg ,_eabd );_gagfc .SetNRGBA (_bcdg ,_eabd ,_gcac (_ecgd ));
};};};func _bga (_dc ,_ebe *Monochrome )(_gga error ){_bd :=_ebe .BytesPerLine ;_daa :=_dc .BytesPerLine ;_dbe :=_ebe .BytesPerLine *4-_dc .BytesPerLine ;var (_fb ,_ebc byte ;_gc uint32 ;_ea ,_cfc ,_bgg ,_fab ,_bdf ,_cd ,_bceg int ;);for _bgg =0;_bgg < _ebe .Height ;
_bgg ++{_ea =_bgg *_bd ;_cfc =4*_bgg *_daa ;for _fab =0;_fab < _bd ;_fab ++{_fb =_ebe .Data [_ea +_fab ];_gc =_cbe [_fb ];_cd =_cfc +_fab *4;if _dbe !=0&&(_fab +1)*4> _dc .BytesPerLine {for _bdf =_dbe ;_bdf > 0;_bdf --{_ebc =byte ((_gc >>uint (_bdf *8))&0xff);
_bceg =_cd +(_dbe -_bdf );if _gga =_dc .setByte (_bceg ,_ebc );_gga !=nil {return _gga ;};};}else if _gga =_dc .setFourBytes (_cd ,_gc );_gga !=nil {return _gga ;};if _gga =_dc .setFourBytes (_cfc +_fab *4,_cbe [_ebe .Data [_ea +_fab ]]);_gga !=nil {return _gga ;
};};for _bdf =1;_bdf < 4;_bdf ++{for _fab =0;_fab < _daa ;_fab ++{if _gga =_dc .setByte (_cfc +_bdf *_daa +_fab ,_dc .Data [_cfc +_fab ]);_gga !=nil {return _gga ;};};};};return nil ;};func (_ffb *Gray16 )Set (x ,y int ,c _b .Color ){_cbdd :=(y *_ffb .BytesPerLine /2+x )*2;
if _cbdd +1>=len (_ffb .Data ){return ;};_dff :=_b .Gray16Model .Convert (c ).(_b .Gray16 );_ffb .Data [_cbdd ],_ffb .Data [_cbdd +1]=uint8 (_dff .Y >>8),uint8 (_dff .Y &0xff);};var _ Gray =&Monochrome {};type Gray2 struct{ImageBase };var _ _cg .Image =&Gray2 {};
func init (){_fdfa ()};func (_fggc *CMYK32 )At (x ,y int )_b .Color {_cca ,_ :=_fggc .ColorAt (x ,y );return _cca };func (_edef *Gray2 )ColorModel ()_b .Model {return Gray2Model };func _ccfc (_ebgd *_cg .NYCbCrA ,_gfaa NRGBA ,_dbcc _cg .Rectangle ){for _bbde :=0;
_bbde < _dbcc .Max .X ;_bbde ++{for _aecg :=0;_aecg < _dbcc .Max .Y ;_aecg ++{_edgd :=_ebgd .NYCbCrAAt (_bbde ,_aecg );_gfaa .SetNRGBA (_bbde ,_aecg ,_gfe (_edgd ));};};};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray16 ,error ){_gcaa :=(y *bytesPerLine /2+x )*2;
if _gcaa +1>=len (data ){return _b .Gray16 {},_g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dcac :=uint16 (data [_gcaa ])<<8|uint16 (data [_gcaa +1]);if len (decode )==2{_dcac =uint16 (uint64 (LinearInterpolate (float64 (_dcac ),0,65535,decode [0],decode [1])));};return _b .Gray16 {Y :_dcac },nil ;};func (_aaae *Gray2 )Validate ()error {if len (_aaae .Data )!=_aaae .Height *_aaae .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_bagef *Gray4 )ColorModel ()_b .Model {return Gray4Model };func MonochromeModel (threshold uint8 )_b .Model {return monochromeModel (threshold )};type NRGBA interface{NRGBAAt (_egca ,_dcfd int )_b .NRGBA ;SetNRGBA (_fbfd ,_edeed int ,_gdcfd _b .NRGBA );
};func (_dfbd *NRGBA64 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_dfbd .Width ,Y :_dfbd .Height }};};func _bgabe (_bbd _b .CMYK )_b .Gray {_cab ,_gaf ,_eea :=_b .CMYKToRGB (_bbd .C ,_bbd .M ,_bbd .Y ,_bbd .K );_edc :=(19595*uint32 (_cab )+38470*uint32 (_gaf )+7471*uint32 (_eea )+1<<7)>>16;
return _b .Gray {Y :uint8 (_edc )};};func (_daeg *NRGBA16 )SetNRGBA (x ,y int ,c _b .NRGBA ){_fbcgb :=y *_daeg .BytesPerLine +x *3/2;if _fbcgb +1>=len (_daeg .Data ){return ;};c =_debd (c );_daeg .setNRGBA (x ,y ,_fbcgb ,c );};func (_gag *Monochrome )ColorModel ()_b .Model {return MonochromeModel (_gag .ModelThreshold )};
type Gray4 struct{ImageBase };var _ Image =&NRGBA64 {};var (_addc =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_eacc =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_dffe *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_dffe .copy ()}};
func _dgc (_eg *Monochrome ,_bag int )(*Monochrome ,error ){if _eg ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _bag ==1{return _eg .copy (),nil ;};if !IsPowerOf2 (uint (_bag )){return nil ,_g .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_bag );
};_cb :=_beac (_bag );return _ag (_eg ,_bag ,_cb );};func _bgbb (_eaeg *_cg .Gray16 ,_dgceb uint8 )*_cg .Gray {_fgagd :=_eaeg .Bounds ();_acece :=_cg .NewGray (_fgagd );for _aagfg :=0;_aagfg < _fgagd .Dx ();_aagfg ++{for _bced :=0;_bced < _fgagd .Dy ();
_bced ++{_dfgeb :=_eaeg .Gray16At (_aagfg ,_bced );_acece .SetGray (_aagfg ,_bced ,_b .Gray {Y :_acafd (uint8 (_dfgeb .Y /256),_dgceb )});};};return _acece ;};func (_dcec *NRGBA16 )At (x ,y int )_b .Color {_cgg ,_ :=_dcec .ColorAt (x ,y );return _cgg };
func (_fdeaf *NRGBA64 )setNRGBA64 (_efdg int ,_ccdg _b .NRGBA64 ,_ccaea int ){_fdeaf .Data [_efdg ]=uint8 (_ccdg .R >>8);_fdeaf .Data [_efdg +1]=uint8 (_ccdg .R &0xff);_fdeaf .Data [_efdg +2]=uint8 (_ccdg .G >>8);_fdeaf .Data [_efdg +3]=uint8 (_ccdg .G &0xff);
_fdeaf .Data [_efdg +4]=uint8 (_ccdg .B >>8);_fdeaf .Data [_efdg +5]=uint8 (_ccdg .B &0xff);if _ccaea +1< len (_fdeaf .Alpha ){_fdeaf .Alpha [_ccaea ]=uint8 (_ccdg .A >>8);_fdeaf .Alpha [_ccaea +1]=uint8 (_ccdg .A &0xff);};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_g .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _ccag (_aggc *Monochrome ,_bfga ,_aebe ,_bcaeg ,_cefc int ,_cfaf RasterOperator ){if _bfga < 0{_bcaeg +=_bfga ;_bfga =0;};_fbee :=_bfga +_bcaeg -_aggc .Width ;if _fbee > 0{_bcaeg -=_fbee ;};if _aebe < 0{_cefc +=_aebe ;_aebe =0;};_cfbg :=_aebe +_cefc -_aggc .Height ;
if _cfbg > 0{_cefc -=_cfbg ;};if _bcaeg <=0||_cefc <=0{return ;};if (_bfga &7)==0{_dgbb (_aggc ,_bfga ,_aebe ,_bcaeg ,_cefc ,_cfaf );}else {_facd (_aggc ,_bfga ,_aebe ,_bcaeg ,_cefc ,_cfaf );};};func (_aeba *Gray16 )Base ()*ImageBase {return &_aeba .ImageBase };
var _ _cg .Image =&Gray16 {};func (_dag *Gray2 )Histogram ()(_ccf [256]int ){for _fabc :=0;_fabc < _dag .Width ;_fabc ++{for _cfeg :=0;_cfeg < _dag .Height ;_cfeg ++{_ccf [_dag .GrayAt (_fabc ,_cfeg ).Y ]++;};};return _ccf ;};func _gggb (_gcaf int ,_fabe int )int {if _gcaf < _fabe {return _gcaf ;
};return _fabe ;};func _adcf (_affd *Monochrome ,_ebcg ,_dbdg ,_dfag ,_bfce int ,_gcdc RasterOperator ,_cfdb *Monochrome ,_gdg ,_dcdb int )error {var (_bbaa byte ;_dgae int ;_accd int ;_eccb ,_ggae int ;_cbdc ,_acag int ;);_ffd :=_dfag >>3;_afdad :=_dfag &7;
if _afdad > 0{_bbaa =_addc [_afdad ];};_dgae =_cfdb .BytesPerLine *_dcdb +(_gdg >>3);_accd =_affd .BytesPerLine *_dbdg +(_ebcg >>3);switch _gcdc {case PixSrc :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;
for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]=_cfdb .Data [_eccb ];_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],_cfdb .Data [_eccb ],_bbaa );};};case PixNotSrc :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;
_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]=^(_cfdb .Data [_eccb ]);_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],^_cfdb .Data [_eccb ],_bbaa );};};case PixSrcOrDst :for _cbdc =0;
_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]|=_cfdb .Data [_eccb ];_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],_cfdb .Data [_eccb ]|_affd .Data [_ggae ],_bbaa );
};};case PixSrcAndDst :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]&=_cfdb .Data [_eccb ];_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],_cfdb .Data [_eccb ]&_affd .Data [_ggae ],_bbaa );
};};case PixSrcXorDst :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]^=_cfdb .Data [_eccb ];_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],_cfdb .Data [_eccb ]^_affd .Data [_ggae ],_bbaa );
};};case PixNotSrcOrDst :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]|=^(_cfdb .Data [_eccb ]);_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],^(_cfdb .Data [_eccb ])|_affd .Data [_ggae ],_bbaa );
};};case PixNotSrcAndDst :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]&=^(_cfdb .Data [_eccb ]);_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],^(_cfdb .Data [_eccb ])&_affd .Data [_ggae ],_bbaa );
};};case PixSrcOrNotDst :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]=_cfdb .Data [_eccb ]|^(_affd .Data [_ggae ]);_ggae ++;
_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],_cfdb .Data [_eccb ]|^(_affd .Data [_ggae ]),_bbaa );};};case PixSrcAndNotDst :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;
for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]=_cfdb .Data [_eccb ]&^(_affd .Data [_ggae ]);_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],_cfdb .Data [_eccb ]&^(_affd .Data [_ggae ]),_bbaa );};};case PixNotPixSrcOrDst :for _cbdc =0;
_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]=^(_cfdb .Data [_eccb ]|_affd .Data [_ggae ]);_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],^(_cfdb .Data [_eccb ]|_affd .Data [_ggae ]),_bbaa );
};};case PixNotPixSrcAndDst :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]=^(_cfdb .Data [_eccb ]&_affd .Data [_ggae ]);
_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],^(_cfdb .Data [_eccb ]&_affd .Data [_ggae ]),_bbaa );};};case PixNotPixSrcXorDst :for _cbdc =0;_cbdc < _bfce ;_cbdc ++{_eccb =_dgae +_cbdc *_cfdb .BytesPerLine ;_ggae =_accd +_cbdc *_affd .BytesPerLine ;
for _acag =0;_acag < _ffd ;_acag ++{_affd .Data [_ggae ]=^(_cfdb .Data [_eccb ]^_affd .Data [_ggae ]);_ggae ++;_eccb ++;};if _afdad > 0{_affd .Data [_ggae ]=_cgba (_affd .Data [_ggae ],^(_cfdb .Data [_eccb ]^_affd .Data [_ggae ]),_bbaa );};};default:_gg .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_gcdc );
return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};var _ _cg .Image =&NRGBA16 {};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_fceg :=y *bytesPerLine +x >>1;
if _fceg >=len (data ){return _b .Gray {},_g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ddcg :=data [_fceg ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ddcg =uint8 (uint32 (LinearInterpolate (float64 (_ddcg ),0,15,decode [0],decode [1]))&0xf);};return _b .Gray {Y :_ddcg *17&0xff},nil ;};func _beb ()(_fadg []byte ){_fadg =make ([]byte ,256);
for _cfe :=0;_cfe < 256;_cfe ++{_bgc :=byte (_cfe );_fadg [_bgc ]=(_bgc &0x01)|((_bgc &0x04)>>1)|((_bgc &0x10)>>2)|((_bgc &0x40)>>3)|((_bgc &0x02)<<3)|((_bgc &0x08)<<2)|((_bgc &0x20)<<1)|(_bgc &0x80);};return _fadg ;};func _edee (_gbfe uint )uint {var _bbegf uint ;
for _gbfe !=0{_gbfe >>=1;_bbegf ++;};return _bbegf -1;};func _baad (_daece _cg .Image ,_dfbda Image ,_gbc _cg .Rectangle ){if _bdafa ,_fdga :=_daece .(SMasker );_fdga &&_bdafa .HasAlpha (){_dfbda .(SMasker ).MakeAlpha ();};switch _dggcb :=_daece .(type ){case Gray :_fedb (_dggcb ,_dfbda .(NRGBA ),_gbc );
case NRGBA :_gbea (_dggcb ,_dfbda .(NRGBA ),_gbc );case *_cg .NYCbCrA :_ccfc (_dggcb ,_dfbda .(NRGBA ),_gbc );case CMYK :_fgd (_dggcb ,_dfbda .(NRGBA ),_gbc );case RGBA :_egfb (_dggcb ,_dfbda .(NRGBA ),_gbc );case nrgba64 :_gede (_dggcb ,_dfbda .(NRGBA ),_gbc );
default:_fcaf (_daece ,_dfbda ,_gbc );};};func _bae (_gcc ,_cbc int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_gcc ,_cbc ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func (_efdc *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_cdg :=_edee (uint (factor ));
if !IsPowerOf2 (uint (factor )){_cdg ++;};_ebbg :=make ([]int ,_cdg );for _gfcg :=range _ebbg {_ebbg [_gfcg ]=4;};_fef ,_cag :=_gdd (_efdc ,_ebbg ...);if _cag !=nil {return nil ,_cag ;};return _fef ,nil ;};var _ Gray =&Gray8 {};func _dddg (_agdf _b .Gray )_b .NRGBA {return _b .NRGBA {R :_agdf .Y ,G :_agdf .Y ,B :_agdf .Y ,A :0xff}};
var _ Image =&Gray16 {};var (Gray2Model =_b .ModelFunc (_agaf );Gray4Model =_b .ModelFunc (_gaea );NRGBA16Model =_b .ModelFunc (_bgee ););func _bagb (_fge _cg .Image )(Image ,error ){if _feaf ,_fadf :=_fge .(*Gray4 );_fadf {return _feaf .Copy (),nil ;};
_abec :=_fge .Bounds ();_egfg ,_daae :=NewImage (_abec .Max .X ,_abec .Max .Y ,4,1,nil ,nil ,nil );if _daae !=nil {return nil ,_daae ;};_fbbg (_fge ,_egfg ,_abec );return _egfg ,nil ;};func (_acac *Gray4 )Base ()*ImageBase {return &_acac .ImageBase };func _bcbde (_fdagg *_cg .Gray )bool {for _fbba :=0;
_fbba < len (_fdagg .Pix );_fbba ++{if !_gedec (_fdagg .Pix [_fbba ]){return false ;};};return true ;};func _cebf (_eaddg Gray ,_dgcdd CMYK ,_fgce _cg .Rectangle ){for _gefb :=0;_gefb < _fgce .Max .X ;_gefb ++{for _dafc :=0;_dafc < _fgce .Max .Y ;_dafc ++{_ccda :=_eaddg .GrayAt (_gefb ,_dafc );
_dgcdd .SetCMYK (_gefb ,_dafc ,_ecb (_ccda ));};};};func (_bdce *NRGBA32 )Base ()*ImageBase {return &_bdce .ImageBase };func _cfa (_cad _b .RGBA )_b .Gray {_fcf :=(19595*uint32 (_cad .R )+38470*uint32 (_cad .G )+7471*uint32 (_cad .B )+1<<7)>>16;return _b .Gray {Y :uint8 (_fcf )};
};func (_edbcc *Monochrome )clearBit (_efgg ,_faae int ){_edbcc .Data [_efgg ]&=^(0x80>>uint (_faae &7))};func ConverterFunc (converterFunc func (_egbc _cg .Image )(Image ,error ))ColorConverter {return colorConverter {_beef :converterFunc };};func (_bfgd *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_bfgd .copy ()}};
func (_ebfef *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bgac (_ebfef ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_acce *Gray8 )At (x ,y int )_b .Color {_dbga ,_ :=_acce .ColorAt (x ,y );
return _dbga };func _dgb (_dba Gray ,_fadc NRGBA ,_gebb _cg .Rectangle ){for _fed :=0;_fed < _gebb .Max .X ;_fed ++{for _gaa :=0;_gaa < _gebb .Max .Y ;_gaa ++{_dgfc :=_gcf (_fadc .NRGBAAt (_fed ,_gaa ));_dba .SetGray (_fed ,_gaa ,_dgfc );};};};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA64 ,error ){_ddbfg :=(y *width +x )*2;
_edag :=_ddbfg *3;if _edag +5>=len (data ){return _b .NRGBA64 {},_g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _adgfe =0xffff;_bfdg :=uint16 (_adgfe );if alpha !=nil &&len (alpha )> _ddbfg +1{_bfdg =uint16 (alpha [_ddbfg ])<<8|uint16 (alpha [_ddbfg +1]);};_fabae :=uint16 (data [_edag ])<<8|uint16 (data [_edag +1]);_gdbf :=uint16 (data [_edag +2])<<8|uint16 (data [_edag +3]);
_fafgd :=uint16 (data [_edag +4])<<8|uint16 (data [_edag +5]);if len (decode )==6{_fabae =uint16 (uint64 (LinearInterpolate (float64 (_fabae ),0,65535,decode [0],decode [1]))&_adgfe );_gdbf =uint16 (uint64 (LinearInterpolate (float64 (_gdbf ),0,65535,decode [2],decode [3]))&_adgfe );
_fafgd =uint16 (uint64 (LinearInterpolate (float64 (_fafgd ),0,65535,decode [4],decode [5]))&_adgfe );};return _b .NRGBA64 {R :_fabae ,G :_gdbf ,B :_fafgd ,A :_bfdg },nil ;};func _bea ()(_ed [256]uint64 ){for _fcb :=0;_fcb < 256;_fcb ++{if _fcb &0x01!=0{_ed [_fcb ]|=0xff;
};if _fcb &0x02!=0{_ed [_fcb ]|=0xff00;};if _fcb &0x04!=0{_ed [_fcb ]|=0xff0000;};if _fcb &0x08!=0{_ed [_fcb ]|=0xff000000;};if _fcb &0x10!=0{_ed [_fcb ]|=0xff00000000;};if _fcb &0x20!=0{_ed [_fcb ]|=0xff0000000000;};if _fcb &0x40!=0{_ed [_fcb ]|=0xff000000000000;
};if _fcb &0x80!=0{_ed [_fcb ]|=0xff00000000000000;};};return _ed ;};func _aede (_gbddc *_cg .Gray ,_feee uint8 )*_cg .Gray {_egba :=_gbddc .Bounds ();_egcbb :=_cg .NewGray (_egba );for _cfgg :=0;_cfgg < _egba .Dx ();_cfgg ++{for _dbcca :=0;_dbcca < _egba .Dy ();
_dbcca ++{_bead :=_gbddc .GrayAt (_cfgg ,_dbcca );_egcbb .SetGray (_cfgg ,_dbcca ,_b .Gray {Y :_acafd (_bead .Y ,_feee )});};};return _egcbb ;};func InDelta (expected ,current ,delta float64 )bool {_geef :=expected -current ;if _geef <=-delta ||_geef >=delta {return false ;
};return true ;};func (_ebbge *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_ebbge .copy ()}};func (_feac *CMYK32 )Base ()*ImageBase {return &_feac .ImageBase };func _dce (_cgac _cg .Image )(Image ,error ){if _dbgea ,_bedb :=_cgac .(*Gray8 );_bedb {return _dbgea .Copy (),nil ;
};_cegf :=_cgac .Bounds ();_acdc ,_efcd :=NewImage (_cegf .Max .X ,_cegf .Max .Y ,8,1,nil ,nil ,nil );if _efcd !=nil {return nil ,_efcd ;};_fbbg (_cgac ,_acdc ,_cegf );return _acdc ,nil ;};func (_abde *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_abde .copy ()}};
func (_ebcad *Gray4 )Validate ()error {if len (_ebcad .Data )!=_ebcad .Height *_ebcad .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_bdee *Monochrome )copy ()*Monochrome {_gee :=_bae (_bdee .Width ,_bdee .Height );_gee .ModelThreshold =_bdee .ModelThreshold ;
_gee .Data =make ([]byte ,len (_bdee .Data ));copy (_gee .Data ,_bdee .Data );if len (_bdee .Decode )!=0{_gee .Decode =make ([]float64 ,len (_bdee .Decode ));copy (_gee .Decode ,_bdee .Decode );};if len (_bdee .Alpha )!=0{_gee .Alpha =make ([]byte ,len (_bdee .Alpha ));
copy (_gee .Alpha ,_bdee .Alpha );};return _gee ;};func (_effb *Gray8 )ColorModel ()_b .Model {return _b .GrayModel };func _gdd (_fg *Monochrome ,_bcbd ...int )(_bee *Monochrome ,_bgaf error ){if _fg ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_bcbd )==0{return nil ,_d .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_agd :=_beb ();_bee =_fg ;for _ ,_fbe :=range _bcbd {if _fbe <=0{break ;};_bee ,_bgaf =_afb (_bee ,_fbe ,_agd );if _bgaf !=nil {return nil ,_bgaf ;};};return _bee ,nil ;};func (_befe *NRGBA32 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_befe .Width ,Y :_befe .Height }};
};func (_ecff *Gray2 )Set (x ,y int ,c _b .Color ){if x >=_ecff .Width ||y >=_ecff .Height {return ;};_ceec :=Gray2Model .Convert (c ).(_b .Gray );_eab :=y *_ecff .BytesPerLine ;_fbf :=_eab +(x >>2);_ggfb :=_ceec .Y >>6;_ecff .Data [_fbf ]=(_ecff .Data [_fbf ]&(^(0xc0>>uint (2*((x )&3)))))|(_ggfb <<uint (6-2*(x &3)));
};func (_egac *NRGBA32 )NRGBAAt (x ,y int )_b .NRGBA {_ffcb ,_ :=ColorAtNRGBA32 (x ,y ,_egac .Width ,_egac .Data ,_egac .Alpha ,_egac .Decode );return _ffcb ;};func ImgToGray (i _cg .Image )*_cg .Gray {if _bbece ,_bdcea :=i .(*_cg .Gray );_bdcea {return _bbece ;
};_babd :=i .Bounds ();_fcea :=_cg .NewGray (_babd );for _aace :=0;_aace < _babd .Max .X ;_aace ++{for _badd :=0;_badd < _babd .Max .Y ;_badd ++{_bgedd :=i .At (_aace ,_badd );_fcea .Set (_aace ,_badd ,_bgedd );};};return _fcea ;};func (_dfde *Monochrome )AddPadding ()(_dbeg error ){if _ggfa :=((_dfde .Width *_dfde .Height )+7)>>3;
len (_dfde .Data )< _ggfa {return _g .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_dfde .Data ),_ggfa );
};_aad :=_dfde .Width %8;if _aad ==0{return nil ;};_feg :=_dfde .Width /8;_dgd :=_ba .NewReader (_dfde .Data );_dgbd :=make ([]byte ,_dfde .Height *_dfde .BytesPerLine );_fcfg :=_ba .NewWriterMSB (_dgbd );_eeea :=make ([]byte ,_feg );var (_gbdb int ;_eda uint64 ;
);for _gbdb =0;_gbdb < _dfde .Height ;_gbdb ++{if _ ,_dbeg =_dgd .Read (_eeea );_dbeg !=nil {return _dbeg ;};if _ ,_dbeg =_fcfg .Write (_eeea );_dbeg !=nil {return _dbeg ;};if _eda ,_dbeg =_dgd .ReadBits (byte (_aad ));_dbeg !=nil {return _dbeg ;};if _dbeg =_fcfg .WriteByte (byte (_eda )<<uint (8-_aad ));
_dbeg !=nil {return _dbeg ;};};_dfde .Data =_fcfg .Data ();return nil ;};func (_efe *Gray16 )At (x ,y int )_b .Color {_fee ,_ :=_efe .ColorAt (x ,y );return _fee };func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};type NRGBA16 struct{ImageBase };func (_dfcg *CMYK32 )SetCMYK (x ,y int ,c _b .CMYK ){_fggd :=4*(y *_dfcg .Width +x );if _fggd +3>=len (_dfcg .Data ){return ;};_dfcg .Data [_fggd ]=c .C ;_dfcg .Data [_fggd +1]=c .M ;_dfcg .Data [_fggd +2]=c .Y ;_dfcg .Data [_fggd +3]=c .K ;
};func (_deafc *NRGBA32 )Validate ()error {if len (_deafc .Data )!=3*_deafc .Width *_deafc .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _ffag (_ffdeb _cg .Image ,_adf Image ,_ddef _cg .Rectangle ){if _acgb ,_ebfa :=_ffdeb .(SMasker );_ebfa &&_acgb .HasAlpha (){_adf .(SMasker ).MakeAlpha ();};_fcaf (_ffdeb ,_adf ,_ddef );};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};
func (_bcae *Gray8 )Histogram ()(_fgad [256]int ){for _dbcge :=0;_dbcge < len (_bcae .Data );_dbcge ++{_fgad [_bcae .Data [_dbcge ]]++;};return _fgad ;};func _ccea (_faafe _cg .Image )(Image ,error ){if _aegg ,_gfgc :=_faafe .(*NRGBA16 );_gfgc {return _aegg .Copy (),nil ;
};_aadg :=_faafe .Bounds ();_abfc ,_bafd :=NewImage (_aadg .Max .X ,_aadg .Max .Y ,4,3,nil ,nil ,nil );if _bafd !=nil {return nil ,_bafd ;};_baad (_faafe ,_abfc ,_aadg );return _abfc ,nil ;};func (_egcb *Monochrome )setGray (_cebe int ,_effcb _b .Gray ,_acaf int ){if _effcb .Y ==0{_egcb .clearBit (_acaf ,_cebe );
}else {_egcb .setGrayBit (_acaf ,_cebe );};};func _dac (_aabe _cg .Image )(Image ,error ){if _geeb ,_ggcd :=_aabe .(*Gray16 );_ggcd {return _geeb .Copy (),nil ;};_bggd :=_aabe .Bounds ();_dddag ,_cgbb :=NewImage (_bggd .Max .X ,_bggd .Max .Y ,16,1,nil ,nil ,nil );
if _cgbb !=nil {return nil ,_cgbb ;};_fbbg (_aabe ,_dddag ,_bggd );return _dddag ,nil ;};func (_bada *NRGBA16 )Base ()*ImageBase {return &_bada .ImageBase };var _dcdgc [256]uint8 ;func (_fggcf *ImageBase )MakeAlpha (){_fggcf .newAlpha ()};func (_gccce *Monochrome )IsUnpadded ()bool {return (_gccce .Width *_gccce .Height )==len (_gccce .Data );
};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;
case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_g .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_fbcg *Monochrome )InverseData ()error {return _fbcg .RasterOperation (0,0,_fbcg .Width ,_fbcg .Height ,PixNotDst ,nil ,0,0);};func (_cebbb *Monochrome )getBitAt (_fbb ,_gbad int )bool {_dbcg :=_gbad *_cebbb .BytesPerLine +(_fbb >>3);_bbfb :=_fbb &0x07;
_egg :=uint (7-_bbfb );if _dbcg > len (_cebbb .Data )-1{return false ;};if (_cebbb .Data [_dbcg ]>>_egg )&0x01>=1{return true ;};return false ;};type Image interface{_da .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_ddbf ,_adc int )(_b .Color ,error );
Validate ()error ;};func _ecc (_adg _b .RGBA )_b .CMYK {_efga ,_fdaf ,_fbea ,_dgcf :=_b .RGBToCMYK (_adg .R ,_adg .G ,_adg .B );return _b .CMYK {C :_efga ,M :_fdaf ,Y :_fbea ,K :_dgcf };};func _gec (_bfgg ,_bbc *Monochrome ,_baf []byte ,_bbg int )(_gdc error ){var (_dbg ,_cee ,_aef ,_gfg ,_fgf ,_geg ,_aff ,_bac int ;
_eadd ,_bbbg uint32 ;_fea ,_bcf byte ;_cbd uint16 ;);_fd :=make ([]byte ,4);_dfb :=make ([]byte ,4);for _aef =0;_aef < _bfgg .Height -1;_aef ,_gfg =_aef +2,_gfg +1{_dbg =_aef *_bfgg .BytesPerLine ;_cee =_gfg *_bbc .BytesPerLine ;for _fgf ,_geg =0,0;_fgf < _bbg ;
_fgf ,_geg =_fgf +4,_geg +1{for _aff =0;_aff < 4;_aff ++{_bac =_dbg +_fgf +_aff ;if _bac <=len (_bfgg .Data )-1&&_bac < _dbg +_bfgg .BytesPerLine {_fd [_aff ]=_bfgg .Data [_bac ];}else {_fd [_aff ]=0x00;};_bac =_dbg +_bfgg .BytesPerLine +_fgf +_aff ;if _bac <=len (_bfgg .Data )-1&&_bac < _dbg +(2*_bfgg .BytesPerLine ){_dfb [_aff ]=_bfgg .Data [_bac ];
}else {_dfb [_aff ]=0x00;};};_eadd =_dae .BigEndian .Uint32 (_fd );_bbbg =_dae .BigEndian .Uint32 (_dfb );_bbbg |=_eadd ;_bbbg |=_bbbg <<1;_bbbg &=0xaaaaaaaa;_eadd =_bbbg |(_bbbg <<7);_fea =byte (_eadd >>24);_bcf =byte ((_eadd >>8)&0xff);_bac =_cee +_geg ;
if _bac +1==len (_bbc .Data )-1||_bac +1>=_cee +_bbc .BytesPerLine {_bbc .Data [_bac ]=_baf [_fea ];}else {_cbd =(uint16 (_baf [_fea ])<<8)|uint16 (_baf [_bcf ]);if _gdc =_bbc .setTwoBytes (_bac ,_cbd );_gdc !=nil {return _g .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bac );
};_geg ++;};};};return nil ;};func (_gefea *Monochrome )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_gefea .Width ,Y :_gefea .Height }};};func (_egdd *Gray2 )SetGray (x ,y int ,gray _b .Gray ){_afa :=_fgbb (gray );_gcfc :=y *_egdd .BytesPerLine ;
_bbea :=_gcfc +(x >>2);if _bbea >=len (_egdd .Data ){return ;};_cfg :=_afa .Y >>6;_egdd .Data [_bbea ]=(_egdd .Data [_bbea ]&(^(0xc0>>uint (2*((x )&3)))))|(_cfg <<uint (6-2*(x &3)));};func (_bdfg *Monochrome )Validate ()error {if len (_bdfg .Data )!=_bdfg .Height *_bdfg .BytesPerLine {return ErrInvalidImage ;
};return nil ;};var _ Gray =&Gray16 {};func (_fgeaa *NRGBA16 )Validate ()error {if len (_fgeaa .Data )!=3*_fgeaa .Width *_fgeaa .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ecba *Gray16 )Histogram ()(_bgfc [256]int ){for _fdf :=0;_fdf < _ecba .Width ;_fdf ++{for _bfdd :=0;_bfdd < _ecba .Height ;_bfdd ++{_bgfc [_ecba .GrayAt (_fdf ,_bfdd ).Y ]++;};};return _bgfc ;};func (_aafe *NRGBA64 )ColorModel ()_b .Model {return _b .NRGBA64Model };
func _eed (_cdf _b .NRGBA )_b .Gray {_cbf ,_gfd ,_bgab ,_ :=_cdf .RGBA ();_fac :=(19595*_cbf +38470*_gfd +7471*_bgab +1<<15)>>24;return _b .Gray {Y :uint8 (_fac )};};func (_dbbe *Monochrome )ResolveDecode ()error {if len (_dbbe .Decode )!=2{return nil ;
};if _dbbe .Decode [0]==1&&_dbbe .Decode [1]==0{if _edca :=_dbbe .InverseData ();_edca !=nil {return _edca ;};_dbbe .Decode =nil ;};return nil ;};var _ _cg .Image =&Monochrome {};func _bfg ()(_acd [256]uint16 ){for _ab :=0;_ab < 256;_ab ++{if _ab &0x01!=0{_acd [_ab ]|=0x3;
};if _ab &0x02!=0{_acd [_ab ]|=0xc;};if _ab &0x04!=0{_acd [_ab ]|=0x30;};if _ab &0x08!=0{_acd [_ab ]|=0xc0;};if _ab &0x10!=0{_acd [_ab ]|=0x300;};if _ab &0x20!=0{_acd [_ab ]|=0xc00;};if _ab &0x40!=0{_acd [_ab ]|=0x3000;};if _ab &0x80!=0{_acd [_ab ]|=0xc000;
};};return _acd ;};func _efgf (_fbg _cg .Image )(Image ,error ){if _add ,_caea :=_fbg .(*Monochrome );_caea {return _add ,nil ;};_fada :=_fbg .Bounds ();var _dbcff Gray ;switch _abda :=_fbg .(type ){case Gray :_dbcff =_abda ;case NRGBA :_dbcff =&Gray8 {ImageBase :NewImageBase (_fada .Max .X ,_fada .Max .Y ,8,1,nil ,nil ,nil )};
_dgb (_dbcff ,_abda ,_fada );case nrgba64 :_dbcff =&Gray8 {ImageBase :NewImageBase (_fada .Max .X ,_fada .Max .Y ,8,1,nil ,nil ,nil )};_efd (_dbcff ,_abda ,_fada );default:_gdea ,_dee :=GrayConverter .Convert (_fbg );if _dee !=nil {return nil ,_dee ;};
_dbcff =_gdea .(Gray );};_gaca ,_gade :=NewImage (_fada .Max .X ,_fada .Max .Y ,1,1,nil ,nil ,nil );if _gade !=nil {return nil ,_gade ;};_cced :=_gaca .(*Monochrome );_ecfb :=AutoThresholdTriangle (GrayHistogram (_dbcff ));for _eedc :=0;_eedc < _fada .Max .X ;
_eedc ++{for _gfc :=0;_gfc < _fada .Max .Y ;_gfc ++{_daff :=_dde (_dbcff .GrayAt (_eedc ,_gfc ),monochromeModel (_ecfb ));_cced .SetGray (_eedc ,_gfc ,_daff );};};return _gaca ,nil ;};func (_ece *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_ece .copy ()}};
func (_aedb *Monochrome )setGrayBit (_fcab ,_acdf int ){_aedb .Data [_fcab ]|=0x80>>uint (_acdf &7)};func (_gfcf *Monochrome )At (x ,y int )_b .Color {_dcd ,_ :=_gfcf .ColorAt (x ,y );return _dcd };func (_aadc *NRGBA32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA32 (x ,y ,_aadc .Width ,_aadc .Data ,_aadc .Alpha ,_aadc .Decode );
};func (_cdda *Gray4 )Set (x ,y int ,c _b .Color ){if x >=_cdda .Width ||y >=_cdda .Height {return ;};_eaae :=Gray4Model .Convert (c ).(_b .Gray );_cdda .setGray (x ,y ,_eaae );};var _ Image =&Gray4 {};func (_gcga *ImageBase )copy ()ImageBase {_bbca :=*_gcga ;
_bbca .Data =make ([]byte ,len (_gcga .Data ));copy (_bbca .Data ,_gcga .Data );return _bbca ;};func _dde (_deea _b .Gray ,_afda monochromeModel )_b .Gray {if _deea .Y > uint8 (_afda ){return _b .Gray {Y :_e .MaxUint8 };};return _b .Gray {};};func _fcg ()(_bcb [256]uint32 ){for _ggb :=0;
_ggb < 256;_ggb ++{if _ggb &0x01!=0{_bcb [_ggb ]|=0xf;};if _ggb &0x02!=0{_bcb [_ggb ]|=0xf0;};if _ggb &0x04!=0{_bcb [_ggb ]|=0xf00;};if _ggb &0x08!=0{_bcb [_ggb ]|=0xf000;};if _ggb &0x10!=0{_bcb [_ggb ]|=0xf0000;};if _ggb &0x20!=0{_bcb [_ggb ]|=0xf00000;
};if _ggb &0x40!=0{_bcb [_ggb ]|=0xf000000;};if _ggb &0x80!=0{_bcb [_ggb ]|=0xf0000000;};};return _bcb ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA ,error ){_abgc :=y *width +x ;_befc :=3*_abgc ;if _befc +2>=len (data ){return _b .NRGBA {},_g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ggfd :=uint8 (0xff);if alpha !=nil &&len (alpha )> _abgc {_ggfd =alpha [_abgc ];};_afee ,_afaa ,_bebea :=data [_befc ],data [_befc +1],data [_befc +2];if len (decode )==6{_afee =uint8 (uint32 (LinearInterpolate (float64 (_afee ),0,255,decode [0],decode [1]))&0xff);
_afaa =uint8 (uint32 (LinearInterpolate (float64 (_afaa ),0,255,decode [2],decode [3]))&0xff);_bebea =uint8 (uint32 (LinearInterpolate (float64 (_bebea ),0,255,decode [4],decode [5]))&0xff);};return _b .NRGBA {R :_afee ,G :_afaa ,B :_bebea ,A :_ggfd },nil ;
};func _agaf (_dbeb _b .Color )_b .Color {_aebg :=_b .GrayModel .Convert (_dbeb ).(_b .Gray );return _fgbb (_aebg );};var _ _cg .Image =&NRGBA32 {};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_feag :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_feag .Data =make ([]byte ,height *_feag .BytesPerLine );};return _feag ;};func (_bgcb *Gray16 )ColorModel ()_b .Model {return _b .Gray16Model };func (_efda *Gray2 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray2BPC (x ,y ,_efda .BytesPerLine ,_efda .Data ,_efda .Decode );
};func (_adgca *NRGBA16 )setNRGBA (_faac ,_ceae ,_gfdf int ,_fadcb _b .NRGBA ){if _faac *3%2==0{_adgca .Data [_gfdf ]=(_fadcb .R >>4)<<4|(_fadcb .G >>4);_adgca .Data [_gfdf +1]=(_fadcb .B >>4)<<4|(_adgca .Data [_gfdf +1]&0xf);}else {_adgca .Data [_gfdf ]=(_adgca .Data [_gfdf ]&0xf0)|(_fadcb .R >>4);
_adgca .Data [_gfdf +1]=(_fadcb .G >>4)<<4|(_fadcb .B >>4);};if _adgca .Alpha !=nil {_gfedf :=_ceae *BytesPerLine (_adgca .Width ,4,1);if _gfedf < len (_adgca .Alpha ){if _faac %2==0{_adgca .Alpha [_gfedf ]=(_fadcb .A >>uint (4))<<uint (4)|(_adgca .Alpha [_gfdf ]&0xf);
}else {_adgca .Alpha [_gfedf ]=(_adgca .Alpha [_gfedf ]&0xf0)|(_fadcb .A >>uint (4));};};};};func _begf (_cff _cg .Image ,_fdcc uint8 )*_cg .Gray {_dcdd :=_cff .Bounds ();_fbge :=_cg .NewGray (_dcdd );var (_ggab _b .Color ;_bafda _b .Gray ;);for _dcbe :=0;
_dcbe < _dcdd .Max .X ;_dcbe ++{for _fdfe :=0;_fdfe < _dcdd .Max .Y ;_fdfe ++{_ggab =_cff .At (_dcbe ,_fdfe );_fbge .Set (_dcbe ,_fdfe ,_ggab );_bafda =_fbge .GrayAt (_dcbe ,_fdfe );_fbge .SetGray (_dcbe ,_fdfe ,_b .Gray {Y :_acafd (_bafda .Y ,_fdcc )});
};};return _fbge ;};type CMYK interface{CMYKAt (_gbf ,_gcb int )_b .CMYK ;SetCMYK (_bace ,_dgcac int ,_dede _b .CMYK );};func (_beda *ImageBase )setEightPartlyBytes (_cbbg ,_ccb int ,_efaf uint64 )(_cedf error ){var (_aaca byte ;_ccfg int ;);for _gaeab :=1;
_gaeab <=_ccb ;_gaeab ++{_ccfg =64-_gaeab *8;_aaca =byte (_efaf >>uint (_ccfg )&0xff);if _cedf =_beda .setByte (_cbbg +_gaeab -1,_aaca );_cedf !=nil {return _cedf ;};};_facb :=_beda .BytesPerLine *8-_beda .Width ;if _facb ==0{return nil ;};_ccfg -=8;_aaca =byte (_efaf >>uint (_ccfg )&0xff)<<uint (_facb );
if _cedf =_beda .setByte (_cbbg +_ccb ,_aaca );_cedf !=nil {return _cedf ;};return nil ;};func FromGoImage (i _cg .Image )(Image ,error ){switch _bge :=i .(type ){case Image :return _bge .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_cg .Gray16 :return Gray16Converter .Convert (i );
case CMYK :return CMYKConverter .Convert (i );case *_cg .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func _cddd (_eeae RGBA ,_dfaf Gray ,_aaff _cg .Rectangle ){for _bgd :=0;_bgd < _aaff .Max .X ;_bgd ++{for _ggfbc :=0;
_ggfbc < _aaff .Max .Y ;_ggfbc ++{_faaf :=_cfa (_eeae .RGBAAt (_bgd ,_ggfbc ));_dfaf .SetGray (_bgd ,_ggfbc ,_faaf );};};};type NRGBA32 struct{ImageBase };type monochromeThresholdConverter struct{Threshold uint8 ;};func _db (_dafb ,_ec *Monochrome )(_ggd error ){_bc :=_ec .BytesPerLine ;
_cfd :=_dafb .BytesPerLine ;var (_ggg byte ;_dbc uint16 ;_ce ,_ga ,_bce ,_faa ,_ggga int ;);for _bce =0;_bce < _ec .Height ;_bce ++{_ce =_bce *_bc ;_ga =2*_bce *_cfd ;for _faa =0;_faa < _bc ;_faa ++{_ggg =_ec .Data [_ce +_faa ];_dbc =_acf [_ggg ];_ggga =_ga +_faa *2;
if _dafb .BytesPerLine !=_ec .BytesPerLine *2&&(_faa +1)*2> _dafb .BytesPerLine {_ggd =_dafb .setByte (_ggga ,byte (_dbc >>8));}else {_ggd =_dafb .setTwoBytes (_ggga ,_dbc );};if _ggd !=nil {return _ggd ;};};for _faa =0;_faa < _cfd ;_faa ++{_ggga =_ga +_cfd +_faa ;
_ggg =_dafb .Data [_ga +_faa ];if _ggd =_dafb .setByte (_ggga ,_ggg );_ggd !=nil {return _ggd ;};};};return nil ;};var _ Image =&NRGBA32 {};var _ _cg .Image =&Gray8 {};func _afb (_dcb *Monochrome ,_dgca int ,_ede []byte )(_bfbg *Monochrome ,_bed error ){const _abb ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _dcb ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _dgca < 1||_dgca > 4{return nil ,_d .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _dcb .Height <=1{return nil ,_d .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_bfbg =_bae (_dcb .Width /2,_dcb .Height /2);
if _ede ==nil {_ede =_beb ();};_dfge :=_gggb (_dcb .BytesPerLine ,2*_bfbg .BytesPerLine );switch _dgca {case 1:_bed =_gec (_dcb ,_bfbg ,_ede ,_dfge );case 2:_bed =_dca (_dcb ,_bfbg ,_ede ,_dfge );case 3:_bed =_ff (_dcb ,_bfbg ,_ede ,_dfge );case 4:_bed =_fcbf (_dcb ,_bfbg ,_ede ,_dfge );
};if _bed !=nil {return nil ,_bed ;};return _bfbg ,nil ;};func (_dfbf *Monochrome )Base ()*ImageBase {return &_dfbf .ImageBase };func _egfb (_ddeg RGBA ,_bacg NRGBA ,_bdga _cg .Rectangle ){for _bacee :=0;_bacee < _bdga .Max .X ;_bacee ++{for _bbbcff :=0;
_bbbcff < _bdga .Max .Y ;_bbbcff ++{_befg :=_ddeg .RGBAAt (_bacee ,_bbbcff );_bacg .SetNRGBA (_bacee ,_bbbcff ,_dbcf (_befg ));};};};type RasterOperator int ;func (_adgf *ImageBase )setTwoBytes (_bdaf int ,_efcc uint16 )error {if _bdaf +1> len (_adgf .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_adgf .Data [_bdaf ]=byte ((_efcc &0xff00)>>8);_adgf .Data [_bdaf +1]=byte (_efcc &0xff);return nil ;};var _ NRGBA =&NRGBA32 {};func (_dda *Gray8 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray8BPC (x ,y ,_dda .BytesPerLine ,_dda .Data ,_dda .Decode );
};func _dca (_dbb ,_bedd *Monochrome ,_eff []byte ,_cce int )(_eca error ){var (_fgg ,_gba ,_ad ,_dcg ,_ccd ,_ee ,_gcgg ,_fgc int ;_bcg ,_dcab ,_efg ,_faad uint32 ;_gab ,_aca byte ;_edg uint16 ;);_fde :=make ([]byte ,4);_ada :=make ([]byte ,4);for _ad =0;
_ad < _dbb .Height -1;_ad ,_dcg =_ad +2,_dcg +1{_fgg =_ad *_dbb .BytesPerLine ;_gba =_dcg *_bedd .BytesPerLine ;for _ccd ,_ee =0,0;_ccd < _cce ;_ccd ,_ee =_ccd +4,_ee +1{for _gcgg =0;_gcgg < 4;_gcgg ++{_fgc =_fgg +_ccd +_gcgg ;if _fgc <=len (_dbb .Data )-1&&_fgc < _fgg +_dbb .BytesPerLine {_fde [_gcgg ]=_dbb .Data [_fgc ];
}else {_fde [_gcgg ]=0x00;};_fgc =_fgg +_dbb .BytesPerLine +_ccd +_gcgg ;if _fgc <=len (_dbb .Data )-1&&_fgc < _fgg +(2*_dbb .BytesPerLine ){_ada [_gcgg ]=_dbb .Data [_fgc ];}else {_ada [_gcgg ]=0x00;};};_bcg =_dae .BigEndian .Uint32 (_fde );_dcab =_dae .BigEndian .Uint32 (_ada );
_efg =_bcg &_dcab ;_efg |=_efg <<1;_faad =_bcg |_dcab ;_faad &=_faad <<1;_dcab =_efg |_faad ;_dcab &=0xaaaaaaaa;_bcg =_dcab |(_dcab <<7);_gab =byte (_bcg >>24);_aca =byte ((_bcg >>8)&0xff);_fgc =_gba +_ee ;if _fgc +1==len (_bedd .Data )-1||_fgc +1>=_gba +_bedd .BytesPerLine {if _eca =_bedd .setByte (_fgc ,_eff [_gab ]);
_eca !=nil {return _g .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fgc );};}else {_edg =(uint16 (_eff [_gab ])<<8)|uint16 (_eff [_aca ]);if _eca =_bedd .setTwoBytes (_fgc ,_edg );_eca !=nil {return _g .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fgc );
};_ee ++;};};};return nil ;};var _ Image =&CMYK32 {};func _gede (_bdgc nrgba64 ,_cgcb NRGBA ,_agca _cg .Rectangle ){for _gfcc :=0;_gfcc < _agca .Max .X ;_gfcc ++{for _dgbf :=0;_dgbf < _agca .Max .Y ;_dgbf ++{_ecad :=_bdgc .NRGBA64At (_gfcc ,_dgbf );_cgcb .SetNRGBA (_gfcc ,_dgbf ,_fdb (_ecad ));
};};};func (_fga *Gray4 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_fga .Width ,Y :_fga .Height }};};func (_effc *CMYK32 )ColorModel ()_b .Model {return _b .CMYKModel };func _bgac (_bcbc *Monochrome ,_bcgg ,_ebgg ,_bcaf ,_cagc int ,_eece RasterOperator ,_bbbcf *Monochrome ,_fabcf ,_afeb int )error {if _bcbc ==nil {return _d .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _eece ==PixDst {return nil ;};switch _eece {case PixClr ,PixSet ,PixNotDst :_ccag (_bcbc ,_bcgg ,_ebgg ,_bcaf ,_cagc ,_eece );return nil ;};if _bbbcf ==nil {_gg .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _d .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _egcc :=_fcag (_bcbc ,_bcgg ,_ebgg ,_bcaf ,_cagc ,_eece ,_bbbcf ,_fabcf ,_afeb );_egcc !=nil {return _egcc ;};return nil ;};func (_gfac *NRGBA64 )SetNRGBA64 (x ,y int ,c _b .NRGBA64 ){_cadg :=(y *_gfac .Width +x )*2;
_eacf :=_cadg *3;if _eacf +5>=len (_gfac .Data ){return ;};_gfac .setNRGBA64 (_eacf ,c ,_cadg );};func (_adb *CMYK32 )Set (x ,y int ,c _b .Color ){_cgf :=4*(y *_adb .Width +x );if _cgf +3>=len (_adb .Data ){return ;};_fec :=_b .CMYKModel .Convert (c ).(_b .CMYK );
_adb .Data [_cgf ]=_fec .C ;_adb .Data [_cgf +1]=_fec .M ;_adb .Data [_cgf +2]=_fec .Y ;_adb .Data [_cgf +3]=_fec .K ;};func (_gebd *NRGBA64 )At (x ,y int )_b .Color {_cdbe ,_ :=_gebd .ColorAt (x ,y );return _cdbe };func (_edbccd *NRGBA32 )SetNRGBA (x ,y int ,c _b .NRGBA ){_gacf :=y *_edbccd .Width +x ;
_fbfg :=3*_gacf ;if _fbfg +2>=len (_edbccd .Data ){return ;};_edbccd .setRGBA (_gacf ,c );};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_daab :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _eaddb Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_eaddb =&Monochrome {ImageBase :_daab ,ModelThreshold :0x0f};case 2:_eaddb =&Gray2 {ImageBase :_daab };case 4:_eaddb =&Gray4 {ImageBase :_daab };case 8:_eaddb =&Gray8 {ImageBase :_daab };
case 16:_eaddb =&Gray16 {ImageBase :_daab };};case 3:switch bitsPerComponent {case 4:_eaddb =&NRGBA16 {ImageBase :_daab };case 8:_eaddb =&NRGBA32 {ImageBase :_daab };case 16:_eaddb =&NRGBA64 {ImageBase :_daab };};case 4:_eaddb =&CMYK32 {ImageBase :_daab };
};if _eaddb ==nil {return nil ,ErrInvalidImage ;};return _eaddb ,nil ;};func (_edf *CMYK32 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_edf .Width ,Y :_edf .Height }};};var (_acf =_bfg ();_cbe =_fcg ();_dfg =_bea (););func (_dcfg *Gray2 )GrayAt (x ,y int )_b .Gray {_gbg ,_ :=ColorAtGray2BPC (x ,y ,_dcfg .BytesPerLine ,_dcfg .Data ,_dcfg .Decode );
return _gbg ;};func _gbadf (_gcae _cg .Image )(Image ,error ){if _fefd ,_ggc :=_gcae .(*Gray2 );_ggc {return _fefd .Copy (),nil ;};_bddg :=_gcae .Bounds ();_dgdb ,_gcfeg :=NewImage (_bddg .Max .X ,_bddg .Max .Y ,2,1,nil ,nil ,nil );if _gcfeg !=nil {return nil ,_gcfeg ;
};_fbbg (_gcae ,_dgdb ,_bddg );return _dgdb ,nil ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};type colorConverter struct{_beef func (_afc _cg .Image )(Image ,error );};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;
PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;
PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;
);func (_gggg *Gray4 )At (x ,y int )_b .Color {_gacg ,_ :=_gggg .ColorAt (x ,y );return _gacg };func _ddf (_dgce _cg .Image )(Image ,error ){if _daffb ,_cged :=_dgce .(*NRGBA32 );_cged {return _daffb .Copy (),nil ;};_fccd ,_fbae ,_bedae :=_badb (_dgce ,1);
_cggf ,_dffc :=NewImage (_fccd .Max .X ,_fccd .Max .Y ,8,3,nil ,_bedae ,nil );if _dffc !=nil {return nil ,_dffc ;};_baad (_dgce ,_cggf ,_fccd );if len (_bedae )!=0&&!_fbae {if _cegc :=_cbgb (_bedae ,_cggf );_cegc !=nil {return nil ,_cegc ;};};return _cggf ,nil ;
};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _fcag (_cadd *Monochrome ,_affb ,_egeb int ,_ggcc ,_bfbgb int ,_bccb RasterOperator ,_egbd *Monochrome ,_ecag ,_agc int )error {var _ceaad ,_bcaeb ,_bbbgd ,_fdeg int ;if _affb < 0{_ecag -=_affb ;
_ggcc +=_affb ;_affb =0;};if _ecag < 0{_affb -=_ecag ;_ggcc +=_ecag ;_ecag =0;};_ceaad =_affb +_ggcc -_cadd .Width ;if _ceaad > 0{_ggcc -=_ceaad ;};_bcaeb =_ecag +_ggcc -_egbd .Width ;if _bcaeb > 0{_ggcc -=_bcaeb ;};if _egeb < 0{_agc -=_egeb ;_bfbgb +=_egeb ;
_egeb =0;};if _agc < 0{_egeb -=_agc ;_bfbgb +=_agc ;_agc =0;};_bbbgd =_egeb +_bfbgb -_cadd .Height ;if _bbbgd > 0{_bfbgb -=_bbbgd ;};_fdeg =_agc +_bfbgb -_egbd .Height ;if _fdeg > 0{_bfbgb -=_fdeg ;};if _ggcc <=0||_bfbgb <=0{return nil ;};var _bcff error ;
switch {case _affb &7==0&&_ecag &7==0:_bcff =_adcf (_cadd ,_affb ,_egeb ,_ggcc ,_bfbgb ,_bccb ,_egbd ,_ecag ,_agc );case _affb &7==_ecag &7:_bcff =_bbec (_cadd ,_affb ,_egeb ,_ggcc ,_bfbgb ,_bccb ,_egbd ,_ecag ,_agc );default:_bcff =_fecf (_cadd ,_affb ,_egeb ,_ggcc ,_bfbgb ,_bccb ,_egbd ,_ecag ,_agc );
};if _bcff !=nil {return _bcff ;};return nil ;};func (_eead *Gray16 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_eead .Width ,Y :_eead .Height }};};func _cbgb (_adcaa []byte ,_fcff Image )error {_bcca :=true ;for _accf :=0;_accf < len (_adcaa );
_accf ++{if _adcaa [_accf ]!=0xff{_bcca =false ;break ;};};if _bcca {switch _efb :=_fcff .(type ){case *NRGBA32 :_efb .Alpha =nil ;case *NRGBA64 :_efb .Alpha =nil ;default:return _g .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_fcff );
};};return nil ;};func _cabf (_geag _cg .Image )(Image ,error ){if _fccba ,_dge :=_geag .(*NRGBA64 );_dge {return _fccba .Copy (),nil ;};_bcafg ,_beg ,_adab :=_badb (_geag ,2);_agea ,_ffdb :=NewImage (_bcafg .Max .X ,_bcafg .Max .Y ,16,3,nil ,_adab ,nil );
if _ffdb !=nil {return nil ,_ffdb ;};_ffag (_geag ,_agea ,_bcafg );if len (_adab )!=0&&!_beg {if _eaf :=_cbgb (_adab ,_agea );_eaf !=nil {return nil ,_eaf ;};};return _agea ,nil ;};type NRGBA64 struct{ImageBase };func _debd (_fefb _b .NRGBA )_b .NRGBA {_fefb .R =_fefb .R >>4|(_fefb .R >>4)<<4;
_fefb .G =_fefb .G >>4|(_fefb .G >>4)<<4;_fefb .B =_fefb .B >>4|(_fefb .B >>4)<<4;return _fefb ;};func _gcac (_bgabd _b .CMYK )_b .NRGBA {_aag ,_ddda ,_gdb :=_b .CMYKToRGB (_bgabd .C ,_bgabd .M ,_bgabd .Y ,_bgabd .K );return _b .NRGBA {R :_aag ,G :_ddda ,B :_gdb ,A :0xff};
};func _bef (_efa _cg .Image )(Image ,error ){if _bbbc ,_afe :=_efa .(*CMYK32 );_afe {return _bbbc .Copy (),nil ;};_aa :=_efa .Bounds ();_gbb ,_fccc :=NewImage (_aa .Max .X ,_aa .Max .Y ,8,4,nil ,nil ,nil );if _fccc !=nil {return nil ,_fccc ;};switch _eaef :=_efa .(type ){case CMYK :_ffa (_eaef ,_gbb .(CMYK ),_aa );
case Gray :_cebf (_eaef ,_gbb .(CMYK ),_aa );case NRGBA :_bacc (_eaef ,_gbb .(CMYK ),_aa );case RGBA :_gfa (_eaef ,_gbb .(CMYK ),_aa );default:_fcaf (_efa ,_gbb ,_aa );};return _gbb ,nil ;};func _dgbb (_bcggg *Monochrome ,_dbf ,_dadf int ,_dfdb ,_ccbac int ,_faag RasterOperator ){var (_abf int ;
_bgcaa byte ;_fcad ,_bec int ;_gdfb int ;);_eggd :=_dfdb >>3;_ffde :=_dfdb &7;if _ffde > 0{_bgcaa =_addc [_ffde ];};_abf =_bcggg .BytesPerLine *_dadf +(_dbf >>3);switch _faag {case PixClr :for _fcad =0;_fcad < _ccbac ;_fcad ++{_gdfb =_abf +_fcad *_bcggg .BytesPerLine ;
for _bec =0;_bec < _eggd ;_bec ++{_bcggg .Data [_gdfb ]=0x0;_gdfb ++;};if _ffde > 0{_bcggg .Data [_gdfb ]=_cgba (_bcggg .Data [_gdfb ],0x0,_bgcaa );};};case PixSet :for _fcad =0;_fcad < _ccbac ;_fcad ++{_gdfb =_abf +_fcad *_bcggg .BytesPerLine ;for _bec =0;
_bec < _eggd ;_bec ++{_bcggg .Data [_gdfb ]=0xff;_gdfb ++;};if _ffde > 0{_bcggg .Data [_gdfb ]=_cgba (_bcggg .Data [_gdfb ],0xff,_bgcaa );};};case PixNotDst :for _fcad =0;_fcad < _ccbac ;_fcad ++{_gdfb =_abf +_fcad *_bcggg .BytesPerLine ;for _bec =0;_bec < _eggd ;
_bec ++{_bcggg .Data [_gdfb ]=^_bcggg .Data [_gdfb ];_gdfb ++;};if _ffde > 0{_bcggg .Data [_gdfb ]=_cgba (_bcggg .Data [_gdfb ],^_bcggg .Data [_gdfb ],_bgcaa );};};};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_abbf :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _abbf ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_ecfc :=width *colorComponents *bitsPerComponent ;_gebf :=_abbf *8;_cbg :=8-(_gebf -_ecfc );_efdcg :=_ba .NewReader (data );_fbeg :=_abbf -1;_efce :=make ([]byte ,_fbeg );_acde :=make ([]byte ,height *_abbf );
_badf :=_ba .NewWriterMSB (_acde );var _ccba uint64 ;var _fegd error ;for _fdea :=0;_fdea < height ;_fdea ++{_ ,_fegd =_efdcg .Read (_efce );if _fegd !=nil {return nil ,_fegd ;};_ ,_fegd =_badf .Write (_efce );if _fegd !=nil {return nil ,_fegd ;};_ccba ,_fegd =_efdcg .ReadBits (byte (_cbg ));
if _fegd !=nil {return nil ,_fegd ;};_ ,_fegd =_badf .WriteBits (_ccba ,_cbg );if _fegd !=nil {return nil ,_fegd ;};_badf .FinishByte ();};return _acde ,nil ;};func _gaea (_ccae _b .Color )_b .Color {_bcd :=_b .GrayModel .Convert (_ccae ).(_b .Gray );return _ebeg (_bcd );
};func (_gcfe *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_gcfe .ImageBase .copy (),ModelThreshold :_gcfe .ModelThreshold };};func _gdfg (_fegf int ,_bffc int )error {return _g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_fegf ,_bffc );
};func _faff (_cdd _b .NRGBA64 )_b .Gray {var _gbbe _b .NRGBA64 ;if _cdd ==_gbbe {return _b .Gray {Y :0xff};};_acg ,_dcabc ,_cege ,_ :=_cdd .RGBA ();_edeb :=(19595*_acg +38470*_dcabc +7471*_cege +1<<15)>>24;return _b .Gray {Y :uint8 (_edeb )};};func _fcbf (_afbd ,_bbcd *Monochrome ,_dfc []byte ,_gddc int )(_gcab error ){var (_ggdg ,_gccc ,_bggg ,_gecg ,_baa ,_gac ,_fad ,_fcca int ;
_ddd ,_cebb uint32 ;_cbb ,_dbd byte ;_bage uint16 ;);_fade :=make ([]byte ,4);_faba :=make ([]byte ,4);for _bggg =0;_bggg < _afbd .Height -1;_bggg ,_gecg =_bggg +2,_gecg +1{_ggdg =_bggg *_afbd .BytesPerLine ;_gccc =_gecg *_bbcd .BytesPerLine ;for _baa ,_gac =0,0;
_baa < _gddc ;_baa ,_gac =_baa +4,_gac +1{for _fad =0;_fad < 4;_fad ++{_fcca =_ggdg +_baa +_fad ;if _fcca <=len (_afbd .Data )-1&&_fcca < _ggdg +_afbd .BytesPerLine {_fade [_fad ]=_afbd .Data [_fcca ];}else {_fade [_fad ]=0x00;};_fcca =_ggdg +_afbd .BytesPerLine +_baa +_fad ;
if _fcca <=len (_afbd .Data )-1&&_fcca < _ggdg +(2*_afbd .BytesPerLine ){_faba [_fad ]=_afbd .Data [_fcca ];}else {_faba [_fad ]=0x00;};};_ddd =_dae .BigEndian .Uint32 (_fade );_cebb =_dae .BigEndian .Uint32 (_faba );_cebb &=_ddd ;_cebb &=_cebb <<1;_cebb &=0xaaaaaaaa;
_ddd =_cebb |(_cebb <<7);_cbb =byte (_ddd >>24);_dbd =byte ((_ddd >>8)&0xff);_fcca =_gccc +_gac ;if _fcca +1==len (_bbcd .Data )-1||_fcca +1>=_gccc +_bbcd .BytesPerLine {_bbcd .Data [_fcca ]=_dfc [_cbb ];if _gcab =_bbcd .setByte (_fcca ,_dfc [_cbb ]);_gcab !=nil {return _g .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fcca );
};}else {_bage =(uint16 (_dfc [_cbb ])<<8)|uint16 (_dfc [_dbd ]);if _gcab =_bbcd .setTwoBytes (_fcca ,_bage );_gcab !=nil {return _g .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fcca );
};_gac ++;};};};return nil ;};func (_faaeg *Gray4 )SetGray (x ,y int ,g _b .Gray ){if x >=_faaeg .Width ||y >=_faaeg .Height {return ;};g =_ebeg (g );_faaeg .setGray (x ,y ,g );};func _bfaf (_edefc ,_bgaa Gray ,_gedd _cg .Rectangle ){for _bafg :=0;_bafg < _gedd .Max .X ;
_bafg ++{for _dcdg :=0;_dcdg < _gedd .Max .Y ;_dcdg ++{_bgaa .SetGray (_bafg ,_dcdg ,_edefc .GrayAt (_bafg ,_dcdg ));};};};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;
};func (_deb *Gray16 )Validate ()error {if len (_deb .Data )!=_deb .Height *_deb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _ggde (_df ,_ac *Monochrome )(_dgf error ){_dgg :=_ac .BytesPerLine ;_bf :=_df .BytesPerLine ;var _af ,_bb ,_bbe ,_ecf ,_gcg int ;
for _bbe =0;_bbe < _ac .Height ;_bbe ++{_af =_bbe *_dgg ;_bb =8*_bbe *_bf ;for _ecf =0;_ecf < _dgg ;_ecf ++{if _dgf =_df .setEightBytes (_bb +_ecf *8,_dfg [_ac .Data [_af +_ecf ]]);_dgf !=nil {return _dgf ;};};for _gcg =1;_gcg < 8;_gcg ++{for _ecf =0;_ecf < _bf ;
_ecf ++{if _dgf =_df .setByte (_bb +_gcg *_bf +_ecf ,_df .Data [_bb +_ecf ]);_dgf !=nil {return _dgf ;};};};};return nil ;};type Gray16 struct{ImageBase };func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_cac :=y *bytesPerLine +x >>2;
if _cac >=len (data ){return _b .Gray {},_g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_daec :=data [_cac ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_daec =uint8 (uint32 (LinearInterpolate (float64 (_daec ),0,3.0,decode [0],decode [1]))&3);};return _b .Gray {Y :_daec *85},nil ;};func _fdfa (){for _fbef :=0;_fbef < 256;_fbef ++{_dcdgc [_fbef ]=uint8 (_fbef &0x1)+(uint8 (_fbef >>1)&0x1)+(uint8 (_fbef >>2)&0x1)+(uint8 (_fbef >>3)&0x1)+(uint8 (_fbef >>4)&0x1)+(uint8 (_fbef >>5)&0x1)+(uint8 (_fbef >>6)&0x1)+(uint8 (_fbef >>7)&0x1);
};};func (_cde *Monochrome )Histogram ()(_ced [256]int ){for _ ,_dbge :=range _cde .Data {_ced [0xff]+=int (_dcdgc [_cde .Data [_dbge ]]);};return _ced ;};func (_fcd *Monochrome )getBit (_aeb ,_edbc int )uint8 {return _fcd .Data [_aeb +(_edbc >>3)]>>uint (7-(_edbc &7))&1;
};func (_eadg *Gray4 )setGray (_bbeg int ,_ccc int ,_ccde _b .Gray ){_bdg :=_ccc *_eadg .BytesPerLine ;_dea :=_bdg +(_bbeg >>1);if _dea >=len (_eadg .Data ){return ;};_ecgb :=_ccde .Y >>4;_eadg .Data [_dea ]=(_eadg .Data [_dea ]&(^(0xf0>>uint (4*(_bbeg &1)))))|(_ecgb <<uint (4-4*(_bbeg &1)));
};func _gbea (_dfdg ,_eeg NRGBA ,_fgcg _cg .Rectangle ){for _gage :=0;_gage < _fgcg .Max .X ;_gage ++{for _bacb :=0;_bacb < _fgcg .Max .Y ;_bacb ++{_eeg .SetNRGBA (_gage ,_bacb ,_dfdg .NRGBAAt (_gage ,_bacb ));};};};func _fcaf (_fdc _cg .Image ,_bab Image ,_fda _cg .Rectangle ){for _abd :=0;
_abd < _fda .Max .X ;_abd ++{for _gcbe :=0;_gcbe < _fda .Max .Y ;_gcbe ++{_aae :=_fdc .At (_abd ,_gcbe );_bab .Set (_abd ,_gcbe ,_aae );};};};func GrayHistogram (g Gray )(_acacc [256]int ){switch _fedc :=g .(type ){case Histogramer :return _fedc .Histogram ();
case _cg .Image :_bbab :=_fedc .Bounds ();for _dcdgcb :=0;_dcdgcb < _bbab .Max .X ;_dcdgcb ++{for _cdeb :=0;_cdeb < _bbab .Max .Y ;_cdeb ++{_acacc [g .GrayAt (_dcdgcb ,_cdeb ).Y ]++;};};return _acacc ;default:return [256]int {};};};func (_gaaf *Gray2 )Base ()*ImageBase {return &_gaaf .ImageBase };
func (_edba monochromeModel )Convert (c _b .Color )_b .Color {_gfcd :=_b .GrayModel .Convert (c ).(_b .Gray );return _dde (_gfcd ,_edba );};func _fecf (_aacb *Monochrome ,_adcg ,_dggc ,_aba ,_deaf int ,_cedc RasterOperator ,_agabg *Monochrome ,_aade ,_bged int )error {var (_dcba bool ;
_fgag bool ;_cbcf byte ;_adca int ;_eccc int ;_gfga int ;_eeee int ;_gaff bool ;_gbbb int ;_cfed int ;_fabb int ;_dedc bool ;_cefa byte ;_fbgg int ;_bgabb int ;_eba int ;_fceb byte ;_dbaa int ;_bgfd int ;_beea uint ;_efceg uint ;_fabg byte ;_cfegd shift ;
_dfe bool ;_fdfg bool ;_acec ,_cfgd int ;);if _aade &7!=0{_bgfd =8-(_aade &7);};if _adcg &7!=0{_eccc =8-(_adcg &7);};if _bgfd ==0&&_eccc ==0{_fabg =_eacc [0];}else {if _eccc > _bgfd {_beea =uint (_eccc -_bgfd );}else {_beea =uint (8-(_bgfd -_eccc ));};
_efceg =8-_beea ;_fabg =_eacc [_beea ];};if (_adcg &7)!=0{_dcba =true ;_adca =8-(_adcg &7);_cbcf =_eacc [_adca ];_gfga =_aacb .BytesPerLine *_dggc +(_adcg >>3);_eeee =_agabg .BytesPerLine *_bged +(_aade >>3);_dbaa =8-(_aade &7);if _adca > _dbaa {_cfegd =_babag ;
if _aba >=_bgfd {_dfe =true ;};}else {_cfegd =_dggca ;};};if _aba < _adca {_fgag =true ;_cbcf &=_addc [8-_adca +_aba ];};if !_fgag {_gbbb =(_aba -_adca )>>3;if _gbbb !=0{_gaff =true ;_cfed =_aacb .BytesPerLine *_dggc +((_adcg +_eccc )>>3);_fabb =_agabg .BytesPerLine *_bged +((_aade +_eccc )>>3);
};};_fbgg =(_adcg +_aba )&7;if !(_fgag ||_fbgg ==0){_dedc =true ;_cefa =_addc [_fbgg ];_bgabb =_aacb .BytesPerLine *_dggc +((_adcg +_eccc )>>3)+_gbbb ;_eba =_agabg .BytesPerLine *_bged +((_aade +_eccc )>>3)+_gbbb ;if _fbgg > int (_efceg ){_fdfg =true ;
};};switch _cedc {case PixSrc :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;
};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],_fceb ,_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );
_aacb .Data [_cfed +_cfgd ]=_fceb ;};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );
};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],_fceb ,_cefa );_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;};};case PixNotSrc :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );
};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],^_fceb ,_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;_cfgd < _gbbb ;
_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]=^_fceb ;};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;
if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],^_fceb ,_cefa );_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;};};case PixSrcOrDst :if _dcba {for _acec =0;_acec < _deaf ;
_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],_fceb |_aacb .Data [_gfga ],_cbcf );
_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]|=_fceb ;
};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],_fceb |_aacb .Data [_bgabb ],_cefa );
_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;};};case PixSrcAndDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );
};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],_fceb &_aacb .Data [_gfga ],_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;
_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]&=_fceb ;};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;
_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],_fceb &_aacb .Data [_bgabb ],_cefa );_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;
};};case PixSrcXorDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],_fceb ^_aacb .Data [_gfga ],_cbcf );
_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]^=_fceb ;
};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],_fceb ^_aacb .Data [_bgabb ],_cefa );
_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;};};case PixNotSrcOrDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );
};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],^_fceb |_aacb .Data [_gfga ],_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;
_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]|=^_fceb ;};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;
_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],^_fceb |_aacb .Data [_bgabb ],_cefa );_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;
};};case PixNotSrcAndDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],^_fceb &_aacb .Data [_gfga ],_cbcf );
_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]&=^_fceb ;
};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],^_fceb &_aacb .Data [_bgabb ],_cefa );
_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;};};case PixSrcOrNotDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );
};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],_fceb |^_aacb .Data [_gfga ],_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;
_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]=_fceb |^_aacb .Data [_cfed +_cfgd ];};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};
if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],_fceb |^_aacb .Data [_bgabb ],_cefa );_bgabb +=_aacb .BytesPerLine ;
_eba +=_agabg .BytesPerLine ;};};case PixSrcAndNotDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;
};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],_fceb &^_aacb .Data [_gfga ],_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );
_aacb .Data [_cfed +_cfgd ]=_fceb &^_aacb .Data [_cfed +_cfgd ];};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );
};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],_fceb &^_aacb .Data [_bgabb ],_cefa );_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;};};case PixNotPixSrcOrDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;
if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],^(_fceb |_aacb .Data [_gfga ]),_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;
};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]=^(_fceb |_aacb .Data [_cfed +_cfgd ]);
};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],^(_fceb |_aacb .Data [_bgabb ]),_cefa );
_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;};};case PixNotPixSrcAndDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );
};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],^(_fceb &_aacb .Data [_gfga ]),_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;
_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );_aacb .Data [_cfed +_cfgd ]=^(_fceb &_aacb .Data [_cfed +_cfgd ]);};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};
};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],^(_fceb &_aacb .Data [_bgabb ]),_cefa );_bgabb +=_aacb .BytesPerLine ;
_eba +=_agabg .BytesPerLine ;};};case PixNotPixSrcXorDst :if _dcba {for _acec =0;_acec < _deaf ;_acec ++{if _cfegd ==_babag {_fceb =_agabg .Data [_eeee ]<<_beea ;if _dfe {_fceb =_cgba (_fceb ,_agabg .Data [_eeee +1]>>_efceg ,_fabg );};}else {_fceb =_agabg .Data [_eeee ]>>_efceg ;
};_aacb .Data [_gfga ]=_cgba (_aacb .Data [_gfga ],^(_fceb ^_aacb .Data [_gfga ]),_cbcf );_gfga +=_aacb .BytesPerLine ;_eeee +=_agabg .BytesPerLine ;};};if _gaff {for _acec =0;_acec < _deaf ;_acec ++{for _cfgd =0;_cfgd < _gbbb ;_cfgd ++{_fceb =_cgba (_agabg .Data [_fabb +_cfgd ]<<_beea ,_agabg .Data [_fabb +_cfgd +1]>>_efceg ,_fabg );
_aacb .Data [_cfed +_cfgd ]=^(_fceb ^_aacb .Data [_cfed +_cfgd ]);};_cfed +=_aacb .BytesPerLine ;_fabb +=_agabg .BytesPerLine ;};};if _dedc {for _acec =0;_acec < _deaf ;_acec ++{_fceb =_agabg .Data [_eba ]<<_beea ;if _fdfg {_fceb =_cgba (_fceb ,_agabg .Data [_eba +1]>>_efceg ,_fabg );
};_aacb .Data [_bgabb ]=_cgba (_aacb .Data [_bgabb ],^(_fceb ^_aacb .Data [_bgabb ]),_cefa );_bgabb +=_aacb .BytesPerLine ;_eba +=_agabg .BytesPerLine ;};};default:_gg .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_cedc );
return _d .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_acff :=y *bytesPerLine +x ;
if _acff >=len (data ){return _b .Gray {},_g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_agabd :=data [_acff ];if len (decode )==2{_agabd =uint8 (uint32 (LinearInterpolate (float64 (_agabd ),0,255,decode [0],decode [1]))&0xff);};return _b .Gray {Y :_agabd },nil ;};func (_gfed *Gray8 )Set (x ,y int ,c _b .Color ){_gce :=y *_gfed .BytesPerLine +x ;
if _gce > len (_gfed .Data )-1{return ;};_eddf :=_b .GrayModel .Convert (c );_gfed .Data [_gce ]=_eddf .(_b .Gray ).Y ;};var _ Image =&Gray8 {};func (_bfbga *Gray16 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray16BPC (x ,y ,_bfbga .BytesPerLine ,_bfbga .Data ,_bfbga .Decode );
};func _acafd (_fbd ,_bgfdf uint8 )uint8 {if _fbd < _bgfdf {return 255;};return 0;};func _gedec (_cfab uint8 )bool {if _cfab ==0||_cfab ==255{return true ;};return false ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func _facd (_fdae *Monochrome ,_eag ,_abdgf int ,_gbde ,_bddb int ,_adba RasterOperator ){var (_gff bool ;_accb bool ;_dcgb int ;_deg int ;_fedd int ;_eddfa int ;_bfgb bool ;_bgbe byte ;);_fbeb :=8-(_eag &7);_gbe :=_eacc [_fbeb ];_fgea :=_fdae .BytesPerLine *_abdgf +(_eag >>3);
if _gbde < _fbeb {_gff =true ;_gbe &=_addc [8-_fbeb +_gbde ];};if !_gff {_dcgb =(_gbde -_fbeb )>>3;if _dcgb !=0{_accb =true ;_deg =_fgea +1;};};_fedd =(_eag +_gbde )&7;if !(_gff ||_fedd ==0){_bfgb =true ;_bgbe =_addc [_fedd ];_eddfa =_fgea +1+_dcgb ;};
var _dbgg ,_gffa int ;switch _adba {case PixClr :for _dbgg =0;_dbgg < _bddb ;_dbgg ++{_fdae .Data [_fgea ]=_cgba (_fdae .Data [_fgea ],0x0,_gbe );_fgea +=_fdae .BytesPerLine ;};if _accb {for _dbgg =0;_dbgg < _bddb ;_dbgg ++{for _gffa =0;_gffa < _dcgb ;
_gffa ++{_fdae .Data [_deg +_gffa ]=0x0;};_deg +=_fdae .BytesPerLine ;};};if _bfgb {for _dbgg =0;_dbgg < _bddb ;_dbgg ++{_fdae .Data [_eddfa ]=_cgba (_fdae .Data [_eddfa ],0x0,_bgbe );_eddfa +=_fdae .BytesPerLine ;};};case PixSet :for _dbgg =0;_dbgg < _bddb ;
_dbgg ++{_fdae .Data [_fgea ]=_cgba (_fdae .Data [_fgea ],0xff,_gbe );_fgea +=_fdae .BytesPerLine ;};if _accb {for _dbgg =0;_dbgg < _bddb ;_dbgg ++{for _gffa =0;_gffa < _dcgb ;_gffa ++{_fdae .Data [_deg +_gffa ]=0xff;};_deg +=_fdae .BytesPerLine ;};};if _bfgb {for _dbgg =0;
_dbgg < _bddb ;_dbgg ++{_fdae .Data [_eddfa ]=_cgba (_fdae .Data [_eddfa ],0xff,_bgbe );_eddfa +=_fdae .BytesPerLine ;};};case PixNotDst :for _dbgg =0;_dbgg < _bddb ;_dbgg ++{_fdae .Data [_fgea ]=_cgba (_fdae .Data [_fgea ],^_fdae .Data [_fgea ],_gbe );
_fgea +=_fdae .BytesPerLine ;};if _accb {for _dbgg =0;_dbgg < _bddb ;_dbgg ++{for _gffa =0;_gffa < _dcgb ;_gffa ++{_fdae .Data [_deg +_gffa ]=^(_fdae .Data [_deg +_gffa ]);};_deg +=_fdae .BytesPerLine ;};};if _bfgb {for _dbgg =0;_dbgg < _bddb ;_dbgg ++{_fdae .Data [_eddfa ]=_cgba (_fdae .Data [_eddfa ],^_fdae .Data [_eddfa ],_bgbe );
_eddfa +=_fdae .BytesPerLine ;};};};};type Gray8 struct{ImageBase };func (_acc *Monochrome )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray1BPC (x ,y ,_acc .BytesPerLine ,_acc .Data ,_acc .Decode );};func (_cfdg *ImageBase )HasAlpha ()bool {if _cfdg .Alpha ==nil {return false ;
};for _agdfc :=range _cfdg .Alpha {if _cfdg .Alpha [_agdfc ]!=0xff{return true ;};};return false ;};var (MonochromeConverter =ConverterFunc (_efgf );Gray2Converter =ConverterFunc (_gbadf );Gray4Converter =ConverterFunc (_bagb );GrayConverter =ConverterFunc (_dce );
Gray16Converter =ConverterFunc (_dac );NRGBA16Converter =ConverterFunc (_ccea );NRGBAConverter =ConverterFunc (_ddf );NRGBA64Converter =ConverterFunc (_cabf );CMYKConverter =ConverterFunc (_bef ););func (_aefb *Gray8 )SetGray (x ,y int ,g _b .Gray ){_fdcf :=y *_aefb .BytesPerLine +x ;
if _fdcf > len (_aefb .Data )-1{return ;};_aefb .Data [_fdcf ]=g .Y ;};func (_ffg *NRGBA16 )Set (x ,y int ,c _b .Color ){_gbae :=y *_ffg .BytesPerLine +x *3/2;if _gbae +1>=len (_ffg .Data ){return ;};_befd :=NRGBA16Model .Convert (c ).(_b .NRGBA );_ffg .setNRGBA (x ,y ,_gbae ,_befd );
};func (_ecge *NRGBA64 )Base ()*ImageBase {return &_ecge .ImageBase };func (_addd *NRGBA16 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA16 (x ,y ,_addd .Width ,_addd .BytesPerLine ,_addd .Data ,_addd .Alpha ,_addd .Decode );};type Histogramer interface{Histogram ()[256]int ;
};func (_ffee *ImageBase )newAlpha (){_def :=BytesPerLine (_ffee .Width ,_ffee .BitsPerComponent ,1);_ffee .Alpha =make ([]byte ,_ffee .Height *_def );};func (_fega *NRGBA64 )Validate ()error {if len (_fega .Data )!=3*2*_fega .Width *_fega .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func IsGrayImgBlackAndWhite (i *_cg .Gray )bool {return _bcbde (i )};func (_bcbe *NRGBA64 )Set (x ,y int ,c _b .Color ){_facde :=(y *_bcbe .Width +x )*2;_bdeg :=_facde *3;if _bdeg +5>=len (_bcbe .Data ){return ;};_efba :=_b .NRGBA64Model .Convert (c ).(_b .NRGBA64 );
_bcbe .setNRGBA64 (_bdeg ,_efba ,_facde );};func (_bbgf *Gray4 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray4BPC (x ,y ,_bbgf .BytesPerLine ,_bbgf .Data ,_bbgf .Decode );};func _fedb (_daaf Gray ,_gcfd NRGBA ,_bfaa _cg .Rectangle ){for _dedf :=0;
_dedf < _bfaa .Max .X ;_dedf ++{for _gdaa :=0;_gdaa < _bfaa .Max .Y ;_gdaa ++{_bfeb :=_daaf .GrayAt (_dedf ,_gdaa );_gcfd .SetNRGBA (_dedf ,_gdaa ,_dddg (_bfeb ));};};};func ImgToBinary (i _cg .Image ,threshold uint8 )*_cg .Gray {switch _befgf :=i .(type ){case *_cg .Gray :if _bcbde (_befgf ){return _befgf ;
};return _aede (_befgf ,threshold );case *_cg .Gray16 :return _bgbb (_befgf ,threshold );default:return _begf (_befgf ,threshold );};};func (_afge colorConverter )Convert (src _cg .Image )(Image ,error ){return _afge ._beef (src )};func _gaac (_aeea CMYK ,_fccg Gray ,_gdeb _cg .Rectangle ){for _bcebe :=0;
_bcebe < _gdeb .Max .X ;_bcebe ++{for _caa :=0;_caa < _gdeb .Max .Y ;_caa ++{_bagc :=_bgabe (_aeea .CMYKAt (_bcebe ,_caa ));_fccg .SetGray (_bcebe ,_caa ,_bagc );};};};var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func _ff (_ccg ,_bbgg *Monochrome ,_ebb []byte ,_ceg int )(_cae error ){var (_gdcf ,_ggf ,_dgcd ,_afbf ,_abbb ,_fba ,_faf ,_age int ;_fdg ,_cgc ,_afg ,_ggff uint32 ;_afbc ,_cbeg byte ;_gca uint16 ;);_ceb :=make ([]byte ,4);_gdda :=make ([]byte ,4);for _dgcd =0;
_dgcd < _ccg .Height -1;_dgcd ,_afbf =_dgcd +2,_afbf +1{_gdcf =_dgcd *_ccg .BytesPerLine ;_ggf =_afbf *_bbgg .BytesPerLine ;for _abbb ,_fba =0,0;_abbb < _ceg ;_abbb ,_fba =_abbb +4,_fba +1{for _faf =0;_faf < 4;_faf ++{_age =_gdcf +_abbb +_faf ;if _age <=len (_ccg .Data )-1&&_age < _gdcf +_ccg .BytesPerLine {_ceb [_faf ]=_ccg .Data [_age ];
}else {_ceb [_faf ]=0x00;};_age =_gdcf +_ccg .BytesPerLine +_abbb +_faf ;if _age <=len (_ccg .Data )-1&&_age < _gdcf +(2*_ccg .BytesPerLine ){_gdda [_faf ]=_ccg .Data [_age ];}else {_gdda [_faf ]=0x00;};};_fdg =_dae .BigEndian .Uint32 (_ceb );_cgc =_dae .BigEndian .Uint32 (_gdda );
_afg =_fdg &_cgc ;_afg |=_afg <<1;_ggff =_fdg |_cgc ;_ggff &=_ggff <<1;_cgc =_afg &_ggff ;_cgc &=0xaaaaaaaa;_fdg =_cgc |(_cgc <<7);_afbc =byte (_fdg >>24);_cbeg =byte ((_fdg >>8)&0xff);_age =_ggf +_fba ;if _age +1==len (_bbgg .Data )-1||_age +1>=_ggf +_bbgg .BytesPerLine {if _cae =_bbgg .setByte (_age ,_ebb [_afbc ]);
_cae !=nil {return _g .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_age );};}else {_gca =(uint16 (_ebb [_afbc ])<<8)|uint16 (_ebb [_cbeg ]);if _cae =_bbgg .setTwoBytes (_age ,_gca );_cae !=nil {return _g .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_age );
};_fba ++;};};};return nil ;};func _fbbg (_cfcf _cg .Image ,_fggee Image ,_gfca _cg .Rectangle ){switch _gdeaa :=_cfcf .(type ){case Gray :_bfaf (_gdeaa ,_fggee .(Gray ),_gfca );case NRGBA :_fcge (_gdeaa ,_fggee .(Gray ),_gfca );case CMYK :_gaac (_gdeaa ,_fggee .(Gray ),_gfca );
case RGBA :_cddd (_gdeaa ,_fggee .(Gray ),_gfca );default:_fcaf (_cfcf ,_fggee .(Image ),_gfca );};};func (_bbce *Gray2 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_bbce .Width ,Y :_bbce .Height }};};func (_ceef *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_ceef .copy ()}};
func (_ddb *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_d .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_cgb :=_bae (width ,height );_cecc :=make ([]int ,height );_dbdd :=make ([]int ,width );_egc :=float64 (_ddb .Width )/float64 (width );_dbbd :=float64 (_ddb .Height )/float64 (height );for _ggffe :=0;_ggffe < height ;_ggffe ++{_cecc [_ggffe ]=int (_e .Min (_dbbd *float64 (_ggffe )+0.5,float64 (_ddb .Height -1)));
};for _bfc :=0;_bfc < width ;_bfc ++{_dbdd [_bfc ]=int (_e .Min (_egc *float64 (_bfc )+0.5,float64 (_ddb .Width -1)));};_ecg :=-1;_ddce :=byte (0);for _ceaa :=0;_ceaa < height ;_ceaa ++{_eccg :=_cecc [_ceaa ]*_ddb .BytesPerLine ;_cade :=_ceaa *_cgb .BytesPerLine ;
for _cceb :=0;_cceb < width ;_cceb ++{_fccb :=_dbdd [_cceb ];if _fccb !=_ecg {_ddce =_ddb .getBit (_eccg ,_fccb );if _ddce !=0{_cgb .setBit (_cade ,_cceb );};_ecg =_fccb ;}else {if _ddce !=0{_cgb .setBit (_cade ,_cceb );};};};};return _cgb ,nil ;};func _dga (_eedd _b .NRGBA )_b .CMYK {_gggc ,_gcbd ,_agg ,_ :=_eedd .RGBA ();
_abg ,_befb ,_aed ,_egbf :=_b .RGBToCMYK (uint8 (_gggc >>8),uint8 (_gcbd >>8),uint8 (_agg >>8));return _b .CMYK {C :_abg ,M :_befb ,Y :_aed ,K :_egbf };};type nrgba64 interface{NRGBA64At (_ggeb ,_gdead int )_b .NRGBA64 ;SetNRGBA64 (_faea ,_cfba int ,_abdec _b .NRGBA64 );
};func _beac (_bbf int )[]uint {var _cdb []uint ;_ae :=_bbf ;_dab :=_ae /8;if _dab !=0{for _dd :=0;_dd < _dab ;_dd ++{_cdb =append (_cdb ,8);};_abe :=_ae %8;_ae =0;if _abe !=0{_ae =_abe ;};};_egef :=_ae /4;if _egef !=0{for _geb :=0;_geb < _egef ;_geb ++{_cdb =append (_cdb ,4);
};_ggag :=_ae %4;_ae =0;if _ggag !=0{_ae =_ggag ;};};_cba :=_ae /2;if _cba !=0{for _agb :=0;_agb < _cba ;_agb ++{_cdb =append (_cdb ,2);};};return _cdb ;};func (_gbfef *NRGBA32 )At (x ,y int )_b .Color {_gega ,_ :=_gbfef .ColorAt (x ,y );return _gega };
func _dbcf (_aea _b .RGBA )_b .NRGBA {switch _aea .A {case 0xff:return _b .NRGBA {R :_aea .R ,G :_aea .G ,B :_aea .B ,A :0xff};case 0x00:return _b .NRGBA {};default:_cbdf ,_fgfe ,_fce ,_ebga :=_aea .RGBA ();_cbdf =(_cbdf *0xffff)/_ebga ;_fgfe =(_fgfe *0xffff)/_ebga ;
_fce =(_fce *0xffff)/_ebga ;return _b .NRGBA {R :uint8 (_cbdf >>8),G :uint8 (_fgfe >>8),B :uint8 (_fce >>8),A :uint8 (_ebga >>8)};};};func (_dafg *CMYK32 )Validate ()error {if len (_dafg .Data )!=4*_dafg .Width *_dafg .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fgfc *Gray8 )Validate ()error {if len (_fgfc .Data )!=_fgfc .Height *_fgfc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_egbb *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_egbb .copy ()}};func (_ebca *Monochrome )setIndexedBit (_edd int ){_ebca .Data [(_edd >>3)]|=0x80>>uint (_edd &7)};
func _ecb (_dfd _b .Gray )_b .CMYK {return _b .CMYK {K :0xff-_dfd .Y }};var _ NRGBA =&NRGBA16 {};type monochromeModel uint8 ;func _bbec (_cefe *Monochrome ,_dfcfb ,_faeb ,_ddgd ,_dbddf int ,_ggaf RasterOperator ,_bgef *Monochrome ,_ebea ,_fbfcg int )error {var (_fgfcc bool ;
_gagf bool ;_gabb int ;_abeb int ;_debe int ;_affa bool ;_abdg byte ;_bgdf int ;_cfb int ;_fbad int ;_ggcg ,_acfe int ;);_cdff :=8-(_dfcfb &7);_ace :=_eacc [_cdff ];_agdad :=_cefe .BytesPerLine *_faeb +(_dfcfb >>3);_fdag :=_bgef .BytesPerLine *_fbfcg +(_ebea >>3);
if _ddgd < _cdff {_fgfcc =true ;_ace &=_addc [8-_cdff +_ddgd ];};if !_fgfcc {_gabb =(_ddgd -_cdff )>>3;if _gabb > 0{_gagf =true ;_abeb =_agdad +1;_debe =_fdag +1;};};_bgdf =(_dfcfb +_ddgd )&7;if !(_fgfcc ||_bgdf ==0){_affa =true ;_abdg =_addc [_bgdf ];
_cfb =_agdad +1+_gabb ;_fbad =_fdag +1+_gabb ;};switch _ggaf {case PixSrc :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],_bgef .Data [_fdag ],_ace );_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;};
if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]=_bgef .Data [_debe +_acfe ];};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],_bgef .Data [_fbad ],_abdg );
_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixNotSrc :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],^_bgef .Data [_fdag ],_ace );_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;
};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]=^_bgef .Data [_debe +_acfe ];};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],^_bgef .Data [_fbad ],_abdg );
_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixSrcOrDst :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],_bgef .Data [_fdag ]|_cefe .Data [_agdad ],_ace );_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;
};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]|=_bgef .Data [_debe +_acfe ];};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],_bgef .Data [_fbad ]|_cefe .Data [_cfb ],_abdg );
_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixSrcAndDst :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],_bgef .Data [_fdag ]&_cefe .Data [_agdad ],_ace );_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;
};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]&=_bgef .Data [_debe +_acfe ];};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],_bgef .Data [_fbad ]&_cefe .Data [_cfb ],_abdg );
_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixSrcXorDst :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],_bgef .Data [_fdag ]^_cefe .Data [_agdad ],_ace );_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;
};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]^=_bgef .Data [_debe +_acfe ];};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],_bgef .Data [_fbad ]^_cefe .Data [_cfb ],_abdg );
_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixNotSrcOrDst :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],^(_bgef .Data [_fdag ])|_cefe .Data [_agdad ],_ace );_agdad +=_cefe .BytesPerLine ;
_fdag +=_bgef .BytesPerLine ;};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]|=^(_bgef .Data [_debe +_acfe ]);};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;
_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],^(_bgef .Data [_fbad ])|_cefe .Data [_cfb ],_abdg );_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixNotSrcAndDst :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],^(_bgef .Data [_fdag ])&_cefe .Data [_agdad ],_ace );
_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]&=^_bgef .Data [_debe +_acfe ];};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;
};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],^(_bgef .Data [_fbad ])&_cefe .Data [_cfb ],_abdg );_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixSrcOrNotDst :for _ggcg =0;_ggcg < _dbddf ;
_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],_bgef .Data [_fdag ]|^(_cefe .Data [_agdad ]),_ace );_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]=_bgef .Data [_debe +_acfe ]|^(_cefe .Data [_abeb +_acfe ]);
};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],_bgef .Data [_fbad ]|^(_cefe .Data [_cfb ]),_abdg );_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;
};};case PixSrcAndNotDst :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],_bgef .Data [_fdag ]&^(_cefe .Data [_agdad ]),_ace );_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;};if _gagf {for _ggcg =0;
_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]=_bgef .Data [_debe +_acfe ]&^(_cefe .Data [_abeb +_acfe ]);};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;
_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],_bgef .Data [_fbad ]&^(_cefe .Data [_cfb ]),_abdg );_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixNotPixSrcOrDst :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],^(_bgef .Data [_fdag ]|_cefe .Data [_agdad ]),_ace );
_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]=^(_bgef .Data [_debe +_acfe ]|_cefe .Data [_abeb +_acfe ]);};_abeb +=_cefe .BytesPerLine ;
_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],^(_bgef .Data [_fbad ]|_cefe .Data [_cfb ]),_abdg );_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixNotPixSrcAndDst :for _ggcg =0;
_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],^(_bgef .Data [_fdag ]&_cefe .Data [_agdad ]),_ace );_agdad +=_cefe .BytesPerLine ;_fdag +=_bgef .BytesPerLine ;};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;
_acfe ++{_cefe .Data [_abeb +_acfe ]=^(_bgef .Data [_debe +_acfe ]&_cefe .Data [_abeb +_acfe ]);};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],^(_bgef .Data [_fbad ]&_cefe .Data [_cfb ]),_abdg );
_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};case PixNotPixSrcXorDst :for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_agdad ]=_cgba (_cefe .Data [_agdad ],^(_bgef .Data [_fdag ]^_cefe .Data [_agdad ]),_ace );_agdad +=_cefe .BytesPerLine ;
_fdag +=_bgef .BytesPerLine ;};if _gagf {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{for _acfe =0;_acfe < _gabb ;_acfe ++{_cefe .Data [_abeb +_acfe ]=^(_bgef .Data [_debe +_acfe ]^_cefe .Data [_abeb +_acfe ]);};_abeb +=_cefe .BytesPerLine ;_debe +=_bgef .BytesPerLine ;
};};if _affa {for _ggcg =0;_ggcg < _dbddf ;_ggcg ++{_cefe .Data [_cfb ]=_cgba (_cefe .Data [_cfb ],^(_bgef .Data [_fbad ]^_cefe .Data [_cfb ]),_abdg );_cfb +=_cefe .BytesPerLine ;_fbad +=_bgef .BytesPerLine ;};};default:_gg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_ggaf );
return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA ,error ){_cefee :=y *bytesPerLine +x *3/2;
if _cefee +1>=len (data ){return _b .NRGBA {},_gdfg (x ,y );};const (_bgcf =0xf;_cabc =uint8 (0xff););_cgce :=_cabc ;if alpha !=nil {_cacb :=y *BytesPerLine (width ,4,1);if _cacb < len (alpha ){if x %2==0{_cgce =(alpha [_cacb ]>>uint (4))&_bgcf ;}else {_cgce =alpha [_cacb ]&_bgcf ;
};_cgce |=_cgce <<4;};};var _bdb ,_dcdga ,_agef uint8 ;if x *3%2==0{_bdb =(data [_cefee ]>>uint (4))&_bgcf ;_dcdga =data [_cefee ]&_bgcf ;_agef =(data [_cefee +1]>>uint (4))&_bgcf ;}else {_bdb =data [_cefee ]&_bgcf ;_dcdga =(data [_cefee +1]>>uint (4))&_bgcf ;
_agef =data [_cefee +1]&_bgcf ;};if len (decode )==6{_bdb =uint8 (uint32 (LinearInterpolate (float64 (_bdb ),0,15,decode [0],decode [1]))&0xf);_dcdga =uint8 (uint32 (LinearInterpolate (float64 (_dcdga ),0,15,decode [2],decode [3]))&0xf);_agef =uint8 (uint32 (LinearInterpolate (float64 (_agef ),0,15,decode [4],decode [5]))&0xf);
};return _b .NRGBA {R :(_bdb <<4)|(_bdb &0xf),G :(_dcdga <<4)|(_dcdga &0xf),B :(_agef <<4)|(_agef &0xf),A :_cgce },nil ;};func _aee (_dbcb ,_ded int ,_fcc []byte )*Monochrome {_gad :=_bae (_dbcb ,_ded );_gad .Data =_fcc ;return _gad ;};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bgac (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};var _ Gray =&Gray4 {};func _gcf (_afd _b .NRGBA )_b .Gray {var _bfgga _b .NRGBA ;if _afd ==_bfgga {return _b .Gray {Y :0xff};};_ebbb ,_aga ,_eec ,_ :=_afd .RGBA ();_fgb :=(19595*_ebbb +38470*_aga +7471*_eec +1<<15)>>24;return _b .Gray {Y :uint8 (_fgb )};
};type Gray interface{GrayAt (_gfdc ,_cda int )_b .Gray ;SetGray (_fbec ,_bfd int ,_dfa _b .Gray );};func _efd (_gbab Gray ,_eeec nrgba64 ,_ccgg _cg .Rectangle ){for _ddcb :=0;_ddcb < _ccgg .Max .X ;_ddcb ++{for _ccgb :=0;_ccgb < _ccgg .Max .Y ;_ccgb ++{_fcbg :=_faff (_eeec .NRGBA64At (_ddcb ,_ccgb ));
_gbab .SetGray (_ddcb ,_ccgb ,_fcbg );};};};func (_dfagd *NRGBA64 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dfagd .Width ,_dfagd .Data ,_dfagd .Alpha ,_dfagd .Decode );};var _ Image =&Monochrome {};func (_eae *CMYK32 )CMYKAt (x ,y int )_b .CMYK {_bdfd ,_ :=ColorAtCMYK (x ,y ,_eae .Width ,_eae .Data ,_eae .Decode );
return _bdfd ;};func (_afca *NRGBA64 )NRGBA64At (x ,y int )_b .NRGBA64 {_fccbf ,_ :=ColorAtNRGBA64 (x ,y ,_afca .Width ,_afca .Data ,_afca .Alpha ,_afca .Decode );return _fccbf ;};type RGBA interface{RGBAAt (_fabd ,_gbdg int )_b .RGBA ;SetRGBA (_gge ,_dbda int ,_fdcg _b .RGBA );
};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_b .CMYK ,error ){_eee :=4*(y *width +x );if _eee +3>=len (data ){return _b .CMYK {},_g .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_eee ]&0xff;M :=data [_eee +1]&0xff;Y :=data [_eee +2]&0xff;K :=data [_eee +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _b .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_ddbc *Monochrome )setBit (_afgg ,_cgbe int ){_ddbc .Data [_afgg +(_cgbe >>3)]|=0x80>>uint (_cgbe &7);
};