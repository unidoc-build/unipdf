//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_d "errors";_ef "fmt";_efa "github.com/unidoc/unipdf/v3/internal/bitwise";_dd "image";_a "image/color";_f "image/draw";_b "math";);func (_abc *Gray8 )ColorModel ()_a .Model {return _a .GrayModel };func (_feba *NRGBA64 )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_feba .Width ,Y :_feba .Height }};};func (_bfbd *Gray2 )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_bfbd .Width ,Y :_bfbd .Height }};};type Gray8 struct{ImageBase };type NRGBA interface{NRGBAAt (_eecb ,_dbcf int )_a .NRGBA ;SetNRGBA (_dfa ,_cbb int ,_bgfc _a .NRGBA );};func _cfe (_afg _a .NRGBA )_a .Gray {_bbgf ,_ade ,_ecb ,_ :=_afg .RGBA ();_adg :=(19595*_bbgf +38470*_ade +7471*_ecb +1<<15)>>24;return _a .Gray {Y :uint8 (_adg )};};type Histogramer interface{Histogram ()[256]int ;};func _bdfc (_bgeb *_dd .Gray16 ,_ggcd uint8 )*_dd .Gray {_aege :=_bgeb .Bounds ();_cdcf :=_dd .NewGray (_aege );for _fgf :=0;_fgf < _aege .Dx ();_fgf ++{for _aeda :=0;_aeda < _aege .Dy ();_aeda ++{_fgb :=_bgeb .Gray16At (_fgf ,_aeda );_cdcf .SetGray (_fgf ,_aeda ,_a .Gray {Y :_bba (uint8 (_fgb .Y /256),_ggcd )});};};return _cdcf ;};func _fee (_bbfa _dd .Image )(Image ,error ){if _ddeg ,_ffgb :=_bbfa .(*NRGBA16 );_ffgb {return _ddeg .Copy (),nil ;};_cdcdc :=_bbfa .Bounds ();_cbf ,_edb :=NewImage (_cdcdc .Max .X ,_cdcdc .Max .Y ,4,3,nil ,nil ,nil );if _edb !=nil {return nil ,_edb ;};_eabd (_bbfa ,_cbf ,_cdcdc );return _cbf ,nil ;};var _ Image =&NRGBA16 {};var _ _dd .Image =&NRGBA64 {};func (_eadd *Gray16 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray16BPC (x ,y ,_eadd .BytesPerLine ,_eadd .Data ,_eadd .Decode );};func (_bade *NRGBA64 )Set (x ,y int ,c _a .Color ){_gac :=(y *_bade .Width +x )*2;_fcdg :=_gac *3;if _fcdg +5>=len (_bade .Data ){return ;};_begd :=_a .NRGBA64Model .Convert (c ).(_a .NRGBA64 );_bade .setNRGBA64 (_fcdg ,_begd ,_gac );};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _b .Abs (xmax -xmin )< 0.000001{return ymin ;};_bcf :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _bcf ;};func _dbb (_fedb _a .Gray ,_dgf monochromeModel )_a .Gray {if _fedb .Y > uint8 (_dgf ){return _a .Gray {Y :_b .MaxUint8 };};return _a .Gray {};};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_cgbb :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_cgbb .Data =make ([]byte ,height *_cgbb .BytesPerLine );};return _cgbb ;};func (_gfbf *Gray8 )Set (x ,y int ,c _a .Color ){_fcec :=y *_gfbf .BytesPerLine +x ;if _fcec > len (_gfbf .Data )-1{return ;};_fgd :=_a .GrayModel .Convert (c );_gfbf .Data [_fcec ]=_fgd .(_a .Gray ).Y ;};func _fd (_ddd RGBA ,_fga CMYK ,_fda _dd .Rectangle ){for _bfb :=0;_bfb < _fda .Max .X ;_bfb ++{for _af :=0;_af < _fda .Max .Y ;_af ++{_eeg :=_ddd .RGBAAt (_bfb ,_af );_fga .SetCMYK (_bfb ,_af ,_cfc (_eeg ));};};};func _gae (_abcb _dd .Image )(Image ,error ){if _aged ,_agc :=_abcb .(*NRGBA32 );_agc {return _aged .Copy (),nil ;};_eege ,_cfbd ,_cad :=_cgfb (_abcb ,1);_dbg ,_eebf :=NewImage (_eege .Max .X ,_eege .Max .Y ,8,3,nil ,_cad ,nil );if _eebf !=nil {return nil ,_eebf ;};_eabd (_abcb ,_dbg ,_eege );if len (_cad )!=0&&!_cfbd {if _eeee :=_eab (_cad ,_dbg );_eeee !=nil {return nil ,_eeee ;};};return _dbg ,nil ;};type Image interface{_f .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_bcbf ,_eaac int )(_a .Color ,error );Validate ()error ;};func _cfc (_dfd _a .RGBA )_a .CMYK {_fec ,_eecc ,_ega ,_gec :=_a .RGBToCMYK (_dfd .R ,_dfd .G ,_dfd .B );return _a .CMYK {C :_fec ,M :_eecc ,Y :_ega ,K :_gec };};func (_fdagc *NRGBA32 )Validate ()error {if len (_fdagc .Data )!=3*_fdagc .Width *_fdagc .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_ffcd *NRGBA16 )ColorModel ()_a .Model {return NRGBA16Model };func _fggd (_ffe _a .Gray )_a .CMYK {return _a .CMYK {K :0xff-_ffe .Y }};func _fcc (_fdf _a .Gray )_a .Gray {_bge :=_fdf .Y >>6;_bge |=_bge <<2;_fdf .Y =_bge |_bge <<4;return _fdf ;};func (_cfgb *NRGBA64 )NRGBA64At (x ,y int )_a .NRGBA64 {_gbcga ,_ :=ColorAtNRGBA64 (x ,y ,_cfgb .Width ,_cfgb .Data ,_cfgb .Alpha ,_cfgb .Decode );return _gbcga ;};func (_eff *Gray2 )GrayAt (x ,y int )_a .Gray {_gdc ,_ :=ColorAtGray2BPC (x ,y ,_eff .BytesPerLine ,_eff .Data ,_eff .Decode );return _gdc ;};func (_afc *Gray2 )ColorModel ()_a .Model {return Gray2Model };func (_aca *Monochrome )SetGray (x ,y int ,g _a .Gray ){_fgeg :=y *_aca .BytesPerLine +x >>3;if _fgeg > len (_aca .Data )-1{return ;};g =_dbb (g ,monochromeModel (_aca .ModelThreshold ));_aca .setGray (x ,g ,_fgeg );};func _ffb (_edg _a .NRGBA64 )_a .NRGBA {return _a .NRGBA {R :uint8 (_edg .R >>8),G :uint8 (_edg .G >>8),B :uint8 (_edg .B >>8),A :uint8 (_edg .A >>8)};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_ef .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};type CMYK32 struct{ImageBase };func (_gff *Gray16 )ColorModel ()_a .Model {return _a .Gray16Model };type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_aagb *NRGBA16 )NRGBAAt (x ,y int )_a .NRGBA {_ceg ,_ :=ColorAtNRGBA16 (x ,y ,_aagb .Width ,_aagb .BytesPerLine ,_aagb .Data ,_aagb .Alpha ,_aagb .Decode );return _ceg ;};func _acb (_dda RGBA ,_gecb NRGBA ,_fbf _dd .Rectangle ){for _cdbd :=0;_cdbd < _fbf .Max .X ;_cdbd ++{for _eaabff :=0;_eaabff < _fbf .Max .Y ;_eaabff ++{_aeb :=_dda .RGBAAt (_cdbd ,_eaabff );_gecb .SetNRGBA (_cdbd ,_eaabff ,_fde (_aeb ));};};};var (MonochromeConverter =ConverterFunc (_ga );Gray2Converter =ConverterFunc (_ccg );Gray4Converter =ConverterFunc (_bgd );GrayConverter =ConverterFunc (_ecg );Gray16Converter =ConverterFunc (_agbc );NRGBA16Converter =ConverterFunc (_fee );NRGBAConverter =ConverterFunc (_gae );NRGBA64Converter =ConverterFunc (_cfa );CMYKConverter =ConverterFunc (_df ););func _gbc (_ge _a .CMYK )_a .Gray {_gdd ,_afb ,_eaf :=_a .CMYKToRGB (_ge .C ,_ge .M ,_ge .Y ,_ge .K );_daf :=(19595*uint32 (_gdd )+38470*uint32 (_afb )+7471*uint32 (_eaf )+1<<7)>>16;return _a .Gray {Y :uint8 (_daf )};};func _aafb (_bcg ,_eeeb Gray ,_dff _dd .Rectangle ){for _deg :=0;_deg < _dff .Max .X ;_deg ++{for _acab :=0;_acab < _dff .Max .Y ;_acab ++{_eeeb .SetGray (_deg ,_acab ,_bcg .GrayAt (_deg ,_acab ));};};};func (_cgf *Gray4 )setGray (_ddf int ,_cafg int ,_eccd _a .Gray ){_gda :=_cafg *_cgf .BytesPerLine ;_fef :=_gda +(_ddf >>1);if _fef >=len (_cgf .Data ){return ;};_faa :=_eccd .Y >>4;_cgf .Data [_fef ]=(_cgf .Data [_fef ]&(^(0xf0>>uint (4*(_ddf &1)))))|(_faa <<uint (4-4*(_ddf &1)));};var _ Image =&Monochrome {};func init (){_abg ()};func (_cdg *Monochrome )setBit (_acf ,_bcb int ){_cdg .Data [_acf ]|=0x80>>uint (_bcb &7)};func (_ffge *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_ffge .ImageBase .copy (),ModelThreshold :_ffge .ModelThreshold };};func (_bag *Monochrome )Set (x ,y int ,c _a .Color ){_feb :=y *_bag .BytesPerLine +x >>3;if _feb > len (_bag .Data )-1{return ;};_dbe :=_bag .ColorModel ().Convert (c ).(_a .Gray );_bag .setGray (x ,_dbe ,_feb );};func (_egd *Gray16 )GrayAt (x ,y int )_a .Gray {_bgb ,_ :=_egd .ColorAt (x ,y );return _a .Gray {Y :uint8 (_bgb .(_a .Gray16 ).Y >>8)};};func (_bddd *Gray8 )At (x ,y int )_a .Color {_dbea ,_ :=_bddd .ColorAt (x ,y );return _dbea };func (_eccg *NRGBA16 )SetNRGBA (x ,y int ,c _a .NRGBA ){_gfe :=y *_eccg .BytesPerLine +x *3/2;if _gfe +1>=len (_eccg .Data ){return ;};c =_gabg (c );_eccg .setNRGBA (x ,y ,_gfe ,c );};func (_ccbd *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ccbd .copy ()}};func (_ecd *CMYK32 )Set (x ,y int ,c _a .Color ){_eec :=4*(y *_ecd .Width +x );if _eec +3>=len (_ecd .Data ){return ;};_faf :=_a .CMYKModel .Convert (c ).(_a .CMYK );_ecd .Data [_eec ]=_faf .C ;_ecd .Data [_eec +1]=_faf .M ;_ecd .Data [_eec +2]=_faf .Y ;_ecd .Data [_eec +3]=_faf .K ;};func (_bgegc *NRGBA16 )At (x ,y int )_a .Color {_bgba ,_ :=_bgegc .ColorAt (x ,y );return _bgba };func (_ged *NRGBA16 )Set (x ,y int ,c _a .Color ){_bbcb :=y *_ged .BytesPerLine +x *3/2;if _bbcb +1>=len (_ged .Data ){return ;};_fca :=NRGBA16Model .Convert (c ).(_a .NRGBA );_ged .setNRGBA (x ,y ,_bbcb ,_fca );};func (_fbbc *Gray4 )Histogram ()(_ecf [256]int ){for _bdca :=0;_bdca < _fbbc .Width ;_bdca ++{for _fecf :=0;_fecf < _fbbc .Height ;_fecf ++{_ecf [_fbbc .GrayAt (_bdca ,_fecf ).Y ]++;};};return _ecf ;};func (_eeb *Monochrome )Validate ()error {if len (_eeb .Data )!=_eeb .Height *_eeb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_ggcg *Gray4 )Base ()*ImageBase {return &_ggcg .ImageBase };func (_gf *CMYK32 )Base ()*ImageBase {return &_gf .ImageBase };func _cc (_aeg _dd .Image ,_fed Image ,_gb _dd .Rectangle ){for _eca :=0;_eca < _gb .Max .X ;_eca ++{for _dde :=0;_dde < _gb .Max .Y ;_dde ++{_fcf :=_aeg .At (_eca ,_dde );_fed .Set (_eca ,_dde ,_fcf );};};};var _ Gray =&Gray8 {};func _gfd (_cg ,_eg CMYK ,_db _dd .Rectangle ){for _fgca :=0;_fgca < _db .Max .X ;_fgca ++{for _ae :=0;_ae < _db .Max .Y ;_ae ++{_eg .SetCMYK (_fgca ,_ae ,_cg .CMYKAt (_fgca ,_ae ));};};};func (_abdc *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_abdc .copy ()}};func (_da *CMYK32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtCMYK (x ,y ,_da .Width ,_da .Data ,_da .Decode );};var _ Image =&Gray8 {};func _geae (_gedc int ,_bgge int )error {return _ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_gedc ,_bgge );};func (_cbgf *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_cbgf .copy ()}};func _cae (_deb _a .RGBA )_a .Gray {_dfb :=(19595*uint32 (_deb .R )+38470*uint32 (_deb .G )+7471*uint32 (_deb .B )+1<<7)>>16;return _a .Gray {Y :uint8 (_dfb )};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_cff :=y *bytesPerLine +x >>3;if _cff >=len (data ){return _a .Gray {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_cfd :=data [_cff ]>>uint (7-(x &7))&1;if len (decode )==2{_cfd =uint8 (LinearInterpolate (float64 (_cfd ),0.0,1.0,decode [0],decode [1]))&1;};return _a .Gray {Y :_cfd *255},nil ;};func (_fgcd *NRGBA16 )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_fgcd .Width ,Y :_fgcd .Height }};};func _fdd (_debd *_dd .Gray )bool {for _dddf :=0;_dddf < len (_debd .Pix );_dddf ++{if !_bcae (_debd .Pix [_dddf ]){return false ;};};return true ;};func (_dbba *Gray8 )GrayAt (x ,y int )_a .Gray {_fbcb ,_ :=ColorAtGray8BPC (x ,y ,_dbba .BytesPerLine ,_dbba .Data ,_dbba .Decode );return _fbcb ;};type ColorConverter interface{Convert (_ecdf _dd .Image )(Image ,error );};type Gray2 struct{ImageBase };func ImgToBinary (i _dd .Image ,threshold uint8 )*_dd .Gray {switch _gadg :=i .(type ){case *_dd .Gray :if _fdd (_gadg ){return _gadg ;};return _cdgd (_gadg ,threshold );case *_dd .Gray16 :return _bdfc (_gadg ,threshold );default:return _dce (_gadg ,threshold );};};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_bbdc :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _fede Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_fede =&Monochrome {ImageBase :_bbdc ,ModelThreshold :0x0f};case 2:_fede =&Gray2 {ImageBase :_bbdc };case 4:_fede =&Gray4 {ImageBase :_bbdc };case 8:_fede =&Gray8 {ImageBase :_bbdc };case 16:_fede =&Gray16 {ImageBase :_bbdc };};case 3:switch bitsPerComponent {case 4:_fede =&NRGBA16 {ImageBase :_bbdc };case 8:_fede =&NRGBA32 {ImageBase :_bbdc };case 16:_fede =&NRGBA64 {ImageBase :_bbdc };};case 4:_fede =&CMYK32 {ImageBase :_bbdc };};if _fede ==nil {return nil ,ErrInvalidImage ;};return _fede ,nil ;};func (_bfa *Monochrome )setGray (_gabb int ,_ecde _a .Gray ,_gfad int ){if _ecde .Y ==0{_bfa .clearBit (_gfad ,_gabb );}else {_bfa .setBit (_gfad ,_gabb );};};func (_afbf *Gray2 )SetGray (x ,y int ,gray _a .Gray ){_cdcd :=_fcc (gray );_ddcb :=y *_afbf .BytesPerLine ;_bfc :=_ddcb +(x >>2);if _bfc >=len (_afbf .Data ){return ;};_acac :=_cdcd .Y >>6;_afbf .Data [_bfc ]=(_afbf .Data [_bfc ]&(^(0xc0>>uint (2*((x )&3)))))|(_acac <<uint (6-2*(x &3)));};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_a .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ef .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func (_bff *Gray4 )SetGray (x ,y int ,g _a .Gray ){if x >=_bff .Width ||y >=_bff .Height {return ;};g =_ege (g );_bff .setGray (x ,y ,g );};var _ Image =&Gray4 {};func (_ebab *Monochrome )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray1BPC (x ,y ,_ebab .BytesPerLine ,_ebab .Data ,_ebab .Decode );};func _agbc (_ded _dd .Image )(Image ,error ){if _efd ,_dgeg :=_ded .(*Gray16 );_dgeg {return _efd .Copy (),nil ;};_beec :=_ded .Bounds ();_dfe ,_dee :=NewImage (_beec .Max .X ,_beec .Max .Y ,16,1,nil ,nil ,nil );if _dee !=nil {return nil ,_dee ;};_ddcc (_ded ,_dfe ,_beec );return _dfe ,nil ;};func _eea (_ecc _a .NRGBA )_a .CMYK {_ca ,_gbg ,_dgc ,_ :=_ecc .RGBA ();_bdcb ,_gfgg ,_fea ,_feg :=_a .RGBToCMYK (uint8 (_ca >>8),uint8 (_gbg >>8),uint8 (_dgc >>8));return _a .CMYK {C :_bdcb ,M :_gfgg ,Y :_fea ,K :_feg };};func (_aab *NRGBA16 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA16 (x ,y ,_aab .Width ,_aab .BytesPerLine ,_aab .Data ,_aab .Alpha ,_aab .Decode );};func (_ccbb *Gray16 )Set (x ,y int ,c _a .Color ){_cga :=(y *_ccbb .BytesPerLine /2+x )*2;if _cga +1>=len (_ccbb .Data ){return ;};_ebecc :=_a .Gray16Model .Convert (c ).(_a .Gray16 );_ccbb .Data [_cga ],_ccbb .Data [_cga +1]=uint8 (_ebecc .Y >>8),uint8 (_ebecc .Y &0xff);};var (Gray2Model =_a .ModelFunc (_dgca );Gray4Model =_a .ModelFunc (_eaa );NRGBA16Model =_a .ModelFunc (_afa ););func _fgg (_ac NRGBA ,_bbg CMYK ,_ffd _dd .Rectangle ){for _dca :=0;_dca < _ffd .Max .X ;_dca ++{for _dg :=0;_dg < _ffd .Max .Y ;_dg ++{_gfda :=_ac .NRGBAAt (_dca ,_dg );_bbg .SetCMYK (_dca ,_dg ,_eea (_gfda ));};};};func (_bcfc *NRGBA64 )At (x ,y int )_a .Color {_fbbg ,_ :=_bcfc .ColorAt (x ,y );return _fbbg };func (_fcg *Gray4 )Set (x ,y int ,c _a .Color ){if x >=_fcg .Width ||y >=_fcg .Height {return ;};_edd :=Gray4Model .Convert (c ).(_a .Gray );_fcg .setGray (x ,y ,_edd );};func (_ggc *CMYK32 )CMYKAt (x ,y int )_a .CMYK {_ab ,_ :=ColorAtCMYK (x ,y ,_ggc .Width ,_ggc .Data ,_ggc .Decode );return _ab ;};func (_aced *ImageBase )GetAlpha ()[]byte {return _aced .Alpha };func (_dfag *NRGBA32 )NRGBAAt (x ,y int )_a .NRGBA {_eecd ,_ :=ColorAtNRGBA32 (x ,y ,_dfag .Width ,_dfag .Data ,_dfag .Alpha ,_dfag .Decode );return _eecd ;};func (_fbb *Monochrome )At (x ,y int )_a .Color {_bbe ,_ :=_fbb .ColorAt (x ,y );return _bbe };type colorConverter struct{_efaa func (_bad _dd .Image )(Image ,error );};func (_cab *Monochrome )Base ()*ImageBase {return &_cab .ImageBase };type nrgba64 interface{NRGBA64At (_cefa ,_ebc int )_a .NRGBA64 ;SetNRGBA64 (_eebg ,_gbcg int ,_gfae _a .NRGBA64 );};func _ga (_gaf _dd .Image )(Image ,error ){if _ag ,_cd :=_gaf .(*Monochrome );_cd {return _ag ,nil ;};_gecf ,_dea :=_gaf .(Gray );if !_dea {_cba ,_dcf :=GrayConverter .Convert (_gaf );if _dcf !=nil {return nil ,_dcf ;};_gecf =_cba .(Gray );};_bfbc :=_gaf .Bounds ();_bc ,_geb :=NewImage (_bfbc .Max .X ,_bfbc .Max .Y ,1,1,nil ,nil ,nil );if _geb !=nil {return nil ,_geb ;};_cdc :=_bc .(*Monochrome );_bec :=AutoThresholdTriangle (GrayHistogram (_gecf ));for _ceb :=0;_ceb < _bfbc .Max .X ;_ceb ++{for _bfd :=0;_bfd < _bfbc .Max .Y ;_bfd ++{_ffg :=_dbb (_gecf .GrayAt (_ceb ,_bfd ),monochromeModel (_bec ));_cdc .SetGray (_ceb ,_bfd ,_ffg );};};return _bc ,nil ;};func _gc (_gfg Gray ,_fc CMYK ,_ce _dd .Rectangle ){for _eac :=0;_eac < _ce .Max .X ;_eac ++{for _gfb :=0;_gfb < _ce .Max .Y ;_gfb ++{_bdc :=_gfg .GrayAt (_eac ,_gfb );_fc .SetCMYK (_eac ,_gfb ,_fggd (_bdc ));};};};func (_ggff *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_ggff .copy ()}};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _gabg (_fgcg _a .NRGBA )_a .NRGBA {_fgcg .R =_fgcg .R >>4|(_fgcg .R >>4)<<4;_fgcg .G =_fgcg .G >>4|(_fgcg .G >>4)<<4;_fgcg .B =_fgcg .B >>4|(_fgcg .B >>4)<<4;return _fgcg ;};func (_bce *Gray2 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray2BPC (x ,y ,_bce .BytesPerLine ,_bce .Data ,_bce .Decode );};func (_bb *CMYK32 )SetCMYK (x ,y int ,c _a .CMYK ){_fgc :=4*(y *_bb .Width +x );if _fgc +3>=len (_bb .Data ){return ;};_bb .Data [_fgc ]=c .C ;_bb .Data [_fgc +1]=c .M ;_bb .Data [_fgc +2]=c .Y ;_bb .Data [_fgc +3]=c .K ;};func (_cbc *ImageBase )MakeAlpha (){_cbc .newAlpha ()};func (_dafd *NRGBA16 )Validate ()error {if len (_dafd .Data )!=3*_dafd .Width *_dafd .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};var _effb [256]uint8 ;var _ _dd .Image =&Gray4 {};func _afbc (_gfff *_dd .NYCbCrA ,_afcf NRGBA ,_ddag _dd .Rectangle ){for _badc :=0;_badc < _ddag .Max .X ;_badc ++{for _bbdcd :=0;_bbdcd < _ddag .Max .Y ;_bbdcd ++{_bcgd :=_gfff .NYCbCrAAt (_badc ,_bbdcd );_afcf .SetNRGBA (_badc ,_bbdcd ,_fff (_bcgd ));};};};func (_cea *Gray16 )Base ()*ImageBase {return &_cea .ImageBase };func (_fcb *NRGBA64 )SetNRGBA64 (x ,y int ,c _a .NRGBA64 ){_bdga :=(y *_fcb .Width +x )*2;_aade :=_bdga *3;if _aade +5>=len (_fcb .Data ){return ;};_fcb .setNRGBA64 (_aade ,c ,_bdga );};func (_age *Gray4 )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_age .Width ,Y :_age .Height }};};func ConverterFunc (converterFunc func (_aa _dd .Image )(Image ,error ))ColorConverter {return colorConverter {_efaa :converterFunc };};func (_adc *Gray8 )Validate ()error {if len (_adc .Data )!=_adc .Height *_adc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA64 ,error ){_cdca :=(y *width +x )*2;_eeffc :=_cdca *3;if _eeffc +5>=len (data ){return _a .NRGBA64 {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _cgaa =0xffff;_dbbg :=uint16 (_cgaa );if alpha !=nil &&len (alpha )> _cdca +1{_dbbg =uint16 (alpha [_cdca ])<<8|uint16 (alpha [_cdca +1]);};_cfeg :=uint16 (data [_eeffc ])<<8|uint16 (data [_eeffc +1]);_cccf :=uint16 (data [_eeffc +2])<<8|uint16 (data [_eeffc +3]);_gbcgg :=uint16 (data [_eeffc +4])<<8|uint16 (data [_eeffc +5]);if len (decode )==6{_cfeg =uint16 (uint64 (LinearInterpolate (float64 (_cfeg ),0,65535,decode [0],decode [1]))&_cgaa );_cccf =uint16 (uint64 (LinearInterpolate (float64 (_cccf ),0,65535,decode [2],decode [3]))&_cgaa );_gbcgg =uint16 (uint64 (LinearInterpolate (float64 (_gbcgg ),0,65535,decode [4],decode [5]))&_cgaa );};return _a .NRGBA64 {R :_cfeg ,G :_cccf ,B :_gbcgg ,A :_dbbg },nil ;};func _dce (_agad _dd .Image ,_afec uint8 )*_dd .Gray {_aagc :=_agad .Bounds ();_bfeg :=_dd .NewGray (_aagc );var (_egdd _a .Color ;_acbf _a .Gray ;);for _cgff :=0;_cgff < _aagc .Max .X ;_cgff ++{for _effac :=0;_effac < _aagc .Max .Y ;_effac ++{_egdd =_agad .At (_cgff ,_effac );_bfeg .Set (_cgff ,_effac ,_egdd );_acbf =_bfeg .GrayAt (_cgff ,_effac );_bfeg .SetGray (_cgff ,_effac ,_a .Gray {Y :_bba (_acbf .Y ,_afec )});};};return _bfeg ;};func IsGrayImgBlackAndWhite (i *_dd .Gray )bool {return _fdd (i )};func _bcae (_egeee uint8 )bool {if _egeee ==0||_egeee ==255{return true ;};return false ;};func _bfcg (_ebeg CMYK ,_gee Gray ,_cebc _dd .Rectangle ){for _eaabf :=0;_eaabf < _cebc .Max .X ;_eaabf ++{for _edf :=0;_edf < _cebc .Max .Y ;_edf ++{_afcb :=_gbc (_ebeg .CMYKAt (_eaabf ,_edf ));_gee .SetGray (_eaabf ,_edf ,_afcb );};};};var _ Gray =&Gray16 {};var _ Image =&CMYK32 {};func _dgca (_fce _a .Color )_a .Color {_bgcd :=_a .GrayModel .Convert (_fce ).(_a .Gray );return _fcc (_bgcd )};func (_bee *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_bee .copy ()}};func _ege (_eegc _a .Gray )_a .Gray {_eegc .Y >>=4;_eegc .Y |=_eegc .Y <<4;return _eegc };func (_gcg *Gray2 )Validate ()error {if len (_gcg .Data )!=_gcg .Height *_gcg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _df (_ff _dd .Image )(Image ,error ){if _fge ,_ddb :=_ff .(*CMYK32 );_ddb {return _fge .Copy (),nil ;};_dc :=_ff .Bounds ();_de ,_fb :=NewImage (_dc .Max .X ,_dc .Max .Y ,8,4,nil ,nil ,nil );if _fb !=nil {return nil ,_fb ;};switch _ea :=_ff .(type ){case CMYK :_gfd (_ea ,_de .(CMYK ),_dc );case Gray :_gc (_ea ,_de .(CMYK ),_dc );case NRGBA :_fgg (_ea ,_de .(CMYK ),_dc );case RGBA :_fd (_ea ,_de .(CMYK ),_dc );default:_cc (_ff ,_de ,_dc );};return _de ,nil ;};func (_bcec *NRGBA32 )SetNRGBA (x ,y int ,c _a .NRGBA ){_ggfd :=y *_bcec .Width +x ;_egea :=3*_ggfd ;if _egea +2>=len (_bcec .Data ){return ;};_bcec .setRGBA (_ggfd ,c );};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_ad colorConverter )Convert (src _dd .Image )(Image ,error ){return _ad ._efaa (src )};func (_cfccf *ImageBase )Pix ()[]byte {return _cfccf .Data };type Gray interface{GrayAt (_cbg ,_gece int )_a .Gray ;SetGray (_gdf ,_abb int ,_be _a .Gray );};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray16 ,error ){_cdbf :=(y *bytesPerLine /2+x )*2;if _cdbf +1>=len (data ){return _a .Gray16 {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dgb :=uint16 (data [_cdbf ])<<8|uint16 (data [_cdbf +1]);if len (decode )==2{_dgb =uint16 (uint64 (LinearInterpolate (float64 (_dgb ),0,65535,decode [0],decode [1])));};return _a .Gray16 {Y :_dgb },nil ;};func GrayHistogram (g Gray )(_gfadd [256]int ){switch _fbd :=g .(type ){case Histogramer :return _fbd .Histogram ();case _dd .Image :_cbea :=_fbd .Bounds ();for _cffe :=0;_cffe < _cbea .Max .X ;_cffe ++{for _eefd :=0;_eefd < _cbea .Max .Y ;_eefd ++{_gfadd [g .GrayAt (_cffe ,_eefd ).Y ]++;};};return _gfadd ;default:return [256]int {};};};func (_aaed *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_aaed .copy ()}};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};type NRGBA64 struct{ImageBase };func _fff (_eba _a .NYCbCrA )_a .NRGBA {_eee :=int32 (_eba .Y )*0x10101;_caf :=int32 (_eba .Cb )-128;_gbe :=int32 (_eba .Cr )-128;_eag :=_eee +91881*_gbe ;if uint32 (_eag )&0xff000000==0{_eag >>=8;}else {_eag =^(_eag >>31)&0xffff;};_bfg :=_eee -22554*_caf -46802*_gbe ;if uint32 (_bfg )&0xff000000==0{_bfg >>=8;}else {_bfg =^(_bfg >>31)&0xffff;};_gcf :=_eee +116130*_caf ;if uint32 (_gcf )&0xff000000==0{_gcf >>=8;}else {_gcf =^(_gcf >>31)&0xffff;};return _a .NRGBA {R :uint8 (_eag >>8),G :uint8 (_bfg >>8),B :uint8 (_gcf >>8),A :_eba .A };};func (_gebf *NRGBA32 )ColorModel ()_a .Model {return _a .NRGBAModel };func _fagb (_debg ,_ecce NRGBA ,_ccge _dd .Rectangle ){for _bece :=0;_bece < _ccge .Max .X ;_bece ++{for _eacc :=0;_eacc < _ccge .Max .Y ;_eacc ++{_ecce .SetNRGBA (_bece ,_eacc ,_debg .NRGBAAt (_bece ,_eacc ));};};};func (_bcd monochromeModel )Convert (c _a .Color )_a .Color {_aaf :=_a .GrayModel .Convert (c ).(_a .Gray );return _dbb (_aaf ,_bcd );};var _ Image =&Gray2 {};func (_adee *Gray4 )GrayAt (x ,y int )_a .Gray {_ece ,_ :=ColorAtGray4BPC (x ,y ,_adee .BytesPerLine ,_adee .Data ,_adee .Decode );return _ece ;};func (_gafg *Gray16 )Validate ()error {if len (_gafg .Data )!=_gafg .Height *_gafg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_ebe *Gray8 )SetGray (x ,y int ,g _a .Gray ){_dfbd :=y *_ebe .BytesPerLine +x ;if _dfbd > len (_ebe .Data )-1{return ;};_ebe .Data [_dfbd ]=g .Y ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_babd :=y *bytesPerLine +x ;if _babd >=len (data ){return _a .Gray {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_fcfb :=data [_babd ];if len (decode )==2{_fcfb =uint8 (uint32 (LinearInterpolate (float64 (_fcfb ),0,255,decode [0],decode [1]))&0xff);};return _a .Gray {Y :_fcfb },nil ;};func _eab (_cebd []byte ,_beef Image )error {_dbfeb :=true ;for _gfcb :=0;_gfcb < len (_cebd );_gfcb ++{if _cebd [_gfcb ]!=0xff{_dbfeb =false ;break ;};};if _dbfeb {switch _gefe :=_beef .(type ){case *NRGBA32 :_gefe .Alpha =nil ;case *NRGBA64 :_gefe .Alpha =nil ;default:return _ef .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_beef );};};return nil ;};func _bgd (_bda _dd .Image )(Image ,error ){if _faaf ,_bbgc :=_bda .(*Gray4 );_bbgc {return _faaf .Copy (),nil ;};_ebd :=_bda .Bounds ();_bage ,_cca :=NewImage (_ebd .Max .X ,_ebd .Max .Y ,4,1,nil ,nil ,nil );if _cca !=nil {return nil ,_cca ;};_ddcc (_bda ,_bage ,_ebd );return _bage ,nil ;};func (_fdag *Monochrome )GrayAt (x ,y int )_a .Gray {_dbd ,_ :=ColorAtGray1BPC (x ,y ,_fdag .BytesPerLine ,_fdag .Data ,_fdag .Decode );return _dbd ;};func (_agb *Gray16 )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_agb .Width ,Y :_agb .Height }};};func _ecg (_ebec _dd .Image )(Image ,error ){if _fcfg ,_aac :=_ebec .(*Gray8 );_aac {return _fcfg .Copy (),nil ;};_acfc :=_ebec .Bounds ();_efb ,_afe :=NewImage (_acfc .Max .X ,_acfc .Max .Y ,8,1,nil ,nil ,nil );if _afe !=nil {return nil ,_afe ;};_ddcc (_ebec ,_efb ,_acfc );return _efb ,nil ;};func (_fdb *Monochrome )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_fdb .Width ,Y :_fdb .Height }};};type monochromeThresholdConverter struct{Threshold uint8 ;};func _bgcb (_cbaf nrgba64 ,_gfca NRGBA ,_cced _dd .Rectangle ){for _beff :=0;_beff < _cced .Max .X ;_beff ++{for _fedd :=0;_fedd < _cced .Max .Y ;_fedd ++{_cbec :=_cbaf .NRGBA64At (_beff ,_fedd );_gfca .SetNRGBA (_beff ,_fedd ,_ffb (_cbec ));};};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_ef .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};type RGBA interface{RGBAAt (_dbf ,_fegd int )_a .RGBA ;SetRGBA (_gbae ,_cgab int ,_bbdf _a .RGBA );};func (_eafb *Gray4 )Validate ()error {if len (_eafb .Data )!=_eafb .Height *_eafb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _afa (_bed _a .Color )_a .Color {_gbaeg :=_a .NRGBAModel .Convert (_bed ).(_a .NRGBA );return _gabg (_gbaeg );};type Gray16 struct{ImageBase };func _cdgd (_dadb *_dd .Gray ,_cbgd uint8 )*_dd .Gray {_bdcba :=_dadb .Bounds ();_ebecb :=_dd .NewGray (_bdcba );for _bgbe :=0;_bgbe < _bdcba .Dx ();_bgbe ++{for _gdaf :=0;_gdaf < _bdcba .Dy ();_gdaf ++{_dfdf :=_dadb .GrayAt (_bgbe ,_gdaf );_ebecb .SetGray (_bgbe ,_gdaf ,_a .Gray {Y :_bba (_dfdf .Y ,_cbgd )});};};return _ebecb ;};func (_beg *monochromeThresholdConverter )Convert (img _dd .Image )(Image ,error ){if _bbd ,_ffa :=img .(*Monochrome );_ffa {return _bbd .Copy (),nil ;};_ccd :=img .Bounds ();_bfe ,_bg :=NewImage (_ccd .Max .X ,_ccd .Max .Y ,1,1,nil ,nil ,nil );if _bg !=nil {return nil ,_bg ;};_bfe .(*Monochrome ).ModelThreshold =_beg .Threshold ;for _gdfg :=0;_gdfg < _ccd .Max .X ;_gdfg ++{for _bdd :=0;_bdd < _ccd .Max .Y ;_bdd ++{_afd :=img .At (_gdfg ,_bdd );_bfe .Set (_gdfg ,_bdd ,_afd );};};return _bfe ,nil ;};func (_eadg *Gray8 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray8BPC (x ,y ,_eadg .BytesPerLine ,_eadg .Data ,_eadg .Decode );};func (_ba *CMYK32 )At (x ,y int )_a .Color {_eb ,_ :=_ba .ColorAt (x ,y );return _eb };func (_dgfe *Gray4 )ColorModel ()_a .Model {return Gray4Model };var _ _dd .Image =&Monochrome {};var _ Image =&NRGBA64 {};type CMYK interface{CMYKAt (_fg ,_ec int )_a .CMYK ;SetCMYK (_c ,_ee int ,_fa _a .CMYK );};func (_bab *Gray4 )At (x ,y int )_a .Color {_cdb ,_ :=_bab .ColorAt (x ,y );return _cdb };func (_cffa *Gray2 )At (x ,y int )_a .Color {_ebf ,_ :=_cffa .ColorAt (x ,y );return _ebf };func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA ,error ){_ccf :=y *bytesPerLine +x *3/2;if _ccf +1>=len (data ){return _a .NRGBA {},_geae (x ,y );};const (_dgcaf =0xf;_ggb =uint8 (0xff););_eeac :=_ggb ;if alpha !=nil {_eeab :=y *BytesPerLine (width ,4,1);if _eeab < len (alpha ){if x %2==0{_eeac =(alpha [_eeab ]>>uint (4))&_dgcaf ;}else {_eeac =alpha [_eeab ]&_dgcaf ;};_eeac |=_eeac <<4;};};var _badd ,_acg ,_beed uint8 ;if x *3%2==0{_badd =(data [_ccf ]>>uint (4))&_dgcaf ;_acg =data [_ccf ]&_dgcaf ;_beed =(data [_ccf +1]>>uint (4))&_dgcaf ;}else {_badd =data [_ccf ]&_dgcaf ;_acg =(data [_ccf +1]>>uint (4))&_dgcaf ;_beed =data [_ccf +1]&_dgcaf ;};if len (decode )==6{_badd =uint8 (uint32 (LinearInterpolate (float64 (_badd ),0,15,decode [0],decode [1]))&0xf);_acg =uint8 (uint32 (LinearInterpolate (float64 (_acg ),0,15,decode [2],decode [3]))&0xf);_beed =uint8 (uint32 (LinearInterpolate (float64 (_beed ),0,15,decode [4],decode [5]))&0xf);};return _a .NRGBA {R :(_badd <<4)|(_badd &0xf),G :(_acg <<4)|(_acg &0xf),B :(_beed <<4)|(_beed &0xf),A :_eeac },nil ;};func _eaa (_fcdd _a .Color )_a .Color {_fffb :=_a .GrayModel .Convert (_fcdd ).(_a .Gray );return _ege (_fffb );};type monochromeModel uint8 ;func (_fab *NRGBA32 )Base ()*ImageBase {return &_fab .ImageBase };func (_ffc *Gray16 )At (x ,y int )_a .Color {_dfgf ,_ :=_ffc .ColorAt (x ,y );return _dfgf };func (_ceab *NRGBA16 )setNRGBA (_abd ,_aaca ,_dbcd int ,_gea _a .NRGBA ){if _abd *3%2==0{_ceab .Data [_dbcd ]=(_gea .R >>4)<<4|(_gea .G >>4);_ceab .Data [_dbcd +1]=(_gea .B >>4)<<4|(_ceab .Data [_dbcd +1]&0xf);}else {_ceab .Data [_dbcd ]=(_ceab .Data [_dbcd ]&0xf0)|(_gea .R >>4);_ceab .Data [_dbcd +1]=(_gea .G >>4)<<4|(_gea .B >>4);};if _ceab .Alpha !=nil {_bdeg :=_aaca *BytesPerLine (_ceab .Width ,4,1);if _bdeg < len (_ceab .Alpha ){if _abd %2==0{_ceab .Alpha [_bdeg ]=(_gea .A >>uint (4))<<uint (4)|(_ceab .Alpha [_dbcd ]&0xf);}else {_ceab .Alpha [_bdeg ]=(_ceab .Alpha [_bdeg ]&0xf0)|(_gea .A >>uint (4));};};};};func (_bbgb *Gray8 )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_bbgb .Width ,Y :_bbgb .Height }};};func (_fdbf *Gray16 )Histogram ()(_eaab [256]int ){for _bffc :=0;_bffc < _fdbf .Width ;_bffc ++{for _ced :=0;_ced < _fdbf .Height ;_ced ++{_eaab [_fdbf .GrayAt (_bffc ,_ced ).Y ]++;};};return _eaab ;};func FromGoImage (i _dd .Image )(Image ,error ){switch _geg :=i .(type ){case Image :return _geg .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_dd .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_dd .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func ImgToGray (i _dd .Image )*_dd .Gray {if _fcfc ,_dcdd :=i .(*_dd .Gray );_dcdd {return _fcfc ;};_gbce :=i .Bounds ();_dbeb :=_dd .NewGray (_gbce );for _gcc :=0;_gcc < _gbce .Max .X ;_gcc ++{for _ecge :=0;_ecge < _gbce .Max .Y ;_ecge ++{_aeag :=i .At (_gcc ,_ecge );_dbeb .Set (_gcc ,_ecge ,_aeag );};};return _dbeb ;};func (_gg *CMYK32 )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_gg .Width ,Y :_gg .Height }};};var _ NRGBA =&NRGBA32 {};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_cbgg :=y *bytesPerLine +x >>1;if _cbgg >=len (data ){return _a .Gray {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ccc :=data [_cbgg ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ccc =uint8 (uint32 (LinearInterpolate (float64 (_ccc ),0,15,decode [0],decode [1]))&0xf);};return _a .Gray {Y :_ccc *17&0xff},nil ;};func (_bf *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_bf .copy ()}};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_bbcd :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _bbcd ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_bgf :=width *colorComponents *bitsPerComponent ;_bfgf :=_bbcd *8;_fbad :=8-(_bfgf -_bgf );_bgg :=_efa .NewReader (data );_bbb :=_bbcd -1;_effc :=make ([]byte ,_bbb );_bgdc :=make ([]byte ,height *_bbcd );_cbge :=_efa .NewWriterMSB (_bgdc );var _bfba uint64 ;var _aadgc error ;for _dag :=0;_dag < height ;_dag ++{_ ,_aadgc =_bgg .Read (_effc );if _aadgc !=nil {return nil ,_aadgc ;};_ ,_aadgc =_cbge .Write (_effc );if _aadgc !=nil {return nil ,_aadgc ;};_bfba ,_aadgc =_bgg .ReadBits (byte (_fbad ));if _aadgc !=nil {return nil ,_aadgc ;};_ ,_aadgc =_cbge .WriteBits (_bfba ,_fbad );if _aadgc !=nil {return nil ,_aadgc ;};_cbge .FinishByte ();};return _bgdc ,nil ;};func (_ace *Monochrome )clearBit (_bgc ,_aadg int ){_ace .Data [_bgc ]&=^(0x80>>uint (_aadg &7))};var _ Gray =&Gray2 {};func (_befc *NRGBA32 )Set (x ,y int ,c _a .Color ){_cfec :=y *_befc .Width +x ;_abba :=3*_cfec ;if _abba +2>=len (_befc .Data ){return ;};_ccdg :=_a .NRGBAModel .Convert (c ).(_a .NRGBA );_befc .setRGBA (_cfec ,_ccdg );};func (_bgcf *Gray4 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray4BPC (x ,y ,_bgcf .BytesPerLine ,_bgcf .Data ,_bgcf .Decode );};func _fde (_eef _a .RGBA )_a .NRGBA {switch _eef .A {case 0xff:return _a .NRGBA {R :_eef .R ,G :_eef .G ,B :_eef .B ,A :0xff};case 0x00:return _a .NRGBA {};default:_cb ,_acc ,_fag ,_ede :=_eef .RGBA ();_cb =(_cb *0xffff)/_ede ;_acc =(_acc *0xffff)/_ede ;_fag =(_fag *0xffff)/_ede ;return _a .NRGBA {R :uint8 (_cb >>8),G :uint8 (_acc >>8),B :uint8 (_fag >>8),A :uint8 (_ede >>8)};};};func (_bdg *NRGBA32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA32 (x ,y ,_bdg .Width ,_bdg .Data ,_bdg .Alpha ,_bdg .Decode );};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_a .CMYK ,error ){_gfa :=4*(y *width +x );if _gfa +3>=len (data ){return _a .CMYK {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_gfa ]&0xff;M :=data [_gfa +1]&0xff;Y :=data [_gfa +2]&0xff;K :=data [_gfa +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _a .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_fcd *Gray2 )Histogram ()(_dbc [256]int ){for _dcd :=0;_dcd < _fcd .Width ;_dcd ++{for _agf :=0;_agf < _fcd .Height ;_agf ++{_dbc [_fcd .GrayAt (_dcd ,_agf ).Y ]++;};};return _dbc ;};func (_eegb *NRGBA32 )At (x ,y int )_a .Color {_cge ,_ :=_eegb .ColorAt (x ,y );return _cge };func (_bde *Gray16 )SetGray (x ,y int ,g _a .Gray ){_efc :=(y *_bde .BytesPerLine /2+x )*2;if _efc +1>=len (_bde .Data ){return ;};_bde .Data [_efc ]=g .Y ;_bde .Data [_efc +1]=g .Y ;};var _ Gray =&Gray4 {};func _bbbd (_bgce _dd .Image ,_cgc Image ,_cedf _dd .Rectangle ){if _cbcd ,_acee :=_bgce .(SMasker );_acee &&_cbcd .HasAlpha (){_cgc .(SMasker ).MakeAlpha ();};_cc (_bgce ,_cgc ,_cedf );};func (_ed *CMYK32 )ColorModel ()_a .Model {return _a .CMYKModel };func (_eggf *NRGBA64 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA64 (x ,y ,_eggf .Width ,_eggf .Data ,_eggf .Alpha ,_eggf .Decode );};func (_ccef *ImageBase )newAlpha (){_gcae :=BytesPerLine (_ccef .Width ,_ccef .BitsPerComponent ,1);_ccef .Alpha =make ([]byte ,_ccef .Height *_gcae );};func (_gab *Monochrome )Histogram ()(_bbf [256]int ){for _ ,_gca :=range _gab .Data {_bbf [0xff]+=int (_effb [_gab .Data [_gca ]]);};return _bbf ;};func (_bcdg *ImageBase )copy ()ImageBase {_fba :=*_bcdg ;_fba .Data =make ([]byte ,len (_bcdg .Data ));copy (_fba .Data ,_bcdg .Data );return _fba ;};func _cgfb (_gabd _dd .Image ,_ccfa int )(_dd .Rectangle ,bool ,[]byte ){_abf :=_gabd .Bounds ();var (_dbfe bool ;_fega []byte ;);switch _ccca :=_gabd .(type ){case SMasker :_dbfe =_ccca .HasAlpha ();case NRGBA ,RGBA ,*_dd .RGBA64 ,nrgba64 ,*_dd .NYCbCrA :_fega =make ([]byte ,_abf .Max .X *_abf .Max .Y *_ccfa );};return _abf ,_dbfe ,_fega ;};func _bba (_fad ,_dfeb uint8 )uint8 {if _fad < _dfeb {return 255;};return 0;};var _ Gray =&Monochrome {};func _eabd (_efbf _dd .Image ,_deba Image ,_ecgc _dd .Rectangle ){if _fcca ,_ebb :=_efbf .(SMasker );_ebb &&_fcca .HasAlpha (){_deba .(SMasker ).MakeAlpha ();};switch _afbfd :=_efbf .(type ){case Gray :_cfgd (_afbfd ,_deba .(NRGBA ),_ecgc );case NRGBA :_fagb (_afbfd ,_deba .(NRGBA ),_ecgc );case *_dd .NYCbCrA :_afbc (_afbfd ,_deba .(NRGBA ),_ecgc );case CMYK :_efbb (_afbfd ,_deba .(NRGBA ),_ecgc );case RGBA :_acb (_afbfd ,_deba .(NRGBA ),_ecgc );case nrgba64 :_bgcb (_afbfd ,_deba .(NRGBA ),_ecgc );default:_cc (_efbf ,_deba ,_ecgc );};};func (_cf *CMYK32 )Validate ()error {if len (_cf .Data )!=4*_cf .Width *_cf .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_aae *Gray2 )Set (x ,y int ,c _a .Color ){if x >=_aae .Width ||y >=_aae .Height {return ;};_ccb :=Gray2Model .Convert (c ).(_a .Gray );_bcdb :=y *_aae .BytesPerLine ;_beb :=_bcdb +(x >>2);_bdb :=_ccb .Y >>6;_aae .Data [_beb ]=(_aae .Data [_beb ]&(^(0xc0>>uint (2*((x )&3)))))|(_bdb <<uint (6-2*(x &3)));};func _cfa (_febf _dd .Image )(Image ,error ){if _bfad ,_faag :=_febf .(*NRGBA64 );_faag {return _bfad .Copy (),nil ;};_bfac ,_bfcc ,_egee :=_cgfb (_febf ,2);_bcbc ,_dffd :=NewImage (_bfac .Max .X ,_bfac .Max .Y ,16,3,nil ,_egee ,nil );if _dffd !=nil {return nil ,_dffd ;};_bbbd (_febf ,_bcbc ,_bfac );if len (_egee )!=0&&!_bfcc {if _faac :=_eab (_egee ,_bcbc );_faac !=nil {return nil ,_faac ;};};return _bcbc ,nil ;};func _abg (){for _cfcc :=0;_cfcc < 256;_cfcc ++{_effb [_cfcc ]=uint8 (_cfcc &0x1)+(uint8 (_cfcc >>1)&0x1)+(uint8 (_cfcc >>2)&0x1)+(uint8 (_cfcc >>3)&0x1)+(uint8 (_cfcc >>4)&0x1)+(uint8 (_cfcc >>5)&0x1)+(uint8 (_cfcc >>6)&0x1)+(uint8 (_cfcc >>7)&0x1);};};type NRGBA32 struct{ImageBase };var _ _dd .Image =&Gray2 {};func (_edda *NRGBA32 )setRGBA (_dgfg int ,_gafd _a .NRGBA ){_efeb :=3*_dgfg ;_edda .Data [_efeb ]=_gafd .R ;_edda .Data [_efeb +1]=_gafd .G ;_edda .Data [_efeb +2]=_gafd .B ;if _dgfg < len (_edda .Alpha ){_edda .Alpha [_dgfg ]=_gafd .A ;};};func (_addf *Gray8 )Base ()*ImageBase {return &_addf .ImageBase };func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA ,error ){_bfcgg :=y *width +x ;_gcb :=3*_bfcgg ;if _gcb +2>=len (data ){return _a .NRGBA {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dcad :=uint8 (0xff);if alpha !=nil &&len (alpha )> _bfcgg {_dcad =alpha [_bfcgg ];};_ceba ,_gedcb ,_baed :=data [_gcb ],data [_gcb +1],data [_gcb +2];if len (decode )==6{_ceba =uint8 (uint32 (LinearInterpolate (float64 (_ceba ),0,255,decode [0],decode [1]))&0xff);_gedcb =uint8 (uint32 (LinearInterpolate (float64 (_gedcb ),0,255,decode [2],decode [3]))&0xff);_baed =uint8 (uint32 (LinearInterpolate (float64 (_baed ),0,255,decode [4],decode [5]))&0xff);};return _a .NRGBA {R :_ceba ,G :_gedcb ,B :_baed ,A :_dcad },nil ;};var _ _dd .Image =&Gray8 {};func _ccg (_agab _dd .Image )(Image ,error ){if _egab ,_cffc :=_agab .(*Gray2 );_cffc {return _egab .Copy (),nil ;};_dac :=_agab .Bounds ();_ggg ,_bbc :=NewImage (_dac .Max .X ,_dac .Max .Y ,2,1,nil ,nil ,nil );if _bbc !=nil {return nil ,_bbc ;};_ddcc (_agab ,_ggg ,_dac );return _ggg ,nil ;};func _ddcc (_bbca _dd .Image ,_cag Image ,_cbd _dd .Rectangle ){switch _ceae :=_bbca .(type ){case Gray :_aafb (_ceae ,_cag .(Gray ),_cbd );case NRGBA :_beeb (_ceae ,_cag .(Gray ),_cbd );case CMYK :_bfcg (_ceae ,_cag .(Gray ),_cbd );case RGBA :_fedg (_ceae ,_cag .(Gray ),_cbd );default:_cc (_bbca ,_cag .(Image ),_cbd );};};func (_bgec *NRGBA64 )Base ()*ImageBase {return &_bgec .ImageBase };var _ NRGBA =&NRGBA16 {};func (_ecff *NRGBA64 )Validate ()error {if len (_ecff .Data )!=3*2*_ecff .Width *_ecff .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_afag *NRGBA64 )ColorModel ()_a .Model {return _a .NRGBA64Model };type Gray4 struct{ImageBase };func MonochromeModel (threshold uint8 )_a .Model {return monochromeModel (threshold )};func _efbb (_effa CMYK ,_ggge NRGBA ,_febd _dd .Rectangle ){for _dad :=0;_dad < _febd .Max .X ;_dad ++{for _ddg :=0;_ddg < _febd .Max .Y ;_ddg ++{_eagc :=_effa .CMYKAt (_dad ,_ddg );_ggge .SetNRGBA (_dad ,_ddg ,_fae (_eagc ));};};};func (_aea *Gray8 )Histogram ()(_bef [256]int ){for _bca :=0;_bca < len (_aea .Data );_bca ++{_bef [_aea .Data [_bca ]]++;};return _bef ;};var _ Image =&NRGBA32 {};func _beeb (_cde NRGBA ,_eda Gray ,_aag _dd .Rectangle ){for _cec :=0;_cec < _aag .Max .X ;_cec ++{for _gba :=0;_gba < _aag .Max .Y ;_gba ++{_bgeg :=_cfe (_cde .NRGBAAt (_cec ,_gba ));_eda .SetGray (_cec ,_gba ,_bgeg );};};};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_baa :=y *bytesPerLine +x >>2;if _baa >=len (data ){return _a .Gray {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_cgb :=data [_baa ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_cgb =uint8 (uint32 (LinearInterpolate (float64 (_cgb ),0,3.0,decode [0],decode [1]))&3);};return _a .Gray {Y :_cgb *85},nil ;};func (_cfg *NRGBA32 )Bounds ()_dd .Rectangle {return _dd .Rectangle {Max :_dd .Point {X :_cfg .Width ,Y :_cfg .Height }};};func _ddc (_gd _a .Gray )_a .NRGBA {return _a .NRGBA {R :_gd .Y ,G :_gd .Y ,B :_gd .Y ,A :0xff}};func (_bgfb *NRGBA64 )setNRGBA64 (_dab int ,_eddd _a .NRGBA64 ,_bbbg int ){_bgfb .Data [_dab ]=uint8 (_eddd .R >>8);_bgfb .Data [_dab +1]=uint8 (_eddd .R &0xff);_bgfb .Data [_dab +2]=uint8 (_eddd .G >>8);_bgfb .Data [_dab +3]=uint8 (_eddd .G &0xff);_bgfb .Data [_dab +4]=uint8 (_eddd .B >>8);_bgfb .Data [_dab +5]=uint8 (_eddd .B &0xff);if _bbbg +1< len (_bgfb .Alpha ){_bgfb .Alpha [_bbbg ]=uint8 (_eddd .A >>8);_bgfb .Alpha [_bbbg +1]=uint8 (_eddd .A &0xff);};};func (_bddf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_bddf .copy ()}};type NRGBA16 struct{ImageBase };func _fae (_fggf _a .CMYK )_a .NRGBA {_dcc ,_ead ,_fgec :=_a .CMYKToRGB (_fggf .C ,_fggf .M ,_fggf .Y ,_fggf .K );return _a .NRGBA {R :_dcc ,G :_ead ,B :_fgec ,A :0xff};};var _ _dd .Image =&Gray16 {};func AutoThresholdTriangle (histogram [256]int )uint8 {var _aead ,_febc ,_acd ,_bccb int ;for _abe :=0;_abe < len (histogram );_abe ++{if histogram [_abe ]> 0{_aead =_abe ;break ;};};if _aead > 0{_aead --;};for _bdgg :=255;_bdgg > 0;_bdgg --{if histogram [_bdgg ]> 0{_bccb =_bdgg ;break ;};};if _bccb < 255{_bccb ++;};for _fgedb :=0;_fgedb < 256;_fgedb ++{if histogram [_fgedb ]> _febc {_acd =_fgedb ;_febc =histogram [_fgedb ];};};var _bcbb bool ;if (_acd -_aead )< (_bccb -_acd ){_bcbb =true ;var _bdf int ;_feae :=255;for _bdf < _feae {_afgf :=histogram [_bdf ];histogram [_bdf ]=histogram [_feae ];histogram [_feae ]=_afgf ;_bdf ++;_feae --;};_aead =255-_bccb ;_acd =255-_acd ;};if _aead ==_acd {return uint8 (_aead );};_cac :=float64 (histogram [_acd ]);_fdg :=float64 (_aead -_acd );_bdcc :=_b .Sqrt (_cac *_cac +_fdg *_fdg );_cac /=_bdcc ;_fdg /=_bdcc ;_bdcc =_cac *float64 (_aead )+_fdg *float64 (histogram [_aead ]);_dcfb :=_aead ;var _abfg float64 ;for _cdec :=_aead +1;_cdec <=_acd ;_cdec ++{_abbae :=_cac *float64 (_cdec )+_fdg *float64 (histogram [_cdec ])-_bdcc ;if _abbae > _abfg {_dcfb =_cdec ;_abfg =_abbae ;};};_dcfb --;if _bcbb {var _ccfe int ;_cbcf :=255;for _ccfe < _cbcf {_ecfa :=histogram [_ccfe ];histogram [_ccfe ]=histogram [_cbcf ];histogram [_cbcf ]=_ecfa ;_ccfe ++;_cbcf --;};return uint8 (255-_dcfb );};return uint8 (_dcfb );};func (_cce *Monochrome )ColorModel ()_a .Model {return MonochromeModel (_cce .ModelThreshold )};func _fedg (_aed RGBA ,_cbe Gray ,_dafb _dd .Rectangle ){for _egag :=0;_egag < _dafb .Max .X ;_egag ++{for _gga :=0;_gga < _dafb .Max .Y ;_gga ++{_gag :=_cae (_aed .RGBAAt (_egag ,_gga ));_cbe .SetGray (_egag ,_gga ,_gag );};};};func (_bae *Gray2 )Base ()*ImageBase {return &_bae .ImageBase };func (_eagf *ImageBase )HasAlpha ()bool {if _eagf .Alpha ==nil {return false ;};for _bfae :=range _eagf .Alpha {if _eagf .Alpha [_bfae ]!=0xff{return true ;};};return false ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");var _ _dd .Image =&NRGBA32 {};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_a .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ef .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func _cfgd (_ecac Gray ,_fdad NRGBA ,_cbdc _dd .Rectangle ){for _deea :=0;_deea < _cbdc .Max .X ;_deea ++{for _eaaf :=0;_eaaf < _cbdc .Max .Y ;_eaaf ++{_ffgf :=_ecac .GrayAt (_deea ,_eaaf );_fdad .SetNRGBA (_deea ,_eaaf ,_ddc (_ffgf ));};};};func (_eage *NRGBA16 )Base ()*ImageBase {return &_eage .ImageBase };var _ Image =&Gray16 {};var _ _dd .Image =&NRGBA16 {};