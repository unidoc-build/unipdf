//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_d "encoding/binary";_c "errors";_aa "fmt";_bcg "github.com/unidoc/unipdf/v3/common";_ad "github.com/unidoc/unipdf/v3/internal/bitwise";_a "image";_bc "image/color";_be "image/draw";_e "math";);func (_gad *CMYK32 )Validate ()error {if len (_gad .Data )!=4*_gad .Width *_gad .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_efga *ImageBase )setEightBytes (_ebgc int ,_dba uint64 )error {_eadd :=_efga .BytesPerLine -(_ebgc %_efga .BytesPerLine );if _efga .BytesPerLine !=_efga .Width >>3{_eadd --;};if _eadd >=8{return _efga .setEightFullBytes (_ebgc ,_dba );
};return _efga .setEightPartlyBytes (_ebgc ,_eadd ,_dba );};func (_efff *Gray4 )Histogram ()(_abcg [256]int ){for _ecfg :=0;_ecfg < _efff .Width ;_ecfg ++{for _edb :=0;_edb < _efff .Height ;_edb ++{_abcg [_efff .GrayAt (_ecfg ,_edb ).Y ]++;};};return _abcg ;
};func (_dgbcd *Gray16 )SetGray (x ,y int ,g _bc .Gray ){_bfddc :=(y *_dgbcd .BytesPerLine /2+x )*2;if _bfddc +1>=len (_dgbcd .Data ){return ;};_dgbcd .Data [_bfddc ]=g .Y ;_dgbcd .Data [_bfddc +1]=g .Y ;};func _bge (_ccf ,_dce *Monochrome ,_ddb []byte ,_gcd int )(_cece error ){var (_cfd ,_ddc ,_aad ,_aeaad ,_fac ,_fcc ,_bfa ,_ebde int ;
_aaaf ,_eeea uint32 ;_dgbc ,_ceg byte ;_aeb uint16 ;);_bdd :=make ([]byte ,4);_fad :=make ([]byte ,4);for _aad =0;_aad < _ccf .Height -1;_aad ,_aeaad =_aad +2,_aeaad +1{_cfd =_aad *_ccf .BytesPerLine ;_ddc =_aeaad *_dce .BytesPerLine ;for _fac ,_fcc =0,0;
_fac < _gcd ;_fac ,_fcc =_fac +4,_fcc +1{for _bfa =0;_bfa < 4;_bfa ++{_ebde =_cfd +_fac +_bfa ;if _ebde <=len (_ccf .Data )-1&&_ebde < _cfd +_ccf .BytesPerLine {_bdd [_bfa ]=_ccf .Data [_ebde ];}else {_bdd [_bfa ]=0x00;};_ebde =_cfd +_ccf .BytesPerLine +_fac +_bfa ;
if _ebde <=len (_ccf .Data )-1&&_ebde < _cfd +(2*_ccf .BytesPerLine ){_fad [_bfa ]=_ccf .Data [_ebde ];}else {_fad [_bfa ]=0x00;};};_aaaf =_d .BigEndian .Uint32 (_bdd );_eeea =_d .BigEndian .Uint32 (_fad );_eeea &=_aaaf ;_eeea &=_eeea <<1;_eeea &=0xaaaaaaaa;
_aaaf =_eeea |(_eeea <<7);_dgbc =byte (_aaaf >>24);_ceg =byte ((_aaaf >>8)&0xff);_ebde =_ddc +_fcc ;if _ebde +1==len (_dce .Data )-1||_ebde +1>=_ddc +_dce .BytesPerLine {_dce .Data [_ebde ]=_ddb [_dgbc ];if _cece =_dce .setByte (_ebde ,_ddb [_dgbc ]);_cece !=nil {return _aa .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ebde );
};}else {_aeb =(uint16 (_ddb [_dgbc ])<<8)|uint16 (_ddb [_ceg ]);if _cece =_dce .setTwoBytes (_ebde ,_aeb );_cece !=nil {return _aa .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ebde );
};_fcc ++;};};};return nil ;};func _cab (_ffg _bc .RGBA )_bc .NRGBA {switch _ffg .A {case 0xff:return _bc .NRGBA {R :_ffg .R ,G :_ffg .G ,B :_ffg .B ,A :0xff};case 0x00:return _bc .NRGBA {};default:_adga ,_cfed ,_eecg ,_eeec :=_ffg .RGBA ();_adga =(_adga *0xffff)/_eeec ;
_cfed =(_cfed *0xffff)/_eeec ;_eecg =(_eecg *0xffff)/_eeec ;return _bc .NRGBA {R :uint8 (_adga >>8),G :uint8 (_cfed >>8),B :uint8 (_eecg >>8),A :uint8 (_eeec >>8)};};};type ColorConverter interface{Convert (_gab _a .Image )(Image ,error );};func _ebc (_ddab _bc .CMYK )_bc .NRGBA {_ffad ,_efg ,_bae :=_bc .CMYKToRGB (_ddab .C ,_ddab .M ,_ddab .Y ,_ddab .K );
return _bc .NRGBA {R :_ffad ,G :_efg ,B :_bae ,A :0xff};};func _dbe (_gccg _a .Image )(Image ,error ){if _gccc ,_gagd :=_gccg .(*Monochrome );_gagd {return _gccc ,nil ;};_bfg :=_gccg .Bounds ();var _eaea Gray ;switch _cgge :=_gccg .(type ){case Gray :_eaea =_cgge ;
case NRGBA :_eaea =&Gray8 {ImageBase :NewImageBase (_bfg .Max .X ,_bfg .Max .Y ,8,1,nil ,nil ,nil )};_accb (_eaea ,_cgge ,_bfg );case nrgba64 :_eaea =&Gray8 {ImageBase :NewImageBase (_bfg .Max .X ,_bfg .Max .Y ,8,1,nil ,nil ,nil )};_bfc (_eaea ,_cgge ,_bfg );
default:_bcd ,_bdc :=GrayConverter .Convert (_gccg );if _bdc !=nil {return nil ,_bdc ;};_eaea =_bcd .(Gray );};_ddabf ,_dcbc :=NewImage (_bfg .Max .X ,_bfg .Max .Y ,1,1,nil ,nil ,nil );if _dcbc !=nil {return nil ,_dcbc ;};_deeb :=_ddabf .(*Monochrome );
_bddc :=AutoThresholdTriangle (GrayHistogram (_eaea ));for _dcae :=0;_dcae < _bfg .Max .X ;_dcae ++{for _fgba :=0;_fgba < _bfg .Max .Y ;_fgba ++{_bcf :=_bdgf (_eaea .GrayAt (_dcae ,_fgba ),monochromeModel (_bddc ));_deeb .SetGray (_dcae ,_fgba ,_bcf );
};};return _ddabf ,nil ;};func (_dde *Gray4 )Base ()*ImageBase {return &_dde .ImageBase };type RGBA32 struct{ImageBase };func _cec (_acf ,_dbff *Monochrome ,_eec []byte ,_efc int )(_eaa error ){var (_gaf ,_ged ,_dgb ,_gcg ,_agb ,_gee ,_aeaa ,_egfa int ;
_baa ,_gda ,_cecc ,_dfb uint32 ;_cfe ,_fbb byte ;_ebfg uint16 ;);_ead :=make ([]byte ,4);_gfc :=make ([]byte ,4);for _dgb =0;_dgb < _acf .Height -1;_dgb ,_gcg =_dgb +2,_gcg +1{_gaf =_dgb *_acf .BytesPerLine ;_ged =_gcg *_dbff .BytesPerLine ;for _agb ,_gee =0,0;
_agb < _efc ;_agb ,_gee =_agb +4,_gee +1{for _aeaa =0;_aeaa < 4;_aeaa ++{_egfa =_gaf +_agb +_aeaa ;if _egfa <=len (_acf .Data )-1&&_egfa < _gaf +_acf .BytesPerLine {_ead [_aeaa ]=_acf .Data [_egfa ];}else {_ead [_aeaa ]=0x00;};_egfa =_gaf +_acf .BytesPerLine +_agb +_aeaa ;
if _egfa <=len (_acf .Data )-1&&_egfa < _gaf +(2*_acf .BytesPerLine ){_gfc [_aeaa ]=_acf .Data [_egfa ];}else {_gfc [_aeaa ]=0x00;};};_baa =_d .BigEndian .Uint32 (_ead );_gda =_d .BigEndian .Uint32 (_gfc );_cecc =_baa &_gda ;_cecc |=_cecc <<1;_dfb =_baa |_gda ;
_dfb &=_dfb <<1;_gda =_cecc &_dfb ;_gda &=0xaaaaaaaa;_baa =_gda |(_gda <<7);_cfe =byte (_baa >>24);_fbb =byte ((_baa >>8)&0xff);_egfa =_ged +_gee ;if _egfa +1==len (_dbff .Data )-1||_egfa +1>=_ged +_dbff .BytesPerLine {if _eaa =_dbff .setByte (_egfa ,_eec [_cfe ]);
_eaa !=nil {return _aa .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_egfa );};}else {_ebfg =(uint16 (_eec [_cfe ])<<8)|uint16 (_eec [_fbb ]);if _eaa =_dbff .setTwoBytes (_egfa ,_ebfg );_eaa !=nil {return _aa .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_egfa );
};_gee ++;};};};return nil ;};func (_ffce *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ffce .copy ()}};func (_abda *Monochrome )At (x ,y int )_bc .Color {_fgedf ,_ :=_abda .ColorAt (x ,y );return _fgedf };func (_ageb *ImageBase )copy ()ImageBase {_bcca :=*_ageb ;
_bcca .Data =make ([]byte ,len (_ageb .Data ));copy (_bcca .Data ,_ageb .Data );return _bcca ;};var _ _a .Image =&NRGBA16 {};func _acad (_daf NRGBA ,_dfge CMYK ,_fge _a .Rectangle ){for _ddbg :=0;_ddbg < _fge .Max .X ;_ddbg ++{for _efb :=0;_efb < _fge .Max .Y ;
_efb ++{_bca :=_daf .NRGBAAt (_ddbg ,_efb );_dfge .SetCMYK (_ddbg ,_efb ,_eab (_bca ));};};};func (_dggg *Monochrome )SetGray (x ,y int ,g _bc .Gray ){_fecf :=y *_dggg .BytesPerLine +x >>3;if _fecf > len (_dggg .Data )-1{return ;};g =_bdgf (g ,monochromeModel (_dggg .ModelThreshold ));
_dggg .setGray (x ,g ,_fecf );};func (_bebc *Monochrome )InverseData ()error {return _bebc .RasterOperation (0,0,_bebc .Width ,_bebc .Height ,PixNotDst ,nil ,0,0);};func (_aebc *Gray2 )ColorModel ()_bc .Model {return Gray2Model };func _ded (_fcd _bc .Gray )_bc .NRGBA {return _bc .NRGBA {R :_fcd .Y ,G :_fcd .Y ,B :_fcd .Y ,A :0xff}};
func (_fceg *ImageBase )setEightPartlyBytes (_eafca ,_egcc int ,_debf uint64 )(_dbgad error ){var (_fga byte ;_dbee int ;);for _ceba :=1;_ceba <=_egcc ;_ceba ++{_dbee =64-_ceba *8;_fga =byte (_debf >>uint (_dbee )&0xff);if _dbgad =_fceg .setByte (_eafca +_ceba -1,_fga );
_dbgad !=nil {return _dbgad ;};};_ebba :=_fceg .BytesPerLine *8-_fceg .Width ;if _ebba ==0{return nil ;};_dbee -=8;_fga =byte (_debf >>uint (_dbee )&0xff)<<uint (_ebba );if _dbgad =_fceg .setByte (_eafca +_egcc ,_fga );_dbgad !=nil {return _dbgad ;};return nil ;
};func _afdf (_dfgd _a .Image )(Image ,error ){if _cdf ,_adb :=_dfgd .(*Gray2 );_adb {return _cdf .Copy (),nil ;};_gdgc :=_dfgd .Bounds ();_gfcd ,_ccg :=NewImage (_gdgc .Max .X ,_gdgc .Max .Y ,2,1,nil ,nil ,nil );if _ccg !=nil {return nil ,_ccg ;};_acbe (_dfgd ,_gfcd ,_gdgc );
return _gfcd ,nil ;};func _caf (_egfe _a .Image )(Image ,error ){if _fbbg ,_gaddf :=_egfe .(*RGBA32 );_gaddf {return _fbbg .Copy (),nil ;};_bfde ,_bfddcb ,_fcag :=_fbde (_egfe ,1);_bbdcdb :=&RGBA32 {ImageBase :NewImageBase (_bfde .Max .X ,_bfde .Max .Y ,8,3,nil ,_fcag ,nil )};
_ddbb (_egfe ,_bbdcdb ,_bfde );if len (_fcag )!=0&&!_bfddcb {if _gcgdg :=_bfeeg (_fcag ,_bbdcdb );_gcgdg !=nil {return nil ,_gcgdg ;};};return _bbdcdb ,nil ;};func (_aeeb *Monochrome )Histogram ()(_bfd [256]int ){for _ ,_ecd :=range _aeeb .Data {_bfd [0xff]+=int (_afae [_aeeb .Data [_ecd ]]);
};return _bfd ;};func (_fgdb *CMYK32 )CMYKAt (x ,y int )_bc .CMYK {_eea ,_ :=ColorAtCMYK (x ,y ,_fgdb .Width ,_fgdb .Data ,_fgdb .Decode );return _eea ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_aa .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _ddbgf (_cbe int ,_cgec int )int {if _cbe < _cgec {return _cbe ;};return _cgec ;};func InDelta (expected ,current ,delta float64 )bool {_bgaeb :=expected -current ;if _bgaeb <=-delta ||_bgaeb >=delta {return false ;};return true ;};func _fedg (_geccd *Monochrome ,_agabb ,_debec ,_ebfa ,_ddcd int ,_dgcf RasterOperator ,_bafae *Monochrome ,_gccd ,_cacg int )error {var (_dea bool ;
_eage bool ;_eddf int ;_ddabfe int ;_cgaa int ;_egda bool ;_gfgdc byte ;_gdade int ;_acef int ;_gefc int ;_ffde ,_dddc int ;);_cgcf :=8-(_agabb &7);_agde :=_gbee [_cgcf ];_debc :=_geccd .BytesPerLine *_debec +(_agabb >>3);_cgfe :=_bafae .BytesPerLine *_cacg +(_gccd >>3);
if _ebfa < _cgcf {_dea =true ;_agde &=_feae [8-_cgcf +_ebfa ];};if !_dea {_eddf =(_ebfa -_cgcf )>>3;if _eddf > 0{_eage =true ;_ddabfe =_debc +1;_cgaa =_cgfe +1;};};_gdade =(_agabb +_ebfa )&7;if !(_dea ||_gdade ==0){_egda =true ;_gfgdc =_feae [_gdade ];
_acef =_debc +1+_eddf ;_gefc =_cgfe +1+_eddf ;};switch _dgcf {case PixSrc :for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],_bafae .Data [_cgfe ],_agde );_debc +=_geccd .BytesPerLine ;_cgfe +=_bafae .BytesPerLine ;
};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]=_bafae .Data [_cgaa +_dddc ];};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;};};if _egda {for _ffde =0;_ffde < _ddcd ;
_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],_bafae .Data [_gefc ],_gfgdc );_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixNotSrc :for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],^_bafae .Data [_cgfe ],_agde );
_debc +=_geccd .BytesPerLine ;_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]=^_bafae .Data [_cgaa +_dddc ];};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;
};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],^_bafae .Data [_gefc ],_gfgdc );_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixSrcOrDst :for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],_bafae .Data [_cgfe ]|_geccd .Data [_debc ],_agde );
_debc +=_geccd .BytesPerLine ;_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]|=_bafae .Data [_cgaa +_dddc ];};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;
};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],_bafae .Data [_gefc ]|_geccd .Data [_acef ],_gfgdc );_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixSrcAndDst :for _ffde =0;
_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],_bafae .Data [_cgfe ]&_geccd .Data [_debc ],_agde );_debc +=_geccd .BytesPerLine ;_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;
_dddc ++{_geccd .Data [_ddabfe +_dddc ]&=_bafae .Data [_cgaa +_dddc ];};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],_bafae .Data [_gefc ]&_geccd .Data [_acef ],_gfgdc );
_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixSrcXorDst :for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],_bafae .Data [_cgfe ]^_geccd .Data [_debc ],_agde );_debc +=_geccd .BytesPerLine ;
_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]^=_bafae .Data [_cgaa +_dddc ];};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;};};if _egda {for _ffde =0;
_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],_bafae .Data [_gefc ]^_geccd .Data [_acef ],_gfgdc );_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixNotSrcOrDst :for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],^(_bafae .Data [_cgfe ])|_geccd .Data [_debc ],_agde );
_debc +=_geccd .BytesPerLine ;_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]|=^(_bafae .Data [_cgaa +_dddc ]);};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;
};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],^(_bafae .Data [_gefc ])|_geccd .Data [_acef ],_gfgdc );_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixNotSrcAndDst :for _ffde =0;
_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],^(_bafae .Data [_cgfe ])&_geccd .Data [_debc ],_agde );_debc +=_geccd .BytesPerLine ;_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;
_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]&=^_bafae .Data [_cgaa +_dddc ];};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],^(_bafae .Data [_gefc ])&_geccd .Data [_acef ],_gfgdc );
_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixSrcOrNotDst :for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],_bafae .Data [_cgfe ]|^(_geccd .Data [_debc ]),_agde );_debc +=_geccd .BytesPerLine ;
_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]=_bafae .Data [_cgaa +_dddc ]|^(_geccd .Data [_ddabfe +_dddc ]);};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;
};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],_bafae .Data [_gefc ]|^(_geccd .Data [_acef ]),_gfgdc );_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixSrcAndNotDst :for _ffde =0;
_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],_bafae .Data [_cgfe ]&^(_geccd .Data [_debc ]),_agde );_debc +=_geccd .BytesPerLine ;_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;
_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]=_bafae .Data [_cgaa +_dddc ]&^(_geccd .Data [_ddabfe +_dddc ]);};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],_bafae .Data [_gefc ]&^(_geccd .Data [_acef ]),_gfgdc );
_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixNotPixSrcOrDst :for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],^(_bafae .Data [_cgfe ]|_geccd .Data [_debc ]),_agde );_debc +=_geccd .BytesPerLine ;
_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]=^(_bafae .Data [_cgaa +_dddc ]|_geccd .Data [_ddabfe +_dddc ]);};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;
};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],^(_bafae .Data [_gefc ]|_geccd .Data [_acef ]),_gfgdc );_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixNotPixSrcAndDst :for _ffde =0;
_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],^(_bafae .Data [_cgfe ]&_geccd .Data [_debc ]),_agde );_debc +=_geccd .BytesPerLine ;_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;
_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]=^(_bafae .Data [_cgaa +_dddc ]&_geccd .Data [_ddabfe +_dddc ]);};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],^(_bafae .Data [_gefc ]&_geccd .Data [_acef ]),_gfgdc );
_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};case PixNotPixSrcXorDst :for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_debc ]=_gedfc (_geccd .Data [_debc ],^(_bafae .Data [_cgfe ]^_geccd .Data [_debc ]),_agde );_debc +=_geccd .BytesPerLine ;
_cgfe +=_bafae .BytesPerLine ;};if _eage {for _ffde =0;_ffde < _ddcd ;_ffde ++{for _dddc =0;_dddc < _eddf ;_dddc ++{_geccd .Data [_ddabfe +_dddc ]=^(_bafae .Data [_cgaa +_dddc ]^_geccd .Data [_ddabfe +_dddc ]);};_ddabfe +=_geccd .BytesPerLine ;_cgaa +=_bafae .BytesPerLine ;
};};if _egda {for _ffde =0;_ffde < _ddcd ;_ffde ++{_geccd .Data [_acef ]=_gedfc (_geccd .Data [_acef ],^(_bafae .Data [_gefc ]^_geccd .Data [_acef ]),_gfgdc );_acef +=_geccd .BytesPerLine ;_gefc +=_bafae .BytesPerLine ;};};default:_bcg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_dgcf );
return _c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};var _afae [256]uint8 ;func (_aeec *ImageBase )Pix ()[]byte {return _aeec .Data };func _eg (_cg ,_ac *Monochrome )(_cee error ){_gb :=_ac .BytesPerLine ;
_ebd :=_cg .BytesPerLine ;var (_ec byte ;_ae uint16 ;_bbf ,_cd ,_ebdg ,_cc ,_ge int ;);for _ebdg =0;_ebdg < _ac .Height ;_ebdg ++{_bbf =_ebdg *_gb ;_cd =2*_ebdg *_ebd ;for _cc =0;_cc < _gb ;_cc ++{_ec =_ac .Data [_bbf +_cc ];_ae =_cggd [_ec ];_ge =_cd +_cc *2;
if _cg .BytesPerLine !=_ac .BytesPerLine *2&&(_cc +1)*2> _cg .BytesPerLine {_cee =_cg .setByte (_ge ,byte (_ae >>8));}else {_cee =_cg .setTwoBytes (_ge ,_ae );};if _cee !=nil {return _cee ;};};for _cc =0;_cc < _ebd ;_cc ++{_ge =_cd +_ebd +_cc ;_ec =_cg .Data [_cd +_cc ];
if _cee =_cg .setByte (_ge ,_ec );_cee !=nil {return _cee ;};};};return nil ;};func (_efab *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_efab .copy ()}};func (_dcf *Gray2 )Base ()*ImageBase {return &_dcf .ImageBase };func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_bfgd :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _bfgd ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_ggecg :=width *colorComponents *bitsPerComponent ;_dgf :=_bfgd *8;_cfac :=8-(_dgf -_ggecg );_gaac :=_ad .NewReader (data );_dafe :=_bfgd -1;_ggge :=make ([]byte ,_dafe );_babef :=make ([]byte ,height *_bfgd );
_acdf :=_ad .NewWriterMSB (_babef );var _dfcc uint64 ;var _afgg error ;for _cgeg :=0;_cgeg < height ;_cgeg ++{_ ,_afgg =_gaac .Read (_ggge );if _afgg !=nil {return nil ,_afgg ;};_ ,_afgg =_acdf .Write (_ggge );if _afgg !=nil {return nil ,_afgg ;};_dfcc ,_afgg =_gaac .ReadBits (byte (_cfac ));
if _afgg !=nil {return nil ,_afgg ;};_ ,_afgg =_acdf .WriteBits (_dfcc ,_cfac );if _afgg !=nil {return nil ,_afgg ;};_acdf .FinishByte ();};return _babef ,nil ;};func (_gffbg *NRGBA32 )Validate ()error {if len (_gffbg .Data )!=3*_gffbg .Width *_gffbg .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};const (_edbcc shift =iota ;_ecgd ;);func (_caaac *NRGBA32 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtNRGBA32 (x ,y ,_caaac .Width ,_caaac .Data ,_caaac .Alpha ,_caaac .Decode );};func (_baad *NRGBA32 )Base ()*ImageBase {return &_baad .ImageBase };
func (_edge *Gray16 )At (x ,y int )_bc .Color {_cef ,_ :=_edge .ColorAt (x ,y );return _cef };func (_bced *NRGBA16 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_bced .Width ,Y :_bced .Height }};};func (_fgaf *NRGBA32 )Set (x ,y int ,c _bc .Color ){_debg :=y *_fgaf .Width +x ;
_cdgf :=3*_debg ;if _cdgf +2>=len (_fgaf .Data ){return ;};_bgagf :=_bc .NRGBAModel .Convert (c ).(_bc .NRGBA );_fgaf .setRGBA (_debg ,_bgagf );};var _ Image =&Gray4 {};type Gray4 struct{ImageBase };func _gabb (_afb _bc .CMYK )_bc .Gray {_efge ,_bcag ,_eacb :=_bc .CMYKToRGB (_afb .C ,_afb .M ,_afb .Y ,_afb .K );
_efad :=(19595*uint32 (_efge )+38470*uint32 (_bcag )+7471*uint32 (_eacb )+1<<7)>>16;return _bc .Gray {Y :uint8 (_efad )};};func _afeb (_cdag _bc .Color )_bc .Color {_fbgf :=_bc .GrayModel .Convert (_cdag ).(_bc .Gray );return _fcf (_fbgf );};func (_caea *NRGBA64 )setNRGBA64 (_gdafd int ,_acba _bc .NRGBA64 ,_deaf int ){_caea .Data [_gdafd ]=uint8 (_acba .R >>8);
_caea .Data [_gdafd +1]=uint8 (_acba .R &0xff);_caea .Data [_gdafd +2]=uint8 (_acba .G >>8);_caea .Data [_gdafd +3]=uint8 (_acba .G &0xff);_caea .Data [_gdafd +4]=uint8 (_acba .B >>8);_caea .Data [_gdafd +5]=uint8 (_acba .B &0xff);if _deaf +1< len (_caea .Alpha ){_caea .Alpha [_deaf ]=uint8 (_acba .A >>8);
_caea .Alpha [_deaf +1]=uint8 (_acba .A &0xff);};};func (_bbae *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_bbae .copy ()}};func (_ecbc *NRGBA32 )NRGBAAt (x ,y int )_bc .NRGBA {_bacab ,_ :=ColorAtNRGBA32 (x ,y ,_ecbc .Width ,_ecbc .Data ,_ecbc .Alpha ,_ecbc .Decode );
return _bacab ;};func _eab (_edd _bc .NRGBA )_bc .CMYK {_ega ,_ddabb ,_fgcf ,_ :=_edd .RGBA ();_dgd ,_beb ,_dcc ,_bga :=_bc .RGBToCMYK (uint8 (_ega >>8),uint8 (_ddabb >>8),uint8 (_fgcf >>8));return _bc .CMYK {C :_dgd ,M :_beb ,Y :_dcc ,K :_bga };};type Gray2 struct{ImageBase };
func _bac (_fg *Monochrome ,_fa int ,_eb []uint )(*Monochrome ,error ){_fb :=_fa *_fg .Width ;_bef :=_fa *_fg .Height ;_ce :=_efe (_fb ,_bef );for _ebf ,_df :=range _eb {var _bb error ;switch _df {case 2:_bb =_eg (_ce ,_fg );case 4:_bb =_gbc (_ce ,_fg );
case 8:_bb =_bea (_ce ,_fg );};if _bb !=nil {return nil ,_bb ;};if _ebf !=len (_eb )-1{_fg =_ce .copy ();};};return _ce ,nil ;};func (_bacb *Gray4 )Validate ()error {if len (_bacb .Data )!=_bacb .Height *_bacb .BytesPerLine {return ErrInvalidImage ;};return nil ;
};func _aadd (_efbd NRGBA ,_geeac RGBA ,_fgbg _a .Rectangle ){for _bgab :=0;_bgab < _fgbg .Max .X ;_bgab ++{for _eedf :=0;_eedf < _fgbg .Max .Y ;_eedf ++{_aacf :=_efbd .NRGBAAt (_bgab ,_eedf );_geeac .SetRGBA (_bgab ,_eedf ,_eebbad (_aacf ));};};};func (_bcddc *Gray4 )Set (x ,y int ,c _bc .Color ){if x >=_bcddc .Width ||y >=_bcddc .Height {return ;
};_eaac :=Gray4Model .Convert (c ).(_bc .Gray );_bcddc .setGray (x ,y ,_eaac );};func (_acce *ImageBase )HasAlpha ()bool {if _acce .Alpha ==nil {return false ;};for _bgagd :=range _acce .Alpha {if _acce .Alpha [_bgagd ]!=0xff{return true ;};};return false ;
};func _age ()(_ede []byte ){_ede =make ([]byte ,256);for _aca :=0;_aca < 256;_aca ++{_bgb :=byte (_aca );_ede [_bgb ]=(_bgb &0x01)|((_bgb &0x04)>>1)|((_bgb &0x10)>>2)|((_bgb &0x40)>>3)|((_bgb &0x02)<<3)|((_bgb &0x08)<<2)|((_bgb &0x20)<<1)|(_bgb &0x80);
};return _ede ;};func GrayHistogram (g Gray )(_deba [256]int ){switch _bbfaa :=g .(type ){case Histogramer :return _bbfaa .Histogram ();case _a .Image :_beeg :=_bbfaa .Bounds ();for _cdegb :=0;_cdegb < _beeg .Max .X ;_cdegb ++{for _dadf :=0;_dadf < _beeg .Max .Y ;
_dadf ++{_deba [g .GrayAt (_cdegb ,_dadf ).Y ]++;};};return _deba ;default:return [256]int {};};};func _def (_bffb _bc .NRGBA64 )_bc .RGBA {_fccc ,_bgd ,_ccc ,_ecga :=_bffb .RGBA ();return _bc .RGBA {R :uint8 (_fccc >>8),G :uint8 (_bgd >>8),B :uint8 (_ccc >>8),A :uint8 (_ecga >>8)};
};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};var _ Image =&NRGBA64 {};func (_bfdg *NRGBA64 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtNRGBA64 (x ,y ,_bfdg .Width ,_bfdg .Data ,_bfdg .Alpha ,_bfdg .Decode );
};func ImgToGray (i _a .Image )*_a .Gray {if _edbd ,_eafaa :=i .(*_a .Gray );_eafaa {return _edbd ;};_bbgg :=i .Bounds ();_aaddf :=_a .NewGray (_bbgg );for _cbbee :=0;_cbbee < _bbgg .Max .X ;_cbbee ++{for _dedb :=0;_dedb < _bbgg .Max .Y ;_dedb ++{_bdgec :=i .At (_cbbee ,_dedb );
_aaddf .Set (_cbbee ,_dedb ,_bdgec );};};return _aaddf ;};func (_fbcf *ImageBase )setByte (_ffae int ,_abgb byte )error {if _ffae > len (_fbcf .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fbcf .Data [_ffae ]=_abgb ;return nil ;};func (_dbeee *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_dbeee .copy ()}};var _ _a .Image =&RGBA32 {};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_dbce (n )+1);};type colorConverter struct{_gdgf func (_gdb _a .Image )(Image ,error );
};func init (){_dfeb ()};func (_eegg *NRGBA64 )Validate ()error {if len (_eegg .Data )!=3*2*_eegg .Width *_eegg .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _gaae (_ccdbe _bc .NRGBA64 )_bc .NRGBA {return _bc .NRGBA {R :uint8 (_ccdbe .R >>8),G :uint8 (_ccdbe .G >>8),B :uint8 (_ccdbe .B >>8),A :uint8 (_ccdbe .A >>8)};};func _bafd (_geace _bc .CMYK )_bc .RGBA {_abeb ,_dbga ,_afg :=_bc .CMYKToRGB (_geace .C ,_geace .M ,_geace .Y ,_geace .K );
return _bc .RGBA {R :_abeb ,G :_dbga ,B :_afg ,A :0xff};};type nrgba64 interface{NRGBA64At (_dddfa ,_fbce int )_bc .NRGBA64 ;SetNRGBA64 (_dgfg ,_abdg int ,_adcf _bc .NRGBA64 );};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_bc .NRGBA ,error ){_gbge :=y *width +x ;
_feeb :=3*_gbge ;if _feeb +2>=len (data ){return _bc .NRGBA {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_efeb :=uint8 (0xff);if alpha !=nil &&len (alpha )> _gbge {_efeb =alpha [_gbge ];};_geacc ,_aebd ,_fbacc :=data [_feeb ],data [_feeb +1],data [_feeb +2];if len (decode )==6{_geacc =uint8 (uint32 (LinearInterpolate (float64 (_geacc ),0,255,decode [0],decode [1]))&0xff);
_aebd =uint8 (uint32 (LinearInterpolate (float64 (_aebd ),0,255,decode [2],decode [3]))&0xff);_fbacc =uint8 (uint32 (LinearInterpolate (float64 (_fbacc ),0,255,decode [4],decode [5]))&0xff);};return _bc .NRGBA {R :_geacc ,G :_aebd ,B :_fbacc ,A :_efeb },nil ;
};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _cdeg (_dcea *Monochrome ,_adff ,_gbcf int ,_gcgd ,_acab int ,_gcgf RasterOperator ){var (_fgfb int ;_eegd byte ;
_cbdf ,_ddgd int ;_cacc int ;);_bee :=_gcgd >>3;_gfb :=_gcgd &7;if _gfb > 0{_eegd =_feae [_gfb ];};_fgfb =_dcea .BytesPerLine *_gbcf +(_adff >>3);switch _gcgf {case PixClr :for _cbdf =0;_cbdf < _acab ;_cbdf ++{_cacc =_fgfb +_cbdf *_dcea .BytesPerLine ;
for _ddgd =0;_ddgd < _bee ;_ddgd ++{_dcea .Data [_cacc ]=0x0;_cacc ++;};if _gfb > 0{_dcea .Data [_cacc ]=_gedfc (_dcea .Data [_cacc ],0x0,_eegd );};};case PixSet :for _cbdf =0;_cbdf < _acab ;_cbdf ++{_cacc =_fgfb +_cbdf *_dcea .BytesPerLine ;for _ddgd =0;
_ddgd < _bee ;_ddgd ++{_dcea .Data [_cacc ]=0xff;_cacc ++;};if _gfb > 0{_dcea .Data [_cacc ]=_gedfc (_dcea .Data [_cacc ],0xff,_eegd );};};case PixNotDst :for _cbdf =0;_cbdf < _acab ;_cbdf ++{_cacc =_fgfb +_cbdf *_dcea .BytesPerLine ;for _ddgd =0;_ddgd < _bee ;
_ddgd ++{_dcea .Data [_cacc ]=^_dcea .Data [_cacc ];_cacc ++;};if _gfb > 0{_dcea .Data [_cacc ]=_gedfc (_dcea .Data [_cacc ],^_dcea .Data [_cacc ],_eegd );};};};};func (_gefda *NRGBA16 )ColorModel ()_bc .Model {return NRGBA16Model };func (_gaff *Gray4 )At (x ,y int )_bc .Color {_fadae ,_ :=_gaff .ColorAt (x ,y );
return _fadae };func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_bc .CMYK ,error ){_aag :=4*(y *width +x );if _aag +3>=len (data ){return _bc .CMYK {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_aag ]&0xff;M :=data [_aag +1]&0xff;Y :=data [_aag +2]&0xff;K :=data [_aag +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _bc .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _afa (_beca _bc .NYCbCrA )_bc .NRGBA {_abef :=int32 (_beca .Y )*0x10101;
_bbg :=int32 (_beca .Cb )-128;_aee :=int32 (_beca .Cr )-128;_dbbe :=_abef +91881*_aee ;if uint32 (_dbbe )&0xff000000==0{_dbbe >>=8;}else {_dbbe =^(_dbbe >>31)&0xffff;};_eeg :=_abef -22554*_bbg -46802*_aee ;if uint32 (_eeg )&0xff000000==0{_eeg >>=8;}else {_eeg =^(_eeg >>31)&0xffff;
};_gcc :=_abef +116130*_bbg ;if uint32 (_gcc )&0xff000000==0{_gcc >>=8;}else {_gcc =^(_gcc >>31)&0xffff;};return _bc .NRGBA {R :uint8 (_dbbe >>8),G :uint8 (_eeg >>8),B :uint8 (_gcc >>8),A :_beca .A };};func (_ceea *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ceea .copy ()}};
func _gedc (_fdd _bc .RGBA )_bc .Gray {_gcf :=(19595*uint32 (_fdd .R )+38470*uint32 (_fdd .G )+7471*uint32 (_fdd .B )+1<<7)>>16;return _bc .Gray {Y :uint8 (_gcf )};};var _ _a .Image =&Gray2 {};func (_agbc *CMYK32 )Base ()*ImageBase {return &_agbc .ImageBase };
func FromGoImage (i _a .Image )(Image ,error ){switch _acbb :=i .(type ){case Image :return _acbb .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_a .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_a .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_edg *Gray8 )At (x ,y int )_bc .Color {_dgbe ,_ :=_edg .ColorAt (x ,y );return _dgbe };func (_cgcc *Gray4 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_cgcc .Width ,Y :_cgcc .Height }};
};func (_begf *Monochrome )setBit (_bacc ,_faec int ){_begf .Data [_bacc +(_faec >>3)]|=0x80>>uint (_faec &7);};func _ddbb (_dgba _a .Image ,_acfeg Image ,_beafc _a .Rectangle ){if _eeadc ,_cebce :=_dgba .(SMasker );_cebce &&_eeadc .HasAlpha (){_acfeg .(SMasker ).MakeAlpha ();
};switch _defdd :=_dgba .(type ){case Gray :_faabf (_defdd ,_acfeg .(RGBA ),_beafc );case NRGBA :_aadd (_defdd ,_acfeg .(RGBA ),_beafc );case *_a .NYCbCrA :_efdc (_defdd ,_acfeg .(RGBA ),_beafc );case CMYK :_adge (_defdd ,_acfeg .(RGBA ),_beafc );case RGBA :_cgfde (_defdd ,_acfeg .(RGBA ),_beafc );
case nrgba64 :_adgac (_defdd ,_acfeg .(RGBA ),_beafc );default:_cca (_dgba ,_acfeg ,_beafc );};};func (_agg *Monochrome )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtGray1BPC (x ,y ,_agg .BytesPerLine ,_agg .Data ,_agg .Decode );};var _ _a .Image =&Monochrome {};
func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_bc .RGBA ,error ){_fcec :=y *width +x ;_gdbc :=3*_fcec ;if _gdbc +2>=len (data ){return _bc .RGBA {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cag :=uint8 (0xff);if alpha !=nil &&len (alpha )> _fcec {_cag =alpha [_fcec ];};_ecc ,_fgff ,_geae :=data [_gdbc ],data [_gdbc +1],data [_gdbc +2];if len (decode )==6{_ecc =uint8 (uint32 (LinearInterpolate (float64 (_ecc ),0,255,decode [0],decode [1]))&0xff);
_fgff =uint8 (uint32 (LinearInterpolate (float64 (_fgff ),0,255,decode [2],decode [3]))&0xff);_geae =uint8 (uint32 (LinearInterpolate (float64 (_geae ),0,255,decode [4],decode [5]))&0xff);};return _bc .RGBA {R :_ecc ,G :_fgff ,B :_geae ,A :_cag },nil ;
};func (_eacc *Gray16 )Base ()*ImageBase {return &_eacc .ImageBase };var _ Image =&Gray2 {};var (_feae =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_gbee =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func _bbceg (_cbfg _a .Image )(Image ,error ){if _ggag ,_gfdc :=_cbfg .(*NRGBA16 );
_gfdc {return _ggag .Copy (),nil ;};_caag :=_cbfg .Bounds ();_egfc ,_faag :=NewImage (_caag .Max .X ,_caag .Max .Y ,4,3,nil ,nil ,nil );if _faag !=nil {return nil ,_faag ;};_egbb (_cbfg ,_egfc ,_caag );return _egfc ,nil ;};func _gfae (_bgbcf *_a .Gray16 ,_bfbff uint8 )*_a .Gray {_efabd :=_bgbcf .Bounds ();
_eafe :=_a .NewGray (_efabd );for _fgeg :=0;_fgeg < _efabd .Dx ();_fgeg ++{for _agbbc :=0;_agbbc < _efabd .Dy ();_agbbc ++{_cgac :=_bgbcf .Gray16At (_fgeg ,_agbbc );_eafe .SetGray (_fgeg ,_agbbc ,_bc .Gray {Y :_cbea (uint8 (_cgac .Y /256),_bfbff )});};
};return _eafe ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bc .Gray ,error ){_bbdc :=y *bytesPerLine +x ;if _bbdc >=len (data ){return _bc .Gray {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_agea :=data [_bbdc ];if len (decode )==2{_agea =uint8 (uint32 (LinearInterpolate (float64 (_agea ),0,255,decode [0],decode [1]))&0xff);};return _bc .Gray {Y :_agea },nil ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bc .Gray ,error ){_fda :=y *bytesPerLine +x >>2;
if _fda >=len (data ){return _bc .Gray {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gga :=data [_fda ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_gga =uint8 (uint32 (LinearInterpolate (float64 (_gga ),0,3.0,decode [0],decode [1]))&3);};return _bc .Gray {Y :_gga *85},nil ;};func (_bda *Monochrome )ResolveDecode ()error {if len (_bda .Decode )!=2{return nil ;
};if _bda .Decode [0]==1&&_bda .Decode [1]==0{if _ceag :=_bda .InverseData ();_ceag !=nil {return _ceag ;};_bda .Decode =nil ;};return nil ;};var _ RGBA =&RGBA32 {};func _accb (_ebbc Gray ,_ecae NRGBA ,_dae _a .Rectangle ){for _bbd :=0;_bbd < _dae .Max .X ;
_bbd ++{for _efcbf :=0;_efcbf < _dae .Max .Y ;_efcbf ++{_ccda :=_abe (_ecae .NRGBAAt (_bbd ,_efcbf ));_ebbc .SetGray (_bbd ,_efcbf ,_ccda );};};};func _fbbe (_feg nrgba64 ,_ceefa NRGBA ,_ageae _a .Rectangle ){for _gfceg :=0;_gfceg < _ageae .Max .X ;_gfceg ++{for _cfdd :=0;
_cfdd < _ageae .Max .Y ;_cfdd ++{_eaae :=_feg .NRGBA64At (_gfceg ,_cfdd );_ceefa .SetNRGBA (_gfceg ,_cfdd ,_gaae (_eaae ));};};};func (_face *Gray8 )SetGray (x ,y int ,g _bc .Gray ){_eba :=y *_face .BytesPerLine +x ;if _eba > len (_face .Data )-1{return ;
};_face .Data [_eba ]=g .Y ;};func (_cbdg *NRGBA64 )NRGBA64At (x ,y int )_bc .NRGBA64 {_fag ,_ :=ColorAtNRGBA64 (x ,y ,_cbdg .Width ,_cbdg .Data ,_cbdg .Alpha ,_cbdg .Decode );return _fag ;};var _ _a .Image =&NRGBA32 {};type RasterOperator int ;func (_effe *RGBA32 )ColorModel ()_bc .Model {return _bc .NRGBAModel };
type Image interface{_be .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_bcee ,_gaffd int )(_bc .Color ,error );Validate ()error ;};func (_egeb *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_egeb .copy ()}};func (_agf *CMYK32 )At (x ,y int )_bc .Color {_gea ,_ :=_agf .ColorAt (x ,y );
return _gea };func _fcg (_cae _a .Image )(Image ,error ){if _ccef ,_ddabfa :=_cae .(*Gray16 );_ddabfa {return _ccef .Copy (),nil ;};_acgd :=_cae .Bounds ();_bgee ,_bdcg :=NewImage (_acgd .Max .X ,_acgd .Max .Y ,16,1,nil ,nil ,nil );if _bdcg !=nil {return nil ,_bdcg ;
};_acbe (_cae ,_bgee ,_acgd );return _bgee ,nil ;};func _fbc (_eeb *Monochrome ,_de int ,_bg []byte )(_ca *Monochrome ,_fbeg error ){const _aac ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _eeb ==nil {return nil ,_c .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _de < 1||_de > 4{return nil ,_c .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _eeb .Height <=1{return nil ,_c .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_ca =_efe (_eeb .Width /2,_eeb .Height /2);if _bg ==nil {_bg =_age ();};_agc :=_ddbgf (_eeb .BytesPerLine ,2*_ca .BytesPerLine );switch _de {case 1:_fbeg =_fgc (_eeb ,_ca ,_bg ,_agc );case 2:_fbeg =_dfg (_eeb ,_ca ,_bg ,_agc );case 3:_fbeg =_cec (_eeb ,_ca ,_bg ,_agc );
case 4:_fbeg =_bge (_eeb ,_ca ,_bg ,_agc );};if _fbeg !=nil {return nil ,_fbeg ;};return _ca ,nil ;};func _fbde (_ffddd _a .Image ,_gbcea int )(_a .Rectangle ,bool ,[]byte ){_ecafb :=_ffddd .Bounds ();var (_eaba bool ;_egga []byte ;);switch _begg :=_ffddd .(type ){case SMasker :_eaba =_begg .HasAlpha ();
case NRGBA ,RGBA ,*_a .RGBA64 ,nrgba64 ,*_a .NYCbCrA :_egga =make ([]byte ,_ecafb .Max .X *_ecafb .Max .Y *_gbcea );case *_a .Paletted :var _aefa bool ;for _ ,_aecf :=range _begg .Palette {_ddgf ,_bgac ,_abbb ,_egdc :=_aecf .RGBA ();if _ddgf ==0&&_bgac ==0&&_abbb ==0&&_egdc !=0{_aefa =true ;
break ;};};if _aefa {_egga =make ([]byte ,_ecafb .Max .X *_ecafb .Max .Y *_gbcea );};};return _ecafb ,_eaba ,_egga ;};func (_ecafd *Gray4 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtGray4BPC (x ,y ,_ecafd .BytesPerLine ,_ecafd .Data ,_ecafd .Decode );
};func _edcc (_ffga _bc .Gray )_bc .Gray {_bbdf :=_ffga .Y >>6;_bbdf |=_bbdf <<2;_ffga .Y =_bbdf |_bbdf <<4;return _ffga ;};func _gdec (_dac CMYK ,_bfcac Gray ,_ddac _a .Rectangle ){for _cddae :=0;_cddae < _ddac .Max .X ;_cddae ++{for _edee :=0;_edee < _ddac .Max .Y ;
_edee ++{_beag :=_gabb (_dac .CMYKAt (_cddae ,_edee ));_bfcac .SetGray (_cddae ,_edee ,_beag );};};};func _cbea (_efed ,_feba uint8 )uint8 {if _efed < _feba {return 255;};return 0;};func _ddaab (_dgdad *_a .Gray )bool {for _acfb :=0;_acfb < len (_dgdad .Pix );
_acfb ++{if !_cafd (_dgdad .Pix [_acfb ]){return false ;};};return true ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func _bdgf (_aeef _bc .Gray ,_cbbd monochromeModel )_bc .Gray {if _aeef .Y > uint8 (_cbbd ){return _bc .Gray {Y :_e .MaxUint8 };
};return _bc .Gray {};};func (_dfdd *Gray16 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_dfdd .Width ,Y :_dfdd .Height }};};func (_ddcbc *ImageBase )getByte (_bag int )(byte ,error ){if _bag > len (_ddcbc .Data )-1||_bag < 0{return 0,_aa .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_bag );
};return _ddcbc .Data [_bag ],nil ;};func _beaa (_ddd _a .Image )(Image ,error ){if _gbd ,_adag :=_ddd .(*CMYK32 );_adag {return _gbd .Copy (),nil ;};_gbfa :=_ddd .Bounds ();_aeg ,_bdf :=NewImage (_gbfa .Max .X ,_gbfa .Max .Y ,8,4,nil ,nil ,nil );if _bdf !=nil {return nil ,_bdf ;
};switch _aba :=_ddd .(type ){case CMYK :_acd (_aba ,_aeg .(CMYK ),_gbfa );case Gray :_fd (_aba ,_aeg .(CMYK ),_gbfa );case NRGBA :_acad (_aba ,_aeg .(CMYK ),_gbfa );case RGBA :_gbe (_aba ,_aeg .(CMYK ),_gbfa );default:_cca (_ddd ,_aeg ,_gbfa );};return _aeg ,nil ;
};func (_geeab *NRGBA16 )Set (x ,y int ,c _bc .Color ){_gbeg :=y *_geeab .BytesPerLine +x *3/2;if _gbeg +1>=len (_geeab .Data ){return ;};_fadb :=NRGBA16Model .Convert (c ).(_bc .NRGBA );_geeab .setNRGBA (x ,y ,_gbeg ,_fadb );};type SMasker interface{HasAlpha ()bool ;
GetAlpha ()[]byte ;MakeAlpha ();};func (_ebg *Monochrome )ColorModel ()_bc .Model {return MonochromeModel (_ebg .ModelThreshold )};func (_ggd *Monochrome )GrayAt (x ,y int )_bc .Gray {_cdca ,_ :=ColorAtGray1BPC (x ,y ,_ggd .BytesPerLine ,_ggd .Data ,_ggd .Decode );
return _cdca ;};func (_bbcd *NRGBA64 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_bbcd .Width ,Y :_bbcd .Height }};};func ConverterFunc (converterFunc func (_fged _a .Image )(Image ,error ))ColorConverter {return colorConverter {_gdgf :converterFunc };
};func (_dbdc *Gray16 )ColorModel ()_bc .Model {return _bc .Gray16Model };func (_ccga *RGBA32 )At (x ,y int )_bc .Color {_cgbc ,_ :=_ccga .ColorAt (x ,y );return _cgbc };func (_abfd *Monochrome )setGray (_gadb int ,_bacg _bc .Gray ,_acbd int ){if _bacg .Y ==0{_abfd .clearBit (_acbd ,_gadb );
}else {_abfd .setGrayBit (_acbd ,_gadb );};};func (_fcef *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _aeea (_fcef ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _gfa (_ef *Monochrome ,_dff ,_aab int )(*Monochrome ,error ){if _ef ==nil {return nil ,_c .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _dff <=0||_aab <=0{return nil ,_c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _dff ==_aab {if _dff ==1{return _ef .copy (),nil ;};
if _dff ==2||_dff ==4||_dff ==8{_dgc ,_cgg :=_ba (_ef ,_dff );if _cgg !=nil {return nil ,_cgg ;};return _dgc ,nil ;};};_ag :=_dff *_ef .Width ;_bfe :=_aab *_ef .Height ;_cga :=_efe (_ag ,_bfe );_dd :=_cga .BytesPerLine ;var (_aef ,_aea ,_fgg ,_ff ,_ceac int ;
_bec byte ;_dda error ;);for _aea =0;_aea < _ef .Height ;_aea ++{_aef =_aab *_aea *_dd ;for _fgg =0;_fgg < _ef .Width ;_fgg ++{if _adc :=_ef .getBitAt (_fgg ,_aea );_adc {_ceac =_dff *_fgg ;for _ff =0;_ff < _dff ;_ff ++{_cga .setIndexedBit (_aef *8+_ceac +_ff );
};};};for _ff =1;_ff < _aab ;_ff ++{_eca :=_aef +_ff *_dd ;for _dca :=0;_dca < _dd ;_dca ++{if _bec ,_dda =_cga .getByte (_aef +_dca );_dda !=nil {return nil ,_dda ;};if _dda =_cga .setByte (_eca +_dca ,_bec );_dda !=nil {return nil ,_dda ;};};};};return _cga ,nil ;
};func (_bafg *Gray4 )GrayAt (x ,y int )_bc .Gray {_abge ,_ :=ColorAtGray4BPC (x ,y ,_bafg .BytesPerLine ,_bafg .Data ,_bafg .Decode );return _abge ;};type Gray16 struct{ImageBase };func IsGrayImgBlackAndWhite (i *_a .Gray )bool {return _ddaab (i )};func (_bege *Gray16 )Set (x ,y int ,c _bc .Color ){_dcbcd :=(y *_bege .BytesPerLine /2+x )*2;
if _dcbcd +1>=len (_bege .Data ){return ;};_bcde :=_bc .Gray16Model .Convert (c ).(_bc .Gray16 );_bege .Data [_dcbcd ],_bege .Data [_dcbcd +1]=uint8 (_bcde .Y >>8),uint8 (_bcde .Y &0xff);};func _geeca (_faeef _a .Image ,_adbg uint8 )*_a .Gray {_gbegf :=_faeef .Bounds ();
_abcc :=_a .NewGray (_gbegf );var (_fefa _bc .Color ;_efef _bc .Gray ;);for _fgbac :=0;_fgbac < _gbegf .Max .X ;_fgbac ++{for _edeb :=0;_edeb < _gbegf .Max .Y ;_edeb ++{_fefa =_faeef .At (_fgbac ,_edeb );_abcc .Set (_fgbac ,_edeb ,_fefa );_efef =_abcc .GrayAt (_fgbac ,_edeb );
_abcc .SetGray (_fgbac ,_edeb ,_bc .Gray {Y :_cbea (_efef .Y ,_adbg )});};};return _abcc ;};var _ Image =&CMYK32 {};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_eagg :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_eagg .Data =make ([]byte ,height *_eagg .BytesPerLine );};return _eagg ;};func (_cge *CMYK32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_cge .Width ,Y :_cge .Height }};};var _ Gray =&Gray4 {};func (_fee *NRGBA16 )At (x ,y int )_bc .Color {_gaacg ,_ :=_fee .ColorAt (x ,y );
return _gaacg };func (_ffbc *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_ffbc .copy ()}};func _fgc (_eee ,_baf *Monochrome ,_ecb []byte ,_gdg int )(_fgb error ){var (_ecg ,_ffd ,_abd ,_dee ,_eebb ,_cde ,_fgd ,_eebba int ;_fe ,_dbfc uint32 ;_abg ,_cdg byte ;
_bba uint16 ;);_egeg :=make ([]byte ,4);_abbf :=make ([]byte ,4);for _abd =0;_abd < _eee .Height -1;_abd ,_dee =_abd +2,_dee +1{_ecg =_abd *_eee .BytesPerLine ;_ffd =_dee *_baf .BytesPerLine ;for _eebb ,_cde =0,0;_eebb < _gdg ;_eebb ,_cde =_eebb +4,_cde +1{for _fgd =0;
_fgd < 4;_fgd ++{_eebba =_ecg +_eebb +_fgd ;if _eebba <=len (_eee .Data )-1&&_eebba < _ecg +_eee .BytesPerLine {_egeg [_fgd ]=_eee .Data [_eebba ];}else {_egeg [_fgd ]=0x00;};_eebba =_ecg +_eee .BytesPerLine +_eebb +_fgd ;if _eebba <=len (_eee .Data )-1&&_eebba < _ecg +(2*_eee .BytesPerLine ){_abbf [_fgd ]=_eee .Data [_eebba ];
}else {_abbf [_fgd ]=0x00;};};_fe =_d .BigEndian .Uint32 (_egeg );_dbfc =_d .BigEndian .Uint32 (_abbf );_dbfc |=_fe ;_dbfc |=_dbfc <<1;_dbfc &=0xaaaaaaaa;_fe =_dbfc |(_dbfc <<7);_abg =byte (_fe >>24);_cdg =byte ((_fe >>8)&0xff);_eebba =_ffd +_cde ;if _eebba +1==len (_baf .Data )-1||_eebba +1>=_ffd +_baf .BytesPerLine {_baf .Data [_eebba ]=_ecb [_abg ];
}else {_bba =(uint16 (_ecb [_abg ])<<8)|uint16 (_ecb [_cdg ]);if _fgb =_baf .setTwoBytes (_eebba ,_bba );_fgb !=nil {return _aa .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eebba );
};_cde ++;};};};return nil ;};func (_fed *Gray16 )Validate ()error {if len (_fed .Data )!=_fed .Height *_fed .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _gedfc (_adee ,_cgbf ,_bddg byte )byte {return (_adee &^(_bddg ))|(_cgbf &_bddg )};
var _ _a .Image =&Gray4 {};func (_cebc *Gray2 )Set (x ,y int ,c _bc .Color ){if x >=_cebc .Width ||y >=_cebc .Height {return ;};_ebda :=Gray2Model .Convert (c ).(_bc .Gray );_bdag :=y *_cebc .BytesPerLine ;_fccg :=_bdag +(x >>2);_add :=_ebda .Y >>6;_cebc .Data [_fccg ]=(_cebc .Data [_fccg ]&(^(0xc0>>uint (2*((x )&3)))))|(_add <<uint (6-2*(x &3)));
};func (_baae *Gray8 )Set (x ,y int ,c _bc .Color ){_ccgc :=y *_baae .BytesPerLine +x ;if _ccgc > len (_baae .Data )-1{return ;};_becag :=_bc .GrayModel .Convert (c );_baae .Data [_ccgc ]=_becag .(_bc .Gray ).Y ;};func (_dbc colorConverter )Convert (src _a .Image )(Image ,error ){return _dbc ._gdgf (src )};
func (_dgbf *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _babg bool ;_ccb :=scale ;if scale < 1{_ccb =1/scale ;_babg =true ;};_acfg :=NextPowerOf2 (uint (_ccb ));if InDelta (float64 (_acfg ),_ccb ,0.001){if _babg {return _dgbf .ReduceBinary (_ccb );
};return _dgbf .ExpandBinary (int (_acfg ));};_eadb :=int (_e .RoundToEven (float64 (_dgbf .Width )*scale ));_dffd :=int (_e .RoundToEven (float64 (_dgbf .Height )*scale ));return _dgbf .ScaleLow (_eadb ,_dffd );};func (_gffd *NRGBA32 )At (x ,y int )_bc .Color {_cgda ,_ :=_gffd .ColorAt (x ,y );
return _cgda };func (_dcce *RGBA32 )RGBAAt (x ,y int )_bc .RGBA {_fcbf ,_ :=ColorAtRGBA32 (x ,y ,_dcce .Width ,_dcce .Data ,_dcce .Alpha ,_dcce .Decode );return _fcbf ;};func (_dabe *NRGBA16 )SetNRGBA (x ,y int ,c _bc .NRGBA ){_gbea :=y *_dabe .BytesPerLine +x *3/2;
if _gbea +1>=len (_dabe .Data ){return ;};c =_gcef (c );_dabe .setNRGBA (x ,y ,_gbea ,c );};func _ffgg (_deeg CMYK ,_gefce NRGBA ,_dbbf _a .Rectangle ){for _edfc :=0;_edfc < _dbbf .Max .X ;_edfc ++{for _ggegd :=0;_ggegd < _dbbf .Max .Y ;_ggegd ++{_gdaec :=_deeg .CMYKAt (_edfc ,_ggegd );
_gefce .SetNRGBA (_edfc ,_ggegd ,_ebc (_gdaec ));};};};func _gcce (_eaec NRGBA ,_bedg Gray ,_gfdb _a .Rectangle ){for _fadc :=0;_fadc < _gfdb .Max .X ;_fadc ++{for _fcff :=0;_fcff < _gfdb .Max .Y ;_fcff ++{_gbce :=_efa (_eaec .NRGBAAt (_fadc ,_fcff ));
_bedg .SetGray (_fadc ,_fcff ,_gbce );};};};func _bfeeg (_ddaaa []byte ,_cba Image )error {_dbba :=true ;for _eggc :=0;_eggc < len (_ddaaa );_eggc ++{if _ddaaa [_eggc ]!=0xff{_dbba =false ;break ;};};if _dbba {switch _eaff :=_cba .(type ){case *NRGBA32 :_eaff .Alpha =nil ;
case *NRGBA64 :_eaff .Alpha =nil ;default:return _aa .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_cba );
};};return nil ;};func (_bbgf *Monochrome )clearBit (_faeca ,_gebe int ){_bbgf .Data [_faeca ]&=^(0x80>>uint (_gebe &7))};func _cebb (_ddee ,_fcea Gray ,_ddcb _a .Rectangle ){for _faef :=0;_faef < _ddcb .Max .X ;_faef ++{for _gedff :=0;_gedff < _ddcb .Max .Y ;
_gedff ++{_fcea .SetGray (_faef ,_gedff ,_ddee .GrayAt (_faef ,_gedff ));};};};func (_ebffb *NRGBA64 )At (x ,y int )_bc .Color {_bgaa ,_ :=_ebffb .ColorAt (x ,y );return _bgaa };func (_gcae *NRGBA64 )Set (x ,y int ,c _bc .Color ){_afbb :=(y *_gcae .Width +x )*2;
_fbeb :=_afbb *3;if _fbeb +5>=len (_gcae .Data ){return ;};_ffe :=_bc .NRGBA64Model .Convert (c ).(_bc .NRGBA64 );_gcae .setNRGBA64 (_fbeb ,_ffe ,_afbb );};func (_eggcb *RGBA32 )Base ()*ImageBase {return &_eggcb .ImageBase };func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_bc .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_aa .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_fefbf *Monochrome )Base ()*ImageBase {return &_fefbf .ImageBase };func (_da *CMYK32 )SetCMYK (x ,y int ,c _bc .CMYK ){_edc :=4*(y *_da .Width +x );if _edc +3>=len (_da .Data ){return ;};_da .Data [_edc ]=c .C ;_da .Data [_edc +1]=c .M ;_da .Data [_edc +2]=c .Y ;
_da .Data [_edc +3]=c .K ;};type shift int ;func (_bdee *Monochrome )copy ()*Monochrome {_geg :=_efe (_bdee .Width ,_bdee .Height );_geg .ModelThreshold =_bdee .ModelThreshold ;_geg .Data =make ([]byte ,len (_bdee .Data ));copy (_geg .Data ,_bdee .Data );
if len (_bdee .Decode )!=0{_geg .Decode =make ([]float64 ,len (_bdee .Decode ));copy (_geg .Decode ,_bdee .Decode );};if len (_bdee .Alpha )!=0{_geg .Alpha =make ([]byte ,len (_bdee .Alpha ));copy (_geg .Alpha ,_bdee .Alpha );};return _geg ;};func (_gggf *ImageBase )newAlpha (){_ebff :=BytesPerLine (_gggf .Width ,_gggf .BitsPerComponent ,1);
_gggf .Alpha =make ([]byte ,_gggf .Height *_ebff );};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_bc .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_aa .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _egb (_ggc _bc .NRGBA64 )_bc .Gray {var _edf _bc .NRGBA64 ;if _ggc ==_edf {return _bc .Gray {Y :0xff};};_gfg ,_bcaae ,_efd ,_ :=_ggc .RGBA ();_fbg :=(19595*_gfg +38470*_bcaae +7471*_efd +1<<15)>>24;return _bc .Gray {Y :uint8 (_fbg )};};func (_dcac *ImageBase )setFourBytes (_gcfd int ,_fdfa uint32 )error {if _gcfd +3> len (_dcac .Data )-1{return _aa .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_gcfd );
};_dcac .Data [_gcfd ]=byte ((_fdfa &0xff000000)>>24);_dcac .Data [_gcfd +1]=byte ((_fdfa &0xff0000)>>16);_dcac .Data [_gcfd +2]=byte ((_fdfa &0xff00)>>8);_dcac .Data [_gcfd +3]=byte (_fdfa &0xff);return nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bc .Gray16 ,error ){_ggb :=(y *bytesPerLine /2+x )*2;
if _ggb +1>=len (data ){return _bc .Gray16 {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fgdbd :=uint16 (data [_ggb ])<<8|uint16 (data [_ggb +1]);if len (decode )==2{_fgdbd =uint16 (uint64 (LinearInterpolate (float64 (_fgdbd ),0,65535,decode [0],decode [1])));};return _bc .Gray16 {Y :_fgdbd },nil ;};func _bea (_dbf ,_cdd *Monochrome )(_bbe error ){_acb :=_cdd .BytesPerLine ;
_fbe :=_dbf .BytesPerLine ;var _ea ,_gfd ,_ab ,_bff ,_eac int ;for _ab =0;_ab < _cdd .Height ;_ab ++{_ea =_ab *_acb ;_gfd =8*_ab *_fbe ;for _bff =0;_bff < _acb ;_bff ++{if _bbe =_dbf .setEightBytes (_gfd +_bff *8,_dfd [_cdd .Data [_ea +_bff ]]);_bbe !=nil {return _bbe ;
};};for _eac =1;_eac < 8;_eac ++{for _bff =0;_bff < _fbe ;_bff ++{if _bbe =_dbf .setByte (_gfd +_eac *_fbe +_bff ,_dbf .Data [_gfd +_bff ]);_bbe !=nil {return _bbe ;};};};};return nil ;};func _abcb (_cebcb _a .Image )(Image ,error ){if _aege ,_gedf :=_cebcb .(*Gray4 );
_gedf {return _aege .Copy (),nil ;};_fab :=_cebcb .Bounds ();_decb ,_bbeb :=NewImage (_fab .Max .X ,_fab .Max .Y ,4,1,nil ,nil ,nil );if _bbeb !=nil {return nil ,_bbeb ;};_acbe (_cebcb ,_decb ,_fab );return _decb ,nil ;};func (_aead *NRGBA16 )setNRGBA (_cfdf ,_ggeg ,_gdgd int ,_bbcee _bc .NRGBA ){if _cfdf *3%2==0{_aead .Data [_gdgd ]=(_bbcee .R >>4)<<4|(_bbcee .G >>4);
_aead .Data [_gdgd +1]=(_bbcee .B >>4)<<4|(_aead .Data [_gdgd +1]&0xf);}else {_aead .Data [_gdgd ]=(_aead .Data [_gdgd ]&0xf0)|(_bbcee .R >>4);_aead .Data [_gdgd +1]=(_bbcee .G >>4)<<4|(_bbcee .B >>4);};if _aead .Alpha !=nil {_bacbc :=_ggeg *BytesPerLine (_aead .Width ,4,1);
if _bacbc < len (_aead .Alpha ){if _cfdf %2==0{_aead .Alpha [_bacbc ]=(_bbcee .A >>uint (4))<<uint (4)|(_aead .Alpha [_gdgd ]&0xf);}else {_aead .Alpha [_bacbc ]=(_aead .Alpha [_bacbc ]&0xf0)|(_bbcee .A >>uint (4));};};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func _gbf (_cf *Monochrome ,_gbg ...int )(_bbc *Monochrome ,_dfc error ){if _cf ==nil {return nil ,_c .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if len (_gbg )==0{return nil ,_c .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_dbb :=_age ();_bbc =_cf ;for _ ,_bcb :=range _gbg {if _bcb <=0{break ;};_bbc ,_dfc =_fbc (_bbc ,_bcb ,_dbb );if _dfc !=nil {return nil ,_dfc ;};};return _bbc ,nil ;};func (_dfbd *monochromeThresholdConverter )Convert (img _a .Image )(Image ,error ){if _eece ,_ccfg :=img .(*Monochrome );
_ccfg {return _eece .Copy (),nil ;};_bgag :=img .Bounds ();_gdae ,_gbbc :=NewImage (_bgag .Max .X ,_bgag .Max .Y ,1,1,nil ,nil ,nil );if _gbbc !=nil {return nil ,_gbbc ;};_gdae .(*Monochrome ).ModelThreshold =_dfbd .Threshold ;for _cdeb :=0;_cdeb < _bgag .Max .X ;
_cdeb ++{for _ageg :=0;_ageg < _bgag .Max .Y ;_ageg ++{_afag :=img .At (_cdeb ,_ageg );_gdae .Set (_cdeb ,_ageg ,_afag );};};return _gdae ,nil ;};func _adgac (_feaea nrgba64 ,_bcab RGBA ,_cadf _a .Rectangle ){for _fabf :=0;_fabf < _cadf .Max .X ;_fabf ++{for _ddfa :=0;
_ddfa < _cadf .Max .Y ;_ddfa ++{_bdfe :=_feaea .NRGBA64At (_fabf ,_ddfa );_bcab .SetRGBA (_fabf ,_ddfa ,_def (_bdfe ));};};};var _ NRGBA =&NRGBA32 {};var _ Gray =&Gray8 {};type monochromeModel uint8 ;func (_ceec *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_ceec .copy ()}};
func AutoThresholdTriangle (histogram [256]int )uint8 {var _debdd ,_cceb ,_eeeaf ,_bccfg int ;for _dbfe :=0;_dbfe < len (histogram );_dbfe ++{if histogram [_dbfe ]> 0{_debdd =_dbfe ;break ;};};if _debdd > 0{_debdd --;};for _dedd :=255;_dedd > 0;_dedd --{if histogram [_dedd ]> 0{_bccfg =_dedd ;
break ;};};if _bccfg < 255{_bccfg ++;};for _adgd :=0;_adgd < 256;_adgd ++{if histogram [_adgd ]> _cceb {_eeeaf =_adgd ;_cceb =histogram [_adgd ];};};var _daeba bool ;if (_eeeaf -_debdd )< (_bccfg -_eeeaf ){_daeba =true ;var _egcf int ;_faeb :=255;for _egcf < _faeb {_fde :=histogram [_egcf ];
histogram [_egcf ]=histogram [_faeb ];histogram [_faeb ]=_fde ;_egcf ++;_faeb --;};_debdd =255-_bccfg ;_eeeaf =255-_eeeaf ;};if _debdd ==_eeeaf {return uint8 (_debdd );};_ggf :=float64 (histogram [_eeeaf ]);_faecag :=float64 (_debdd -_eeeaf );_cdfa :=_e .Sqrt (_ggf *_ggf +_faecag *_faecag );
_ggf /=_cdfa ;_faecag /=_cdfa ;_cdfa =_ggf *float64 (_debdd )+_faecag *float64 (histogram [_debdd ]);_baada :=_debdd ;var _geag float64 ;for _feaa :=_debdd +1;_feaa <=_eeeaf ;_feaa ++{_aaeg :=_ggf *float64 (_feaa )+_faecag *float64 (histogram [_feaa ])-_cdfa ;
if _aaeg > _geag {_baada =_feaa ;_geag =_aaeg ;};};_baada --;if _daeba {var _dfa int ;_fcda :=255;for _dfa < _fcda {_cdfe :=histogram [_dfa ];histogram [_dfa ]=histogram [_fcda ];histogram [_fcda ]=_cdfe ;_dfa ++;_fcda --;};return uint8 (255-_baada );};
return uint8 (_baada );};func _egbb (_gcee _a .Image ,_caca Image ,_fceb _a .Rectangle ){if _bbfe ,_cgfd :=_gcee .(SMasker );_cgfd &&_bbfe .HasAlpha (){_caca .(SMasker ).MakeAlpha ();};switch _dbfbf :=_gcee .(type ){case Gray :_gcca (_dbfbf ,_caca .(NRGBA ),_fceb );
case NRGBA :_gbga (_dbfbf ,_caca .(NRGBA ),_fceb );case *_a .NYCbCrA :_feaf (_dbfbf ,_caca .(NRGBA ),_fceb );case CMYK :_ffgg (_dbfbf ,_caca .(NRGBA ),_fceb );case RGBA :_eegc (_dbfbf ,_caca .(NRGBA ),_fceb );case nrgba64 :_fbbe (_dbfbf ,_caca .(NRGBA ),_fceb );
default:_cca (_gcee ,_caca ,_fceb );};};var _ Gray =&Monochrome {};func _ba (_fc *Monochrome ,_gg int )(*Monochrome ,error ){if _fc ==nil {return nil ,_c .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _gg ==1{return _fc .copy (),nil ;};if !IsPowerOf2 (uint (_gg )){return nil ,_aa .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gg );
};_gge :=_ffa (_gg );return _bac (_fc ,_gg ,_gge );};func (_cfcf *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_c .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_bcdd :=_efe (width ,height );_adf :=make ([]int ,height );_bcad :=make ([]int ,width );_fggb :=float64 (_cfcf .Width )/float64 (width );_acgf :=float64 (_cfcf .Height )/float64 (height );for _dbge :=0;_dbge < height ;_dbge ++{_adf [_dbge ]=int (_e .Min (_acgf *float64 (_dbge )+0.5,float64 (_cfcf .Height -1)));
};for _bcgb :=0;_bcgb < width ;_bcgb ++{_bcad [_bcgb ]=int (_e .Min (_fggb *float64 (_bcgb )+0.5,float64 (_cfcf .Width -1)));};_egbd :=-1;_ffb :=byte (0);for _cbb :=0;_cbb < height ;_cbb ++{_edec :=_adf [_cbb ]*_cfcf .BytesPerLine ;_ggg :=_cbb *_bcdd .BytesPerLine ;
for _gdad :=0;_gdad < width ;_gdad ++{_gdfd :=_bcad [_gdad ];if _gdfd !=_egbd {_ffb =_cfcf .getBit (_edec ,_gdfd );if _ffb !=0{_bcdd .setBit (_ggg ,_gdad );};_egbd =_gdfd ;}else {if _ffb !=0{_bcdd .setBit (_ggg ,_gdad );};};};};return _bcdd ,nil ;};func (_ebbca *Gray2 )Validate ()error {if len (_ebbca .Data )!=_ebbca .Height *_ebbca .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_ebbe *ImageBase )GetAlpha ()[]byte {return _ebbe .Alpha };func _cca (_dbfca _a .Image ,_fba Image ,_geac _a .Rectangle ){for _eda :=0;_eda < _geac .Max .X ;_eda ++{for _edcd :=0;_edcd < _geac .Max .Y ;_edcd ++{_bdg :=_dbfca .At (_eda ,_edcd );
_fba .Set (_eda ,_edcd ,_bdg );};};};func _gcef (_ffcee _bc .NRGBA )_bc .NRGBA {_ffcee .R =_ffcee .R >>4|(_ffcee .R >>4)<<4;_ffcee .G =_ffcee .G >>4|(_ffcee .G >>4)<<4;_ffcee .B =_ffcee .B >>4|(_ffcee .B >>4)<<4;return _ffcee ;};var _ _a .Image =&NRGBA64 {};
func (_deca *Gray8 )ColorModel ()_bc .Model {return _bc .GrayModel };func (_ceab *NRGBA16 )Base ()*ImageBase {return &_ceab .ImageBase };func (_acca *Gray4 )setGray (_adec int ,_deda int ,_bgdb _bc .Gray ){_gbba :=_deda *_acca .BytesPerLine ;_cede :=_gbba +(_adec >>1);
if _cede >=len (_acca .Data ){return ;};_dgea :=_bgdb .Y >>4;_acca .Data [_cede ]=(_acca .Data [_cede ]&(^(0xf0>>uint (4*(_adec &1)))))|(_dgea <<uint (4-4*(_adec &1)));};type CMYK interface{CMYKAt (_gce ,_ccd int )_bc .CMYK ;SetCMYK (_gefd ,_gfce int ,_efcb _bc .CMYK );
};type monochromeThresholdConverter struct{Threshold uint8 ;};func _efe (_caa ,_dfe int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_caa ,_dfe ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _aeea (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_ddga *Gray8 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtGray8BPC (x ,y ,_ddga .BytesPerLine ,_ddga .Data ,_ddga .Decode );};func (_gadd *ImageBase )MakeAlpha (){_gadd .newAlpha ()};func _efdc (_adfgc *_a .NYCbCrA ,_bcaac RGBA ,_gdef _a .Rectangle ){for _gcfg :=0;
_gcfg < _gdef .Max .X ;_gcfg ++{for _ece :=0;_ece < _gdef .Max .Y ;_ece ++{_dcfd :=_adfgc .NYCbCrAAt (_gcfg ,_ece );_bcaac .SetRGBA (_gcfg ,_ece ,_eeca (_dcfd ));};};};func _dfeb (){for _bgbc :=0;_bgbc < 256;_bgbc ++{_afae [_bgbc ]=uint8 (_bgbc &0x1)+(uint8 (_bgbc >>1)&0x1)+(uint8 (_bgbc >>2)&0x1)+(uint8 (_bgbc >>3)&0x1)+(uint8 (_bgbc >>4)&0x1)+(uint8 (_bgbc >>5)&0x1)+(uint8 (_bgbc >>6)&0x1)+(uint8 (_bgbc >>7)&0x1);
};};var _ Gray =&Gray16 {};func _eeca (_cff _bc .NYCbCrA )_bc .RGBA {_geea ,_gbda ,_gfcg ,_fec :=_afa (_cff ).RGBA ();return _bc .RGBA {R :uint8 (_geea >>8),G :uint8 (_gbda >>8),B :uint8 (_gfcg >>8),A :uint8 (_fec >>8)};};func ImgToBinary (i _a .Image ,threshold uint8 )*_a .Gray {switch _bgfe :=i .(type ){case *_a .Gray :if _ddaab (_bgfe ){return _bgfe ;
};return _dggc (_bgfe ,threshold );case *_a .Gray16 :return _gfae (_bgfe ,threshold );default:return _geeca (_bgfe ,threshold );};};func (_bdcb *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_ecf :=_dbce (uint (factor ));if !IsPowerOf2 (uint (factor )){_ecf ++;
};_bdad :=make ([]int ,_ecf );for _cgd :=range _bdad {_bdad [_cgd ]=4;};_edab ,_dgag :=_gbf (_bdcb ,_bdad ...);if _dgag !=nil {return nil ,_dgag ;};return _edab ,nil ;};type RGBA interface{RGBAAt (_eeced ,_dbfce int )_bc .RGBA ;SetRGBA (_fcfg ,_cdfg int ,_dafgg _bc .RGBA );
};func (_ddaf *NRGBA64 )SetNRGBA64 (x ,y int ,c _bc .NRGBA64 ){_abce :=(y *_ddaf .Width +x )*2;_febg :=_abce *3;if _febg +5>=len (_ddaf .Data ){return ;};_ddaf .setNRGBA64 (_febg ,c ,_abce );};var _ Image =&RGBA32 {};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_bc .NRGBA64 ,error ){_facc :=(y *width +x )*2;
_agfe :=_facc *3;if _agfe +5>=len (data ){return _bc .NRGBA64 {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _gdafc =0xffff;_ecbe :=uint16 (_gdafc );if alpha !=nil &&len (alpha )> _facc +1{_ecbe =uint16 (alpha [_facc ])<<8|uint16 (alpha [_facc +1]);};_agegd :=uint16 (data [_agfe ])<<8|uint16 (data [_agfe +1]);_beaag :=uint16 (data [_agfe +2])<<8|uint16 (data [_agfe +3]);
_ffgf :=uint16 (data [_agfe +4])<<8|uint16 (data [_agfe +5]);if len (decode )==6{_agegd =uint16 (uint64 (LinearInterpolate (float64 (_agegd ),0,65535,decode [0],decode [1]))&_gdafc );_beaag =uint16 (uint64 (LinearInterpolate (float64 (_beaag ),0,65535,decode [2],decode [3]))&_gdafc );
_ffgf =uint16 (uint64 (LinearInterpolate (float64 (_ffgf ),0,65535,decode [4],decode [5]))&_gdafc );};return _bc .NRGBA64 {R :_agegd ,G :_beaag ,B :_ffgf ,A :_ecbe },nil ;};func (_ffcb *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_ffcb .copy ()}};
func _dggc (_dabb *_a .Gray ,_ffbe uint8 )*_a .Gray {_cabd :=_dabb .Bounds ();_feed :=_a .NewGray (_cabd );for _agee :=0;_agee < _cabd .Dx ();_agee ++{for _cbff :=0;_cbff < _cabd .Dy ();_cbff ++{_ddff :=_dabb .GrayAt (_agee ,_cbff );_feed .SetGray (_agee ,_cbff ,_bc .Gray {Y :_cbea (_ddff .Y ,_ffbe )});
};};return _feed ;};func (_gcec *RGBA32 )setRGBA (_dffa int ,_eead _bc .RGBA ){_bccac :=3*_dffa ;_gcec .Data [_bccac ]=_eead .R ;_gcec .Data [_bccac +1]=_eead .G ;_gcec .Data [_bccac +2]=_eead .B ;if _dffa < len (_gcec .Alpha ){_gcec .Alpha [_dffa ]=_eead .A ;
};};func _feaf (_cabcd *_a .NYCbCrA ,_bfbf NRGBA ,_ggagb _a .Rectangle ){for _afbc :=0;_afbc < _ggagb .Max .X ;_afbc ++{for _deac :=0;_deac < _ggagb .Max .Y ;_deac ++{_cggg :=_cabcd .NYCbCrAAt (_afbc ,_deac );_bfbf .SetNRGBA (_afbc ,_deac ,_afa (_cggg ));
};};};var _ Image =&NRGBA16 {};func _becd ()(_adg [256]uint32 ){for _bd :=0;_bd < 256;_bd ++{if _bd &0x01!=0{_adg [_bd ]|=0xf;};if _bd &0x02!=0{_adg [_bd ]|=0xf0;};if _bd &0x04!=0{_adg [_bd ]|=0xf00;};if _bd &0x08!=0{_adg [_bd ]|=0xf000;};if _bd &0x10!=0{_adg [_bd ]|=0xf0000;
};if _bd &0x20!=0{_adg [_bd ]|=0xf00000;};if _bd &0x40!=0{_adg [_bd ]|=0xf000000;};if _bd &0x80!=0{_adg [_bd ]|=0xf0000000;};};return _adg ;};func (_fef *CMYK32 )Set (x ,y int ,c _bc .Color ){_bcbf :=4*(y *_fef .Width +x );if _bcbf +3>=len (_fef .Data ){return ;
};_acfe :=_bc .CMYKModel .Convert (c ).(_bc .CMYK );_fef .Data [_bcbf ]=_acfe .C ;_fef .Data [_bcbf +1]=_acfe .M ;_fef .Data [_bcbf +2]=_acfe .Y ;_fef .Data [_bcbf +3]=_acfe .K ;};func _dbce (_bfb uint )uint {var _defa uint ;for _bfb !=0{_bfb >>=1;_defa ++;
};return _defa -1;};func _dffbc (_eaaa *Monochrome ,_ffdg ,_eadg ,_fdga ,_dgeb int ,_gadc RasterOperator ,_dbac *Monochrome ,_cgeca ,_ebgce int )error {var (_deae bool ;_gdc bool ;_babc byte ;_fgab int ;_cegde int ;_faab int ;_gcdg int ;_edbc bool ;_edca int ;
_bfaa int ;_gbed int ;_gedg bool ;_ebfbe byte ;_cbfea int ;_ggbc int ;_accf int ;_abgee byte ;_gbbd int ;_gbfg int ;_faecc uint ;_dgfc uint ;_eggd byte ;_gbdg shift ;_ageaa bool ;_bcgfa bool ;_gced ,_acfga int ;);if _cgeca &7!=0{_gbfg =8-(_cgeca &7);};
if _ffdg &7!=0{_cegde =8-(_ffdg &7);};if _gbfg ==0&&_cegde ==0{_eggd =_gbee [0];}else {if _cegde > _gbfg {_faecc =uint (_cegde -_gbfg );}else {_faecc =uint (8-(_gbfg -_cegde ));};_dgfc =8-_faecc ;_eggd =_gbee [_faecc ];};if (_ffdg &7)!=0{_deae =true ;_fgab =8-(_ffdg &7);
_babc =_gbee [_fgab ];_faab =_eaaa .BytesPerLine *_eadg +(_ffdg >>3);_gcdg =_dbac .BytesPerLine *_ebgce +(_cgeca >>3);_gbbd =8-(_cgeca &7);if _fgab > _gbbd {_gbdg =_edbcc ;if _fdga >=_gbfg {_ageaa =true ;};}else {_gbdg =_ecgd ;};};if _fdga < _fgab {_gdc =true ;
_babc &=_feae [8-_fgab +_fdga ];};if !_gdc {_edca =(_fdga -_fgab )>>3;if _edca !=0{_edbc =true ;_bfaa =_eaaa .BytesPerLine *_eadg +((_ffdg +_cegde )>>3);_gbed =_dbac .BytesPerLine *_ebgce +((_cgeca +_cegde )>>3);};};_cbfea =(_ffdg +_fdga )&7;if !(_gdc ||_cbfea ==0){_gedg =true ;
_ebfbe =_feae [_cbfea ];_ggbc =_eaaa .BytesPerLine *_eadg +((_ffdg +_cegde )>>3)+_edca ;_accf =_dbac .BytesPerLine *_ebgce +((_cgeca +_cegde )>>3)+_edca ;if _cbfea > int (_dgfc ){_bcgfa =true ;};};switch _gadc {case PixSrc :if _deae {for _gced =0;_gced < _dgeb ;
_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],_abgee ,_babc );
_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]=_abgee ;
};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],_abgee ,_ebfbe );
_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixNotSrc :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );
};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],^_abgee ,_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;_acfga < _edca ;
_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]=^_abgee ;};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;
if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],^_abgee ,_ebfbe );_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixSrcOrDst :if _deae {for _gced =0;_gced < _dgeb ;
_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],_abgee |_eaaa .Data [_faab ],_babc );
_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]|=_abgee ;
};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],_abgee |_eaaa .Data [_ggbc ],_ebfbe );
_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixSrcAndDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );
};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],_abgee &_eaaa .Data [_faab ],_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;
_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]&=_abgee ;};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;
_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],_abgee &_eaaa .Data [_ggbc ],_ebfbe );_ggbc +=_eaaa .BytesPerLine ;
_accf +=_dbac .BytesPerLine ;};};case PixSrcXorDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;
};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],_abgee ^_eaaa .Data [_faab ],_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );
_eaaa .Data [_bfaa +_acfga ]^=_abgee ;};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );
};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],_abgee ^_eaaa .Data [_ggbc ],_ebfbe );_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixNotSrcOrDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;
if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],^_abgee |_eaaa .Data [_faab ],_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;
};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]|=^_abgee ;};_bfaa +=_eaaa .BytesPerLine ;
_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],^_abgee |_eaaa .Data [_ggbc ],_ebfbe );
_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixNotSrcAndDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );
};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],^_abgee &_eaaa .Data [_faab ],_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;
_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]&=^_abgee ;};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;
_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],^_abgee &_eaaa .Data [_ggbc ],_ebfbe );_ggbc +=_eaaa .BytesPerLine ;
_accf +=_dbac .BytesPerLine ;};};case PixSrcOrNotDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;
};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],_abgee |^_eaaa .Data [_faab ],_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );
_eaaa .Data [_bfaa +_acfga ]=_abgee |^_eaaa .Data [_bfaa +_acfga ];};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );
};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],_abgee |^_eaaa .Data [_ggbc ],_ebfbe );_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixSrcAndNotDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;
if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],_abgee &^_eaaa .Data [_faab ],_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;
};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]=_abgee &^_eaaa .Data [_bfaa +_acfga ];
};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],_abgee &^_eaaa .Data [_ggbc ],_ebfbe );
_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixNotPixSrcOrDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );
};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],^(_abgee |_eaaa .Data [_faab ]),_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;
_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]=^(_abgee |_eaaa .Data [_bfaa +_acfga ]);};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;
};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],^(_abgee |_eaaa .Data [_ggbc ]),_ebfbe );
_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixNotPixSrcAndDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );
};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],^(_abgee &_eaaa .Data [_faab ]),_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;
_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]=^(_abgee &_eaaa .Data [_bfaa +_acfga ]);};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;
};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],^(_abgee &_eaaa .Data [_ggbc ]),_ebfbe );
_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};case PixNotPixSrcXorDst :if _deae {for _gced =0;_gced < _dgeb ;_gced ++{if _gbdg ==_edbcc {_abgee =_dbac .Data [_gcdg ]<<_faecc ;if _ageaa {_abgee =_gedfc (_abgee ,_dbac .Data [_gcdg +1]>>_dgfc ,_eggd );
};}else {_abgee =_dbac .Data [_gcdg ]>>_dgfc ;};_eaaa .Data [_faab ]=_gedfc (_eaaa .Data [_faab ],^(_abgee ^_eaaa .Data [_faab ]),_babc );_faab +=_eaaa .BytesPerLine ;_gcdg +=_dbac .BytesPerLine ;};};if _edbc {for _gced =0;_gced < _dgeb ;_gced ++{for _acfga =0;
_acfga < _edca ;_acfga ++{_abgee =_gedfc (_dbac .Data [_gbed +_acfga ]<<_faecc ,_dbac .Data [_gbed +_acfga +1]>>_dgfc ,_eggd );_eaaa .Data [_bfaa +_acfga ]=^(_abgee ^_eaaa .Data [_bfaa +_acfga ]);};_bfaa +=_eaaa .BytesPerLine ;_gbed +=_dbac .BytesPerLine ;
};};if _gedg {for _gced =0;_gced < _dgeb ;_gced ++{_abgee =_dbac .Data [_accf ]<<_faecc ;if _bcgfa {_abgee =_gedfc (_abgee ,_dbac .Data [_accf +1]>>_dgfc ,_eggd );};_eaaa .Data [_ggbc ]=_gedfc (_eaaa .Data [_ggbc ],^(_abgee ^_eaaa .Data [_ggbc ]),_ebfbe );
_ggbc +=_eaaa .BytesPerLine ;_accf +=_dbac .BytesPerLine ;};};default:_bcg .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_gadc );
return _c .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _fd (_ebb Gray ,_bgba CMYK ,_cfc _a .Rectangle ){for _eff :=0;
_eff < _cfc .Max .X ;_eff ++{for _gde :=0;_gde < _cfc .Max .Y ;_gde ++{_cded :=_ebb .GrayAt (_eff ,_gde );_bgba .SetCMYK (_eff ,_gde ,_bfeg (_cded ));};};};func _eegc (_gdce RGBA ,_cbcg NRGBA ,_fdadb _a .Rectangle ){for _bfed :=0;_bfed < _fdadb .Max .X ;
_bfed ++{for _ffee :=0;_ffee < _fdadb .Max .Y ;_ffee ++{_ccgb :=_gdce .RGBAAt (_bfed ,_ffee );_cbcg .SetNRGBA (_bfed ,_ffee ,_cab (_ccgb ));};};};type Gray interface{GrayAt (_ebcf ,_aed int )_bc .Gray ;SetGray (_ebe ,_fbdf int ,_eae _bc .Gray );};func _gbga (_ceeaa ,_abbc NRGBA ,_adeed _a .Rectangle ){for _edfb :=0;
_edfb < _adeed .Max .X ;_edfb ++{for _effdbf :=0;_effdbf < _adeed .Max .Y ;_effdbf ++{_abbc .SetNRGBA (_edfb ,_effdbf ,_ceeaa .NRGBAAt (_edfb ,_effdbf ));};};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bc .Gray ,error ){_ffgb :=y *bytesPerLine +x >>3;
if _ffgb >=len (data ){return _bc .Gray {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ecaf :=data [_ffgb ]>>uint (7-(x &7))&1;if len (decode )==2{_ecaf =uint8 (LinearInterpolate (float64 (_ecaf ),0.0,1.0,decode [0],decode [1]))&1;};return _bc .Gray {Y :_ecaf *255},nil ;};type NRGBA interface{NRGBAAt (_dacc ,_dgdfc int )_bc .NRGBA ;SetNRGBA (_aafb ,_cgcfe int ,_fdfag _bc .NRGBA );
};func _cdfc (_bede *Monochrome ,_eafg ,_fgee ,_bbef ,_abbg int ,_dbdg RasterOperator ){if _eafg < 0{_bbef +=_eafg ;_eafg =0;};_fdb :=_eafg +_bbef -_bede .Width ;if _fdb > 0{_bbef -=_fdb ;};if _fgee < 0{_abbg +=_fgee ;_fgee =0;};_bfbg :=_fgee +_abbg -_bede .Height ;
if _bfbg > 0{_abbg -=_bfbg ;};if _bbef <=0||_abbg <=0{return ;};if (_eafg &7)==0{_cdeg (_bede ,_eafg ,_fgee ,_bbef ,_abbg ,_dbdg );}else {_bbfd (_bede ,_eafg ,_fgee ,_bbef ,_abbg ,_dbdg );};};func _ace (_cbc _bc .Color )_bc .Color {_cbd :=_bc .GrayModel .Convert (_cbc ).(_bc .Gray );
return _edcc (_cbd );};func (_agad *NRGBA32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_agad .Width ,Y :_agad .Height }};};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_bc .NRGBA ,error ){_bddf :=y *bytesPerLine +x *3/2;
if _bddf +1>=len (data ){return _bc .NRGBA {},_fefc (x ,y );};const (_adbe =0xf;_cfeda =uint8 (0xff););_dggd :=_cfeda ;if alpha !=nil {_facf :=y *BytesPerLine (width ,4,1);if _facf < len (alpha ){if x %2==0{_dggd =(alpha [_facf ]>>uint (4))&_adbe ;}else {_dggd =alpha [_facf ]&_adbe ;
};_dggd |=_dggd <<4;};};var _gdecb ,_geec ,_dfde uint8 ;if x *3%2==0{_gdecb =(data [_bddf ]>>uint (4))&_adbe ;_geec =data [_bddf ]&_adbe ;_dfde =(data [_bddf +1]>>uint (4))&_adbe ;}else {_gdecb =data [_bddf ]&_adbe ;_geec =(data [_bddf +1]>>uint (4))&_adbe ;
_dfde =data [_bddf +1]&_adbe ;};if len (decode )==6{_gdecb =uint8 (uint32 (LinearInterpolate (float64 (_gdecb ),0,15,decode [0],decode [1]))&0xf);_geec =uint8 (uint32 (LinearInterpolate (float64 (_geec ),0,15,decode [2],decode [3]))&0xf);_dfde =uint8 (uint32 (LinearInterpolate (float64 (_dfde ),0,15,decode [4],decode [5]))&0xf);
};return _bc .NRGBA {R :(_gdecb <<4)|(_gdecb &0xf),G :(_geec <<4)|(_geec &0xf),B :(_dfde <<4)|(_dfde &0xf),A :_dggd },nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_cgf :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _caec Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_caec =&Monochrome {ImageBase :_cgf ,ModelThreshold :0x0f};case 2:_caec =&Gray2 {ImageBase :_cgf };case 4:_caec =&Gray4 {ImageBase :_cgf };case 8:_caec =&Gray8 {ImageBase :_cgf };
case 16:_caec =&Gray16 {ImageBase :_cgf };};case 3:switch bitsPerComponent {case 4:_caec =&NRGBA16 {ImageBase :_cgf };case 8:_caec =&NRGBA32 {ImageBase :_cgf };case 16:_caec =&NRGBA64 {ImageBase :_cgf };};case 4:_caec =&CMYK32 {ImageBase :_cgf };};if _caec ==nil {return nil ,ErrInvalidImage ;
};return _caec ,nil ;};func (_ddacb *NRGBA16 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtNRGBA16 (x ,y ,_ddacb .Width ,_ddacb .BytesPerLine ,_ddacb .Data ,_ddacb .Alpha ,_ddacb .Decode );};func (_ggbe *NRGBA16 )NRGBAAt (x ,y int )_bc .NRGBA {_ddaag ,_ :=ColorAtNRGBA16 (x ,y ,_ggbe .Width ,_ggbe .BytesPerLine ,_ggbe .Data ,_ggbe .Alpha ,_ggbe .Decode );
return _ddaag ;};func (_cedc *CMYK32 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtCMYK (x ,y ,_cedc .Width ,_cedc .Data ,_cedc .Decode );};func _bfeg (_fefb _bc .Gray )_bc .CMYK {return _bc .CMYK {K :0xff-_fefb .Y }};var _ Image =&NRGBA32 {};
func (_dafg *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _ba (_dafg ,factor );};func _faabf (_gebc Gray ,_gdd RGBA ,_eabe _a .Rectangle ){for _ceaa :=0;_ceaa < _eabe .Max .X ;_ceaa ++{for _ecaec :=0;_ecaec < _eabe .Max .Y ;_ecaec ++{_fefbff :=_gebc .GrayAt (_ceaa ,_ecaec );_gdd .SetRGBA (_ceaa ,_ecaec ,_gbgf (_fefbff ));
};};};func (_cegd *Gray4 )ColorModel ()_bc .Model {return Gray4Model };func _cafd (_fcca uint8 )bool {if _fcca ==0||_fcca ==255{return true ;};return false ;};func _efa (_gbfd _bc .NRGBA )_bc .Gray {_bab ,_ccab ,_edcf ,_ :=_gbfd .RGBA ();_bcgc :=(19595*_bab +38470*_ccab +7471*_edcf +1<<15)>>24;
return _bc .Gray {Y :uint8 (_bcgc )};};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_fdaf *Gray16 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtGray16BPC (x ,y ,_fdaf .BytesPerLine ,_fdaf .Data ,_fdaf .Decode );};func (_bece *Gray2 )GrayAt (x ,y int )_bc .Gray {_abdb ,_ :=ColorAtGray2BPC (x ,y ,_bece .BytesPerLine ,_bece .Data ,_bece .Decode );
return _abdb ;};func (_gcfa *Gray16 )GrayAt (x ,y int )_bc .Gray {_ebgf ,_ :=_gcfa .ColorAt (x ,y );return _bc .Gray {Y :uint8 (_ebgf .(_bc .Gray16 ).Y >>8)};};func (_ecde *Gray8 )GrayAt (x ,y int )_bc .Gray {_ebcfa ,_ :=ColorAtGray8BPC (x ,y ,_ecde .BytesPerLine ,_ecde .Data ,_ecde .Decode );
return _ebcfa ;};func _gbe (_cce RGBA ,_dffb CMYK ,_fae _a .Rectangle ){for _bccb :=0;_bccb < _fae .Max .X ;_bccb ++{for _ecba :=0;_ecba < _fae .Max .Y ;_ecba ++{_ccdb :=_cce .RGBAAt (_bccb ,_ecba );_dffb .SetCMYK (_bccb ,_ecba ,_cfff (_ccdb ));};};};func (_dbdf *RGBA32 )Set (x ,y int ,c _bc .Color ){_gafe :=y *_dbdf .Width +x ;
_cdbd :=3*_gafe ;if _cdbd +2>=len (_dbdf .Data ){return ;};_aaag :=_bc .RGBAModel .Convert (c ).(_bc .RGBA );_dbdf .setRGBA (_gafe ,_aaag );};func (_ccdc *CMYK32 )ColorModel ()_bc .Model {return _bc .CMYKModel };func (_bcaf *Monochrome )getBit (_acge ,_egge int )uint8 {return _bcaf .Data [_acge +(_egge >>3)]>>uint (7-(_egge &7))&1;
};func _cgfde (_dgde ,_adgf RGBA ,_aeac _a .Rectangle ){for _faee :=0;_faee < _aeac .Max .X ;_faee ++{for _bgc :=0;_bgc < _aeac .Max .Y ;_bgc ++{_adgf .SetRGBA (_faee ,_bgc ,_dgde .RGBAAt (_faee ,_bgc ));};};};func (_bdaa *Gray8 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_bdaa .Width ,Y :_bdaa .Height }};
};var (MonochromeConverter =ConverterFunc (_dbe );Gray2Converter =ConverterFunc (_afdf );Gray4Converter =ConverterFunc (_abcb );GrayConverter =ConverterFunc (_gfgd );Gray16Converter =ConverterFunc (_fcg );NRGBA16Converter =ConverterFunc (_bbceg );NRGBAConverter =ConverterFunc (_fcbg );
NRGBA64Converter =ConverterFunc (_fdcb );RGBAConverter =ConverterFunc (_caf );CMYKConverter =ConverterFunc (_beaa ););func (_cedd *NRGBA64 )ColorModel ()_bc .Model {return _bc .NRGBA64Model };func (_cdcc *Monochrome )IsUnpadded ()bool {return (_cdcc .Width *_cdcc .Height )==len (_cdcc .Data )};
func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_bc .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );
case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_aa .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _afagg (_bcfa *Monochrome ,_efea ,_fece ,_gbdf ,_gcfae int ,_cbfe RasterOperator ,_abgbe *Monochrome ,_cabc ,_eefb int )error {var (_baea byte ;_fdg int ;_bafe int ;_fbac ,_bbcg int ;_aaae ,_cfbcf int ;);_dcg :=_gbdf >>3;_aedb :=_gbdf &7;if _aedb > 0{_baea =_feae [_aedb ];
};_fdg =_abgbe .BytesPerLine *_eefb +(_cabc >>3);_bafe =_bcfa .BytesPerLine *_fece +(_efea >>3);switch _cbfe {case PixSrc :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;
_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]=_abgbe .Data [_fbac ];_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],_abgbe .Data [_fbac ],_baea );};};case PixNotSrc :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;
_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]=^(_abgbe .Data [_fbac ]);_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],^_abgbe .Data [_fbac ],_baea );};};case PixSrcOrDst :for _aaae =0;
_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]|=_abgbe .Data [_fbac ];_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],_abgbe .Data [_fbac ]|_bcfa .Data [_bbcg ],_baea );
};};case PixSrcAndDst :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]&=_abgbe .Data [_fbac ];_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],_abgbe .Data [_fbac ]&_bcfa .Data [_bbcg ],_baea );
};};case PixSrcXorDst :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]^=_abgbe .Data [_fbac ];_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],_abgbe .Data [_fbac ]^_bcfa .Data [_bbcg ],_baea );
};};case PixNotSrcOrDst :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]|=^(_abgbe .Data [_fbac ]);_bbcg ++;_fbac ++;};
if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],^(_abgbe .Data [_fbac ])|_bcfa .Data [_bbcg ],_baea );};};case PixNotSrcAndDst :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;
for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]&=^(_abgbe .Data [_fbac ]);_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],^(_abgbe .Data [_fbac ])&_bcfa .Data [_bbcg ],_baea );};};case PixSrcOrNotDst :for _aaae =0;
_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]=_abgbe .Data [_fbac ]|^(_bcfa .Data [_bbcg ]);_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],_abgbe .Data [_fbac ]|^(_bcfa .Data [_bbcg ]),_baea );
};};case PixSrcAndNotDst :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]=_abgbe .Data [_fbac ]&^(_bcfa .Data [_bbcg ]);
_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],_abgbe .Data [_fbac ]&^(_bcfa .Data [_bbcg ]),_baea );};};case PixNotPixSrcOrDst :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;
for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]=^(_abgbe .Data [_fbac ]|_bcfa .Data [_bbcg ]);_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],^(_abgbe .Data [_fbac ]|_bcfa .Data [_bbcg ]),_baea );};};case PixNotPixSrcAndDst :for _aaae =0;
_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]=^(_abgbe .Data [_fbac ]&_bcfa .Data [_bbcg ]);_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],^(_abgbe .Data [_fbac ]&_bcfa .Data [_bbcg ]),_baea );
};};case PixNotPixSrcXorDst :for _aaae =0;_aaae < _gcfae ;_aaae ++{_fbac =_fdg +_aaae *_abgbe .BytesPerLine ;_bbcg =_bafe +_aaae *_bcfa .BytesPerLine ;for _cfbcf =0;_cfbcf < _dcg ;_cfbcf ++{_bcfa .Data [_bbcg ]=^(_abgbe .Data [_fbac ]^_bcfa .Data [_bbcg ]);
_bbcg ++;_fbac ++;};if _aedb > 0{_bcfa .Data [_bbcg ]=_gedfc (_bcfa .Data [_bbcg ],^(_abgbe .Data [_fbac ]^_bcfa .Data [_bbcg ]),_baea );};};default:_bcg .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_cbfe );
return _c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_edfa *NRGBA16 )Validate ()error {if len (_edfa .Data )!=3*_edfa .Width *_edfa .Height /2{return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gdeb *Gray2 )At (x ,y int )_bc .Color {_bfgc ,_ :=_gdeb .ColorAt (x ,y );return _bfgc };const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;
PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;
PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func _gfgd (_gbff _a .Image )(Image ,error ){if _dffe ,_fgbf :=_gbff .(*Gray8 );
_fgbf {return _dffe .Copy (),nil ;};_bcdf :=_gbff .Bounds ();_gdgfa ,_bgae :=NewImage (_bcdf .Max .X ,_bcdf .Max .Y ,8,1,nil ,nil ,nil );if _bgae !=nil {return nil ,_bgae ;};_acbe (_gbff ,_gdgfa ,_bcdf );return _gdgfa ,nil ;};type NRGBA32 struct{ImageBase };
func (_decg *Gray2 )Histogram ()(_gcde [256]int ){for _agbca :=0;_agbca < _decg .Width ;_agbca ++{for _gace :=0;_gace < _decg .Height ;_gace ++{_gcde [_decg .GrayAt (_agbca ,_gace ).Y ]++;};};return _gcde ;};func (_dgg *Monochrome )AddPadding ()(_egc error ){if _fgdc :=((_dgg .Width *_dgg .Height )+7)>>3;
len (_dgg .Data )< _fgdc {return _aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_dgg .Data ),_fgdc );
};_eecb :=_dgg .Width %8;if _eecb ==0{return nil ;};_bbb :=_dgg .Width /8;_aff :=_ad .NewReader (_dgg .Data );_aadc :=make ([]byte ,_dgg .Height *_dgg .BytesPerLine );_feb :=_ad .NewWriterMSB (_aadc );_cac :=make ([]byte ,_bbb );var (_faa int ;_bfegg uint64 ;
);for _faa =0;_faa < _dgg .Height ;_faa ++{if _ ,_egc =_aff .Read (_cac );_egc !=nil {return _egc ;};if _ ,_egc =_feb .Write (_cac );_egc !=nil {return _egc ;};if _bfegg ,_egc =_aff .ReadBits (byte (_eecb ));_egc !=nil {return _egc ;};if _egc =_feb .WriteByte (byte (_bfegg )<<uint (8-_eecb ));
_egc !=nil {return _egc ;};};_dgg .Data =_feb .Data ();return nil ;};func _gfdf (_eafc ,_accd int ,_cfb []byte )*Monochrome {_deg :=_efe (_eafc ,_accd );_deg .Data =_cfb ;return _deg ;};func _acd (_dec ,_bde CMYK ,_deb _a .Rectangle ){for _acg :=0;_acg < _deb .Max .X ;
_acg ++{for _beg :=0;_beg < _deb .Max .Y ;_beg ++{_bde .SetCMYK (_acg ,_beg ,_dec .CMYKAt (_acg ,_beg ));};};};var _ NRGBA =&NRGBA16 {};func (_adfg *RGBA32 )Validate ()error {if len (_adfg .Data )!=3*_adfg .Width *_adfg .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ddgdc *NRGBA32 )SetNRGBA (x ,y int ,c _bc .NRGBA ){_efcf :=y *_ddgdc .Width +x ;_dbfb :=3*_efcf ;if _dbfb +2>=len (_ddgdc .Data ){return ;};_ddgdc .setRGBA (_efcf ,c );};func (_cad *Gray8 )Base ()*ImageBase {return &_cad .ImageBase };
var (Gray2Model =_bc .ModelFunc (_ace );Gray4Model =_bc .ModelFunc (_afeb );NRGBA16Model =_bc .ModelFunc (_ceabf ););func _fcbg (_ddaba _a .Image )(Image ,error ){if _cabaf ,_dbea :=_ddaba .(*NRGBA32 );_dbea {return _cabaf .Copy (),nil ;};_bfdb ,_dgab ,_gebf :=_fbde (_ddaba ,1);
_dgabg ,_eafa :=NewImage (_bfdb .Max .X ,_bfdb .Max .Y ,8,3,nil ,_gebf ,nil );if _eafa !=nil {return nil ,_eafa ;};_egbb (_ddaba ,_dgabg ,_bfdb );if len (_gebf )!=0&&!_dgab {if _aaga :=_bfeeg (_gebf ,_dgabg );_aaga !=nil {return nil ,_aaga ;};};return _dgabg ,nil ;
};func _ceabf (_deaee _bc .Color )_bc .Color {_afef :=_bc .NRGBAModel .Convert (_deaee ).(_bc .NRGBA );return _gcef (_afef );};func _bcecg (_fdad RGBA ,_fgbfd Gray ,_eaab _a .Rectangle ){for _fgda :=0;_fgda < _eaab .Max .X ;_fgda ++{for _ccdg :=0;_ccdg < _eaab .Max .Y ;
_ccdg ++{_bgead :=_gedc (_fdad .RGBAAt (_fgda ,_ccdg ));_fgbfd .SetGray (_fgda ,_ccdg ,_bgead );};};};func (_ffgc *NRGBA64 )Base ()*ImageBase {return &_ffgc .ImageBase };type Gray8 struct{ImageBase };var _ _a .Image =&Gray16 {};func _fddc (_fcdb *Monochrome ,_adcag ,_debd int ,_edcg ,_bbdd int ,_cbbdg RasterOperator ,_decaa *Monochrome ,_dbgc ,_aegg int )error {var _aedgg ,_agbb ,_becaf ,_aaf int ;
if _adcag < 0{_dbgc -=_adcag ;_edcg +=_adcag ;_adcag =0;};if _dbgc < 0{_adcag -=_dbgc ;_edcg +=_dbgc ;_dbgc =0;};_aedgg =_adcag +_edcg -_fcdb .Width ;if _aedgg > 0{_edcg -=_aedgg ;};_agbb =_dbgc +_edcg -_decaa .Width ;if _agbb > 0{_edcg -=_agbb ;};if _debd < 0{_aegg -=_debd ;
_bbdd +=_debd ;_debd =0;};if _aegg < 0{_debd -=_aegg ;_bbdd +=_aegg ;_aegg =0;};_becaf =_debd +_bbdd -_fcdb .Height ;if _becaf > 0{_bbdd -=_becaf ;};_aaf =_aegg +_bbdd -_decaa .Height ;if _aaf > 0{_bbdd -=_aaf ;};if _edcg <=0||_bbdd <=0{return nil ;};var _accc error ;
switch {case _adcag &7==0&&_dbgc &7==0:_accc =_afagg (_fcdb ,_adcag ,_debd ,_edcg ,_bbdd ,_cbbdg ,_decaa ,_dbgc ,_aegg );case _adcag &7==_dbgc &7:_accc =_fedg (_fcdb ,_adcag ,_debd ,_edcg ,_bbdd ,_cbbdg ,_decaa ,_dbgc ,_aegg );default:_accc =_dffbc (_fcdb ,_adcag ,_debd ,_edcg ,_bbdd ,_cbbdg ,_decaa ,_dbgc ,_aegg );
};if _accc !=nil {return _accc ;};return nil ;};func _eebbad (_fefe _bc .NRGBA )_bc .RGBA {_gbb ,_deccf ,_effd ,_eecd :=_fefe .RGBA ();return _bc .RGBA {R :uint8 (_gbb >>8),G :uint8 (_deccf >>8),B :uint8 (_effd >>8),A :uint8 (_eecd >>8)};};func _fcf (_bcgf _bc .Gray )_bc .Gray {_bcgf .Y >>=4;
_bcgf .Y |=_bcgf .Y <<4;return _bcgf };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _e .Abs (xmax -xmin )< 0.000001{return ymin ;};_bdge :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _bdge ;};func _bfc (_deebc Gray ,_cb nrgba64 ,_aedg _a .Rectangle ){for _ccea :=0;
_ccea < _aedg .Max .X ;_ccea ++{for _abgc :=0;_abgc < _aedg .Max .Y ;_abgc ++{_daeb :=_egb (_cb .NRGBA64At (_ccea ,_abgc ));_deebc .SetGray (_ccea ,_abgc ,_daeb );};};};func _gbc (_bce ,_ada *Monochrome )(_ee error ){_cea :=_ada .BytesPerLine ;_acc :=_bce .BytesPerLine ;
_ebdgf :=_ada .BytesPerLine *4-_bce .BytesPerLine ;var (_gc ,_dbg byte ;_gec uint32 ;_ege ,_bf ,_gf ,_ga ,_gef ,_gd ,_dc int ;);for _gf =0;_gf < _ada .Height ;_gf ++{_ege =_gf *_cea ;_bf =4*_gf *_acc ;for _ga =0;_ga < _cea ;_ga ++{_gc =_ada .Data [_ege +_ga ];
_gec =_aae [_gc ];_gd =_bf +_ga *4;if _ebdgf !=0&&(_ga +1)*4> _bce .BytesPerLine {for _gef =_ebdgf ;_gef > 0;_gef --{_dbg =byte ((_gec >>uint (_gef *8))&0xff);_dc =_gd +(_ebdgf -_gef );if _ee =_bce .setByte (_dc ,_dbg );_ee !=nil {return _ee ;};};}else if _ee =_bce .setFourBytes (_gd ,_gec );
_ee !=nil {return _ee ;};if _ee =_bce .setFourBytes (_bf +_ga *4,_aae [_ada .Data [_ege +_ga ]]);_ee !=nil {return _ee ;};};for _gef =1;_gef < 4;_gef ++{for _ga =0;_ga < _acc ;_ga ++{if _ee =_bce .setByte (_bf +_gef *_acc +_ga ,_bce .Data [_bf +_ga ]);
_ee !=nil {return _ee ;};};};};return nil ;};var _ Gray =&Gray2 {};func (_ddg monochromeModel )Convert (c _bc .Color )_bc .Color {_egad :=_bc .GrayModel .Convert (c ).(_bc .Gray );return _bdgf (_egad ,_ddg );};var _ _a .Image =&Gray8 {};func (_eacbe *Monochrome )Set (x ,y int ,c _bc .Color ){_bdbf :=y *_eacbe .BytesPerLine +x >>3;
if _bdbf > len (_eacbe .Data )-1{return ;};_ebbg :=_eacbe .ColorModel ().Convert (c ).(_bc .Gray );_eacbe .setGray (x ,_ebbg ,_bdbf );};func (_ecab *Monochrome )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_ecab .Width ,Y :_ecab .Height }};
};func _cfff (_gdf _bc .RGBA )_bc .CMYK {_adca ,_dge ,_gdaf ,_baba :=_bc .RGBToCMYK (_gdf .R ,_gdf .G ,_gdf .B );return _bc .CMYK {C :_adca ,M :_dge ,Y :_gdaf ,K :_baba };};func _aeea (_egd *Monochrome ,_dfbc ,_gaddd ,_dbfa ,_efba int ,_ebfff RasterOperator ,_cgb *Monochrome ,_eegb ,_aegb int )error {if _egd ==nil {return _c .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _ebfff ==PixDst {return nil ;};switch _ebfff {case PixClr ,PixSet ,PixNotDst :_cdfc (_egd ,_dfbc ,_gaddd ,_dbfa ,_efba ,_ebfff );return nil ;};if _cgb ==nil {_bcg .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _c .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _adbd :=_fddc (_egd ,_dfbc ,_gaddd ,_dbfa ,_efba ,_ebfff ,_cgb ,_eegb ,_aegb );_adbd !=nil {return _adbd ;};return nil ;};type Histogramer interface{Histogram ()[256]int ;
};func (_cfab *ImageBase )setEightFullBytes (_aebe int ,_ddf uint64 )error {if _aebe +7> len (_cfab .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cfab .Data [_aebe ]=byte ((_ddf &0xff00000000000000)>>56);
_cfab .Data [_aebe +1]=byte ((_ddf &0xff000000000000)>>48);_cfab .Data [_aebe +2]=byte ((_ddf &0xff0000000000)>>40);_cfab .Data [_aebe +3]=byte ((_ddf &0xff00000000)>>32);_cfab .Data [_aebe +4]=byte ((_ddf &0xff000000)>>24);_cfab .Data [_aebe +5]=byte ((_ddf &0xff0000)>>16);
_cfab .Data [_aebe +6]=byte ((_ddf &0xff00)>>8);_cfab .Data [_aebe +7]=byte (_ddf &0xff);return nil ;};func _gcca (_bbdcd Gray ,_beaf NRGBA ,_bfcf _a .Rectangle ){for _ccfe :=0;_ccfe < _bfcf .Max .X ;_ccfe ++{for _bbcf :=0;_bbcf < _bfcf .Max .Y ;_bbcf ++{_cgdae :=_bbdcd .GrayAt (_ccfe ,_bbcf );
_beaf .SetNRGBA (_ccfe ,_bbcf ,_ded (_cgdae ));};};};func MonochromeModel (threshold uint8 )_bc .Model {return monochromeModel (threshold )};var _ Image =&Gray8 {};var _ Image =&Gray16 {};type NRGBA64 struct{ImageBase };func (_dabd *Monochrome )setGrayBit (_fce ,_cdda int ){_dabd .Data [_fce ]|=0x80>>uint (_cdda &7)};
func (_bfcd *RGBA32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_bfcd .Width ,Y :_bfcd .Height }};};func _abc ()(_gba [256]uint64 ){for _fff :=0;_fff < 256;_fff ++{if _fff &0x01!=0{_gba [_fff ]|=0xff;};if _fff &0x02!=0{_gba [_fff ]|=0xff00;
};if _fff &0x04!=0{_gba [_fff ]|=0xff0000;};if _fff &0x08!=0{_gba [_fff ]|=0xff000000;};if _fff &0x10!=0{_gba [_fff ]|=0xff00000000;};if _fff &0x20!=0{_gba [_fff ]|=0xff0000000000;};if _fff &0x40!=0{_gba [_fff ]|=0xff000000000000;};if _fff &0x80!=0{_gba [_fff ]|=0xff00000000000000;
};};return _gba ;};func _fefc (_fbge int ,_acgfb int )error {return _aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_fbge ,_acgfb );
};func (_fdf *Gray2 )SetGray (x ,y int ,gray _bc .Gray ){_bfca :=_edcc (gray );_faf :=y *_fdf .BytesPerLine ;_eeee :=_faf +(x >>2);if _eeee >=len (_fdf .Data ){return ;};_edeg :=_bfca .Y >>6;_fdf .Data [_eeee ]=(_fdf .Data [_eeee ]&(^(0xc0>>uint (2*((x )&3)))))|(_edeg <<uint (6-2*(x &3)));
};func _abe (_aded _bc .NRGBA )_bc .Gray {var _af _bc .NRGBA ;if _aded ==_af {return _bc .Gray {Y :0xff};};_gca ,_fea ,_decc ,_ :=_aded .RGBA ();_bcaa :=(19595*_gca +38470*_fea +7471*_decc +1<<15)>>24;return _bc .Gray {Y :uint8 (_bcaa )};};type CMYK32 struct{ImageBase };
func _gbec (_beaagc _a .Image ,_gcb Image ,_cddaee _a .Rectangle ){if _fafa ,_fccgg :=_beaagc .(SMasker );_fccgg &&_fafa .HasAlpha (){_gcb .(SMasker ).MakeAlpha ();};_cca (_beaagc ,_gcb ,_cddaee );};func _acbe (_ggdc _a .Image ,_ebca Image ,_ecgaf _a .Rectangle ){switch _dad :=_ggdc .(type ){case Gray :_cebb (_dad ,_ebca .(Gray ),_ecgaf );
case NRGBA :_gcce (_dad ,_ebca .(Gray ),_ecgaf );case CMYK :_gdec (_dad ,_ebca .(Gray ),_ecgaf );case RGBA :_bcecg (_dad ,_ebca .(Gray ),_ecgaf );default:_cca (_ggdc ,_ebca ,_ecgaf );};};func _ffa (_aec int )[]uint {var _egf []uint ;_gfde :=_aec ;_eaf :=_gfde /8;
if _eaf !=0{for _bfee :=0;_bfee < _eaf ;_bfee ++{_egf =append (_egf ,8);};_dbd :=_gfde %8;_gfde =0;if _dbd !=0{_gfde =_dbd ;};};_bed :=_gfde /4;if _bed !=0{for _dcb :=0;_dcb < _bed ;_dcb ++{_egf =append (_egf ,4);};_fca :=_gfde %4;_gfde =0;if _fca !=0{_gfde =_fca ;
};};_cgc :=_gfde /2;if _cgc !=0{for _ebfb :=0;_ebfb < _cgc ;_ebfb ++{_egf =append (_egf ,2);};};return _egf ;};var ErrInvalidImage =_c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_bcge *Gray8 )Histogram ()(_abed [256]int ){for _fdde :=0;_fdde < len (_bcge .Data );_fdde ++{_abed [_bcge .Data [_fdde ]]++;};return _abed ;};func (_fada *Monochrome )Validate ()error {if len (_fada .Data )!=_fada .Height *_fada .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_gaca *Gray2 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_gaca .Width ,Y :_gaca .Height }};};func (_aga *Monochrome )setIndexedBit (_bfdd int ){_aga .Data [(_bfdd >>3)]|=0x80>>uint (_bfdd &7)};func (_dafd *RGBA32 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtRGBA32 (x ,y ,_dafd .Width ,_dafd .Data ,_dafd .Alpha ,_dafd .Decode );
};func _adge (_gcdf CMYK ,_eaggg RGBA ,_gedb _a .Rectangle ){for _dfff :=0;_dfff < _gedb .Max .X ;_dfff ++{for _feab :=0;_feab < _gedb .Max .Y ;_feab ++{_fcfge :=_gcdf .CMYKAt (_dfff ,_feab );_eaggg .SetRGBA (_dfff ,_feab ,_bafd (_fcfge ));};};};func (_bccf *ImageBase )setTwoBytes (_effdb int ,_dbda uint16 )error {if _effdb +1> len (_bccf .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bccf .Data [_effdb ]=byte ((_dbda &0xff00)>>8);_bccf .Data [_effdb +1]=byte (_dbda &0xff);return nil ;};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_f :=BytesPerLine (width ,8,1);if len (data )< _f *height {return nil ,nil ;
};_dg :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_db ,_g :=MonochromeConverter .Convert (_dg );if _g !=nil {return nil ,_g ;};return _db .Base ().Data ,nil ;};func _bbfd (_eeeb *Monochrome ,_ccge ,_eeba int ,_fbca ,_eggg int ,_cedec RasterOperator ){var (_ebfd bool ;
_dcbf bool ;_dgdf int ;_dcd int ;_bdac int ;_eeeac int ;_gacc bool ;_agfa byte ;);_ggaa :=8-(_ccge &7);_gffb :=_gbee [_ggaa ];_gbffb :=_eeeb .BytesPerLine *_eeba +(_ccge >>3);if _fbca < _ggaa {_ebfd =true ;_gffb &=_feae [8-_ggaa +_fbca ];};if !_ebfd {_dgdf =(_fbca -_ggaa )>>3;
if _dgdf !=0{_dcbf =true ;_dcd =_gbffb +1;};};_bdac =(_ccge +_fbca )&7;if !(_ebfd ||_bdac ==0){_gacc =true ;_agfa =_feae [_bdac ];_eeeac =_gbffb +1+_dgdf ;};var _bbce ,_ceef int ;switch _cedec {case PixClr :for _bbce =0;_bbce < _eggg ;_bbce ++{_eeeb .Data [_gbffb ]=_gedfc (_eeeb .Data [_gbffb ],0x0,_gffb );
_gbffb +=_eeeb .BytesPerLine ;};if _dcbf {for _bbce =0;_bbce < _eggg ;_bbce ++{for _ceef =0;_ceef < _dgdf ;_ceef ++{_eeeb .Data [_dcd +_ceef ]=0x0;};_dcd +=_eeeb .BytesPerLine ;};};if _gacc {for _bbce =0;_bbce < _eggg ;_bbce ++{_eeeb .Data [_eeeac ]=_gedfc (_eeeb .Data [_eeeac ],0x0,_agfa );
_eeeac +=_eeeb .BytesPerLine ;};};case PixSet :for _bbce =0;_bbce < _eggg ;_bbce ++{_eeeb .Data [_gbffb ]=_gedfc (_eeeb .Data [_gbffb ],0xff,_gffb );_gbffb +=_eeeb .BytesPerLine ;};if _dcbf {for _bbce =0;_bbce < _eggg ;_bbce ++{for _ceef =0;_ceef < _dgdf ;
_ceef ++{_eeeb .Data [_dcd +_ceef ]=0xff;};_dcd +=_eeeb .BytesPerLine ;};};if _gacc {for _bbce =0;_bbce < _eggg ;_bbce ++{_eeeb .Data [_eeeac ]=_gedfc (_eeeb .Data [_eeeac ],0xff,_agfa );_eeeac +=_eeeb .BytesPerLine ;};};case PixNotDst :for _bbce =0;_bbce < _eggg ;
_bbce ++{_eeeb .Data [_gbffb ]=_gedfc (_eeeb .Data [_gbffb ],^_eeeb .Data [_gbffb ],_gffb );_gbffb +=_eeeb .BytesPerLine ;};if _dcbf {for _bbce =0;_bbce < _eggg ;_bbce ++{for _ceef =0;_ceef < _dgdf ;_ceef ++{_eeeb .Data [_dcd +_ceef ]=^(_eeeb .Data [_dcd +_ceef ]);
};_dcd +=_eeeb .BytesPerLine ;};};if _gacc {for _bbce =0;_bbce < _eggg ;_bbce ++{_eeeb .Data [_eeeac ]=_gedfc (_eeeb .Data [_eeeac ],^_eeeb .Data [_eeeac ],_agfa );_eeeac +=_eeeb .BytesPerLine ;};};};};func _fdcb (_bbbb _a .Image )(Image ,error ){if _cfde ,_bgf :=_bbbb .(*NRGBA64 );
_bgf {return _cfde .Copy (),nil ;};_begec ,_defd ,_dfebd :=_fbde (_bbbb ,2);_fbf ,_edce :=NewImage (_begec .Max .X ,_begec .Max .Y ,16,3,nil ,_dfebd ,nil );if _edce !=nil {return nil ,_edce ;};_gbec (_bbbb ,_fbf ,_begec );if len (_dfebd )!=0&&!_defd {if _bfcb :=_bfeeg (_dfebd ,_fbf );
_bfcb !=nil {return nil ,_bfcb ;};};return _fbf ,nil ;};func (_cfeb *Gray2 )ColorAt (x ,y int )(_bc .Color ,error ){return ColorAtGray2BPC (x ,y ,_cfeb .BytesPerLine ,_cfeb .Data ,_cfeb .Decode );};func (_bedb *NRGBA32 )ColorModel ()_bc .Model {return _bc .NRGBAModel };
func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bc .Gray ,error ){_eag :=y *bytesPerLine +x >>1;if _eag >=len (data ){return _bc .Gray {},_aa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eed :=data [_eag ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_eed =uint8 (uint32 (LinearInterpolate (float64 (_eed ),0,15,decode [0],decode [1]))&0xf);};return _bc .Gray {Y :_eed *17&0xff},nil ;};func _aeae ()(_abb [256]uint16 ){for _ced :=0;_ced < 256;
_ced ++{if _ced &0x01!=0{_abb [_ced ]|=0x3;};if _ced &0x02!=0{_abb [_ced ]|=0xc;};if _ced &0x04!=0{_abb [_ced ]|=0x30;};if _ced &0x08!=0{_abb [_ced ]|=0xc0;};if _ced &0x10!=0{_abb [_ced ]|=0x300;};if _ced &0x20!=0{_abb [_ced ]|=0xc00;};if _ced &0x40!=0{_abb [_ced ]|=0x3000;
};if _ced &0x80!=0{_abb [_ced ]|=0xc000;};};return _abb ;};func (_fgf *Monochrome )getBitAt (_dbeg ,_fgdf int )bool {_ffag :=_fgdf *_fgf .BytesPerLine +(_dbeg >>3);_afe :=_dbeg &0x07;_caba :=uint (7-_afe );if _ffag > len (_fgf .Data )-1{return false ;};
if (_fgf .Data [_ffag ]>>_caba )&0x01>=1{return true ;};return false ;};func (_bcec *Gray4 )SetGray (x ,y int ,g _bc .Gray ){if x >=_bcec .Width ||y >=_bcec .Height {return ;};g =_fcf (g );_bcec .setGray (x ,y ,g );};func _dfg (_gfaf ,_bcc *Monochrome ,_fgge []byte ,_ade int )(_bcgd error ){var (_fbd ,_eafb ,_bdb ,_gac ,_aaa ,_geb ,_egg ,_ed int ;
_deec ,_gff ,_cdb ,_aeca uint32 ;_baca ,_caaa byte ;_gaa uint16 ;);_ggec :=make ([]byte ,4);_agd :=make ([]byte ,4);for _bdb =0;_bdb < _gfaf .Height -1;_bdb ,_gac =_bdb +2,_gac +1{_fbd =_bdb *_gfaf .BytesPerLine ;_eafb =_gac *_bcc .BytesPerLine ;for _aaa ,_geb =0,0;
_aaa < _ade ;_aaa ,_geb =_aaa +4,_geb +1{for _egg =0;_egg < 4;_egg ++{_ed =_fbd +_aaa +_egg ;if _ed <=len (_gfaf .Data )-1&&_ed < _fbd +_gfaf .BytesPerLine {_ggec [_egg ]=_gfaf .Data [_ed ];}else {_ggec [_egg ]=0x00;};_ed =_fbd +_gfaf .BytesPerLine +_aaa +_egg ;
if _ed <=len (_gfaf .Data )-1&&_ed < _fbd +(2*_gfaf .BytesPerLine ){_agd [_egg ]=_gfaf .Data [_ed ];}else {_agd [_egg ]=0x00;};};_deec =_d .BigEndian .Uint32 (_ggec );_gff =_d .BigEndian .Uint32 (_agd );_cdb =_deec &_gff ;_cdb |=_cdb <<1;_aeca =_deec |_gff ;
_aeca &=_aeca <<1;_gff =_cdb |_aeca ;_gff &=0xaaaaaaaa;_deec =_gff |(_gff <<7);_baca =byte (_deec >>24);_caaa =byte ((_deec >>8)&0xff);_ed =_eafb +_geb ;if _ed +1==len (_bcc .Data )-1||_ed +1>=_eafb +_bcc .BytesPerLine {if _bcgd =_bcc .setByte (_ed ,_fgge [_baca ]);
_bcgd !=nil {return _aa .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ed );};}else {_gaa =(uint16 (_fgge [_baca ])<<8)|uint16 (_fgge [_caaa ]);if _bcgd =_bcc .setTwoBytes (_ed ,_gaa );_bcgd !=nil {return _aa .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ed );
};_geb ++;};};};return nil ;};func (_ebea *Gray8 )Validate ()error {if len (_ebea .Data )!=_ebea .Height *_ebea .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dab *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_dab .ImageBase .copy (),ModelThreshold :_dab .ModelThreshold };
};var _ Image =&Monochrome {};func (_abec *Gray16 )Histogram ()(_ccbf [256]int ){for _eedg :=0;_eedg < _abec .Width ;_eedg ++{for _gecc :=0;_gecc < _abec .Height ;_gecc ++{_ccbf [_abec .GrayAt (_eedg ,_gecc ).Y ]++;};};return _ccbf ;};func _gbgf (_dga _bc .Gray )_bc .RGBA {return _bc .RGBA {R :_dga .Y ,G :_dga .Y ,B :_dga .Y ,A :0xff}};
var (_cggd =_aeae ();_aae =_becd ();_dfd =_abc (););func (_gaaca *RGBA32 )SetRGBA (x ,y int ,c _bc .RGBA ){_fdfb :=y *_gaaca .Width +x ;_gae :=3*_fdfb ;if _gae +2>=len (_gaaca .Data ){return ;};_gaaca .setRGBA (_fdfb ,c );};type NRGBA16 struct{ImageBase };
func (_dgdb *NRGBA32 )setRGBA (_bdfa int ,_ffdd _bc .NRGBA ){_ddfb :=3*_bdfa ;_dgdb .Data [_ddfb ]=_ffdd .R ;_dgdb .Data [_ddfb +1]=_ffdd .G ;_dgdb .Data [_ddfb +2]=_ffdd .B ;if _bdfa < len (_dgdb .Alpha ){_dgdb .Alpha [_bdfa ]=_ffdd .A ;};};