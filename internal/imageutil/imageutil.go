//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_gb "encoding/binary";_a "errors";_bf "fmt";_cd "github.com/unidoc/unipdf/v3/common";_gd "github.com/unidoc/unipdf/v3/internal/bitwise";_aa "image";_bg "image/color";_g "image/draw";_c "math";);func (_fceff *Gray4 )Histogram ()(_ddc [256]int ){for _ebbc :=0;
_ebbc < _fceff .Width ;_ebbc ++{for _cdcf :=0;_cdcf < _fceff .Height ;_cdcf ++{_ddc [_fceff .GrayAt (_ebbc ,_cdcf ).Y ]++;};};return _ddc ;};func (_ffgd *Monochrome )ColorModel ()_bg .Model {return MonochromeModel (_ffgd .ModelThreshold )};func (_dcca *Monochrome )setGrayBit (_daff ,_bfgd int ){_dcca .Data [_daff ]|=0x80>>uint (_bfgd &7)};
func _eebb (_ded NRGBA ,_cabba CMYK ,_fbf _aa .Rectangle ){for _gfc :=0;_gfc < _fbf .Max .X ;_gfc ++{for _fgf :=0;_fgf < _fbf .Max .Y ;_fgf ++{_bdf :=_ded .NRGBAAt (_gfc ,_fgf );_cabba .SetCMYK (_gfc ,_fgf ,_bdgf (_bdf ));};};};func (_dbb *Monochrome )setGray (_bag int ,_bgeg _bg .Gray ,_cfdf int ){if _bgeg .Y ==0{_dbb .clearBit (_cfdf ,_bag );
}else {_dbb .setGrayBit (_cfdf ,_bag );};};func (_gefg *ImageBase )HasAlpha ()bool {if _gefg .Alpha ==nil {return false ;};for _fgcbf :=range _gefg .Alpha {if _gefg .Alpha [_fgcbf ]!=0xff{return true ;};};return false ;};func (_gcg *CMYK32 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_gcg .Width ,Y :_gcg .Height }};
};func _dae (_adag _bg .NYCbCrA )_bg .NRGBA {_fcbf :=int32 (_adag .Y )*0x10101;_aege :=int32 (_adag .Cb )-128;_fca :=int32 (_adag .Cr )-128;_gcae :=_fcbf +91881*_fca ;if uint32 (_gcae )&0xff000000==0{_gcae >>=8;}else {_gcae =^(_gcae >>31)&0xffff;};_fcf :=_fcbf -22554*_aege -46802*_fca ;
if uint32 (_fcf )&0xff000000==0{_fcf >>=8;}else {_fcf =^(_fcf >>31)&0xffff;};_bbga :=_fcbf +116130*_aege ;if uint32 (_bbga )&0xff000000==0{_bbga >>=8;}else {_bbga =^(_bbga >>31)&0xffff;};return _bg .NRGBA {R :uint8 (_gcae >>8),G :uint8 (_fcf >>8),B :uint8 (_bbga >>8),A :_adag .A };
};var (_aaaf =_fdb ();_daa =_gca ();_ecb =_fec (););func _edfb (_agga _aa .Image )(Image ,error ){if _beg ,_efe :=_agga .(*Gray4 );_efe {return _beg .Copy (),nil ;};_gcagg :=_agga .Bounds ();_gcff ,_agc :=NewImage (_gcagg .Max .X ,_gcagg .Max .Y ,4,1,nil ,nil ,nil );
if _agc !=nil {return nil ,_agc ;};_bfda (_agga ,_gcff ,_gcagg );return _gcff ,nil ;};func _dbg (_feeb _aa .Image )(Image ,error ){if _cag ,_bfdd :=_feeb .(*CMYK32 );_bfdd {return _cag .Copy (),nil ;};_edgg :=_feeb .Bounds ();_ecf ,_gcfe :=NewImage (_edgg .Max .X ,_edgg .Max .Y ,8,4,nil ,nil ,nil );
if _gcfe !=nil {return nil ,_gcfe ;};switch _cda :=_feeb .(type ){case CMYK :_eaf (_cda ,_ecf .(CMYK ),_edgg );case Gray :_bcbe (_cda ,_ecf .(CMYK ),_edgg );case NRGBA :_eebb (_cda ,_ecf .(CMYK ),_edgg );case RGBA :_ffa (_cda ,_ecf .(CMYK ),_edgg );default:_dce (_feeb ,_ecf ,_edgg );
};return _ecf ,nil ;};func _gcge (_dbd _bg .NRGBA )_bg .Gray {var _geaf _bg .NRGBA ;if _dbd ==_geaf {return _bg .Gray {Y :0xff};};_fbff ,_bcf ,_ceg ,_ :=_dbd .RGBA ();_fef :=(19595*_fbff +38470*_bcf +7471*_ceg +1<<15)>>24;return _bg .Gray {Y :uint8 (_fef )};
};func MonochromeModel (threshold uint8 )_bg .Model {return monochromeModel (threshold )};func (_bdbeb *Gray16 )GrayAt (x ,y int )_bg .Gray {_bde ,_ :=_bdbeb .ColorAt (x ,y );return _bg .Gray {Y :uint8 (_bde .(_bg .Gray16 ).Y >>8)};};func (_cbg *CMYK32 )Set (x ,y int ,c _bg .Color ){_fead :=4*(y *_cbg .Width +x );
if _fead +3>=len (_cbg .Data ){return ;};_fbc :=_bg .CMYKModel .Convert (c ).(_bg .CMYK );_cbg .Data [_fead ]=_fbc .C ;_cbg .Data [_fead +1]=_fbc .M ;_cbg .Data [_fead +2]=_fbc .Y ;_cbg .Data [_fead +3]=_fbc .K ;};func (_aega *Gray4 )Base ()*ImageBase {return &_aega .ImageBase };
func _ccdd (_fag ,_ead *Monochrome ,_fgba []byte ,_gcea int )(_ecc error ){var (_ece ,_bdc ,_dfgg ,_bfa ,_gcf ,_bab ,_gbg ,_gbb int ;_efga ,_dfee uint32 ;_eed ,_cbf byte ;_ebge uint16 ;);_acd :=make ([]byte ,4);_dfae :=make ([]byte ,4);for _dfgg =0;_dfgg < _fag .Height -1;
_dfgg ,_bfa =_dfgg +2,_bfa +1{_ece =_dfgg *_fag .BytesPerLine ;_bdc =_bfa *_ead .BytesPerLine ;for _gcf ,_bab =0,0;_gcf < _gcea ;_gcf ,_bab =_gcf +4,_bab +1{for _gbg =0;_gbg < 4;_gbg ++{_gbb =_ece +_gcf +_gbg ;if _gbb <=len (_fag .Data )-1&&_gbb < _ece +_fag .BytesPerLine {_acd [_gbg ]=_fag .Data [_gbb ];
}else {_acd [_gbg ]=0x00;};_gbb =_ece +_fag .BytesPerLine +_gcf +_gbg ;if _gbb <=len (_fag .Data )-1&&_gbb < _ece +(2*_fag .BytesPerLine ){_dfae [_gbg ]=_fag .Data [_gbb ];}else {_dfae [_gbg ]=0x00;};};_efga =_gb .BigEndian .Uint32 (_acd );_dfee =_gb .BigEndian .Uint32 (_dfae );
_dfee &=_efga ;_dfee &=_dfee <<1;_dfee &=0xaaaaaaaa;_efga =_dfee |(_dfee <<7);_eed =byte (_efga >>24);_cbf =byte ((_efga >>8)&0xff);_gbb =_bdc +_bab ;if _gbb +1==len (_ead .Data )-1||_gbb +1>=_bdc +_ead .BytesPerLine {_ead .Data [_gbb ]=_fgba [_eed ];if _ecc =_ead .setByte (_gbb ,_fgba [_eed ]);
_ecc !=nil {return _bf .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gbb );};}else {_ebge =(uint16 (_fgba [_eed ])<<8)|uint16 (_fgba [_cbf ]);if _ecc =_ead .setTwoBytes (_gbb ,_ebge );_ecc !=nil {return _bf .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gbb );
};_bab ++;};};};return nil ;};func _fba (_ffbf []byte ,_dadb Image )error {_adaa :=true ;for _ddbd :=0;_ddbd < len (_ffbf );_ddbd ++{if _ffbf [_ddbd ]!=0xff{_adaa =false ;break ;};};if _adaa {switch _ddefa :=_dadb .(type ){case *NRGBA32 :_ddefa .Alpha =nil ;
case *NRGBA64 :_ddefa .Alpha =nil ;default:return _bf .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_dadb );
};};return nil ;};var _ _aa .Image =&NRGBA64 {};func (_aceb *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_a .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_dbf :=_cab (width ,height );_dgae :=make ([]int ,height );_edeb :=make ([]int ,width );_afb :=float64 (_aceb .Width )/float64 (width );_ccga :=float64 (_aceb .Height )/float64 (height );for _egbdb :=0;_egbdb < height ;_egbdb ++{_dgae [_egbdb ]=int (_c .Min (_ccga *float64 (_egbdb )+0.5,float64 (_aceb .Height -1)));
};for _bgee :=0;_bgee < width ;_bgee ++{_edeb [_bgee ]=int (_c .Min (_afb *float64 (_bgee )+0.5,float64 (_aceb .Width -1)));};_badf :=-1;_cdaa :=byte (0);for _eef :=0;_eef < height ;_eef ++{_fdbf :=_dgae [_eef ]*_aceb .BytesPerLine ;_cdba :=_eef *_dbf .BytesPerLine ;
for _cdge :=0;_cdge < width ;_cdge ++{_gbdd :=_edeb [_cdge ];if _gbdd !=_badf {_cdaa =_aceb .getBit (_fdbf ,_gbdd );if _cdaa !=0{_dbf .setBit (_cdba ,_cdge );};_badf =_gbdd ;}else {if _cdaa !=0{_dbf .setBit (_cdba ,_cdge );};};};};return _dbf ,nil ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_bg .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_bf .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_gaaaa :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _gaaaa ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_ffb :=width *colorComponents *bitsPerComponent ;
_aaba :=_gaaaa *8;_abefa :=8-(_aaba -_ffb );_deae :=_gd .NewReader (data );_bgfd :=_gaaaa -1;_bdcce :=make ([]byte ,_bgfd );_beea :=make ([]byte ,height *_gaaaa );_afbd :=_gd .NewWriterMSB (_beea );var _aefg uint64 ;var _fbda error ;for _dgda :=0;_dgda < height ;
_dgda ++{_ ,_fbda =_deae .Read (_bdcce );if _fbda !=nil {return nil ,_fbda ;};_ ,_fbda =_afbd .Write (_bdcce );if _fbda !=nil {return nil ,_fbda ;};_aefg ,_fbda =_deae .ReadBits (byte (_abefa ));if _fbda !=nil {return nil ,_fbda ;};_ ,_fbda =_afbd .WriteBits (_aefg ,_abefa );
if _fbda !=nil {return nil ,_fbda ;};_afbd .FinishByte ();};return _beea ,nil ;};func (_eceg *RGBA32 )At (x ,y int )_bg .Color {_gbda ,_ :=_eceg .ColorAt (x ,y );return _gbda };func _adff (_fedb _aa .Image )(Image ,error ){if _cbcg ,_ggfc :=_fedb .(*NRGBA16 );
_ggfc {return _cbcg .Copy (),nil ;};_ecaa :=_fedb .Bounds ();_gcdb ,_gdaca :=NewImage (_ecaa .Max .X ,_ecaa .Max .Y ,4,3,nil ,nil ,nil );if _gdaca !=nil {return nil ,_gdaca ;};_afed (_fedb ,_gcdb ,_ecaa );return _gcdb ,nil ;};func (_dfbd *Monochrome )Base ()*ImageBase {return &_dfbd .ImageBase };
func _fbee (_bceeb _aa .Image ,_aeae Image ,_bcac _aa .Rectangle ){if _aefdd ,_febf :=_bceeb .(SMasker );_febf &&_aefdd .HasAlpha (){_aeae .(SMasker ).MakeAlpha ();};switch _abgb :=_bceeb .(type ){case Gray :_edfee (_abgb ,_aeae .(RGBA ),_bcac );case NRGBA :_bgfgg (_abgb ,_aeae .(RGBA ),_bcac );
case *_aa .NYCbCrA :_adfg (_abgb ,_aeae .(RGBA ),_bcac );case CMYK :_cbbc (_abgb ,_aeae .(RGBA ),_bcac );case RGBA :_dcfe (_abgb ,_aeae .(RGBA ),_bcac );case nrgba64 :_dfcd (_abgb ,_aeae .(RGBA ),_bcac );default:_dce (_bceeb ,_aeae ,_bcac );};};type Gray2 struct{ImageBase };
func (_bgef *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_egbc :=_facf (uint (factor ));if !IsPowerOf2 (uint (factor )){_egbc ++;};_eadb :=make ([]int ,_egbc );for _fcgb :=range _eadb {_eadb [_fcgb ]=4;};_bcdc ,_beeb :=_gcb (_bgef ,_eadb ...);
if _beeb !=nil {return nil ,_beeb ;};return _bcdc ,nil ;};func _eaf (_fdgc ,_aebb CMYK ,_bgd _aa .Rectangle ){for _aabb :=0;_aabb < _bgd .Max .X ;_aabb ++{for _fbe :=0;_fbe < _bgd .Max .Y ;_fbe ++{_aebb .SetCMYK (_aabb ,_fbe ,_fdgc .CMYKAt (_aabb ,_fbe ));
};};};func _e (_de *Monochrome ,_eb int ,_cfa []uint )(*Monochrome ,error ){_cca :=_eb *_de .Width ;_aab :=_eb *_de .Height ;_gc :=_cab (_cca ,_aab );for _ac ,_df :=range _cfa {var _dc error ;switch _df {case 2:_dc =_bfe (_gc ,_de );case 4:_dc =_ab (_gc ,_de );
case 8:_dc =_dgb (_gc ,_de );};if _dc !=nil {return nil ,_dc ;};if _ac !=len (_cfa )-1{_de =_gc .copy ();};};return _gc ,nil ;};type Gray16 struct{ImageBase };func _bfe (_ef ,_f *Monochrome )(_ae error ){_dff :=_f .BytesPerLine ;_agd :=_ef .BytesPerLine ;
var (_bc byte ;_ea uint16 ;_aac ,_aca ,_fg ,_cg ,_gde int ;);for _fg =0;_fg < _f .Height ;_fg ++{_aac =_fg *_dff ;_aca =2*_fg *_agd ;for _cg =0;_cg < _dff ;_cg ++{_bc =_f .Data [_aac +_cg ];_ea =_aaaf [_bc ];_gde =_aca +_cg *2;if _ef .BytesPerLine !=_f .BytesPerLine *2&&(_cg +1)*2> _ef .BytesPerLine {_ae =_ef .setByte (_gde ,byte (_ea >>8));
}else {_ae =_ef .setTwoBytes (_gde ,_ea );};if _ae !=nil {return _ae ;};};for _cg =0;_cg < _agd ;_cg ++{_gde =_aca +_agd +_cg ;_bc =_ef .Data [_aca +_cg ];if _ae =_ef .setByte (_gde ,_bc );_ae !=nil {return _ae ;};};};return nil ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_bg .NRGBA ,error ){_gdcg :=y *width +x ;
_dafc :=3*_gdcg ;if _dafc +2>=len (data ){return _bg .NRGBA {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fbdeg :=uint8 (0xff);if alpha !=nil &&len (alpha )> _gdcg {_fbdeg =alpha [_gdcg ];};_cfbf ,_dbgb ,_fegf :=data [_dafc ],data [_dafc +1],data [_dafc +2];if len (decode )==6{_cfbf =uint8 (uint32 (LinearInterpolate (float64 (_cfbf ),0,255,decode [0],decode [1]))&0xff);
_dbgb =uint8 (uint32 (LinearInterpolate (float64 (_dbgb ),0,255,decode [2],decode [3]))&0xff);_fegf =uint8 (uint32 (LinearInterpolate (float64 (_fegf ),0,255,decode [4],decode [5]))&0xff);};return _bg .NRGBA {R :_cfbf ,G :_dbgb ,B :_fegf ,A :_fbdeg },nil ;
};func (_acdd *RGBA32 )ColorModel ()_bg .Model {return _bg .NRGBAModel };func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bg .Gray ,error ){_ebga :=y *bytesPerLine +x >>3;if _ebga >=len (data ){return _bg .Gray {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dfeb :=data [_ebga ]>>uint (7-(x &7))&1;if len (decode )==2{_dfeb =uint8 (LinearInterpolate (float64 (_dfeb ),0.0,1.0,decode [0],decode [1]))&1;};return _bg .Gray {Y :_dfeb *255},nil ;};func _eca (_fcb int )[]uint {var _bdd []uint ;_egb :=_fcb ;_afc :=_egb /8;
if _afc !=0{for _eeb :=0;_eeb < _afc ;_eeb ++{_bdd =append (_bdd ,8);};_baa :=_egb %8;_egb =0;if _baa !=0{_egb =_baa ;};};_aeb :=_egb /4;if _aeb !=0{for _ca :=0;_ca < _aeb ;_ca ++{_bdd =append (_bdd ,4);};_ccb :=_egb %4;_egb =0;if _ccb !=0{_egb =_ccb ;
};};_fgc :=_egb /2;if _fgc !=0{for _gdea :=0;_gdea < _fgc ;_gdea ++{_bdd =append (_bdd ,2);};};return _bdd ;};func (_ecbf *Gray16 )ColorModel ()_bg .Model {return _bg .Gray16Model };var _ Image =&Gray4 {};func (_aefb *RGBA32 )Validate ()error {if len (_aefb .Data )!=3*_aefb .Width *_aefb .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ffde *Gray16 )Base ()*ImageBase {return &_ffde .ImageBase };type NRGBA16 struct{ImageBase };func (_bfgge *RGBA32 )RGBAAt (x ,y int )_bg .RGBA {_dbggc ,_ :=ColorAtRGBA32 (x ,y ,_bfgge .Width ,_bfgge .Data ,_bfgge .Alpha ,_bfgge .Decode );
return _dbggc ;};func IsGrayImgBlackAndWhite (i *_aa .Gray )bool {return _bbb (i )};type CMYK interface{CMYKAt (_fea ,_egbb int )_bg .CMYK ;SetCMYK (_edf ,_cgeb int ,_bgc _bg .CMYK );};func (_dbfc *NRGBA16 )setNRGBA (_egef ,_fagbb ,_eegbe int ,_ddgc _bg .NRGBA ){if _egef *3%2==0{_dbfc .Data [_eegbe ]=(_ddgc .R >>4)<<4|(_ddgc .G >>4);
_dbfc .Data [_eegbe +1]=(_ddgc .B >>4)<<4|(_dbfc .Data [_eegbe +1]&0xf);}else {_dbfc .Data [_eegbe ]=(_dbfc .Data [_eegbe ]&0xf0)|(_ddgc .R >>4);_dbfc .Data [_eegbe +1]=(_ddgc .G >>4)<<4|(_ddgc .B >>4);};if _dbfc .Alpha !=nil {_gdfb :=_fagbb *BytesPerLine (_dbfc .Width ,4,1);
if _gdfb < len (_dbfc .Alpha ){if _egef %2==0{_dbfc .Alpha [_gdfb ]=(_ddgc .A >>uint (4))<<uint (4)|(_dbfc .Alpha [_eegbe ]&0xf);}else {_dbfc .Alpha [_gdfb ]=(_dbfc .Alpha [_gdfb ]&0xf0)|(_ddgc .A >>uint (4));};};};};func _bcbe (_ffd Gray ,_edd CMYK ,_cgc _aa .Rectangle ){for _def :=0;
_def < _cgc .Max .X ;_def ++{for _bffg :=0;_bffg < _cgc .Max .Y ;_bffg ++{_fcg :=_ffd .GrayAt (_def ,_bffg );_edd .SetCMYK (_def ,_bffg ,_edfd (_fcg ));};};};func (_bca *CMYK32 )CMYKAt (x ,y int )_bg .CMYK {_bbd ,_ :=ColorAtCMYK (x ,y ,_bca .Width ,_bca .Data ,_bca .Decode );
return _bbd ;};func (_fggd *ImageBase )setTwoBytes (_gdgc int ,_gagd uint16 )error {if _gdgc +1> len (_fggd .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fggd .Data [_gdgc ]=byte ((_gagd &0xff00)>>8);
_fggd .Data [_gdgc +1]=byte (_gagd &0xff);return nil ;};var ErrInvalidImage =_a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
var _ Image =&NRGBA64 {};func (_ceaa *NRGBA16 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtNRGBA16 (x ,y ,_ceaa .Width ,_ceaa .BytesPerLine ,_ceaa .Data ,_ceaa .Alpha ,_ceaa .Decode );};type colorConverter struct{_ddf func (_bee _aa .Image )(Image ,error );
};func _cee (_fdde ,_cfbd ,_bdaa byte )byte {return (_fdde &^(_bdaa ))|(_cfbd &_bdaa )};var _ NRGBA =&NRGBA32 {};func _ab (_ge ,_aaa *Monochrome )(_gee error ){_ad :=_aaa .BytesPerLine ;_adc :=_ge .BytesPerLine ;_cgg :=_aaa .BytesPerLine *4-_ge .BytesPerLine ;
var (_eg ,_bd byte ;_gf uint32 ;_ec ,_dg ,_ada ,_ccc ,_ba ,_db ,_cgb int ;);for _ada =0;_ada < _aaa .Height ;_ada ++{_ec =_ada *_ad ;_dg =4*_ada *_adc ;for _ccc =0;_ccc < _ad ;_ccc ++{_eg =_aaa .Data [_ec +_ccc ];_gf =_daa [_eg ];_db =_dg +_ccc *4;if _cgg !=0&&(_ccc +1)*4> _ge .BytesPerLine {for _ba =_cgg ;
_ba > 0;_ba --{_bd =byte ((_gf >>uint (_ba *8))&0xff);_cgb =_db +(_cgg -_ba );if _gee =_ge .setByte (_cgb ,_bd );_gee !=nil {return _gee ;};};}else if _gee =_ge .setFourBytes (_db ,_gf );_gee !=nil {return _gee ;};if _gee =_ge .setFourBytes (_dg +_ccc *4,_daa [_aaa .Data [_ec +_ccc ]]);
_gee !=nil {return _gee ;};};for _ba =1;_ba < 4;_ba ++{for _ccc =0;_ccc < _adc ;_ccc ++{if _gee =_ge .setByte (_dg +_ba *_adc +_ccc ,_ge .Data [_dg +_ccc ]);_gee !=nil {return _gee ;};};};};return nil ;};func _geeg (_facba _aa .Image )(Image ,error ){if _egbe ,_ffbe :=_facba .(*RGBA32 );
_ffbe {return _egbe .Copy (),nil ;};_feadg ,_aefd ,_aage :=_cebb (_facba ,1);_gcfeea :=&RGBA32 {ImageBase :NewImageBase (_feadg .Max .X ,_feadg .Max .Y ,8,3,nil ,_aage ,nil )};_fbee (_facba ,_gcfeea ,_feadg );if len (_aage )!=0&&!_aefd {if _dbegf :=_fba (_aage ,_gcfeea );
_dbegf !=nil {return nil ,_dbegf ;};};return _gcfeea ,nil ;};func (_edcf *Monochrome )setBit (_aaag ,_gggd int ){_edcf .Data [_aaag +(_gggd >>3)]|=0x80>>uint (_gggd &7);};func (_fbdg *ImageBase )setFourBytes (_fgcgd int ,_dece uint32 )error {if _fgcgd +3> len (_fbdg .Data )-1{return _bf .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_fgcgd );
};_fbdg .Data [_fgcgd ]=byte ((_dece &0xff000000)>>24);_fbdg .Data [_fgcgd +1]=byte ((_dece &0xff0000)>>16);_fbdg .Data [_fgcgd +2]=byte ((_dece &0xff00)>>8);_fbdg .Data [_fgcgd +3]=byte (_dece &0xff);return nil ;};var _ Gray =&Gray2 {};func (_fda *Monochrome )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_fda .Width ,Y :_fda .Height }};
};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;
case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_bf .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _cdbc (_dced CMYK ,_ddfbg Gray ,_ggfb _aa .Rectangle ){for _cdbe :=0;_cdbe < _ggfb .Max .X ;_cdbe ++{for _dggc :=0;_dggc < _ggfb .Max .Y ;_dggc ++{_ebc :=_edc (_dced .CMYKAt (_cdbe ,_dggc ));_ddfbg .SetGray (_cdbe ,_dggc ,_ebc );};};};func (_edbb *RGBA32 )Base ()*ImageBase {return &_edbb .ImageBase };
func (_aced *RGBA32 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_aced .Width ,Y :_aced .Height }};};func (_afa *Monochrome )Set (x ,y int ,c _bg .Color ){_eaaa :=y *_afa .BytesPerLine +x >>3;if _eaaa > len (_afa .Data )-1{return ;
};_gbdb :=_afa .ColorModel ().Convert (c ).(_bg .Gray );_afa .setGray (x ,_gbdb ,_eaaa );};func _bcfc (_aegb _bg .NRGBA64 )_bg .Gray {var _adcc _bg .NRGBA64 ;if _aegb ==_adcc {return _bg .Gray {Y :0xff};};_fded ,_agff ,_gcfee ,_ :=_aegb .RGBA ();_eff :=(19595*_fded +38470*_agff +7471*_gcfee +1<<15)>>24;
return _bg .Gray {Y :uint8 (_eff )};};func ConverterFunc (converterFunc func (_aeg _aa .Image )(Image ,error ))ColorConverter {return colorConverter {_ddf :converterFunc };};func (_acab *CMYK32 )SetCMYK (x ,y int ,c _bg .CMYK ){_cgbg :=4*(y *_acab .Width +x );
if _cgbg +3>=len (_acab .Data ){return ;};_acab .Data [_cgbg ]=c .C ;_acab .Data [_cgbg +1]=c .M ;_acab .Data [_cgbg +2]=c .Y ;_acab .Data [_cgbg +3]=c .K ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func init (){_dcbde ()};func _dbgg (_ddeg Gray ,_ggea NRGBA ,_bcfb _aa .Rectangle ){for _efd :=0;_efd < _bcfb .Max .X ;_efd ++{for _bcbb :=0;_bcbb < _bcfb .Max .Y ;_bcbb ++{_feea :=_gcge (_ggea .NRGBAAt (_efd ,_bcbb ));_ddeg .SetGray (_efd ,_bcbb ,_feea );
};};};func (_cfea *Monochrome )copy ()*Monochrome {_feeg :=_cab (_cfea .Width ,_cfea .Height );_feeg .ModelThreshold =_cfea .ModelThreshold ;_feeg .Data =make ([]byte ,len (_cfea .Data ));copy (_feeg .Data ,_cfea .Data );if len (_cfea .Decode )!=0{_feeg .Decode =make ([]float64 ,len (_cfea .Decode ));
copy (_feeg .Decode ,_cfea .Decode );};if len (_cfea .Alpha )!=0{_feeg .Alpha =make ([]byte ,len (_cfea .Alpha ));copy (_feeg .Alpha ,_cfea .Alpha );};return _feeg ;};func (_fgcb *Gray4 )setGray (_fafg int ,_cgbe int ,_ebbg _bg .Gray ){_gcbg :=_cgbe *_fgcb .BytesPerLine ;
_cebd :=_gcbg +(_fafg >>1);if _cebd >=len (_fgcb .Data ){return ;};_abb :=_ebbg .Y >>4;_fgcb .Data [_cebd ]=(_fgcb .Data [_cebd ]&(^(0xf0>>uint (4*(_fafg &1)))))|(_abb <<uint (4-4*(_fafg &1)));};func (_dcf *Gray16 )Histogram ()(_cde [256]int ){for _gabfb :=0;
_gabfb < _dcf .Width ;_gabfb ++{for _fdbb :=0;_fdbb < _dcf .Height ;_fdbb ++{_cde [_dcf .GrayAt (_gabfb ,_fdbb ).Y ]++;};};return _cde ;};func (_afgg *Gray4 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtGray4BPC (x ,y ,_afgg .BytesPerLine ,_afgg .Data ,_afgg .Decode );
};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_bg .RGBA ,error ){_egge :=y *width +x ;_badc :=3*_egge ;if _badc +2>=len (data ){return _bg .RGBA {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_adgc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _egge {_adgc =alpha [_egge ];};_ecaae ,_bdgg ,_addfe :=data [_badc ],data [_badc +1],data [_badc +2];if len (decode )==6{_ecaae =uint8 (uint32 (LinearInterpolate (float64 (_ecaae ),0,255,decode [0],decode [1]))&0xff);
_bdgg =uint8 (uint32 (LinearInterpolate (float64 (_bdgg ),0,255,decode [2],decode [3]))&0xff);_addfe =uint8 (uint32 (LinearInterpolate (float64 (_addfe ),0,255,decode [4],decode [5]))&0xff);};return _bg .RGBA {R :_ecaae ,G :_bdgg ,B :_addfe ,A :_adgc },nil ;
};var _ Gray =&Monochrome {};func (_aebee *NRGBA32 )ColorModel ()_bg .Model {return _bg .NRGBAModel };var _ _aa .Image =&RGBA32 {};func _dgb (_da ,_fe *Monochrome )(_fd error ){_aad :=_fe .BytesPerLine ;_bfd :=_da .BytesPerLine ;var _eac ,_ade ,_bgg ,_abe ,_feg int ;
for _bgg =0;_bgg < _fe .Height ;_bgg ++{_eac =_bgg *_aad ;_ade =8*_bgg *_bfd ;for _abe =0;_abe < _aad ;_abe ++{if _fd =_da .setEightBytes (_ade +_abe *8,_ecb [_fe .Data [_eac +_abe ]]);_fd !=nil {return _fd ;};};for _feg =1;_feg < 8;_feg ++{for _abe =0;
_abe < _bfd ;_abe ++{if _fd =_da .setByte (_ade +_feg *_bfd +_abe ,_da .Data [_ade +_abe ]);_fd !=nil {return _fd ;};};};};return nil ;};func (_bcabe *RGBA32 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtRGBA32 (x ,y ,_bcabe .Width ,_bcabe .Data ,_bcabe .Alpha ,_bcabe .Decode );
};func (_bfeea *Gray16 )SetGray (x ,y int ,g _bg .Gray ){_egedc :=(y *_bfeea .BytesPerLine /2+x )*2;if _egedc +1>=len (_bfeea .Data ){return ;};_bfeea .Data [_egedc ]=g .Y ;_bfeea .Data [_egedc +1]=g .Y ;};func (_fdee *Gray8 )At (x ,y int )_bg .Color {_acef ,_ :=_fdee .ColorAt (x ,y );
return _acef };func _bfda (_gdeb _aa .Image ,_bfdgc Image ,_bgce _aa .Rectangle ){switch _fgbf :=_gdeb .(type ){case Gray :_cfdff (_fgbf ,_bfdgc .(Gray ),_bgce );case NRGBA :_gaaa (_fgbf ,_bfdgc .(Gray ),_bgce );case CMYK :_cdbc (_fgbf ,_bfdgc .(Gray ),_bgce );
case RGBA :_cgdf (_fgbf ,_bfdgc .(Gray ),_bgce );default:_dce (_gdeb ,_bfdgc .(Image ),_bgce );};};func _bdcc (_cbdb _bg .NRGBA64 )_bg .NRGBA {return _bg .NRGBA {R :uint8 (_cbdb .R >>8),G :uint8 (_cbdb .G >>8),B :uint8 (_cbdb .B >>8),A :uint8 (_cbdb .A >>8)};
};func _bbc (_ggff int ,_abbe int )int {if _ggff < _abbe {return _ggff ;};return _abbe ;};func (_ddfa *Gray4 )Set (x ,y int ,c _bg .Color ){if x >=_ddfa .Width ||y >=_ddfa .Height {return ;};_gcdf :=Gray4Model .Convert (c ).(_bg .Gray );_ddfa .setGray (x ,y ,_gcdf );
};func (_bgae *NRGBA16 )Validate ()error {if len (_bgae .Data )!=3*_bgae .Width *_bgae .Height /2{return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bbfd (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_ggfa *NRGBA32 )Set (x ,y int ,c _bg .Color ){_effd :=y *_ggfa .Width +x ;
_bcba :=3*_effd ;if _bcba +2>=len (_ggfa .Data ){return ;};_ceccd :=_bg .NRGBAModel .Convert (c ).(_bg .NRGBA );_ggfa .setRGBA (_effd ,_ceccd );};func _dcbde (){for _begg :=0;_begg < 256;_begg ++{_gdg [_begg ]=uint8 (_begg &0x1)+(uint8 (_begg >>1)&0x1)+(uint8 (_begg >>2)&0x1)+(uint8 (_begg >>3)&0x1)+(uint8 (_begg >>4)&0x1)+(uint8 (_begg >>5)&0x1)+(uint8 (_begg >>6)&0x1)+(uint8 (_begg >>7)&0x1);
};};func _gbba (_ecfb _bg .NRGBA )_bg .Gray {_cbc ,_cdfb ,_fbd ,_ :=_ecfb .RGBA ();_fcbg :=(19595*_cbc +38470*_cdfb +7471*_fbd +1<<15)>>24;return _bg .Gray {Y :uint8 (_fcbg )};};func (_aafa *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_aafa .copy ()}};
func (_cfaf *Gray2 )Validate ()error {if len (_cfaf .Data )!=_cfaf .Height *_cfaf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gbcg *NRGBA32 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtNRGBA32 (x ,y ,_gbcg .Width ,_gbcg .Data ,_gbcg .Alpha ,_gbcg .Decode );
};func (_egcf *RGBA32 )setRGBA (_gdbg int ,_dfagb _bg .RGBA ){_bae :=3*_gdbg ;_egcf .Data [_bae ]=_dfagb .R ;_egcf .Data [_bae +1]=_dfagb .G ;_egcf .Data [_bae +2]=_dfagb .B ;if _gdbg < len (_egcf .Alpha ){_egcf .Alpha [_gdbg ]=_dfagb .A ;};};type NRGBA32 struct{ImageBase };
var _ _aa .Image =&NRGBA16 {};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bg .Gray16 ,error ){_egeed :=(y *bytesPerLine /2+x )*2;if _egeed +1>=len (data ){return _bg .Gray16 {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gfg :=uint16 (data [_egeed ])<<8|uint16 (data [_egeed +1]);if len (decode )==2{_gfg =uint16 (uint64 (LinearInterpolate (float64 (_gfg ),0,65535,decode [0],decode [1])));};return _bg .Gray16 {Y :_gfg },nil ;};func (_ffgf *NRGBA64 )SetNRGBA64 (x ,y int ,c _bg .NRGBA64 ){_ebfg :=(y *_ffgf .Width +x )*2;
_ecadd :=_ebfg *3;if _ecadd +5>=len (_ffgf .Data ){return ;};_ffgf .setNRGBA64 (_ecadd ,c ,_ebfg );};func _dcfe (_dacg ,_eeed RGBA ,_fceb _aa .Rectangle ){for _fga :=0;_fga < _fceb .Max .X ;_fga ++{for _accd :=0;_accd < _fceb .Max .Y ;_accd ++{_eeed .SetRGBA (_fga ,_accd ,_dacg .RGBAAt (_fga ,_accd ));
};};};func (_bagg *NRGBA32 )Validate ()error {if len (_bagg .Data )!=3*_bagg .Width *_bagg .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _bcfbe (_eddc Gray ,_aeaf NRGBA ,_fada _aa .Rectangle ){for _ffgcf :=0;_ffgcf < _fada .Max .X ;_ffgcf ++{for _dgdg :=0;_dgdg < _fada .Max .Y ;_dgdg ++{_abaa :=_eddc .GrayAt (_ffgcf ,_dgdg );_aeaf .SetNRGBA (_ffgcf ,_dgdg ,_faca (_abaa ));
};};};func _dfda (_ggc *Monochrome ,_ccbbe ,_ged ,_eefd ,_dgde int ,_acf RasterOperator ){if _ccbbe < 0{_eefd +=_ccbbe ;_ccbbe =0;};_gcfb :=_ccbbe +_eefd -_ggc .Width ;if _gcfb > 0{_eefd -=_gcfb ;};if _ged < 0{_dgde +=_ged ;_ged =0;};_dedg :=_ged +_dgde -_ggc .Height ;
if _dedg > 0{_dgde -=_dedg ;};if _eefd <=0||_dgde <=0{return ;};if (_ccbbe &7)==0{_ebdc (_ggc ,_ccbbe ,_ged ,_eefd ,_dgde ,_acf );}else {_acae (_ggc ,_ccbbe ,_ged ,_eefd ,_dgde ,_acf );};};const (_affed shift =iota ;_gdbc ;);func _efgc (_ccf *Monochrome ,_defc ,_dedc ,_gefe ,_daaf int ,_dcac RasterOperator ,_dggd *Monochrome ,_cga ,_bege int )error {var (_cedeb byte ;
_aded int ;_deaef int ;_cedc ,_fgeb int ;_gff ,_cdbg int ;);_eedd :=_gefe >>3;_fbbe :=_gefe &7;if _fbbe > 0{_cedeb =_gbec [_fbbe ];};_aded =_dggd .BytesPerLine *_bege +(_cga >>3);_deaef =_ccf .BytesPerLine *_dedc +(_defc >>3);switch _dcac {case PixSrc :for _gff =0;
_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]=_dggd .Data [_cedc ];_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],_dggd .Data [_cedc ],_cedeb );
};};case PixNotSrc :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]=^(_dggd .Data [_cedc ]);_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],^_dggd .Data [_cedc ],_cedeb );
};};case PixSrcOrDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]|=_dggd .Data [_cedc ];_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],_dggd .Data [_cedc ]|_ccf .Data [_fgeb ],_cedeb );
};};case PixSrcAndDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]&=_dggd .Data [_cedc ];_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],_dggd .Data [_cedc ]&_ccf .Data [_fgeb ],_cedeb );
};};case PixSrcXorDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]^=_dggd .Data [_cedc ];_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],_dggd .Data [_cedc ]^_ccf .Data [_fgeb ],_cedeb );
};};case PixNotSrcOrDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]|=^(_dggd .Data [_cedc ]);_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],^(_dggd .Data [_cedc ])|_ccf .Data [_fgeb ],_cedeb );
};};case PixNotSrcAndDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]&=^(_dggd .Data [_cedc ]);_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],^(_dggd .Data [_cedc ])&_ccf .Data [_fgeb ],_cedeb );
};};case PixSrcOrNotDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]=_dggd .Data [_cedc ]|^(_ccf .Data [_fgeb ]);_fgeb ++;_cedc ++;
};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],_dggd .Data [_cedc ]|^(_ccf .Data [_fgeb ]),_cedeb );};};case PixSrcAndNotDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;
for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]=_dggd .Data [_cedc ]&^(_ccf .Data [_fgeb ]);_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],_dggd .Data [_cedc ]&^(_ccf .Data [_fgeb ]),_cedeb );};};case PixNotPixSrcOrDst :for _gff =0;
_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]=^(_dggd .Data [_cedc ]|_ccf .Data [_fgeb ]);_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],^(_dggd .Data [_cedc ]|_ccf .Data [_fgeb ]),_cedeb );
};};case PixNotPixSrcAndDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]=^(_dggd .Data [_cedc ]&_ccf .Data [_fgeb ]);_fgeb ++;
_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],^(_dggd .Data [_cedc ]&_ccf .Data [_fgeb ]),_cedeb );};};case PixNotPixSrcXorDst :for _gff =0;_gff < _daaf ;_gff ++{_cedc =_aded +_gff *_dggd .BytesPerLine ;_fgeb =_deaef +_gff *_ccf .BytesPerLine ;
for _cdbg =0;_cdbg < _eedd ;_cdbg ++{_ccf .Data [_fgeb ]=^(_dggd .Data [_cedc ]^_ccf .Data [_fgeb ]);_fgeb ++;_cedc ++;};if _fbbe > 0{_ccf .Data [_fgeb ]=_cee (_ccf .Data [_fgeb ],^(_dggd .Data [_cedc ]^_ccf .Data [_fgeb ]),_cedeb );};};default:_cd .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_dcac );
return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};var _ Image =&Gray2 {};func (_caf *Gray16 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtGray16BPC (x ,y ,_caf .BytesPerLine ,_caf .Data ,_caf .Decode );
};func (_egdd *RGBA32 )SetRGBA (x ,y int ,c _bg .RGBA ){_acc :=y *_egdd .Width +x ;_dfaebb :=3*_acc ;if _dfaebb +2>=len (_egdd .Data ){return ;};_egdd .setRGBA (_acc ,c );};func _cgdf (_aafb RGBA ,_eefg Gray ,_edge _aa .Rectangle ){for _aafd :=0;_aafd < _edge .Max .X ;
_aafd ++{for _cdgb :=0;_cdgb < _edge .Max .Y ;_cdgb ++{_bfdc :=_bfge (_aafb .RGBAAt (_aafd ,_cdgb ));_eefg .SetGray (_aafd ,_cdgb ,_bfdc );};};};func (_fgbb *Gray8 )Validate ()error {if len (_fgbb .Data )!=_fgbb .Height *_fgbb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_bddb *Monochrome )InverseData ()error {return _bddb .RasterOperation (0,0,_bddb .Width ,_bddb .Height ,PixNotDst ,nil ,0,0);};func (_fcdc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_fcdc .copy ()}};var _ _aa .Image =&Gray8 {};
type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _edfe (_fdgd _bg .NYCbCrA )_bg .RGBA {_dga ,_eab ,_affe ,_feed :=_dae (_fdgd ).RGBA ();return _bg .RGBA {R :uint8 (_dga >>8),G :uint8 (_eab >>8),B :uint8 (_affe >>8),A :uint8 (_feed >>8)};
};func (_abddc *Monochrome )setIndexedBit (_bbge int ){_abddc .Data [(_bbge >>3)]|=0x80>>uint (_bbge &7);};func (_cebc *NRGBA64 )Set (x ,y int ,c _bg .Color ){_ebae :=(y *_cebc .Width +x )*2;_cafbd :=_ebae *3;if _cafbd +5>=len (_cebc .Data ){return ;};
_bbcb :=_bg .NRGBA64Model .Convert (c ).(_bg .NRGBA64 );_cebc .setNRGBA64 (_cafbd ,_bbcb ,_ebae );};func _bb ()(_bade []byte ){_bade =make ([]byte ,256);for _eeg :=0;_eeg < 256;_eeg ++{_ggbf :=byte (_eeg );_bade [_ggbf ]=(_ggbf &0x01)|((_ggbf &0x04)>>1)|((_ggbf &0x10)>>2)|((_ggbf &0x40)>>3)|((_ggbf &0x02)<<3)|((_ggbf &0x08)<<2)|((_ggbf &0x20)<<1)|(_ggbf &0x80);
};return _bade ;};func (_bbecf *Gray2 )Histogram ()(_eaaab [256]int ){for _fgg :=0;_fgg < _bbecf .Width ;_fgg ++{for _dfaa :=0;_dfaa < _bbecf .Height ;_dfaa ++{_eaaab [_bbecf .GrayAt (_fgg ,_dfaa ).Y ]++;};};return _eaaab ;};func _eebe (_gfa _bg .Color )_bg .Color {_ebf :=_bg .NRGBAModel .Convert (_gfa ).(_bg .NRGBA );
return _fecf (_ebf );};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_bg .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_bf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};type Gray8 struct{ImageBase };func (_gcgf *NRGBA32 )NRGBAAt (x ,y int )_bg .NRGBA {_feeae ,_ :=ColorAtNRGBA32 (x ,y ,_gcgf .Width ,_gcgf .Data ,_gcgf .Alpha ,_gcgf .Decode );return _feeae ;};func (_faeg *Gray4 )ColorModel ()_bg .Model {return Gray4Model };
func _edc (_deee _bg .CMYK )_bg .Gray {_feggg ,_bcd ,_bge :=_bg .CMYKToRGB (_deee .C ,_deee .M ,_deee .Y ,_deee .K );_bfee :=(19595*uint32 (_feggg )+38470*uint32 (_bcd )+7471*uint32 (_bge )+1<<7)>>16;return _bg .Gray {Y :uint8 (_bfee )};};func (_bagc *ImageBase )setEightFullBytes (_baca int ,_dcaf uint64 )error {if _baca +7> len (_bagc .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bagc .Data [_baca ]=byte ((_dcaf &0xff00000000000000)>>56);_bagc .Data [_baca +1]=byte ((_dcaf &0xff000000000000)>>48);_bagc .Data [_baca +2]=byte ((_dcaf &0xff0000000000)>>40);_bagc .Data [_baca +3]=byte ((_dcaf &0xff00000000)>>32);_bagc .Data [_baca +4]=byte ((_dcaf &0xff000000)>>24);
_bagc .Data [_baca +5]=byte ((_dcaf &0xff0000)>>16);_bagc .Data [_baca +6]=byte ((_dcaf &0xff00)>>8);_bagc .Data [_baca +7]=byte (_dcaf &0xff);return nil ;};func _cddd (_cggd *Monochrome ,_cgag ,_ggef ,_dcbdg ,_dfca int ,_fcddf RasterOperator ,_cage *Monochrome ,_aaga ,_ccbb int )error {var (_abbc bool ;
_ggggf bool ;_cgbae byte ;_ggeg int ;_bfcf int ;_gdec int ;_afe int ;_fcba bool ;_aabc int ;_cafb int ;_fddc int ;_dged bool ;_efbg byte ;_cgec int ;_dbeg int ;_gaaaf int ;_agaa byte ;_cdda int ;_gafc int ;_adee uint ;_eaba uint ;_cgac byte ;_cddb shift ;
_ebcb bool ;_begb bool ;_cggdb ,_afca int ;);if _aaga &7!=0{_gafc =8-(_aaga &7);};if _cgag &7!=0{_bfcf =8-(_cgag &7);};if _gafc ==0&&_bfcf ==0{_cgac =_dgf [0];}else {if _bfcf > _gafc {_adee =uint (_bfcf -_gafc );}else {_adee =uint (8-(_gafc -_bfcf ));};
_eaba =8-_adee ;_cgac =_dgf [_adee ];};if (_cgag &7)!=0{_abbc =true ;_ggeg =8-(_cgag &7);_cgbae =_dgf [_ggeg ];_gdec =_cggd .BytesPerLine *_ggef +(_cgag >>3);_afe =_cage .BytesPerLine *_ccbb +(_aaga >>3);_cdda =8-(_aaga &7);if _ggeg > _cdda {_cddb =_affed ;
if _dcbdg >=_gafc {_ebcb =true ;};}else {_cddb =_gdbc ;};};if _dcbdg < _ggeg {_ggggf =true ;_cgbae &=_gbec [8-_ggeg +_dcbdg ];};if !_ggggf {_aabc =(_dcbdg -_ggeg )>>3;if _aabc !=0{_fcba =true ;_cafb =_cggd .BytesPerLine *_ggef +((_cgag +_bfcf )>>3);_fddc =_cage .BytesPerLine *_ccbb +((_aaga +_bfcf )>>3);
};};_cgec =(_cgag +_dcbdg )&7;if !(_ggggf ||_cgec ==0){_dged =true ;_efbg =_gbec [_cgec ];_dbeg =_cggd .BytesPerLine *_ggef +((_cgag +_bfcf )>>3)+_aabc ;_gaaaf =_cage .BytesPerLine *_ccbb +((_aaga +_bfcf )>>3)+_aabc ;if _cgec > int (_eaba ){_begb =true ;
};};switch _fcddf {case PixSrc :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],_agaa ,_cgbae );
_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]=_agaa ;
};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],_agaa ,_efbg );
_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;};};case PixNotSrc :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );};
}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],^_agaa ,_cgbae );_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );
_cggd .Data [_cafb +_afca ]=^_agaa ;};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );
};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],^_agaa ,_efbg );_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;};};case PixSrcOrDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );
};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],_agaa |_cggd .Data [_gdec ],_cgbae );_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;
_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]|=_agaa ;};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;
_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],_agaa |_cggd .Data [_dbeg ],_efbg );_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;
};};case PixSrcAndDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],_agaa &_cggd .Data [_gdec ],_cgbae );
_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]&=_agaa ;
};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],_agaa &_cggd .Data [_dbeg ],_efbg );
_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;};};case PixSrcXorDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );
};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],_agaa ^_cggd .Data [_gdec ],_cgbae );_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;
_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]^=_agaa ;};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;
_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],_agaa ^_cggd .Data [_dbeg ],_efbg );_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;
};};case PixNotSrcOrDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],^_agaa |_cggd .Data [_gdec ],_cgbae );
_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]|=^_agaa ;
};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],^_agaa |_cggd .Data [_dbeg ],_efbg );
_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;};};case PixNotSrcAndDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );
};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],^_agaa &_cggd .Data [_gdec ],_cgbae );_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;
_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]&=^_agaa ;};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;
_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],^_agaa &_cggd .Data [_dbeg ],_efbg );_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;
};};case PixSrcOrNotDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],_agaa |^_cggd .Data [_gdec ],_cgbae );
_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]=_agaa |^_cggd .Data [_cafb +_afca ];
};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],_agaa |^_cggd .Data [_dbeg ],_efbg );
_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;};};case PixSrcAndNotDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );
};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],_agaa &^_cggd .Data [_gdec ],_cgbae );_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;
_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]=_agaa &^_cggd .Data [_cafb +_afca ];};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;
_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],_agaa &^_cggd .Data [_dbeg ],_efbg );_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;
};};case PixNotPixSrcOrDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],^(_agaa |_cggd .Data [_gdec ]),_cgbae );
_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]=^(_agaa |_cggd .Data [_cafb +_afca ]);
};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],^(_agaa |_cggd .Data [_dbeg ]),_efbg );
_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;};};case PixNotPixSrcAndDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );
};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],^(_agaa &_cggd .Data [_gdec ]),_cgbae );_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;
_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]=^(_agaa &_cggd .Data [_cafb +_afca ]);};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;
_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],^(_agaa &_cggd .Data [_dbeg ]),_efbg );_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;
};};case PixNotPixSrcXorDst :if _abbc {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{if _cddb ==_affed {_agaa =_cage .Data [_afe ]<<_adee ;if _ebcb {_agaa =_cee (_agaa ,_cage .Data [_afe +1]>>_eaba ,_cgac );};}else {_agaa =_cage .Data [_afe ]>>_eaba ;};_cggd .Data [_gdec ]=_cee (_cggd .Data [_gdec ],^(_agaa ^_cggd .Data [_gdec ]),_cgbae );
_gdec +=_cggd .BytesPerLine ;_afe +=_cage .BytesPerLine ;};};if _fcba {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{for _afca =0;_afca < _aabc ;_afca ++{_agaa =_cee (_cage .Data [_fddc +_afca ]<<_adee ,_cage .Data [_fddc +_afca +1]>>_eaba ,_cgac );_cggd .Data [_cafb +_afca ]=^(_agaa ^_cggd .Data [_cafb +_afca ]);
};_cafb +=_cggd .BytesPerLine ;_fddc +=_cage .BytesPerLine ;};};if _dged {for _cggdb =0;_cggdb < _dfca ;_cggdb ++{_agaa =_cage .Data [_gaaaf ]<<_adee ;if _begb {_agaa =_cee (_agaa ,_cage .Data [_gaaaf +1]>>_eaba ,_cgac );};_cggd .Data [_dbeg ]=_cee (_cggd .Data [_dbeg ],^(_agaa ^_cggd .Data [_dbeg ]),_efbg );
_dbeg +=_cggd .BytesPerLine ;_gaaaf +=_cage .BytesPerLine ;};};default:_cd .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_fcddf );
return _a .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _fddg (_dde _bg .RGBA )_bg .NRGBA {switch _dde .A {case 0xff:return _bg .NRGBA {R :_dde .R ,G :_dde .G ,B :_dde .B ,A :0xff};
case 0x00:return _bg .NRGBA {};default:_caga ,_gdfg ,_fcef ,_fbga :=_dde .RGBA ();_caga =(_caga *0xffff)/_fbga ;_gdfg =(_gdfg *0xffff)/_fbga ;_fcef =(_fcef *0xffff)/_fbga ;return _bg .NRGBA {R :uint8 (_caga >>8),G :uint8 (_gdfg >>8),B :uint8 (_fcef >>8),A :uint8 (_fbga >>8)};
};};func (_ggaa *NRGBA64 )At (x ,y int )_bg .Color {_fcbc ,_ :=_ggaa .ColorAt (x ,y );return _fcbc };type Gray4 struct{ImageBase };const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;
PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;
PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_fdbe *NRGBA64 )setNRGBA64 (_eaaf int ,_dffe _bg .NRGBA64 ,_gadfe int ){_fdbe .Data [_eaaf ]=uint8 (_dffe .R >>8);
_fdbe .Data [_eaaf +1]=uint8 (_dffe .R &0xff);_fdbe .Data [_eaaf +2]=uint8 (_dffe .G >>8);_fdbe .Data [_eaaf +3]=uint8 (_dffe .G &0xff);_fdbe .Data [_eaaf +4]=uint8 (_dffe .B >>8);_fdbe .Data [_eaaf +5]=uint8 (_dffe .B &0xff);if _gadfe +1< len (_fdbe .Alpha ){_fdbe .Alpha [_gadfe ]=uint8 (_dffe .A >>8);
_fdbe .Alpha [_gadfe +1]=uint8 (_dffe .A &0xff);};};var _ Gray =&Gray16 {};func (_ddac *Gray16 )Set (x ,y int ,c _bg .Color ){_cbff :=(y *_ddac .BytesPerLine /2+x )*2;if _cbff +1>=len (_ddac .Data ){return ;};_addf :=_bg .Gray16Model .Convert (c ).(_bg .Gray16 );
_ddac .Data [_cbff ],_ddac .Data [_cbff +1]=uint8 (_addf .Y >>8),uint8 (_addf .Y &0xff);};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bg .Gray ,error ){_fecg :=y *bytesPerLine +x ;if _fecg >=len (data ){return _bg .Gray {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eedb :=data [_fecg ];if len (decode )==2{_eedb =uint8 (uint32 (LinearInterpolate (float64 (_eedb ),0,255,decode [0],decode [1]))&0xff);};return _bg .Gray {Y :_eedb },nil ;};func (_ecfd *Gray16 )Validate ()error {if len (_ecfd .Data )!=_ecfd .Height *_ecfd .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _fec ()(_fgb [256]uint64 ){for _fcd :=0;_fcd < 256;_fcd ++{if _fcd &0x01!=0{_fgb [_fcd ]|=0xff;};if _fcd &0x02!=0{_fgb [_fcd ]|=0xff00;};if _fcd &0x04!=0{_fgb [_fcd ]|=0xff0000;};if _fcd &0x08!=0{_fgb [_fcd ]|=0xff000000;};if _fcd &0x10!=0{_fgb [_fcd ]|=0xff00000000;
};if _fcd &0x20!=0{_fgb [_fcd ]|=0xff0000000000;};if _fcd &0x40!=0{_fgb [_fcd ]|=0xff000000000000;};if _fcd &0x80!=0{_fgb [_fcd ]|=0xff00000000000000;};};return _fgb ;};var _ _aa .Image =&NRGBA32 {};func (_eddg *Gray2 )Base ()*ImageBase {return &_eddg .ImageBase };
func (_gaeb *Monochrome )AddPadding ()(_eegb error ){if _bdbe :=((_gaeb .Width *_gaeb .Height )+7)>>3;len (_gaeb .Data )< _bdbe {return _bf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_gaeb .Data ),_bdbe );
};_dgac :=_gaeb .Width %8;if _dgac ==0{return nil ;};_bda :=_gaeb .Width /8;_aecd :=_gd .NewReader (_gaeb .Data );_fgbe :=make ([]byte ,_gaeb .Height *_gaeb .BytesPerLine );_ede :=_gd .NewWriterMSB (_fgbe );_cdaee :=make ([]byte ,_bda );var (_aaf int ;
_egf uint64 ;);for _aaf =0;_aaf < _gaeb .Height ;_aaf ++{if _ ,_eegb =_aecd .Read (_cdaee );_eegb !=nil {return _eegb ;};if _ ,_eegb =_ede .Write (_cdaee );_eegb !=nil {return _eegb ;};if _egf ,_eegb =_aecd .ReadBits (byte (_dgac ));_eegb !=nil {return _eegb ;
};if _eegb =_ede .WriteByte (byte (_egf )<<uint (8-_dgac ));_eegb !=nil {return _eegb ;};};_gaeb .Data =_ede .Data ();return nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_fff :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _fdc Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_fdc =&Monochrome {ImageBase :_fff ,ModelThreshold :0x0f};case 2:_fdc =&Gray2 {ImageBase :_fff };case 4:_fdc =&Gray4 {ImageBase :_fff };case 8:_fdc =&Gray8 {ImageBase :_fff };
case 16:_fdc =&Gray16 {ImageBase :_fff };};case 3:switch bitsPerComponent {case 4:_fdc =&NRGBA16 {ImageBase :_fff };case 8:_fdc =&NRGBA32 {ImageBase :_fff };case 16:_fdc =&NRGBA64 {ImageBase :_fff };};case 4:_fdc =&CMYK32 {ImageBase :_fff };};if _fdc ==nil {return nil ,ErrInvalidImage ;
};return _fdc ,nil ;};func _gaaa (_aacg NRGBA ,_bbed Gray ,_aee _aa .Rectangle ){for _adfd :=0;_adfd < _aee .Max .X ;_adfd ++{for _cede :=0;_cede < _aee .Max .Y ;_cede ++{_cbcbd :=_gbba (_aacg .NRGBAAt (_adfd ,_cede ));_bbed .SetGray (_adfd ,_cede ,_cbcbd );
};};};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_d :=BytesPerLine (width ,8,1);if len (data )< _d *height {return nil ,nil ;};_ag :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_gg ,_gda :=MonochromeConverter .Convert (_ag );
if _gda !=nil {return nil ,_gda ;};return _gg .Base ().Data ,nil ;};func (_fgeg *ImageBase )GetAlpha ()[]byte {return _fgeg .Alpha };func (_cfgb *Gray4 )At (x ,y int )_bg .Color {_cgbc ,_ :=_cfgb .ColorAt (x ,y );return _cgbc };func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_bg .NRGBA64 ,error ){_bfdga :=(y *width +x )*2;
_afdc :=_bfdga *3;if _afdc +5>=len (data ){return _bg .NRGBA64 {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _aecb =0xffff;_fbbaa :=uint16 (_aecb );if alpha !=nil &&len (alpha )> _bfdga +1{_fbbaa =uint16 (alpha [_bfdga ])<<8|uint16 (alpha [_bfdga +1]);};_caee :=uint16 (data [_afdc ])<<8|uint16 (data [_afdc +1]);_fdga :=uint16 (data [_afdc +2])<<8|uint16 (data [_afdc +3]);
_ccadb :=uint16 (data [_afdc +4])<<8|uint16 (data [_afdc +5]);if len (decode )==6{_caee =uint16 (uint64 (LinearInterpolate (float64 (_caee ),0,65535,decode [0],decode [1]))&_aecb );_fdga =uint16 (uint64 (LinearInterpolate (float64 (_fdga ),0,65535,decode [2],decode [3]))&_aecb );
_ccadb =uint16 (uint64 (LinearInterpolate (float64 (_ccadb ),0,65535,decode [4],decode [5]))&_aecb );};return _bg .NRGBA64 {R :_caee ,G :_fdga ,B :_ccadb ,A :_fbbaa },nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_aacd *Gray4 )GrayAt (x ,y int )_bg .Gray {_bfgb ,_ :=ColorAtGray4BPC (x ,y ,_aacd .BytesPerLine ,_aacd .Data ,_aacd .Decode );
return _bfgb ;};func (_gadc *Gray8 )Set (x ,y int ,c _bg .Color ){_eagd :=y *_gadc .BytesPerLine +x ;if _eagd > len (_gadc .Data )-1{return ;};_ebgd :=_bg .GrayModel .Convert (c );_gadc .Data [_eagd ]=_ebgd .(_bg .Gray ).Y ;};func (_eaab *Gray8 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_eaab .Width ,Y :_eaab .Height }};
};var _ _aa .Image =&Gray16 {};var _ NRGBA =&NRGBA16 {};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_cfbdd *NRGBA64 )Base ()*ImageBase {return &_cfbdd .ImageBase };
func (_bcg *monochromeThresholdConverter )Convert (img _aa .Image )(Image ,error ){if _dfb ,_gfdc :=img .(*Monochrome );_gfdc {return _dfb .Copy (),nil ;};_babg :=img .Bounds ();_cfd ,_geb :=NewImage (_babg .Max .X ,_babg .Max .Y ,1,1,nil ,nil ,nil );if _geb !=nil {return nil ,_geb ;
};_cfd .(*Monochrome ).ModelThreshold =_bcg .Threshold ;for _dag :=0;_dag < _babg .Max .X ;_dag ++{for _add :=0;_add < _babg .Max .Y ;_add ++{_fgee :=img .At (_dag ,_add );_cfd .Set (_dag ,_add ,_fgee );};};return _cfd ,nil ;};func _cc (_cf *Monochrome ,_ccg int )(*Monochrome ,error ){if _cf ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ccg ==1{return _cf .copy (),nil ;};if !IsPowerOf2 (uint (_ccg )){return nil ,_bf .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ccg );
};_ggg :=_eca (_ccg );return _e (_cf ,_ccg ,_ggg );};func _edbe (_bgefd uint8 )bool {if _bgefd ==0||_bgefd ==255{return true ;};return false ;};func _abeff (_abea *_aa .Gray ,_cfgg uint8 )*_aa .Gray {_cgdc :=_abea .Bounds ();_bdccc :=_aa .NewGray (_cgdc );
for _eeca :=0;_eeca < _cgdc .Dx ();_eeca ++{for _adbd :=0;_adbd < _cgdc .Dy ();_adbd ++{_cfaa :=_abea .GrayAt (_eeca ,_adbd );_bdccc .SetGray (_eeca ,_adbd ,_bg .Gray {Y :_addc (_cfaa .Y ,_cfgg )});};};return _bdccc ;};var _gdg [256]uint8 ;func (_dab *NRGBA16 )Set (x ,y int ,c _bg .Color ){_gcbge :=y *_dab .BytesPerLine +x *3/2;
if _gcbge +1>=len (_dab .Data ){return ;};_dbdf :=NRGBA16Model .Convert (c ).(_bg .NRGBA );_dab .setNRGBA (x ,y ,_gcbge ,_dbdf );};func _bgf (_bdg *Monochrome ,_dd int ,_gce []byte )(_adf *Monochrome ,_ccd error ){const _cad ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _bdg ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _dd < 1||_dd > 4{return nil ,_a .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _bdg .Height <=1{return nil ,_a .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_adf =_cab (_bdg .Width /2,_bdg .Height /2);
if _gce ==nil {_gce =_bb ();};_gea :=_bbc (_bdg .BytesPerLine ,2*_adf .BytesPerLine );switch _dd {case 1:_ccd =_febe (_bdg ,_adf ,_gce ,_gea );case 2:_ccd =_bfc (_bdg ,_adf ,_gce ,_gea );case 3:_ccd =_gaf (_bdg ,_adf ,_gce ,_gea );case 4:_ccd =_ccdd (_bdg ,_adf ,_gce ,_gea );
};if _ccd !=nil {return nil ,_ccd ;};return _adf ,nil ;};type shift int ;func (_deaf *Gray2 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtGray2BPC (x ,y ,_deaf .BytesPerLine ,_deaf .Data ,_deaf .Decode );};func _facf (_bfgde uint )uint {var _cdbaf uint ;
for _bfgde !=0{_bfgde >>=1;_cdbaf ++;};return _cdbaf -1;};func _bfge (_daf _bg .RGBA )_bg .Gray {_agbg :=(19595*uint32 (_daf .R )+38470*uint32 (_daf .G )+7471*uint32 (_daf .B )+1<<7)>>16;return _bg .Gray {Y :uint8 (_agbg )};};func (_aace *Monochrome )clearBit (_bgdb ,_egg int ){_aace .Data [_bgdb ]&=^(0x80>>uint (_egg &7))};
func _ddefg (_agaf nrgba64 ,_bcgg NRGBA ,_ffbg _aa .Rectangle ){for _bfea :=0;_bfea < _ffbg .Max .X ;_bfea ++{for _gbcd :=0;_gbcd < _ffbg .Max .Y ;_gbcd ++{_begec :=_agaf .NRGBA64At (_bfea ,_gbcd );_bcgg .SetNRGBA (_bfea ,_gbcd ,_bdcc (_begec ));};};};
func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _c .Abs (xmax -xmin )< 0.000001{return ymin ;};_ebab :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _ebab ;};func (_acb *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_bf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _cc (_acb ,factor );};func _faff (_agbe *Monochrome ,_gbge ,_bfbe int ,_gagf ,_ecg int ,_bceb RasterOperator ,_cbad *Monochrome ,_egdb ,_febd int )error {var _abff ,_fcfa ,_ffdg ,_gegf int ;if _gbge < 0{_egdb -=_gbge ;_gagf +=_gbge ;_gbge =0;};
if _egdb < 0{_gbge -=_egdb ;_gagf +=_egdb ;_egdb =0;};_abff =_gbge +_gagf -_agbe .Width ;if _abff > 0{_gagf -=_abff ;};_fcfa =_egdb +_gagf -_cbad .Width ;if _fcfa > 0{_gagf -=_fcfa ;};if _bfbe < 0{_febd -=_bfbe ;_ecg +=_bfbe ;_bfbe =0;};if _febd < 0{_bfbe -=_febd ;
_ecg +=_febd ;_febd =0;};_ffdg =_bfbe +_ecg -_agbe .Height ;if _ffdg > 0{_ecg -=_ffdg ;};_gegf =_febd +_ecg -_cbad .Height ;if _gegf > 0{_ecg -=_gegf ;};if _gagf <=0||_ecg <=0{return nil ;};var _gaaab error ;switch {case _gbge &7==0&&_egdb &7==0:_gaaab =_efgc (_agbe ,_gbge ,_bfbe ,_gagf ,_ecg ,_bceb ,_cbad ,_egdb ,_febd );
case _gbge &7==_egdb &7:_gaaab =_gbea (_agbe ,_gbge ,_bfbe ,_gagf ,_ecg ,_bceb ,_cbad ,_egdb ,_febd );default:_gaaab =_cddd (_agbe ,_gbge ,_bfbe ,_gagf ,_ecg ,_bceb ,_cbad ,_egdb ,_febd );};if _gaaab !=nil {return _gaaab ;};return nil ;};var _ Gray =&Gray4 {};
func _adfg (_ffdd *_aa .NYCbCrA ,_abcb RGBA ,_cega _aa .Rectangle ){for _addfef :=0;_addfef < _cega .Max .X ;_addfef ++{for _fbcd :=0;_fbcd < _cega .Max .Y ;_fbcd ++{_fede :=_ffdd .NYCbCrAAt (_addfef ,_fbcd );_abcb .SetRGBA (_addfef ,_fbcd ,_edfe (_fede ));
};};};func (_fcddb *ImageBase )setByte (_bba int ,_defeb byte )error {if _bba > len (_fcddb .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fcddb .Data [_bba ]=_defeb ;return nil ;
};func (_defe *ImageBase )Pix ()[]byte {return _defe .Data };func _bbac (_gfga *_aa .Gray16 ,_bffgg uint8 )*_aa .Gray {_ffbee :=_gfga .Bounds ();_eege :=_aa .NewGray (_ffbee );for _eeec :=0;_eeec < _ffbee .Dx ();_eeec ++{for _feeaee :=0;_feeaee < _ffbee .Dy ();
_feeaee ++{_ebfgf :=_gfga .Gray16At (_eeec ,_feeaee );_eege .SetGray (_eeec ,_feeaee ,_bg .Gray {Y :_addc (uint8 (_ebfgf .Y /256),_bffgg )});};};return _eege ;};var (Gray2Model =_bg .ModelFunc (_bbec );Gray4Model =_bg .ModelFunc (_effb );NRGBA16Model =_bg .ModelFunc (_eebe );
);func _acae (_fgbc *Monochrome ,_caca ,_dgcg int ,_ddef ,_daeg int ,_gabfd RasterOperator ){var (_agde bool ;_ebee bool ;_eebfc int ;_fgea int ;_ffc int ;_aeeg int ;_abaf bool ;_cfbe byte ;);_ffgef :=8-(_caca &7);_fagg :=_dgf [_ffgef ];_dbdb :=_fgbc .BytesPerLine *_dgcg +(_caca >>3);
if _ddef < _ffgef {_agde =true ;_fagg &=_gbec [8-_ffgef +_ddef ];};if !_agde {_eebfc =(_ddef -_ffgef )>>3;if _eebfc !=0{_ebee =true ;_fgea =_dbdb +1;};};_ffc =(_caca +_ddef )&7;if !(_agde ||_ffc ==0){_abaf =true ;_cfbe =_gbec [_ffc ];_aeeg =_dbdb +1+_eebfc ;
};var _bdce ,_fgeba int ;switch _gabfd {case PixClr :for _bdce =0;_bdce < _daeg ;_bdce ++{_fgbc .Data [_dbdb ]=_cee (_fgbc .Data [_dbdb ],0x0,_fagg );_dbdb +=_fgbc .BytesPerLine ;};if _ebee {for _bdce =0;_bdce < _daeg ;_bdce ++{for _fgeba =0;_fgeba < _eebfc ;
_fgeba ++{_fgbc .Data [_fgea +_fgeba ]=0x0;};_fgea +=_fgbc .BytesPerLine ;};};if _abaf {for _bdce =0;_bdce < _daeg ;_bdce ++{_fgbc .Data [_aeeg ]=_cee (_fgbc .Data [_aeeg ],0x0,_cfbe );_aeeg +=_fgbc .BytesPerLine ;};};case PixSet :for _bdce =0;_bdce < _daeg ;
_bdce ++{_fgbc .Data [_dbdb ]=_cee (_fgbc .Data [_dbdb ],0xff,_fagg );_dbdb +=_fgbc .BytesPerLine ;};if _ebee {for _bdce =0;_bdce < _daeg ;_bdce ++{for _fgeba =0;_fgeba < _eebfc ;_fgeba ++{_fgbc .Data [_fgea +_fgeba ]=0xff;};_fgea +=_fgbc .BytesPerLine ;
};};if _abaf {for _bdce =0;_bdce < _daeg ;_bdce ++{_fgbc .Data [_aeeg ]=_cee (_fgbc .Data [_aeeg ],0xff,_cfbe );_aeeg +=_fgbc .BytesPerLine ;};};case PixNotDst :for _bdce =0;_bdce < _daeg ;_bdce ++{_fgbc .Data [_dbdb ]=_cee (_fgbc .Data [_dbdb ],^_fgbc .Data [_dbdb ],_fagg );
_dbdb +=_fgbc .BytesPerLine ;};if _ebee {for _bdce =0;_bdce < _daeg ;_bdce ++{for _fgeba =0;_fgeba < _eebfc ;_fgeba ++{_fgbc .Data [_fgea +_fgeba ]=^(_fgbc .Data [_fgea +_fgeba ]);};_fgea +=_fgbc .BytesPerLine ;};};if _abaf {for _bdce =0;_bdce < _daeg ;
_bdce ++{_fgbc .Data [_aeeg ]=_cee (_fgbc .Data [_aeeg ],^_fgbc .Data [_aeeg ],_cfbe );_aeeg +=_fgbc .BytesPerLine ;};};};};func _fecc (_gbbg _bg .CMYK )_bg .NRGBA {_debg ,_feccb ,_fge :=_bg .CMYKToRGB (_gbbg .C ,_gbbg .M ,_gbbg .Y ,_gbbg .K );return _bg .NRGBA {R :_debg ,G :_feccb ,B :_fge ,A :0xff};
};func (_gcac *Gray8 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtGray8BPC (x ,y ,_gcac .BytesPerLine ,_gcac .Data ,_gcac .Decode );};func (_gfe *Monochrome )getBitAt (_cacd ,_fcac int )bool {_gfec :=_fcac *_gfe .BytesPerLine +(_cacd >>3);_badd :=_cacd &0x07;
_aadb :=uint (7-_badd );if _gfec > len (_gfe .Data )-1{return false ;};if (_gfe .Data [_gfec ]>>_aadb )&0x01>=1{return true ;};return false ;};func (_abde *NRGBA64 )ColorModel ()_bg .Model {return _bg .NRGBA64Model };var _ Gray =&Gray8 {};func _dea (_gage _bg .Gray ,_bef monochromeModel )_bg .Gray {if _gage .Y > uint8 (_bef ){return _bg .Gray {Y :_c .MaxUint8 };
};return _bg .Gray {};};func (_gaac *NRGBA32 )SetNRGBA (x ,y int ,c _bg .NRGBA ){_ceed :=y *_gaac .Width +x ;_ebgdc :=3*_ceed ;if _ebgdc +2>=len (_gaac .Data ){return ;};_gaac .setRGBA (_ceed ,c );};type Gray interface{GrayAt (_dfga ,_gbd int )_bg .Gray ;
SetGray (_eddd ,_bcdg int ,_gdad _bg .Gray );};func (_affg *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_affg .copy ()}};type RGBA32 struct{ImageBase };type Image interface{_g .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_dgbc ,_eddaf int )(_bg .Color ,error );
Validate ()error ;};func (_fac *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_fac .copy ()}};var _ _aa .Image =&Gray4 {};func _febe (_eaa ,_bfeb *Monochrome ,_bfef []byte ,_dfe int )(_gga error ){var (_bgff ,_ebaf ,_fee ,_dfc ,_cec ,_dffd ,_fde ,_cggg int ;
_ccag ,_aggd uint32 ;_dfad ,_cfb byte ;_efc uint16 ;);_gab :=make ([]byte ,4);_dec :=make ([]byte ,4);for _fee =0;_fee < _eaa .Height -1;_fee ,_dfc =_fee +2,_dfc +1{_bgff =_fee *_eaa .BytesPerLine ;_ebaf =_dfc *_bfeb .BytesPerLine ;for _cec ,_dffd =0,0;
_cec < _dfe ;_cec ,_dffd =_cec +4,_dffd +1{for _fde =0;_fde < 4;_fde ++{_cggg =_bgff +_cec +_fde ;if _cggg <=len (_eaa .Data )-1&&_cggg < _bgff +_eaa .BytesPerLine {_gab [_fde ]=_eaa .Data [_cggg ];}else {_gab [_fde ]=0x00;};_cggg =_bgff +_eaa .BytesPerLine +_cec +_fde ;
if _cggg <=len (_eaa .Data )-1&&_cggg < _bgff +(2*_eaa .BytesPerLine ){_dec [_fde ]=_eaa .Data [_cggg ];}else {_dec [_fde ]=0x00;};};_ccag =_gb .BigEndian .Uint32 (_gab );_aggd =_gb .BigEndian .Uint32 (_dec );_aggd |=_ccag ;_aggd |=_aggd <<1;_aggd &=0xaaaaaaaa;
_ccag =_aggd |(_aggd <<7);_dfad =byte (_ccag >>24);_cfb =byte ((_ccag >>8)&0xff);_cggg =_ebaf +_dffd ;if _cggg +1==len (_bfeb .Data )-1||_cggg +1>=_ebaf +_bfeb .BytesPerLine {_bfeb .Data [_cggg ]=_bfef [_dfad ];}else {_efc =(uint16 (_bfef [_dfad ])<<8)|uint16 (_bfef [_cfb ]);
if _gga =_bfeb .setTwoBytes (_cggg ,_efc );_gga !=nil {return _bf .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cggg );
};_dffd ++;};};};return nil ;};func (_aae *Gray2 )Set (x ,y int ,c _bg .Color ){if x >=_aae .Width ||y >=_aae .Height {return ;};_ggbd :=Gray2Model .Convert (c ).(_bg .Gray );_feda :=y *_aae .BytesPerLine ;_ffe :=_feda +(x >>2);_fgd :=_ggbd .Y >>6;_aae .Data [_ffe ]=(_aae .Data [_ffe ]&(^(0xc0>>uint (2*((x )&3)))))|(_fgd <<uint (6-2*(x &3)));
};func (_dgd *Gray8 )ColorModel ()_bg .Model {return _bg .GrayModel };var _ _aa .Image =&Monochrome {};func (_bec *Gray2 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_bec .Width ,Y :_bec .Height }};};func (_bgde *Monochrome )IsUnpadded ()bool {return (_bgde .Width *_bgde .Height )==len (_bgde .Data )};
type monochromeThresholdConverter struct{Threshold uint8 ;};var _ _aa .Image =&Gray2 {};func _fab (_fed _bg .NRGBA64 )_bg .RGBA {_egbd ,_face ,_cbcf ,_cgd :=_fed .RGBA ();return _bg .RGBA {R :uint8 (_egbd >>8),G :uint8 (_face >>8),B :uint8 (_cbcf >>8),A :uint8 (_cgd >>8)};
};func _cab (_gag ,_fbb int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_gag ,_fbb ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};var (MonochromeConverter =ConverterFunc (_acea );Gray2Converter =ConverterFunc (_eag );Gray4Converter =ConverterFunc (_edfb );
GrayConverter =ConverterFunc (_abef );Gray16Converter =ConverterFunc (_ggae );NRGBA16Converter =ConverterFunc (_adff );NRGBAConverter =ConverterFunc (_eeff );NRGBA64Converter =ConverterFunc (_dfcb );RGBAConverter =ConverterFunc (_geeg );CMYKConverter =ConverterFunc (_dbg );
);func _fecf (_bgcdc _bg .NRGBA )_bg .NRGBA {_bgcdc .R =_bgcdc .R >>4|(_bgcdc .R >>4)<<4;_bgcdc .G =_bgcdc .G >>4|(_bgcdc .G >>4)<<4;_bgcdc .B =_bgcdc .B >>4|(_bgcdc .B >>4)<<4;return _bgcdc ;};func _bbb (_cdggg *_aa .Gray )bool {for _ggbae :=0;_ggbae < len (_cdggg .Pix );
_ggbae ++{if !_edbe (_cdggg .Pix [_ggbae ]){return false ;};};return true ;};func (_agfb colorConverter )Convert (src _aa .Image )(Image ,error ){return _agfb ._ddf (src )};func AutoThresholdTriangle (histogram [256]int )uint8 {var _bffgf ,_ffcf ,_ffcd ,_bgdbc int ;
for _dafg :=0;_dafg < len (histogram );_dafg ++{if histogram [_dafg ]> 0{_bffgf =_dafg ;break ;};};if _bffgf > 0{_bffgf --;};for _bgac :=255;_bgac > 0;_bgac --{if histogram [_bgac ]> 0{_bgdbc =_bgac ;break ;};};if _bgdbc < 255{_bgdbc ++;};for _acge :=0;
_acge < 256;_acge ++{if histogram [_acge ]> _ffcf {_ffcd =_acge ;_ffcf =histogram [_acge ];};};var _bffb bool ;if (_ffcd -_bffgf )< (_bgdbc -_ffcd ){_bffb =true ;var _ddaf int ;_debb :=255;for _ddaf < _debb {_ecabdg :=histogram [_ddaf ];histogram [_ddaf ]=histogram [_debb ];
histogram [_debb ]=_ecabdg ;_ddaf ++;_debb --;};_bffgf =255-_bgdbc ;_ffcd =255-_ffcd ;};if _bffgf ==_ffcd {return uint8 (_bffgf );};_dcga :=float64 (histogram [_ffcd ]);_aade :=float64 (_bffgf -_ffcd );_ebbgc :=_c .Sqrt (_dcga *_dcga +_aade *_aade );_dcga /=_ebbgc ;
_aade /=_ebbgc ;_ebbgc =_dcga *float64 (_bffgf )+_aade *float64 (histogram [_bffgf ]);_ffba :=_bffgf ;var _fbdb float64 ;for _egcfg :=_bffgf +1;_egcfg <=_ffcd ;_egcfg ++{_dbfg :=_dcga *float64 (_egcfg )+_aade *float64 (histogram [_egcfg ])-_ebbgc ;if _dbfg > _fbdb {_ffba =_egcfg ;
_fbdb =_dbfg ;};};_ffba --;if _bffb {var _baf int ;_ceadd :=255;for _baf < _ceadd {_adfa :=histogram [_baf ];histogram [_baf ]=histogram [_ceadd ];histogram [_ceadd ]=_adfa ;_baf ++;_ceadd --;};return uint8 (255-_ffba );};return uint8 (_ffba );};func _dgag (_fged _bg .RGBA )_bg .CMYK {_ggbc ,_dcd ,_bcdb ,_gbgf :=_bg .RGBToCMYK (_fged .R ,_fged .G ,_fged .B );
return _bg .CMYK {C :_ggbc ,M :_dcd ,Y :_bcdb ,K :_gbgf };};func (_gcdbf *NRGBA64 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtNRGBA64 (x ,y ,_gcdbf .Width ,_gcdbf .Data ,_gcdbf .Alpha ,_gcdbf .Decode );};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bg .Gray ,error ){_fbef :=y *bytesPerLine +x >>2;
if _fbef >=len (data ){return _bg .Gray {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_aceba :=data [_fbef ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_aceba =uint8 (uint32 (LinearInterpolate (float64 (_aceba ),0,3.0,decode [0],decode [1]))&3);};return _bg .Gray {Y :_aceba *85},nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_bg .NRGBA ,error ){_gedf :=y *bytesPerLine +x *3/2;
if _gedf +1>=len (data ){return _bg .NRGBA {},_adad (x ,y );};const (_babgc =0xf;_cafd =uint8 (0xff););_ddabg :=_cafd ;if alpha !=nil {_aaec :=y *BytesPerLine (width ,4,1);if _aaec < len (alpha ){if x %2==0{_ddabg =(alpha [_aaec ]>>uint (4))&_babgc ;}else {_ddabg =alpha [_aaec ]&_babgc ;
};_ddabg |=_ddabg <<4;};};var _feebe ,_fgfe ,_bdbbe uint8 ;if x *3%2==0{_feebe =(data [_gedf ]>>uint (4))&_babgc ;_fgfe =data [_gedf ]&_babgc ;_bdbbe =(data [_gedf +1]>>uint (4))&_babgc ;}else {_feebe =data [_gedf ]&_babgc ;_fgfe =(data [_gedf +1]>>uint (4))&_babgc ;
_bdbbe =data [_gedf +1]&_babgc ;};if len (decode )==6{_feebe =uint8 (uint32 (LinearInterpolate (float64 (_feebe ),0,15,decode [0],decode [1]))&0xf);_fgfe =uint8 (uint32 (LinearInterpolate (float64 (_fgfe ),0,15,decode [2],decode [3]))&0xf);_bdbbe =uint8 (uint32 (LinearInterpolate (float64 (_bdbbe ),0,15,decode [4],decode [5]))&0xf);
};return _bg .NRGBA {R :(_feebe <<4)|(_feebe &0xf),G :(_fgfe <<4)|(_fgfe &0xf),B :(_bdbbe <<4)|(_bdbbe &0xf),A :_ddabg },nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_bg .Gray ,error ){_adb :=y *bytesPerLine +x >>1;
if _adb >=len (data ){return _bg .Gray {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_acdg :=data [_adb ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_acdg =uint8 (uint32 (LinearInterpolate (float64 (_acdg ),0,15,decode [0],decode [1]))&0xf);};return _bg .Gray {Y :_acdg *17&0xff},nil ;};func _edfd (_gdc _bg .Gray )_bg .CMYK {return _bg .CMYK {K :0xff-_gdc .Y }};
func _dbfa (_beb _aa .Image ,_feab Image ,_gbbc _aa .Rectangle ){if _cff ,_ecab :=_beb .(SMasker );_ecab &&_cff .HasAlpha (){_feab .(SMasker ).MakeAlpha ();};_dce (_beb ,_feab ,_gbbc );};func (_gbce *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bbfd (_gbce ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func _bbfd (_fgbbb *Monochrome ,_gadf ,_ffaed ,_dfbg ,_fedaf int ,_fbec RasterOperator ,_acdc *Monochrome ,_bfb ,_bfgg int )error {if _fgbbb ==nil {return _a .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _fbec ==PixDst {return nil ;};switch _fbec {case PixClr ,PixSet ,PixNotDst :_dfda (_fgbbb ,_gadf ,_ffaed ,_dfbg ,_fedaf ,_fbec );return nil ;};if _acdc ==nil {_cd .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _a .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _bggf :=_faff (_fgbbb ,_gadf ,_ffaed ,_dfbg ,_fedaf ,_fbec ,_acdc ,_bfb ,_bfgg );_bggf !=nil {return _bggf ;};return nil ;};func _efgg (_efgb CMYK ,_gede NRGBA ,_edb _aa .Rectangle ){for _fgfa :=0;
_fgfa < _edb .Max .X ;_fgfa ++{for _bbad :=0;_bbad < _edb .Max .Y ;_bbad ++{_cffb :=_efgb .CMYKAt (_fgfa ,_bbad );_gede .SetNRGBA (_fgfa ,_bbad ,_fecc (_cffb ));};};};func (_afg *CMYK32 )At (x ,y int )_bg .Color {_bbg ,_ :=_afg .ColorAt (x ,y );return _bbg };
func (_ccdea *Monochrome )Validate ()error {if len (_ccdea .Data )!=_ccdea .Height *_ccdea .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _gbea (_geced *Monochrome ,_egc ,_bggdc ,_cce ,_cfadd int ,_aabe RasterOperator ,_gdeg *Monochrome ,_bfed ,_edgb int )error {var (_fgdd bool ;
_dcfa bool ;_cebg int ;_dccd int ;_cgbeb int ;_cgaf bool ;_ffee byte ;_ffec int ;_dacab int ;_geef int ;_bggc ,_ddab int ;);_dfadb :=8-(_egc &7);_bfdda :=_dgf [_dfadb ];_dfce :=_geced .BytesPerLine *_bggdc +(_egc >>3);_agdd :=_gdeg .BytesPerLine *_edgb +(_bfed >>3);
if _cce < _dfadb {_fgdd =true ;_bfdda &=_gbec [8-_dfadb +_cce ];};if !_fgdd {_cebg =(_cce -_dfadb )>>3;if _cebg > 0{_dcfa =true ;_dccd =_dfce +1;_cgbeb =_agdd +1;};};_ffec =(_egc +_cce )&7;if !(_fgdd ||_ffec ==0){_cgaf =true ;_ffee =_gbec [_ffec ];_dacab =_dfce +1+_cebg ;
_geef =_agdd +1+_cebg ;};switch _aabe {case PixSrc :for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],_gdeg .Data [_agdd ],_bfdda );_dfce +=_geced .BytesPerLine ;_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;
_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]=_gdeg .Data [_cgbeb +_ddab ];};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],_gdeg .Data [_geef ],_ffee );
_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixNotSrc :for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],^_gdeg .Data [_agdd ],_bfdda );_dfce +=_geced .BytesPerLine ;_agdd +=_gdeg .BytesPerLine ;
};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]=^_gdeg .Data [_cgbeb +_ddab ];};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],^_gdeg .Data [_geef ],_ffee );
_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixSrcOrDst :for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],_gdeg .Data [_agdd ]|_geced .Data [_dfce ],_bfdda );_dfce +=_geced .BytesPerLine ;
_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]|=_gdeg .Data [_cgbeb +_ddab ];};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;};};if _cgaf {for _bggc =0;
_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],_gdeg .Data [_geef ]|_geced .Data [_dacab ],_ffee );_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixSrcAndDst :for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],_gdeg .Data [_agdd ]&_geced .Data [_dfce ],_bfdda );
_dfce +=_geced .BytesPerLine ;_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]&=_gdeg .Data [_cgbeb +_ddab ];};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;
};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],_gdeg .Data [_geef ]&_geced .Data [_dacab ],_ffee );_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixSrcXorDst :for _bggc =0;
_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],_gdeg .Data [_agdd ]^_geced .Data [_dfce ],_bfdda );_dfce +=_geced .BytesPerLine ;_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;
_ddab ++{_geced .Data [_dccd +_ddab ]^=_gdeg .Data [_cgbeb +_ddab ];};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],_gdeg .Data [_geef ]^_geced .Data [_dacab ],_ffee );
_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixNotSrcOrDst :for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],^(_gdeg .Data [_agdd ])|_geced .Data [_dfce ],_bfdda );_dfce +=_geced .BytesPerLine ;
_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]|=^(_gdeg .Data [_cgbeb +_ddab ]);};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;};};if _cgaf {for _bggc =0;
_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],^(_gdeg .Data [_geef ])|_geced .Data [_dacab ],_ffee );_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixNotSrcAndDst :for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],^(_gdeg .Data [_agdd ])&_geced .Data [_dfce ],_bfdda );
_dfce +=_geced .BytesPerLine ;_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]&=^_gdeg .Data [_cgbeb +_ddab ];};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;
};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],^(_gdeg .Data [_geef ])&_geced .Data [_dacab ],_ffee );_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixSrcOrNotDst :for _bggc =0;
_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],_gdeg .Data [_agdd ]|^(_geced .Data [_dfce ]),_bfdda );_dfce +=_geced .BytesPerLine ;_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;
_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]=_gdeg .Data [_cgbeb +_ddab ]|^(_geced .Data [_dccd +_ddab ]);};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],_gdeg .Data [_geef ]|^(_geced .Data [_dacab ]),_ffee );
_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixSrcAndNotDst :for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],_gdeg .Data [_agdd ]&^(_geced .Data [_dfce ]),_bfdda );_dfce +=_geced .BytesPerLine ;
_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]=_gdeg .Data [_cgbeb +_ddab ]&^(_geced .Data [_dccd +_ddab ]);};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;
};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],_gdeg .Data [_geef ]&^(_geced .Data [_dacab ]),_ffee );_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixNotPixSrcOrDst :for _bggc =0;
_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],^(_gdeg .Data [_agdd ]|_geced .Data [_dfce ]),_bfdda );_dfce +=_geced .BytesPerLine ;_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;
_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]=^(_gdeg .Data [_cgbeb +_ddab ]|_geced .Data [_dccd +_ddab ]);};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],^(_gdeg .Data [_geef ]|_geced .Data [_dacab ]),_ffee );
_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixNotPixSrcAndDst :for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],^(_gdeg .Data [_agdd ]&_geced .Data [_dfce ]),_bfdda );_dfce +=_geced .BytesPerLine ;
_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]=^(_gdeg .Data [_cgbeb +_ddab ]&_geced .Data [_dccd +_ddab ]);};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;
};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],^(_gdeg .Data [_geef ]&_geced .Data [_dacab ]),_ffee );_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};case PixNotPixSrcXorDst :for _bggc =0;
_bggc < _cfadd ;_bggc ++{_geced .Data [_dfce ]=_cee (_geced .Data [_dfce ],^(_gdeg .Data [_agdd ]^_geced .Data [_dfce ]),_bfdda );_dfce +=_geced .BytesPerLine ;_agdd +=_gdeg .BytesPerLine ;};if _dcfa {for _bggc =0;_bggc < _cfadd ;_bggc ++{for _ddab =0;
_ddab < _cebg ;_ddab ++{_geced .Data [_dccd +_ddab ]=^(_gdeg .Data [_cgbeb +_ddab ]^_geced .Data [_dccd +_ddab ]);};_dccd +=_geced .BytesPerLine ;_cgbeb +=_gdeg .BytesPerLine ;};};if _cgaf {for _bggc =0;_bggc < _cfadd ;_bggc ++{_geced .Data [_dacab ]=_cee (_geced .Data [_dacab ],^(_gdeg .Data [_geef ]^_geced .Data [_dacab ]),_ffee );
_dacab +=_geced .BytesPerLine ;_geef +=_gdeg .BytesPerLine ;};};default:_cd .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_aabe );return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _gaf (_bad ,_debc *Monochrome ,_fdg []byte ,_ebd int )(_ebafg error ){var (_age ,_ebg ,_cdd ,_debcd ,_cabb ,_aag ,_dfg ,_gcag int ;_dbe ,_abg ,_daab ,_bff uint32 ;_aff ,_bdb byte ;_ege uint16 ;);_ed :=make ([]byte ,4);_ceb :=make ([]byte ,4);
for _cdd =0;_cdd < _bad .Height -1;_cdd ,_debcd =_cdd +2,_debcd +1{_age =_cdd *_bad .BytesPerLine ;_ebg =_debcd *_debc .BytesPerLine ;for _cabb ,_aag =0,0;_cabb < _ebd ;_cabb ,_aag =_cabb +4,_aag +1{for _dfg =0;_dfg < 4;_dfg ++{_gcag =_age +_cabb +_dfg ;
if _gcag <=len (_bad .Data )-1&&_gcag < _age +_bad .BytesPerLine {_ed [_dfg ]=_bad .Data [_gcag ];}else {_ed [_dfg ]=0x00;};_gcag =_age +_bad .BytesPerLine +_cabb +_dfg ;if _gcag <=len (_bad .Data )-1&&_gcag < _age +(2*_bad .BytesPerLine ){_ceb [_dfg ]=_bad .Data [_gcag ];
}else {_ceb [_dfg ]=0x00;};};_dbe =_gb .BigEndian .Uint32 (_ed );_abg =_gb .BigEndian .Uint32 (_ceb );_daab =_dbe &_abg ;_daab |=_daab <<1;_bff =_dbe |_abg ;_bff &=_bff <<1;_abg =_daab &_bff ;_abg &=0xaaaaaaaa;_dbe =_abg |(_abg <<7);_aff =byte (_dbe >>24);
_bdb =byte ((_dbe >>8)&0xff);_gcag =_ebg +_aag ;if _gcag +1==len (_debc .Data )-1||_gcag +1>=_ebg +_debc .BytesPerLine {if _ebafg =_debc .setByte (_gcag ,_fdg [_aff ]);_ebafg !=nil {return _bf .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gcag );
};}else {_ege =(uint16 (_fdg [_aff ])<<8)|uint16 (_fdg [_bdb ]);if _ebafg =_debc .setTwoBytes (_gcag ,_ege );_ebafg !=nil {return _bf .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gcag );
};_aag ++;};};};return nil ;};func (_dbdd *Gray16 )At (x ,y int )_bg .Color {_cbffa ,_ :=_dbdd .ColorAt (x ,y );return _cbffa };func _ebdc (_cdcg *Monochrome ,_feaee ,_gfb int ,_ggga ,_bgfdg int ,_ddgfd RasterOperator ){var (_ccdf int ;_cafe byte ;_eaag ,_edde int ;
_eea int ;);_dbee :=_ggga >>3;_fdcg :=_ggga &7;if _fdcg > 0{_cafe =_gbec [_fdcg ];};_ccdf =_cdcg .BytesPerLine *_gfb +(_feaee >>3);switch _ddgfd {case PixClr :for _eaag =0;_eaag < _bgfdg ;_eaag ++{_eea =_ccdf +_eaag *_cdcg .BytesPerLine ;for _edde =0;_edde < _dbee ;
_edde ++{_cdcg .Data [_eea ]=0x0;_eea ++;};if _fdcg > 0{_cdcg .Data [_eea ]=_cee (_cdcg .Data [_eea ],0x0,_cafe );};};case PixSet :for _eaag =0;_eaag < _bgfdg ;_eaag ++{_eea =_ccdf +_eaag *_cdcg .BytesPerLine ;for _edde =0;_edde < _dbee ;_edde ++{_cdcg .Data [_eea ]=0xff;
_eea ++;};if _fdcg > 0{_cdcg .Data [_eea ]=_cee (_cdcg .Data [_eea ],0xff,_cafe );};};case PixNotDst :for _eaag =0;_eaag < _bgfdg ;_eaag ++{_eea =_ccdf +_eaag *_cdcg .BytesPerLine ;for _edde =0;_edde < _dbee ;_edde ++{_cdcg .Data [_eea ]=^_cdcg .Data [_eea ];
_eea ++;};if _fdcg > 0{_cdcg .Data [_eea ]=_cee (_cdcg .Data [_eea ],^_cdcg .Data [_eea ],_cafe );};};};};func (_dddcg *NRGBA16 )At (x ,y int )_bg .Color {_dbde ,_ :=_dddcg .ColorAt (x ,y );return _dbde };func _ff (_deb *Monochrome ,_gbf ,_gdb int )(*Monochrome ,error ){if _deb ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _gbf <=0||_gdb <=0{return nil ,_a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _gbf ==_gdb {if _gbf ==1{return _deb .copy (),nil ;};
if _gbf ==2||_gbf ==4||_gbf ==8{_cdc ,_dfa :=_cc (_deb ,_gbf );if _dfa !=nil {return nil ,_dfa ;};return _cdc ,nil ;};};_eba :=_gbf *_deb .Width ;_ee :=_gdb *_deb .Height ;_dcc :=_cab (_eba ,_ee );_abd :=_dcc .BytesPerLine ;var (_bfdg ,_gge ,_ce ,_fc ,_fb int ;
_cdb byte ;_cge error ;);for _gge =0;_gge < _deb .Height ;_gge ++{_bfdg =_gdb *_gge *_abd ;for _ce =0;_ce < _deb .Width ;_ce ++{if _gdf :=_deb .getBitAt (_ce ,_gge );_gdf {_fb =_gbf *_ce ;for _fc =0;_fc < _gbf ;_fc ++{_dcc .setIndexedBit (_bfdg *8+_fb +_fc );
};};};for _fc =1;_fc < _gdb ;_fc ++{_af :=_bfdg +_fc *_abd ;for _ga :=0;_ga < _abd ;_ga ++{if _cdb ,_cge =_dcc .getByte (_bfdg +_ga );_cge !=nil {return nil ,_cge ;};if _cge =_dcc .setByte (_af +_ga ,_cdb );_cge !=nil {return nil ,_cge ;};};};};return _dcc ,nil ;
};func (_bacd *NRGBA16 )SetNRGBA (x ,y int ,c _bg .NRGBA ){_ddgd :=y *_bacd .BytesPerLine +x *3/2;if _ddgd +1>=len (_bacd .Data ){return ;};c =_fecf (c );_bacd .setNRGBA (x ,y ,_ddgd ,c );};func FromGoImage (i _aa .Image )(Image ,error ){switch _ecef :=i .(type ){case Image :return _ecef .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_aa .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_aa .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};
};func (_dcbe *NRGBA32 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_dcbe .Width ,Y :_dcbe .Height }};};func (_dcda *Monochrome )getBit (_ffae ,_feae int )uint8 {return _dcda .Data [_ffae +(_feae >>3)]>>uint (7-(_feae &7))&1;};func (_bcc *Gray4 )Validate ()error {if len (_bcc .Data )!=_bcc .Height *_bcc .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _dfcb (_agda _aa .Image )(Image ,error ){if _ggad ,_ccgb :=_agda .(*NRGBA64 );_ccgb {return _ggad .Copy (),nil ;};_bbgc ,_gdfd ,_gfgf :=_cebb (_agda ,2);_dfab ,_bfgaf :=NewImage (_bbgc .Max .X ,_bbgc .Max .Y ,16,3,nil ,_gfgf ,nil );
if _bfgaf !=nil {return nil ,_bfgaf ;};_dbfa (_agda ,_dfab ,_bbgc );if len (_gfgf )!=0&&!_gdfd {if _dfaeb :=_fba (_gfgf ,_dfab );_dfaeb !=nil {return nil ,_dfaeb ;};};return _dfab ,nil ;};func (_baac *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _gfde bool ;
_dfgaa :=scale ;if scale < 1{_dfgaa =1/scale ;_gfde =true ;};_aef :=NextPowerOf2 (uint (_dfgaa ));if InDelta (float64 (_aef ),_dfgaa ,0.001){if _gfde {return _baac .ReduceBinary (_dfgaa );};return _baac .ExpandBinary (int (_aef ));};_fbde :=int (_c .RoundToEven (float64 (_baac .Width )*scale ));
_gggg :=int (_c .RoundToEven (float64 (_baac .Height )*scale ));return _baac .ScaleLow (_fbde ,_gggg );};func (_fabe *Gray4 )SetGray (x ,y int ,g _bg .Gray ){if x >=_fabe .Width ||y >=_fabe .Height {return ;};g =_faeb (g );_fabe .setGray (x ,y ,g );};type NRGBA interface{NRGBAAt (_cead ,_bgcd int )_bg .NRGBA ;
SetNRGBA (_eggb ,_cgef int ,_cbfce _bg .NRGBA );};var _ Image =&NRGBA16 {};func _cebb (_gfag _aa .Image ,_ebbga int )(_aa .Rectangle ,bool ,[]byte ){_cae :=_gfag .Bounds ();var (_aedd bool ;_fabeg []byte ;);switch _bcee :=_gfag .(type ){case SMasker :_aedd =_bcee .HasAlpha ();
case NRGBA ,RGBA ,*_aa .RGBA64 ,nrgba64 ,*_aa .NYCbCrA :_fabeg =make ([]byte ,_cae .Max .X *_cae .Max .Y *_ebbga );case *_aa .Paletted :var _facb bool ;for _ ,_bcaa :=range _bcee .Palette {_dfag ,_aebfe ,_gecc ,_cdag :=_bcaa .RGBA ();if _dfag ==0&&_aebfe ==0&&_gecc ==0&&_cdag !=0{_facb =true ;
break ;};};if _facb {_fabeg =make ([]byte ,_cae .Max .X *_cae .Max .Y *_ebbga );};};return _cae ,_aedd ,_fabeg ;};var _ Image =&CMYK32 {};func (_bddc *Gray8 )Base ()*ImageBase {return &_bddc .ImageBase };var (_gbec =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};
_dgf =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_fffb *ImageBase )setEightPartlyBytes (_adae ,_gfecf int ,_abee uint64 )(_ebef error ){var (_fgcbfe byte ;_ebaa int ;);for _cdaf :=1;_cdaf <=_gfecf ;_cdaf ++{_ebaa =64-_cdaf *8;_fgcbfe =byte (_abee >>uint (_ebaa )&0xff);
if _ebef =_fffb .setByte (_adae +_cdaf -1,_fgcbfe );_ebef !=nil {return _ebef ;};};_fece :=_fffb .BytesPerLine *8-_fffb .Width ;if _fece ==0{return nil ;};_ebaa -=8;_fgcbfe =byte (_abee >>uint (_ebaa )&0xff)<<uint (_fece );if _ebef =_fffb .setByte (_adae +_gfecf ,_fgcbfe );
_ebef !=nil {return _ebef ;};return nil ;};func GrayHistogram (g Gray )(_dbgd [256]int ){switch _gdccf :=g .(type ){case Histogramer :return _gdccf .Histogram ();case _aa .Image :_aabcb :=_gdccf .Bounds ();for _fffd :=0;_fffd < _aabcb .Max .X ;_fffd ++{for _daba :=0;
_daba < _aabcb .Max .Y ;_daba ++{_dbgd [g .GrayAt (_fffd ,_daba ).Y ]++;};};return _dbgd ;default:return [256]int {};};};func ImgToGray (i _aa .Image )*_aa .Gray {if _dgad ,_abge :=i .(*_aa .Gray );_abge {return _dgad ;};_badea :=i .Bounds ();_cbfd :=_aa .NewGray (_badea );
for _agbf :=0;_agbf < _badea .Max .X ;_agbf ++{for _bcde :=0;_bcde < _badea .Max .Y ;_bcde ++{_gfbb :=i .At (_agbf ,_bcde );_cbfd .Set (_agbf ,_bcde ,_gfbb );};};return _cbfd ;};func (_egefe *NRGBA16 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_egefe .Width ,Y :_egefe .Height }};
};func (_gcc *Monochrome )GrayAt (x ,y int )_bg .Gray {_bbe ,_ :=ColorAtGray1BPC (x ,y ,_gcc .BytesPerLine ,_gcc .Data ,_gcc .Decode );return _bbe ;};var _ RGBA =&RGBA32 {};func _fgff (_bfad _bg .NRGBA )_bg .RGBA {_cfe ,_ccde ,_geg ,_gfd :=_bfad .RGBA ();
return _bg .RGBA {R :uint8 (_cfe >>8),G :uint8 (_ccde >>8),B :uint8 (_geg >>8),A :uint8 (_gfd >>8)};};func (_gaad *Gray16 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_gaad .Width ,Y :_gaad .Height }};};func _abef (_feag _aa .Image )(Image ,error ){if _ebe ,_gabfa :=_feag .(*Gray8 );
_gabfa {return _ebe .Copy (),nil ;};_cbgb :=_feag .Bounds ();_cacdf ,_ggf :=NewImage (_cbgb .Max .X ,_cbgb .Max .Y ,8,1,nil ,nil ,nil );if _ggf !=nil {return nil ,_ggf ;};_bfda (_feag ,_cacdf ,_cbgb );return _cacdf ,nil ;};func _gfab (_febb *_aa .NYCbCrA ,_eead NRGBA ,_cfba _aa .Rectangle ){for _bfec :=0;
_bfec < _cfba .Max .X ;_bfec ++{for _ggba :=0;_ggba < _cfba .Max .Y ;_ggba ++{_agfa :=_febb .NYCbCrAAt (_bfec ,_ggba );_eead .SetNRGBA (_bfec ,_ggba ,_dae (_agfa ));};};};func _cfdff (_bdfe ,_dgc Gray ,_gbgc _aa .Rectangle ){for _feaec :=0;_feaec < _gbgc .Max .X ;
_feaec ++{for _ecbe :=0;_ecbe < _gbgc .Max .Y ;_ecbe ++{_dgc .SetGray (_feaec ,_ecbe ,_bdfe .GrayAt (_feaec ,_ecbe ));};};};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _fgedg (_cbcfa ,_cgfd NRGBA ,_gdcd _aa .Rectangle ){for _cefa :=0;
_cefa < _gdcd .Max .X ;_cefa ++{for _eagb :=0;_eagb < _gdcd .Max .Y ;_eagb ++{_cgfd .SetNRGBA (_cefa ,_eagb ,_cbcfa .NRGBAAt (_cefa ,_eagb ));};};};func _edfee (_eabf Gray ,_dbdg RGBA ,_agba _aa .Rectangle ){for _aaagc :=0;_aaagc < _agba .Max .X ;_aaagc ++{for _fegga :=0;
_fegga < _agba .Max .Y ;_fegga ++{_bfde :=_eabf .GrayAt (_aaagc ,_fegga );_dbdg .SetRGBA (_aaagc ,_fegga ,_aebf (_bfde ));};};};func (_acg *CMYK32 )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtCMYK (x ,y ,_acg .Width ,_acg .Data ,_acg .Decode );
};func (_fegd *Gray2 )SetGray (x ,y int ,gray _bg .Gray ){_ecad :=_gabf (gray );_fdedb :=y *_fegd .BytesPerLine ;_egee :=_fdedb +(x >>2);if _egee >=len (_fegd .Data ){return ;};_dfeef :=_ecad .Y >>6;_fegd .Data [_egee ]=(_fegd .Data [_egee ]&(^(0xc0>>uint (2*((x )&3)))))|(_dfeef <<uint (6-2*(x &3)));
};var _ Image =&Gray8 {};func _faeb (_fefa _bg .Gray )_bg .Gray {_fefa .Y >>=4;_fefa .Y |=_fefa .Y <<4;return _fefa };func (_ddgf *Gray2 )At (x ,y int )_bg .Color {_caa ,_ :=_ddgf .ColorAt (x ,y );return _caa };func _faca (_ced _bg .Gray )_bg .NRGBA {return _bg .NRGBA {R :_ced .Y ,G :_ced .Y ,B :_ced .Y ,A :0xff}};
func (_bcdd *NRGBA32 )At (x ,y int )_bg .Color {_ddfe ,_ :=_bcdd .ColorAt (x ,y );return _ddfe };type RasterOperator int ;func _effb (_fgde _bg .Color )_bg .Color {_eged :=_bg .GrayModel .Convert (_fgde ).(_bg .Gray );return _faeb (_eged );};func (_cdgg *Monochrome )ResolveDecode ()error {if len (_cdgg .Decode )!=2{return nil ;
};if _cdgg .Decode [0]==1&&_cdgg .Decode [1]==0{if _fedd :=_cdgg .InverseData ();_fedd !=nil {return _fedd ;};_cdgg .Decode =nil ;};return nil ;};func _dce (_dede _aa .Image ,_gae Image ,_cdce _aa .Rectangle ){for _gef :=0;_gef < _cdce .Max .X ;_gef ++{for _gbee :=0;
_gbee < _cdce .Max .Y ;_gbee ++{_ddd :=_dede .At (_gef ,_gbee );_gae .Set (_gef ,_gbee ,_ddd );};};};func (_befe *Gray8 )SetGray (x ,y int ,g _bg .Gray ){_ebafc :=y *_befe .BytesPerLine +x ;if _ebafc > len (_befe .Data )-1{return ;};_befe .Data [_ebafc ]=g .Y ;
};func (_adfe *NRGBA16 )Base ()*ImageBase {return &_adfe .ImageBase };func (_ceda *NRGBA64 )Validate ()error {if len (_ceda .Data )!=3*2*_ceda .Width *_ceda .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_facf (n )+1);};func (_cfad *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_cfad .copy ()}};func (_cfcg *ImageBase )getByte (_gdgb int )(byte ,error ){if _gdgb > len (_cfcg .Data )-1||_gdgb < 0{return 0,_bf .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_gdgb );
};return _cfcg .Data [_gdgb ],nil ;};func (_agdc *ImageBase )copy ()ImageBase {_ffag :=*_agdc ;_ffag .Data =make ([]byte ,len (_agdc .Data ));copy (_ffag .Data ,_agdc .Data );return _ffag ;};type NRGBA64 struct{ImageBase };func _acea (_dbc _aa .Image )(Image ,error ){if _fcc ,_ccgf :=_dbc .(*Monochrome );
_ccgf {return _fcc ,nil ;};_dddc :=_dbc .Bounds ();var _decd Gray ;switch _dfcc :=_dbc .(type ){case Gray :_decd =_dfcc ;case NRGBA :_decd =&Gray8 {ImageBase :NewImageBase (_dddc .Max .X ,_dddc .Max .Y ,8,1,nil ,nil ,nil )};_dbgg (_decd ,_dfcc ,_dddc );
case nrgba64 :_decd =&Gray8 {ImageBase :NewImageBase (_dddc .Max .X ,_dddc .Max .Y ,8,1,nil ,nil ,nil )};_fcdd (_decd ,_dfcc ,_dddc );default:_ffgc ,_agae :=GrayConverter .Convert (_dbc );if _agae !=nil {return nil ,_agae ;};_decd =_ffgc .(Gray );};_cef ,_gad :=NewImage (_dddc .Max .X ,_dddc .Max .Y ,1,1,nil ,nil ,nil );
if _gad !=nil {return nil ,_gad ;};_ddg :=_cef .(*Monochrome );_fbeb :=AutoThresholdTriangle (GrayHistogram (_decd ));for _abfb :=0;_abfb < _dddc .Max .X ;_abfb ++{for _ebb :=0;_ebb < _dddc .Max .Y ;_ebb ++{_cdae :=_dea (_decd .GrayAt (_abfb ,_ebb ),monochromeModel (_fbeb ));
_ddg .SetGray (_abfb ,_ebb ,_cdae );};};return _cef ,nil ;};func (_fdd *CMYK32 )ColorModel ()_bg .Model {return _bg .CMYKModel };func _gca ()(_fa [256]uint32 ){for _gbe :=0;_gbe < 256;_gbe ++{if _gbe &0x01!=0{_fa [_gbe ]|=0xf;};if _gbe &0x02!=0{_fa [_gbe ]|=0xf0;
};if _gbe &0x04!=0{_fa [_gbe ]|=0xf00;};if _gbe &0x08!=0{_fa [_gbe ]|=0xf000;};if _gbe &0x10!=0{_fa [_gbe ]|=0xf0000;};if _gbe &0x20!=0{_fa [_gbe ]|=0xf00000;};if _gbe &0x40!=0{_fa [_gbe ]|=0xf000000;};if _gbe &0x80!=0{_fa [_gbe ]|=0xf0000000;};};return _fa ;
};func (_dgbg *Gray2 )ColorModel ()_bg .Model {return Gray2Model };func _adad (_dedef int ,_fdcd int )error {return _bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_dedef ,_fdcd );
};func _gabf (_ccad _bg .Gray )_bg .Gray {_fcaf :=_ccad .Y >>6;_fcaf |=_fcaf <<2;_ccad .Y =_fcaf |_fcaf <<4;return _ccad ;};func _dfcd (_cfga nrgba64 ,_gbcb RGBA ,_gdfba _aa .Rectangle ){for _gfcg :=0;_gfcg < _gdfba .Max .X ;_gfcg ++{for _fggb :=0;_fggb < _gdfba .Max .Y ;
_fggb ++{_abga :=_cfga .NRGBA64At (_gfcg ,_fggb );_gbcb .SetRGBA (_gfcg ,_fggb ,_fab (_abga ));};};};func (_dadf *NRGBA32 )Base ()*ImageBase {return &_dadf .ImageBase };func (_cbfg *ImageBase )newAlpha (){_ddde :=BytesPerLine (_cbfg .Width ,_cbfg .BitsPerComponent ,1);
_cbfg .Alpha =make ([]byte ,_cbfg .Height *_ddde );};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};type Histogramer interface{Histogram ()[256]int ;};func (_cgf *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_cgf .ImageBase .copy (),ModelThreshold :_cgf .ModelThreshold };
};var _ Image =&Gray16 {};func (_gaec *NRGBA64 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_gaec .Width ,Y :_gaec .Height }};};func (_egbdba *Monochrome )Histogram ()(_afd [256]int ){for _ ,_geaff :=range _egbdba .Data {_afd [0xff]+=int (_gdg [_egbdba .Data [_geaff ]]);
};return _afd ;};type CMYK32 struct{ImageBase };func _eeff (_dfed _aa .Image )(Image ,error ){if _aed ,_bdgff :=_dfed .(*NRGBA32 );_bdgff {return _aed .Copy (),nil ;};_cbb ,_eece ,_fcec :=_cebb (_dfed ,1);_acbb ,_ggab :=NewImage (_cbb .Max .X ,_cbb .Max .Y ,8,3,nil ,_fcec ,nil );
if _ggab !=nil {return nil ,_ggab ;};_afed (_dfed ,_acbb ,_cbb );if len (_fcec )!=0&&!_eece {if _baae :=_fba (_fcec ,_acbb );_baae !=nil {return nil ,_baae ;};};return _acbb ,nil ;};type monochromeModel uint8 ;type RGBA interface{RGBAAt (_effe ,_ecbfe int )_bg .RGBA ;
SetRGBA (_fbbab ,_dgeb int ,_dedgf _bg .RGBA );};func (_faf *CMYK32 )Base ()*ImageBase {return &_faf .ImageBase };func (_daee *NRGBA16 )NRGBAAt (x ,y int )_bg .NRGBA {_gedg ,_ :=ColorAtNRGBA16 (x ,y ,_daee .Width ,_daee .BytesPerLine ,_daee .Data ,_daee .Alpha ,_daee .Decode );
return _gedg ;};func (_eade *Gray4 )Bounds ()_aa .Rectangle {return _aa .Rectangle {Max :_aa .Point {X :_eade .Width ,Y :_eade .Height }};};func (_dggg *NRGBA16 )ColorModel ()_bg .Model {return NRGBA16Model };func _gcb (_ggb *Monochrome ,_dac ...int )(_agg *Monochrome ,_cfc error ){if _ggb ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_dac )==0{return nil ,_a .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_feb :=_bb ();_agg =_ggb ;for _ ,_eec :=range _dac {if _eec <=0{break ;};_agg ,_cfc =_bgf (_agg ,_eec ,_feb );if _cfc !=nil {return nil ,_cfc ;};};return _agg ,nil ;};var _ Image =&NRGBA32 {};func _bfdb (_bac ,_cgee int ,_ffg []byte )*Monochrome {_dee :=_cab (_bac ,_cgee );
_dee .Data =_ffg ;return _dee ;};func (_abdd monochromeModel )Convert (c _bg .Color )_bg .Color {_cedd :=_bg .GrayModel .Convert (c ).(_bg .Gray );return _dea (_cedd ,_abdd );};func _bgfgg (_cbeb NRGBA ,_abda RGBA ,_egbea _aa .Rectangle ){for _bgdg :=0;
_bgdg < _egbea .Max .X ;_bgdg ++{for _eagbf :=0;_eagbf < _egbea .Max .Y ;_eagbf ++{_gceg :=_cbeb .NRGBAAt (_bgdg ,_eagbf );_abda .SetRGBA (_bgdg ,_eagbf ,_fgff (_gceg ));};};};func _bdgf (_gagb _bg .NRGBA )_bg .CMYK {_fbfg ,_dda ,_cfg ,_ :=_gagb .RGBA ();
_deeb ,_cbd ,_adcb ,_fce :=_bg .RGBToCMYK (uint8 (_fbfg >>8),uint8 (_dda >>8),uint8 (_cfg >>8));return _bg .CMYK {C :_deeb ,M :_cbd ,Y :_adcb ,K :_fce };};func _dcbea (_fbbb _aa .Image ,_fdeec uint8 )*_aa .Gray {_bea :=_fbbb .Bounds ();_dfec :=_aa .NewGray (_bea );
var (_fbdd _bg .Color ;_gdcb _bg .Gray ;);for _bfcd :=0;_bfcd < _bea .Max .X ;_bfcd ++{for _ggbfb :=0;_ggbfb < _bea .Max .Y ;_ggbfb ++{_fbdd =_fbbb .At (_bfcd ,_ggbfb );_dfec .Set (_bfcd ,_ggbfb ,_fbdd );_gdcb =_dfec .GrayAt (_bfcd ,_ggbfb );_dfec .SetGray (_bfcd ,_ggbfb ,_bg .Gray {Y :_addc (_gdcb .Y ,_fdeec )});
};};return _dfec ;};func (_bfga *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_bfga .copy ()}};func (_eebf *Gray8 )Histogram ()(_efge [256]int ){for _bffe :=0;_bffe < len (_eebf .Data );_bffe ++{_efge [_eebf .Data [_bffe ]]++;};return _efge ;};func _bfc (_cea ,_ddb *Monochrome ,_cb []byte ,_gdd int )(_fbg error ){var (_adg ,_gbc ,_dgg ,_aga ,_acaf ,_dge ,_febg ,_fae int ;
_aec ,_bcb ,_agb ,_fegg uint32 ;_gdac ,_dcb byte ;_abf uint16 ;);_agf :=make ([]byte ,4);_abc :=make ([]byte ,4);for _dgg =0;_dgg < _cea .Height -1;_dgg ,_aga =_dgg +2,_aga +1{_adg =_dgg *_cea .BytesPerLine ;_gbc =_aga *_ddb .BytesPerLine ;for _acaf ,_dge =0,0;
_acaf < _gdd ;_acaf ,_dge =_acaf +4,_dge +1{for _febg =0;_febg < 4;_febg ++{_fae =_adg +_acaf +_febg ;if _fae <=len (_cea .Data )-1&&_fae < _adg +_cea .BytesPerLine {_agf [_febg ]=_cea .Data [_fae ];}else {_agf [_febg ]=0x00;};_fae =_adg +_cea .BytesPerLine +_acaf +_febg ;
if _fae <=len (_cea .Data )-1&&_fae < _adg +(2*_cea .BytesPerLine ){_abc [_febg ]=_cea .Data [_fae ];}else {_abc [_febg ]=0x00;};};_aec =_gb .BigEndian .Uint32 (_agf );_bcb =_gb .BigEndian .Uint32 (_abc );_agb =_aec &_bcb ;_agb |=_agb <<1;_fegg =_aec |_bcb ;
_fegg &=_fegg <<1;_bcb =_agb |_fegg ;_bcb &=0xaaaaaaaa;_aec =_bcb |(_bcb <<7);_gdac =byte (_aec >>24);_dcb =byte ((_aec >>8)&0xff);_fae =_gbc +_dge ;if _fae +1==len (_ddb .Data )-1||_fae +1>=_gbc +_ddb .BytesPerLine {if _fbg =_ddb .setByte (_fae ,_cb [_gdac ]);
_fbg !=nil {return _bf .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fae );};}else {_abf =(uint16 (_cb [_gdac ])<<8)|uint16 (_cb [_dcb ]);if _fbg =_ddb .setTwoBytes (_fae ,_abf );_fbg !=nil {return _bf .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fae );
};_dge ++;};};};return nil ;};func _afed (_ggdf _aa .Image ,_fcdg Image ,_ggead _aa .Rectangle ){if _adfda ,_ccgc :=_ggdf .(SMasker );_ccgc &&_adfda .HasAlpha (){_fcdg .(SMasker ).MakeAlpha ();};switch _gfdb :=_ggdf .(type ){case Gray :_bcfbe (_gfdb ,_fcdg .(NRGBA ),_ggead );
case NRGBA :_fgedg (_gfdb ,_fcdg .(NRGBA ),_ggead );case *_aa .NYCbCrA :_gfab (_gfdb ,_fcdg .(NRGBA ),_ggead );case CMYK :_efgg (_gfdb ,_fcdg .(NRGBA ),_ggead );case RGBA :_dfced (_gfdb ,_fcdg .(NRGBA ),_ggead );case nrgba64 :_ddefg (_gfdb ,_fcdg .(NRGBA ),_ggead );
default:_dce (_ggdf ,_fcdg ,_ggead );};};func (_agbd *Monochrome )At (x ,y int )_bg .Color {_ccdb ,_ :=_agbd .ColorAt (x ,y );return _ccdb };type nrgba64 interface{NRGBA64At (_cfbea ,_cbe int )_bg .NRGBA64 ;SetNRGBA64 (_fdcc ,_bagd int ,_cged _bg .NRGBA64 );
};func (_agfe *NRGBA64 )NRGBA64At (x ,y int )_bg .NRGBA64 {_deea ,_ :=ColorAtNRGBA64 (x ,y ,_agfe .Width ,_agfe .Data ,_agfe .Alpha ,_agfe .Decode );return _deea ;};func _fdb ()(_efg [256]uint16 ){for _cdf :=0;_cdf < 256;_cdf ++{if _cdf &0x01!=0{_efg [_cdf ]|=0x3;
};if _cdf &0x02!=0{_efg [_cdf ]|=0xc;};if _cdf &0x04!=0{_efg [_cdf ]|=0x30;};if _cdf &0x08!=0{_efg [_cdf ]|=0xc0;};if _cdf &0x10!=0{_efg [_cdf ]|=0x300;};if _cdf &0x20!=0{_efg [_cdf ]|=0xc00;};if _cdf &0x40!=0{_efg [_cdf ]|=0x3000;};if _cdf &0x80!=0{_efg [_cdf ]|=0xc000;
};};return _efg ;};func (_cdgf *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_cdgf .copy ()}};func _ffa (_ace RGBA ,_bcag CMYK ,_cbfc _aa .Rectangle ){for _be :=0;_be < _cbfc .Max .X ;_be ++{for _gac :=0;_gac < _cbfc .Max .Y ;_gac ++{_gaa :=_ace .RGBAAt (_be ,_gac );
_bcag .SetCMYK (_be ,_gac ,_dgag (_gaa ));};};};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_dad :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_dad .Data =make ([]byte ,height *_dad .BytesPerLine );};return _dad ;};func _ggae (_aba _aa .Image )(Image ,error ){if _fcce ,_edda :=_aba .(*Gray16 );_edda {return _fcce .Copy (),nil ;};_dfade :=_aba .Bounds ();_gagee ,_bggd :=NewImage (_dfade .Max .X ,_dfade .Max .Y ,16,1,nil ,nil ,nil );
if _bggd !=nil {return nil ,_bggd ;};_bfda (_aba ,_gagee ,_dfade );return _gagee ,nil ;};func InDelta (expected ,current ,delta float64 )bool {_acdga :=expected -current ;if _acdga <=-delta ||_acdga >=delta {return false ;};return true ;};func (_bcab *Monochrome )ColorAt (x ,y int )(_bg .Color ,error ){return ColorAtGray1BPC (x ,y ,_bcab .BytesPerLine ,_bcab .Data ,_bcab .Decode );
};func (_fbefd *Gray8 )GrayAt (x ,y int )_bg .Gray {_eacc ,_ :=ColorAtGray8BPC (x ,y ,_fbefd .BytesPerLine ,_fbefd .Data ,_fbefd .Decode );return _eacc ;};func ImgToBinary (i _aa .Image ,threshold uint8 )*_aa .Gray {switch _edfg :=i .(type ){case *_aa .Gray :if _bbb (_edfg ){return _edfg ;
};return _abeff (_edfg ,threshold );case *_aa .Gray16 :return _bbac (_edfg ,threshold );default:return _dcbea (_edfg ,threshold );};};func _addc (_cdff ,_cace uint8 )uint8 {if _cdff < _cace {return 255;};return 0;};func (_bdbb *ImageBase )MakeAlpha (){_bdbb .newAlpha ()};
func (_fcbd *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_fcbd .copy ()}};func _cbbc (_gegb CMYK ,_gbcf RGBA ,_ededf _aa .Rectangle ){for _bffc :=0;_bffc < _ededf .Max .X ;_bffc ++{for _gcbe :=0;_gcbe < _ededf .Max .Y ;_gcbe ++{_gebd :=_gegb .CMYKAt (_bffc ,_gcbe );
_gbcf .SetRGBA (_bffc ,_gcbe ,_cbcb (_gebd ));};};};func _aebf (_gec _bg .Gray )_bg .RGBA {return _bg .RGBA {R :_gec .Y ,G :_gec .Y ,B :_gec .Y ,A :0xff}};func (_ggdc *Gray2 )GrayAt (x ,y int )_bg .Gray {_adde ,_ :=ColorAtGray2BPC (x ,y ,_ggdc .BytesPerLine ,_ggdc .Data ,_ggdc .Decode );
return _adde ;};func (_gadbe *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_gadbe .copy ()}};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_bg .CMYK ,error ){_fgcg :=4*(y *width +x );if _fgcg +3>=len (data ){return _bg .CMYK {},_bf .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_fgcg ]&0xff;M :=data [_fgcg +1]&0xff;Y :=data [_fgcg +2]&0xff;K :=data [_fgcg +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _bg .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_bce *Monochrome )SetGray (x ,y int ,g _bg .Gray ){_fbfa :=y *_bce .BytesPerLine +x >>3;
if _fbfa > len (_bce .Data )-1{return ;};g =_dea (g ,monochromeModel (_bce .ModelThreshold ));_bce .setGray (x ,g ,_fbfa );};var _ Image =&RGBA32 {};var _ Image =&Monochrome {};type ColorConverter interface{Convert (_dfd _aa .Image )(Image ,error );};func (_bfg *CMYK32 )Validate ()error {if len (_bfg .Data )!=4*_bfg .Width *_bfg .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ebfb *RGBA32 )Set (x ,y int ,c _bg .Color ){_bccg :=y *_ebfb .Width +x ;_bbce :=3*_bccg ;if _bbce +2>=len (_ebfb .Data ){return ;};_ddabb :=_bg .RGBAModel .Convert (c ).(_bg .RGBA );_ebfb .setRGBA (_bccg ,_ddabb );};func _dfced (_dgcd RGBA ,_gfbe NRGBA ,_eebd _aa .Rectangle ){for _agffc :=0;
_agffc < _eebd .Max .X ;_agffc ++{for _bgge :=0;_bgge < _eebd .Max .Y ;_bgge ++{_agbec :=_dgcd .RGBAAt (_agffc ,_bgge );_gfbe .SetNRGBA (_agffc ,_bgge ,_fddg (_agbec ));};};};func _bbec (_gbfe _bg .Color )_bg .Color {_dcg :=_bg .GrayModel .Convert (_gbfe ).(_bg .Gray );
return _gabf (_dcg );};func _fcdd (_egd Gray ,_cecc nrgba64 ,_cgba _aa .Rectangle ){for _gbca :=0;_gbca < _cgba .Max .X ;_gbca ++{for _cdg :=0;_cdg < _cgba .Max .Y ;_cdg ++{_fecb :=_bcfc (_cecc .NRGBA64At (_gbca ,_cdg ));_egd .SetGray (_gbca ,_cdg ,_fecb );
};};};func _cbcb (_gcd _bg .CMYK )_bg .RGBA {_efgae ,_ggd ,_gba :=_bg .CMYKToRGB (_gcd .C ,_gcd .M ,_gcd .Y ,_gcd .K );return _bg .RGBA {R :_efgae ,G :_ggd ,B :_gba ,A :0xff};};func _eag (_bdcg _aa .Image )(Image ,error ){if _ffge ,_eebc :=_bdcg .(*Gray2 );
_eebc {return _ffge .Copy (),nil ;};_bbf :=_bdcg .Bounds ();_aebe ,_bcgb :=NewImage (_bbf .Max .X ,_bbf .Max .Y ,2,1,nil ,nil ,nil );if _bcgb !=nil {return nil ,_bcgb ;};_bfda (_bdcg ,_aebe ,_bbf );return _aebe ,nil ;};func (_gcacb *NRGBA32 )setRGBA (_bgfg int ,_fcefe _bg .NRGBA ){_aea :=3*_bgfg ;
_gcacb .Data [_aea ]=_fcefe .R ;_gcacb .Data [_aea +1]=_fcefe .G ;_gcacb .Data [_aea +2]=_fcefe .B ;if _bgfg < len (_gcacb .Alpha ){_gcacb .Alpha [_bgfg ]=_fcefe .A ;};};func (_gbab *ImageBase )setEightBytes (_fad int ,_agfc uint64 )error {_geee :=_gbab .BytesPerLine -(_fad %_gbab .BytesPerLine );
if _gbab .BytesPerLine !=_gbab .Width >>3{_geee --;};if _geee >=8{return _gbab .setEightFullBytes (_fad ,_agfc );};return _gbab .setEightPartlyBytes (_fad ,_geee ,_agfc );};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_bg .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_bf .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};