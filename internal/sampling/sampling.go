//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_eg "github.com/unidoc/unipdf/v3/internal/bitwise";_c "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);type Reader struct{_f _c .ImageBase ;_ed *_eg .Reader ;_ef ,_d ,_dd int ;_fg bool ;};type SampleWriter interface{WriteSample (_ca uint32 )error ;
WriteSamples (_cac []uint32 )error ;};func NewReader (img _c .ImageBase )*Reader {return &Reader {_ed :_eg .NewReader (img .Data ),_f :img ,_dd :img .ColorComponents ,_fg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _cb []uint32 ;_bf :=bitsPerOutputSample ;var _bef uint32 ;var _fd uint32 ;_gb :=0;_db :=0;_egab :=0;for _egab < len (data ){if _gb > 0{_gg :=_gb ;if _bf < _gg {_gg =_bf ;
};_bef =(_bef <<uint (_gg ))|(_fd >>uint (bitsPerInputSample -_gg ));_gb -=_gg ;if _gb > 0{_fd =_fd <<uint (_gg );}else {_fd =0;};_bf -=_gg ;if _bf ==0{_cb =append (_cb ,_bef );_bf =bitsPerOutputSample ;_bef =0;_db ++;};}else {_bb :=data [_egab ];_egab ++;
_dbg :=bitsPerInputSample ;if _bf < _dbg {_dbg =_bf ;};_gb =bitsPerInputSample -_dbg ;_bef =(_bef <<uint (_dbg ))|(_bb >>uint (_gb ));if _dbg < bitsPerInputSample {_fd =_bb <<uint (_dbg );};_bf -=_dbg ;if _bf ==0{_cb =append (_cb ,_bef );_bf =bitsPerOutputSample ;
_bef =0;_db ++;};};};for _gb >=bitsPerOutputSample {_ecf :=_gb ;if _bf < _ecf {_ecf =_bf ;};_bef =(_bef <<uint (_ecf ))|(_fd >>uint (bitsPerInputSample -_ecf ));_gb -=_ecf ;if _gb > 0{_fd =_fd <<uint (_ecf );}else {_fd =0;};_bf -=_ecf ;if _bf ==0{_cb =append (_cb ,_bef );
_bf =bitsPerOutputSample ;_bef =0;_db ++;};};if _bf > 0&&_bf < bitsPerOutputSample {_bef <<=uint (_bf );_cb =append (_cb ,_bef );};return _cb ;};func (_ffe *Reader )ReadSamples (samples []uint32 )(_ab error ){for _aa :=0;_aa < len (samples );_aa ++{samples [_aa ],_ab =_ffe .ReadSample ();
if _ab !=nil {return _ab ;};};return nil ;};func (_cd *Writer )WriteSamples (samples []uint32 )error {for _bfd :=0;_bfd < len (samples );_bfd ++{if _de :=_cd .WriteSample (samples [_bfd ]);_de !=nil {return _de ;};};return nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_b []uint32 )error ;};func (_gf *Reader )ReadSample ()(uint32 ,error ){if _gf ._d ==_gf ._f .Height {return 0,_e .EOF ;};_ff ,_a :=_gf ._ed .ReadBits (byte (_gf ._f .BitsPerComponent ));if _a !=nil {return 0,_a ;};_gf ._dd --;if _gf ._dd ==0{_gf ._dd =_gf ._f .ColorComponents ;
_gf ._ef ++;};if _gf ._ef ==_gf ._f .Width {if _gf ._fg {_gf ._ed .ConsumeRemainingBits ();};_gf ._ef =0;_gf ._d ++;};return uint32 (_ff ),nil ;};func (_ee *Writer )WriteSample (sample uint32 )error {if _ ,_dfb :=_ee ._cag .WriteBits (uint64 (sample ),_ee ._abb .BitsPerComponent );
_dfb !=nil {return _dfb ;};_ee ._cbb --;if _ee ._cbb ==0{_ee ._cbb =_ee ._abb .ColorComponents ;_ee ._bfg ++;};if _ee ._bfg ==_ee ._abb .Width {if _ee ._bd {_ee ._cag .FinishByte ();};_ee ._bfg =0;};return nil ;};type Writer struct{_abb _c .ImageBase ;
_cag *_eg .Writer ;_bfg ,_cbb int ;_bd bool ;};func NewWriter (img _c .ImageBase )*Writer {return &Writer {_cag :_eg .NewWriterMSB (img .Data ),_abb :img ,_cbb :img .ColorComponents ,_bd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _df []uint32 ;_gfd :=bitsPerSample ;var _da uint32 ;var _ega byte ;_ga :=0;_fc :=0;_cc :=0;for _cc < len (data ){if _ga > 0{_edc :=_ga ;if _gfd < _edc {_edc =_gfd ;};_da =(_da <<uint (_edc ))|uint32 (_ega >>uint (8-_edc ));
_ga -=_edc ;if _ga > 0{_ega =_ega <<uint (_edc );}else {_ega =0;};_gfd -=_edc ;if _gfd ==0{_df =append (_df ,_da );_gfd =bitsPerSample ;_da =0;_fc ++;};}else {_be :=data [_cc ];_cc ++;_ec :=8;if _gfd < _ec {_ec =_gfd ;};_ga =8-_ec ;_da =(_da <<uint (_ec ))|uint32 (_be >>uint (_ga ));
if _ec < 8{_ega =_be <<uint (_ec );};_gfd -=_ec ;if _gfd ==0{_df =append (_df ,_da );_gfd =bitsPerSample ;_da =0;_fc ++;};};};for _ga >=bitsPerSample {_bc :=_ga ;if _gfd < _bc {_bc =_gfd ;};_da =(_da <<uint (_bc ))|uint32 (_ega >>uint (8-_bc ));_ga -=_bc ;
if _ga > 0{_ega =_ega <<uint (_bc );}else {_ega =0;};_gfd -=_bc ;if _gfd ==0{_df =append (_df ,_da );_gfd =bitsPerSample ;_da =0;_fc ++;};};return _df ;};