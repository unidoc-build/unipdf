//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_fa "github.com/unidoc/unipdf/v3/internal/bitwise";_gd "github.com/unidoc/unipdf/v3/internal/imageutil";_f "io";);func (_da *Reader )ReadSamples (samples []uint32 )(_bc error ){for _cgc :=0;_cgc < len (samples );_cgc ++{samples [_cgc ],_bc =_da .ReadSample ();
if _bc !=nil {return _bc ;};};return nil ;};func (_bd *Writer )WriteSamples (samples []uint32 )error {for _cc :=0;_cc < len (samples );_cc ++{if _aae :=_bd .WriteSample (samples [_cc ]);_aae !=nil {return _aae ;};};return nil ;};type Reader struct{_ff _gd .ImageBase ;
_fb *_fa .Reader ;_c ,_b ,_cg int ;_d bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ba []uint32 ;_dd :=bitsPerSample ;var _cgf uint32 ;var _de byte ;_fg :=0;_ed :=0;_dg :=0;for _dg < len (data ){if _fg > 0{_ec :=_fg ;if _dd < _ec {_ec =_dd ;
};_cgf =(_cgf <<uint (_ec ))|uint32 (_de >>uint (8-_ec ));_fg -=_ec ;if _fg > 0{_de =_de <<uint (_ec );}else {_de =0;};_dd -=_ec ;if _dd ==0{_ba =append (_ba ,_cgf );_dd =bitsPerSample ;_cgf =0;_ed ++;};}else {_ac :=data [_dg ];_dg ++;_cf :=8;if _dd < _cf {_cf =_dd ;
};_fg =8-_cf ;_cgf =(_cgf <<uint (_cf ))|uint32 (_ac >>uint (_fg ));if _cf < 8{_de =_ac <<uint (_cf );};_dd -=_cf ;if _dd ==0{_ba =append (_ba ,_cgf );_dd =bitsPerSample ;_cgf =0;_ed ++;};};};for _fg >=bitsPerSample {_bcd :=_fg ;if _dd < _bcd {_bcd =_dd ;
};_cgf =(_cgf <<uint (_bcd ))|uint32 (_de >>uint (8-_bcd ));_fg -=_bcd ;if _fg > 0{_de =_de <<uint (_bcd );}else {_de =0;};_dd -=_bcd ;if _dd ==0{_ba =append (_ba ,_cgf );_dd =bitsPerSample ;_cgf =0;_ed ++;};};return _ba ;};func (_acg *Writer )WriteSample (sample uint32 )error {if _ ,_fde :=_acg ._aba .WriteBits (uint64 (sample ),_acg ._edg .BitsPerComponent );
_fde !=nil {return _fde ;};_acg ._ag --;if _acg ._ag ==0{_acg ._ag =_acg ._edg .ColorComponents ;_acg ._cdc ++;};if _acg ._cdc ==_acg ._edg .Width {if _acg ._ae {_acg ._aba .FinishByte ();};_acg ._cdc =0;};return nil ;};type Writer struct{_edg _gd .ImageBase ;
_aba *_fa .Writer ;_cdc ,_ag int ;_ae bool ;};func NewWriter (img _gd .ImageBase )*Writer {return &Writer {_aba :_fa .NewWriterMSB (img .Data ),_edg :img ,_ag :img .ColorComponents ,_ae :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleWriter interface{WriteSample (_baf uint32 )error ;WriteSamples (_cd []uint32 )error ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_a []uint32 )error ;};func (_aa *Reader )ReadSample ()(uint32 ,error ){if _aa ._b ==_aa ._ff .Height {return 0,_f .EOF ;
};_bf ,_e :=_aa ._fb .ReadBits (byte (_aa ._ff .BitsPerComponent ));if _e !=nil {return 0,_e ;};_aa ._cg --;if _aa ._cg ==0{_aa ._cg =_aa ._ff .ColorComponents ;_aa ._c ++;};if _aa ._c ==_aa ._ff .Width {if _aa ._d {_aa ._fb .ConsumeRemainingBits ();};
_aa ._c =0;_aa ._b ++;};return uint32 (_bf ),nil ;};func NewReader (img _gd .ImageBase )*Reader {return &Reader {_fb :_fa .NewReader (img .Data ),_ff :img ,_cg :img .ColorComponents ,_d :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _db []uint32 ;_ddg :=bitsPerOutputSample ;var _ab uint32 ;var _fc uint32 ;_ece :=0;_cfa :=0;_fd :=0;for _fd < len (data ){if _ece > 0{_eda :=_ece ;if _ddg < _eda {_eda =_ddg ;
};_ab =(_ab <<uint (_eda ))|(_fc >>uint (bitsPerInputSample -_eda ));_ece -=_eda ;if _ece > 0{_fc =_fc <<uint (_eda );}else {_fc =0;};_ddg -=_eda ;if _ddg ==0{_db =append (_db ,_ab );_ddg =bitsPerOutputSample ;_ab =0;_cfa ++;};}else {_ga :=data [_fd ];
_fd ++;_acf :=bitsPerInputSample ;if _ddg < _acf {_acf =_ddg ;};_ece =bitsPerInputSample -_acf ;_ab =(_ab <<uint (_acf ))|(_ga >>uint (_ece ));if _acf < bitsPerInputSample {_fc =_ga <<uint (_acf );};_ddg -=_acf ;if _ddg ==0{_db =append (_db ,_ab );_ddg =bitsPerOutputSample ;
_ab =0;_cfa ++;};};};for _ece >=bitsPerOutputSample {_ea :=_ece ;if _ddg < _ea {_ea =_ddg ;};_ab =(_ab <<uint (_ea ))|(_fc >>uint (bitsPerInputSample -_ea ));_ece -=_ea ;if _ece > 0{_fc =_fc <<uint (_ea );}else {_fc =0;};_ddg -=_ea ;if _ddg ==0{_db =append (_db ,_ab );
_ddg =bitsPerOutputSample ;_ab =0;_cfa ++;};};if _ddg > 0&&_ddg < bitsPerOutputSample {_ab <<=uint (_ddg );_db =append (_db ,_ab );};return _db ;};