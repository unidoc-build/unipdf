//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_ge "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/imageutil";_a "io";);type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_d []uint32 )error ;};func (_afb *Reader )ReadSample ()(uint32 ,error ){if _afb ._af ==_afb ._e .Height {return 0,_a .EOF ;
};_ae ,_dd :=_afb ._c .ReadBits (byte (_afb ._e .BitsPerComponent ));if _dd !=nil {return 0,_dd ;};_afb ._bg --;if _afb ._bg ==0{_afb ._bg =_afb ._e .ColorComponents ;_afb ._b ++;};if _afb ._b ==_afb ._e .Width {if _afb ._bd {_afb ._c .ConsumeRemainingBits ();
};_afb ._b =0;_afb ._af ++;};return uint32 (_ae ),nil ;};func NewReader (img _f .ImageBase )*Reader {return &Reader {_c :_ge .NewReader (img .Data ),_e :img ,_bg :img .ColorComponents ,_bd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _cf []uint32 ;_eg :=bitsPerOutputSample ;var _cd uint32 ;var _agg uint32 ;_be :=0;_fbe :=0;_fe :=0;for _fe < len (data ){if _be > 0{_ca :=_be ;if _eg < _ca {_ca =_eg ;
};_cd =(_cd <<uint (_ca ))|(_agg >>uint (bitsPerInputSample -_ca ));_be -=_ca ;if _be > 0{_agg =_agg <<uint (_ca );}else {_agg =0;};_eg -=_ca ;if _eg ==0{_cf =append (_cf ,_cd );_eg =bitsPerOutputSample ;_cd =0;_fbe ++;};}else {_dg :=data [_fe ];_fe ++;
_gfg :=bitsPerInputSample ;if _eg < _gfg {_gfg =_eg ;};_be =bitsPerInputSample -_gfg ;_cd =(_cd <<uint (_gfg ))|(_dg >>uint (_be ));if _gfg < bitsPerInputSample {_agg =_dg <<uint (_gfg );};_eg -=_gfg ;if _eg ==0{_cf =append (_cf ,_cd );_eg =bitsPerOutputSample ;
_cd =0;_fbe ++;};};};for _be >=bitsPerOutputSample {_db :=_be ;if _eg < _db {_db =_eg ;};_cd =(_cd <<uint (_db ))|(_agg >>uint (bitsPerInputSample -_db ));_be -=_db ;if _be > 0{_agg =_agg <<uint (_db );}else {_agg =0;};_eg -=_db ;if _eg ==0{_cf =append (_cf ,_cd );
_eg =bitsPerOutputSample ;_cd =0;_fbe ++;};};if _eg > 0&&_eg < bitsPerOutputSample {_cd <<=uint (_eg );_cf =append (_cf ,_cd );};return _cf ;};func (_aa *Reader )ReadSamples (samples []uint32 )(_fa error ){for _cb :=0;_cb < len (samples );_cb ++{samples [_cb ],_fa =_aa .ReadSample ();
if _fa !=nil {return _fa ;};};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ag []uint32 ;_agb :=bitsPerSample ;var _fb uint32 ;var _ed byte ;_fd :=0;_ab :=0;_bdb :=0;for _bdb < len (data ){if _fd > 0{_eb :=_fd ;if _agb < _eb {_eb =_agb ;
};_fb =(_fb <<uint (_eb ))|uint32 (_ed >>uint (8-_eb ));_fd -=_eb ;if _fd > 0{_ed =_ed <<uint (_eb );}else {_ed =0;};_agb -=_eb ;if _agb ==0{_ag =append (_ag ,_fb );_agb =bitsPerSample ;_fb =0;_ab ++;};}else {_ef :=data [_bdb ];_bdb ++;_gf :=8;if _agb < _gf {_gf =_agb ;
};_fd =8-_gf ;_fb =(_fb <<uint (_gf ))|uint32 (_ef >>uint (_fd ));if _gf < 8{_ed =_ef <<uint (_gf );};_agb -=_gf ;if _agb ==0{_ag =append (_ag ,_fb );_agb =bitsPerSample ;_fb =0;_ab ++;};};};for _fd >=bitsPerSample {_da :=_fd ;if _agb < _da {_da =_agb ;
};_fb =(_fb <<uint (_da ))|uint32 (_ed >>uint (8-_da ));_fd -=_da ;if _fd > 0{_ed =_ed <<uint (_da );}else {_ed =0;};_agb -=_da ;if _agb ==0{_ag =append (_ag ,_fb );_agb =bitsPerSample ;_fb =0;_ab ++;};};return _ag ;};type Writer struct{_ga _f .ImageBase ;
_eff *_ge .Writer ;_dac ,_cac int ;_fc bool ;};func (_de *Writer )WriteSamples (samples []uint32 )error {for _fcc :=0;_fcc < len (samples );_fcc ++{if _fcg :=_de .WriteSample (samples [_fcc ]);_fcg !=nil {return _fcg ;};};return nil ;};func (_aee *Writer )WriteSample (sample uint32 )error {if _ ,_cbc :=_aee ._eff .WriteBits (uint64 (sample ),_aee ._ga .BitsPerComponent );
_cbc !=nil {return _cbc ;};_aee ._cac --;if _aee ._cac ==0{_aee ._cac =_aee ._ga .ColorComponents ;_aee ._dac ++;};if _aee ._dac ==_aee ._ga .Width {if _aee ._fc {_aee ._eff .FinishByte ();};_aee ._dac =0;};return nil ;};func NewWriter (img _f .ImageBase )*Writer {return &Writer {_eff :_ge .NewWriterMSB (img .Data ),_ga :img ,_cac :img .ColorComponents ,_fc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleWriter interface{WriteSample (_eba uint32 )error ;WriteSamples (_afa []uint32 )error ;};type Reader struct{_e _f .ImageBase ;_c *_ge .Reader ;_b ,_af ,_bg int ;_bd bool ;};