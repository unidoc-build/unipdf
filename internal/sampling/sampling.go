//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_de "github.com/unidoc/unipdf/v3/internal/bitwise";_e "github.com/unidoc/unipdf/v3/internal/imageutil";_d "io";);type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_f []uint32 )error ;};func NewWriter (img _e .ImageBase )*Writer {return &Writer {_g :_de .NewWriterMSB (img .Data ),_ff :img ,_gf :img .ColorComponents ,_fef :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func NewReader (img _e .ImageBase )*Reader {return &Reader {_cb :_de .NewReader (img .Data ),_dd :img ,_b :img .ColorComponents ,_ddd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_eeb *Writer )WriteSamples (samples []uint32 )error {for _ddf :=0;_ddf < len (samples );_ddf ++{if _be :=_eeb .WriteSample (samples [_ddf ]);_be !=nil {return _be ;};};return nil ;};func (_ea *Reader )ReadSamples (samples []uint32 )(_ec error ){for _fe :=0;_fe < len (samples );_fe ++{samples [_fe ],_ec =_ea .ReadSample ();if _ec !=nil {return _ec ;};};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _bc []uint32 ;_ece :=bitsPerSample ;var _ce uint32 ;var _eg byte ;_fg :=0;_fd :=0;_ed :=0;for _ed < len (data ){if _fg > 0{_aa :=_fg ;if _ece < _aa {_aa =_ece ;};_ce =(_ce <<uint (_aa ))|uint32 (_eg >>uint (8-_aa ));_fg -=_aa ;if _fg > 0{_eg =_eg <<uint (_aa );}else {_eg =0;};_ece -=_aa ;if _ece ==0{_bc =append (_bc ,_ce );_ece =bitsPerSample ;_ce =0;_fd ++;};}else {_fee :=data [_ed ];_ed ++;_cbb :=8;if _ece < _cbb {_cbb =_ece ;};_fg =8-_cbb ;_ce =(_ce <<uint (_cbb ))|uint32 (_fee >>uint (_fg ));if _cbb < 8{_eg =_fee <<uint (_cbb );};_ece -=_cbb ;if _ece ==0{_bc =append (_bc ,_ce );_ece =bitsPerSample ;_ce =0;_fd ++;};};};for _fg >=bitsPerSample {_egc :=_fg ;if _ece < _egc {_egc =_ece ;};_ce =(_ce <<uint (_egc ))|uint32 (_eg >>uint (8-_egc ));_fg -=_egc ;if _fg > 0{_eg =_eg <<uint (_egc );}else {_eg =0;};_ece -=_egc ;if _ece ==0{_bc =append (_bc ,_ce );_ece =bitsPerSample ;_ce =0;_fd ++;};};return _bc ;};func (_gd *Writer )WriteSample (sample uint32 )error {if _ ,_gc :=_gd ._g .WriteBits (uint64 (sample ),_gd ._ff .BitsPerComponent );_gc !=nil {return _gc ;};_gd ._gf --;if _gd ._gf ==0{_gd ._gf =_gd ._ff .ColorComponents ;_gd ._bf ++;};if _gd ._bf ==_gd ._ff .Width {if _gd ._fef {_gd ._g .FinishByte ();};_gd ._bf =0;};return nil ;};type SampleWriter interface{WriteSample (_dea uint32 )error ;WriteSamples (_ag []uint32 )error ;};func (_a *Reader )ReadSample ()(uint32 ,error ){if _a ._fc ==_a ._dd .Height {return 0,_d .EOF ;};_dddb ,_df :=_a ._cb .ReadBits (byte (_a ._dd .BitsPerComponent ));if _df !=nil {return 0,_df ;};_a ._b --;if _a ._b ==0{_a ._b =_a ._dd .ColorComponents ;_a ._cf ++;};if _a ._cf ==_a ._dd .Width {if _a ._ddd {_a ._cb .ConsumeRemainingBits ();};_a ._cf =0;_a ._fc ++;};return uint32 (_dddb ),nil ;};type Reader struct{_dd _e .ImageBase ;_cb *_de .Reader ;_cf ,_fc ,_b int ;_ddd bool ;};type Writer struct{_ff _e .ImageBase ;_g *_de .Writer ;_bf ,_gf int ;_fef bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _fcc []uint32 ;_dc :=bitsPerOutputSample ;var _ee uint32 ;var _ecc uint32 ;_bcf :=0;_eee :=0;_eed :=0;for _eed < len (data ){if _bcf > 0{_eca :=_bcf ;if _dc < _eca {_eca =_dc ;};_ee =(_ee <<uint (_eca ))|(_ecc >>uint (bitsPerInputSample -_eca ));_bcf -=_eca ;if _bcf > 0{_ecc =_ecc <<uint (_eca );}else {_ecc =0;};_dc -=_eca ;if _dc ==0{_fcc =append (_fcc ,_ee );_dc =bitsPerOutputSample ;_ee =0;_eee ++;};}else {_deg :=data [_eed ];_eed ++;_fb :=bitsPerInputSample ;if _dc < _fb {_fb =_dc ;};_bcf =bitsPerInputSample -_fb ;_ee =(_ee <<uint (_fb ))|(_deg >>uint (_bcf ));if _fb < bitsPerInputSample {_ecc =_deg <<uint (_fb );};_dc -=_fb ;if _dc ==0{_fcc =append (_fcc ,_ee );_dc =bitsPerOutputSample ;_ee =0;_eee ++;};};};for _bcf >=bitsPerOutputSample {_fba :=_bcf ;if _dc < _fba {_fba =_dc ;};_ee =(_ee <<uint (_fba ))|(_ecc >>uint (bitsPerInputSample -_fba ));_bcf -=_fba ;if _bcf > 0{_ecc =_ecc <<uint (_fba );}else {_ecc =0;};_dc -=_fba ;if _dc ==0{_fcc =append (_fcc ,_ee );_dc =bitsPerOutputSample ;_ee =0;_eee ++;};};if _dc > 0&&_dc < bitsPerOutputSample {_ee <<=uint (_dc );_fcc =append (_fcc ,_ee );};return _fcc ;};