//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_ad "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/imageutil";_ab "io";);func (_ccd *Writer )WriteSample (sample uint32 )error {if _ ,_aee :=_ccd ._dbf .WriteBits (uint64 (sample ),_ccd ._fd .BitsPerComponent );_aee !=nil {return _aee ;};_ccd ._be --;if _ccd ._be ==0{_ccd ._be =_ccd ._fd .ColorComponents ;_ccd ._agb ++;};if _ccd ._agb ==_ccd ._fd .Width {if _ccd ._ce {_ccd ._dbf .FinishByte ();};_ccd ._agb =0;};return nil ;};type Writer struct{_fd _f .ImageBase ;_dbf *_ad .Writer ;_agb ,_be int ;_ce bool ;};func (_gd *Writer )WriteSamples (samples []uint32 )error {for _gae :=0;_gae < len (samples );_gae ++{if _ef :=_gd .WriteSample (samples [_gae ]);_ef !=nil {return _ef ;};};return nil ;};func NewReader (img _f .ImageBase )*Reader {return &Reader {_fa :_ad .NewReader (img .Data ),_g :img ,_ff :img .ColorComponents ,_ac :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _gb []uint32 ;_ec :=bitsPerSample ;var _db uint32 ;var _cd byte ;_gbg :=0;_fc :=0;_aa :=0;for _aa < len (data ){if _gbg > 0{_ae :=_gbg ;if _ec < _ae {_ae =_ec ;};_db =(_db <<uint (_ae ))|uint32 (_cd >>uint (8-_ae ));_gbg -=_ae ;if _gbg > 0{_cd =_cd <<uint (_ae );}else {_cd =0;};_ec -=_ae ;if _ec ==0{_gb =append (_gb ,_db );_ec =bitsPerSample ;_db =0;_fc ++;};}else {_cbg :=data [_aa ];_aa ++;_ee :=8;if _ec < _ee {_ee =_ec ;};_gbg =8-_ee ;_db =(_db <<uint (_ee ))|uint32 (_cbg >>uint (_gbg ));if _ee < 8{_cd =_cbg <<uint (_ee );};_ec -=_ee ;if _ec ==0{_gb =append (_gb ,_db );_ec =bitsPerSample ;_db =0;_fc ++;};};};for _gbg >=bitsPerSample {_dg :=_gbg ;if _ec < _dg {_dg =_ec ;};_db =(_db <<uint (_dg ))|uint32 (_cd >>uint (8-_dg ));_gbg -=_dg ;if _gbg > 0{_cd =_cd <<uint (_dg );}else {_cd =0;};_ec -=_dg ;if _ec ==0{_gb =append (_gb ,_db );_ec =bitsPerSample ;_db =0;_fc ++;};};return _gb ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _cf []uint32 ;_add :=bitsPerOutputSample ;var _cba uint32 ;var _cae uint32 ;_ed :=0;_ea :=0;_ag :=0;for _ag < len (data ){if _ed > 0{_cfb :=_ed ;if _add < _cfb {_cfb =_add ;};_cba =(_cba <<uint (_cfb ))|(_cae >>uint (bitsPerInputSample -_cfb ));_ed -=_cfb ;if _ed > 0{_cae =_cae <<uint (_cfb );}else {_cae =0;};_add -=_cfb ;if _add ==0{_cf =append (_cf ,_cba );_add =bitsPerOutputSample ;_cba =0;_ea ++;};}else {_dgg :=data [_ag ];_ag ++;_fag :=bitsPerInputSample ;if _add < _fag {_fag =_add ;};_ed =bitsPerInputSample -_fag ;_cba =(_cba <<uint (_fag ))|(_dgg >>uint (_ed ));if _fag < bitsPerInputSample {_cae =_dgg <<uint (_fag );};_add -=_fag ;if _add ==0{_cf =append (_cf ,_cba );_add =bitsPerOutputSample ;_cba =0;_ea ++;};};};for _ed >=bitsPerOutputSample {_cc :=_ed ;if _add < _cc {_cc =_add ;};_cba =(_cba <<uint (_cc ))|(_cae >>uint (bitsPerInputSample -_cc ));_ed -=_cc ;if _ed > 0{_cae =_cae <<uint (_cc );}else {_cae =0;};_add -=_cc ;if _add ==0{_cf =append (_cf ,_cba );_add =bitsPerOutputSample ;_cba =0;_ea ++;};};if _add > 0&&_add < bitsPerOutputSample {_cba <<=uint (_add );_cf =append (_cf ,_cba );};return _cf ;};func (_fe *Reader )ReadSamples (samples []uint32 )(_d error ){for _da :=0;_da < len (samples );_da ++{samples [_da ],_d =_fe .ReadSample ();if _d !=nil {return _d ;};};return nil ;};type SampleWriter interface{WriteSample (_b uint32 )error ;WriteSamples (_faf []uint32 )error ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_c []uint32 )error ;};func NewWriter (img _f .ImageBase )*Writer {return &Writer {_dbf :_ad .NewWriterMSB (img .Data ),_fd :img ,_be :img .ColorComponents ,_ce :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type Reader struct{_g _f .ImageBase ;_fa *_ad .Reader ;_ca ,_gf ,_ff int ;_ac bool ;};func (_ga *Reader )ReadSample ()(uint32 ,error ){if _ga ._gf ==_ga ._g .Height {return 0,_ab .EOF ;};_cb ,_e :=_ga ._fa .ReadBits (byte (_ga ._g .BitsPerComponent ));if _e !=nil {return 0,_e ;};_ga ._ff --;if _ga ._ff ==0{_ga ._ff =_ga ._g .ColorComponents ;_ga ._ca ++;};if _ga ._ca ==_ga ._g .Width {if _ga ._ac {_ga ._fa .ConsumeRemainingBits ();};_ga ._ca =0;_ga ._gf ++;};return uint32 (_cb ),nil ;};