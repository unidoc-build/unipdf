//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_f "github.com/unidoc/unipdf/v3/internal/bitwise";_ea "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);func NewReader (img _ea .ImageBase )*Reader {return &Reader {_d :_f .NewReader (img .Data ),_ec :img ,_dc :img .ColorComponents ,_ag :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Writer struct{_faa _ea .ImageBase ;_cgaf *_f .Writer ;_gc ,_bec int ;_ed bool ;};type Reader struct{_ec _ea .ImageBase ;_d *_f .Reader ;_ba ,_ef ,_dc int ;_ag bool ;};func (_ggf *Writer )WriteSamples (samples []uint32 )error {for _dgc :=0;_dgc < len (samples );
_dgc ++{if _gbc :=_ggf .WriteSample (samples [_dgc ]);_gbc !=nil {return _gbc ;};};return nil ;};func NewWriter (img _ea .ImageBase )*Writer {return &Writer {_cgaf :_f .NewWriterMSB (img .Data ),_faa :img ,_bec :img .ColorComponents ,_ed :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleWriter interface{WriteSample (_bc uint32 )error ;WriteSamples (_ab []uint32 )error ;};func (_fc *Reader )ReadSample ()(uint32 ,error ){if _fc ._ef ==_fc ._ec .Height {return 0,_e .EOF ;};_ad ,_fg :=_fc ._d .ReadBits (byte (_fc ._ec .BitsPerComponent ));
if _fg !=nil {return 0,_fg ;};_fc ._dc --;if _fc ._dc ==0{_fc ._dc =_fc ._ec .ColorComponents ;_fc ._ba ++;};if _fc ._ba ==_fc ._ec .Width {if _fc ._ag {_fc ._d .ConsumeRemainingBits ();};_fc ._ba =0;_fc ._ef ++;};return uint32 (_ad ),nil ;};func (_g *Reader )ReadSamples (samples []uint32 )(_gd error ){for _fa :=0;
_fa < len (samples );_fa ++{samples [_fa ],_gd =_g .ReadSample ();if _gd !=nil {return _gd ;};};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _cb []uint32 ;_aa :=bitsPerOutputSample ;var _be uint32 ;
var _fge uint32 ;_fcg :=0;_bef :=0;_adc :=0;for _adc < len (data ){if _fcg > 0{_cg :=_fcg ;if _aa < _cg {_cg =_aa ;};_be =(_be <<uint (_cg ))|(_fge >>uint (bitsPerInputSample -_cg ));_fcg -=_cg ;if _fcg > 0{_fge =_fge <<uint (_cg );}else {_fge =0;};_aa -=_cg ;
if _aa ==0{_cb =append (_cb ,_be );_aa =bitsPerOutputSample ;_be =0;_bef ++;};}else {_cc :=data [_adc ];_adc ++;_cgf :=bitsPerInputSample ;if _aa < _cgf {_cgf =_aa ;};_fcg =bitsPerInputSample -_cgf ;_be =(_be <<uint (_cgf ))|(_cc >>uint (_fcg ));if _cgf < bitsPerInputSample {_fge =_cc <<uint (_cgf );
};_aa -=_cgf ;if _aa ==0{_cb =append (_cb ,_be );_aa =bitsPerOutputSample ;_be =0;_bef ++;};};};for _fcg >=bitsPerOutputSample {_cga :=_fcg ;if _aa < _cga {_cga =_aa ;};_be =(_be <<uint (_cga ))|(_fge >>uint (bitsPerInputSample -_cga ));_fcg -=_cga ;if _fcg > 0{_fge =_fge <<uint (_cga );
}else {_fge =0;};_aa -=_cga ;if _aa ==0{_cb =append (_cb ,_be );_aa =bitsPerOutputSample ;_be =0;_bef ++;};};if _aa > 0&&_aa < bitsPerOutputSample {_be <<=uint (_aa );_cb =append (_cb ,_be );};return _cb ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ade []uint32 ;
_gb :=bitsPerSample ;var _fgg uint32 ;var _c byte ;_eff :=0;_efg :=0;_gg :=0;for _gg < len (data ){if _eff > 0{_dg :=_eff ;if _gb < _dg {_dg =_gb ;};_fgg =(_fgg <<uint (_dg ))|uint32 (_c >>uint (8-_dg ));_eff -=_dg ;if _eff > 0{_c =_c <<uint (_dg );}else {_c =0;
};_gb -=_dg ;if _gb ==0{_ade =append (_ade ,_fgg );_gb =bitsPerSample ;_fgg =0;_efg ++;};}else {_ca :=data [_gg ];_gg ++;_df :=8;if _gb < _df {_df =_gb ;};_eff =8-_df ;_fgg =(_fgg <<uint (_df ))|uint32 (_ca >>uint (_eff ));if _df < 8{_c =_ca <<uint (_df );
};_gb -=_df ;if _gb ==0{_ade =append (_ade ,_fgg );_gb =bitsPerSample ;_fgg =0;_efg ++;};};};for _eff >=bitsPerSample {_ff :=_eff ;if _gb < _ff {_ff =_gb ;};_fgg =(_fgg <<uint (_ff ))|uint32 (_c >>uint (8-_ff ));_eff -=_ff ;if _eff > 0{_c =_c <<uint (_ff );
}else {_c =0;};_gb -=_ff ;if _gb ==0{_ade =append (_ade ,_fgg );_gb =bitsPerSample ;_fgg =0;_efg ++;};};return _ade ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_b []uint32 )error ;};func (_cd *Writer )WriteSample (sample uint32 )error {if _ ,_fba :=_cd ._cgaf .WriteBits (uint64 (sample ),_cd ._faa .BitsPerComponent );
_fba !=nil {return _fba ;};_cd ._bec --;if _cd ._bec ==0{_cd ._bec =_cd ._faa .ColorComponents ;_cd ._gc ++;};if _cd ._gc ==_cd ._faa .Width {if _cd ._ed {_cd ._cgaf .FinishByte ();};_cd ._gc =0;};return nil ;};