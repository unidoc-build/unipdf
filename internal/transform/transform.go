//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_cf "github.com/unidoc/unipdf/v3/common";_c "math";);const _cab =1e9;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func RotationMatrix (angle float64 )Matrix {_eaa :=_c .Cos (angle );_da :=_c .Sin (angle );
return NewMatrix (_eaa ,_da ,-_da ,_eaa ,0,0);};type Point struct{X float64 ;Y float64 ;};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};const _ca =1e-10;func (_adg Point )Distance (b Point )float64 {return _c .Hypot (_adg .X -b .X ,_adg .Y -b .Y )};func (_gg Matrix )Unrealistic ()bool {_eg ,_fad ,_egc ,_dcb :=_c .Abs (_gg [0]),_c .Abs (_gg [1]),_c .Abs (_gg [3]),_c .Abs (_gg [4]);_baa :=_eg > _ad &&_dcb > _ad ;
_cfe :=_fad > _ad &&_egc > _ad ;return !(_baa ||_cfe );};type Matrix [9]float64 ;func (_bc Matrix )Translation ()(float64 ,float64 ){return _bc [6],_bc [7]};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_dg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_dg .clampRange ();
return _dg ;};func (_b Matrix )Rotate (theta float64 )Matrix {return _b .Mult (RotationMatrix (theta ))};func (_gge Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gge .X +t *b .X ,Y :(1-t )*_gge .Y +t *b .Y };};func (_faa *Point )Set (x ,y float64 ){_faa .X ,_faa .Y =x ,y };
func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_dac Matrix )Scale (xScale ,yScale float64 )Matrix {return _dac .Mult (ScaleMatrix (xScale ,yScale ));};func (_dc *Matrix )Concat (b Matrix ){*_dc =Matrix {b [0]*_dc [0]+b [1]*_dc [3],b [0]*_dc [1]+b [1]*_dc [4],0,b [3]*_dc [0]+b [4]*_dc [3],b [3]*_dc [1]+b [4]*_dc [4],0,b [6]*_dc [0]+b [7]*_dc [3]+_dc [6],b [6]*_dc [1]+b [7]*_dc [4]+_dc [7],1};
_dc .clampRange ();};func (_gf Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fe :=x *_gf [0]+y *_gf [3]+_gf [6];_gd :=x *_gf [1]+y *_gf [4]+_gf [7];return _fe ,_gd ;};func (_df Point )Rotate (theta float64 )Point {_ebe :=_c .Hypot (_df .X ,_df .Y );
_abb :=_c .Atan2 (_df .Y ,_df .X );_af ,_dgb :=_c .Sincos (_abb +theta /180.0*_c .Pi );return Point {_ebe *_dgb ,_ebe *_af };};func (_a Matrix )Inverse ()(Matrix ,bool ){_cc ,_eb :=_a [0],_a [1];_ab ,_ddb :=_a [3],_a [4];_db ,_ce :=_a [6],_a [7];_ge :=_cc *_ddb -_eb *_ab ;
if _c .Abs (_ge )< _bfc {return Matrix {},false ;};_fbg ,_bb :=_ddb /_ge ,-_eb /_ge ;_eac ,_ba :=-_ab /_ge ,_cc /_ge ;_bad :=-(_fbg *_db +_eac *_ce );_cb :=-(_bb *_db +_ba *_ce );return NewMatrix (_fbg ,_bb ,_eac ,_ba ,_bad ,_cb ),true ;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_fc Matrix )String ()string {_de ,_ec ,_cfd ,_eag ,_fa ,_g :=_fc [0],_fc [1],_fc [3],_fc [4],_fc [6],_fc [7];return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_de ,_ec ,_cfd ,_eag ,_fa ,_g );
};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};const _ad =1e-6;func (_cg *Matrix )clampRange (){for _ccc ,_cd :=range _cg {if _cd > _cab {_cf .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cd ,_cab );
_cg [_ccc ]=_cab ;}else if _cd < -_cab {_cf .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cd ,-_cab );_cg [_ccc ]=-_cab ;};};};func (_gc Matrix )Translate (tx ,ty float64 )Matrix {return _gc .Mult (TranslationMatrix (tx ,ty ))};
func (_ea Matrix )Round (precision float64 )Matrix {for _d :=range _ea {_ea [_d ]=_c .Round (_ea [_d ]/precision )*precision ;};return _ea ;};func (_gb *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ccd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_gb .transformByMatrix (_ccd );
};func (_dag Matrix )Angle ()float64 {_fbd :=_c .Atan2 (-_dag [1],_dag [0]);if _fbd < 0.0{_fbd +=2*_c .Pi ;};return _fbd /_c .Pi *180.0;};func (_bf *Matrix )Clone ()Matrix {return NewMatrix (_bf [0],_bf [1],_bf [3],_bf [4],_bf [6],_bf [7])};func (_ff Matrix )Identity ()bool {return _ff [0]==1&&_ff [1]==0&&_ff [2]==0&&_ff [3]==0&&_ff [4]==1&&_ff [5]==0&&_ff [6]==0&&_ff [7]==0&&_ff [8]==1;
};func (_cdb Point )Displace (delta Point )Point {return Point {_cdb .X +delta .X ,_cdb .Y +delta .Y }};func (_dd Matrix )ScalingFactorY ()float64 {return _c .Hypot (_dd [3],_dd [4])};func (_fd *Matrix )Shear (x ,y float64 ){_fd .Concat (ShearMatrix (x ,y ))};
func (_fae Matrix )ScalingFactorX ()float64 {return _c .Hypot (_fae [0],_fae [1])};const _bfc =1.0e-6;func (_fg Matrix )Singular ()bool {return _c .Abs (_fg [0]*_fg [4]-_fg [1]*_fg [3])< _ca };func (_ggeg Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ggeg .X ,_ggeg .Y );
};func (_ef Matrix )Mult (b Matrix )Matrix {_ef .Concat (b );return _ef };func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_ged *Point )transformByMatrix (_dec Matrix ){_ged .X ,_ged .Y =_dec .Transform (_ged .X ,_ged .Y )};
func (_fb *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fb [0],_fb [1]=a ,b ;_fb [3],_fb [4]=c ,d ;_fb [6],_fb [7]=tx ,ty ;_fb .clampRange ();};