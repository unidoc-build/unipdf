//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_a "github.com/unidoc/unipdf/v3/common";_gd "math";);func (_gb *Matrix )Shear (x ,y float64 ){_gb .Concat (ShearMatrix (x ,y ))};func (_c Matrix )Round (precision float64 )Matrix {for _gdd :=range _c {_c [_gdd ]=_gd .Round (_c [_gdd ]/precision )*precision ;
};return _c ;};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_fa :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_fa .clampRange ();return _fa ;};func (_af Matrix )Rotate (theta float64 )Matrix {return _af .Mult (RotationMatrix (theta ))};func (_ega Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ega .X ,_ega .Y );
};type Matrix [9]float64 ;func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_eb Matrix )ScalingFactorX ()float64 {return _gd .Hypot (_eb [0],_eb [1])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_baa Matrix )Scale (xScale ,yScale float64 )Matrix {return _baa .Mult (ScaleMatrix (xScale ,yScale ));
};const _db =1e-10;func (_fdb *Matrix )Clone ()Matrix {return NewMatrix (_fdb [0],_fdb [1],_fdb [3],_fdb [4],_fdb [6],_fdb [7]);};type Point struct{X float64 ;Y float64 ;};func (_fgde Point )Rotate (theta float64 )Point {_bbg :=_gd .Hypot (_fgde .X ,_fgde .Y );
_acb :=_gd .Atan2 (_fgde .Y ,_fgde .X );_ec ,_cc :=_gd .Sincos (_acb +theta /180.0*_gd .Pi );return Point {_bbg *_cc ,_bbg *_ec };};func RotationMatrix (angle float64 )Matrix {_ba :=_gd .Cos (angle );_fd :=_gd .Sin (angle );return NewMatrix (_ba ,_fd ,-_fd ,_ba ,0,0);
};func (_e Matrix )String ()string {_cg ,_eg ,_fg ,_fc ,_bg ,_d :=_e [0],_e [1],_e [3],_e [4],_e [6],_e [7];return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_cg ,_eg ,_fg ,_fc ,_bg ,_d );
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_gba Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ce :=x *_gba [0]+y *_gba [3]+_gba [6];_fgd :=x *_gba [1]+y *_gba [4]+_gba [7];return _ce ,_fgd ;};const _gfd =1.0e-6;func (_ea Matrix )Inverse ()(Matrix ,bool ){_eaa ,_afa :=_ea [0],_ea [1];
_gf ,_ab :=_ea [3],_ea [4];_aa ,_faa :=_ea [6],_ea [7];_ebg :=_eaa *_ab -_afa *_gf ;if _gd .Abs (_ebg )< _gfd {return Matrix {},false ;};_bdd ,_ad :=_ab /_ebg ,-_afa /_ebg ;_adf ,_gg :=-_gf /_ebg ,_eaa /_ebg ;_faf :=-(_bdd *_aa +_adf *_faa );_cea :=-(_ad *_aa +_gg *_faa );
return NewMatrix (_bdd ,_ad ,_adf ,_gg ,_faf ,_cea ),true ;};func (_bb *Matrix )clampRange (){for _ee ,_eae :=range _bb {if _eae > _dag {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_eae ,_dag );_bb [_ee ]=_dag ;
}else if _eae < -_dag {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_eae ,-_dag );_bb [_ee ]=-_dag ;};};};func (_da *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_da [0],_da [1]=a ,b ;_da [3],_da [4]=c ,d ;
_da [6],_da [7]=tx ,ty ;_da .clampRange ();};func (_bc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_acf :=NewMatrix (a ,b ,c ,d ,tx ,ty );_bc .transformByMatrix (_acf );};func (_bd Matrix )Translation ()(float64 ,float64 ){return _bd [6],_bd [7]};func (_f Matrix )Identity ()bool {return _f [0]==1&&_f [1]==0&&_f [2]==0&&_f [3]==0&&_f [4]==1&&_f [5]==0&&_f [6]==0&&_f [7]==0&&_f [8]==1;
};const _dag =1e9;func (_gdae Point )Displace (delta Point )Point {return Point {_gdae .X +delta .X ,_gdae .Y +delta .Y }};func (_dg *Point )Set (x ,y float64 ){_dg .X ,_dg .Y =x ,y };func (_cbc Matrix )ScalingFactorY ()float64 {return _gd .Hypot (_cbc [3],_cbc [4])};
func (_gda Matrix )Unrealistic ()bool {_eab ,_ff ,_bdc ,_feg :=_gd .Abs (_gda [0]),_gd .Abs (_gda [1]),_gd .Abs (_gda [3]),_gd .Abs (_gda [4]);_ace :=_eab > _fdc &&_feg > _fdc ;_de :=_ff > _fdc &&_bdc > _fdc ;return !(_ace ||_de );};func (_ac Matrix )Mult (b Matrix )Matrix {_ac .Concat (b );
return _ac };func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_gff Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gff .X +t *b .X ,Y :(1-t )*_gff .Y +t *b .Y };};func (_geb Matrix )Angle ()float64 {_fe :=_gd .Atan2 (-_geb [1],_geb [0]);
if _fe < 0.0{_fe +=2*_gd .Pi ;};return _fe /_gd .Pi *180.0;};func (_bddd *Point )transformByMatrix (_cbf Matrix ){_bddd .X ,_bddd .Y =_cbf .Transform (_bddd .X ,_bddd .Y );};func (_ge Matrix )Translate (tx ,ty float64 )Matrix {return _ge .Mult (TranslationMatrix (tx ,ty ))};
func (_cb Matrix )Singular ()bool {return _gd .Abs (_cb [0]*_cb [4]-_cb [1]*_cb [3])< _db };func (_fb Point )Distance (b Point )float64 {return _gd .Hypot (_fb .X -b .X ,_fb .Y -b .Y )};func (_dd *Matrix )Concat (b Matrix ){*_dd =Matrix {b [0]*_dd [0]+b [1]*_dd [3],b [0]*_dd [1]+b [1]*_dd [4],0,b [3]*_dd [0]+b [4]*_dd [3],b [3]*_dd [1]+b [4]*_dd [4],0,b [6]*_dd [0]+b [7]*_dd [3]+_dd [6],b [6]*_dd [1]+b [7]*_dd [4]+_dd [7],1};
_dd .clampRange ();};const _fdc =1e-6;