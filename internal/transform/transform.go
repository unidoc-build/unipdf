//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_d "fmt";_a "github.com/unidoc/unipdf/v3/common";_eg "math";);func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ff *Matrix )Concat (b Matrix ){*_ff =Matrix {b [0]*_ff [0]+b [1]*_ff [3],b [0]*_ff [1]+b [1]*_ff [4],0,b [3]*_ff [0]+b [4]*_ff [3],b [3]*_ff [1]+b [4]*_ff [4],0,b [6]*_ff [0]+b [7]*_ff [3]+_ff [6],b [6]*_ff [1]+b [7]*_ff [4]+_ff [7],1};
_ff .clampRange ();};func (_ca Matrix )Transform (x ,y float64 )(float64 ,float64 ){_aa :=x *_ca [0]+y *_ca [3]+_ca [6];_cb :=x *_ca [1]+y *_ca [4]+_ca [7];return _aa ,_cb ;};func (_ab Matrix )Round (precision float64 )Matrix {for _eb :=range _ab {_ab [_eb ]=_eg .Round (_ab [_eb ]/precision )*precision ;
};return _ab ;};func (_cc Matrix )Singular ()bool {return _eg .Abs (_cc [0]*_cc [4]-_cc [1]*_cc [3])< _fce };func (_fgb Matrix )Angle ()float64 {_dcg :=_eg .Atan2 (-_fgb [1],_fgb [0]);if _dcg < 0.0{_dcg +=2*_eg .Pi ;};return _dcg /_eg .Pi *180.0;};func (_fg Matrix )ScalingFactorY ()float64 {return _eg .Hypot (_fg [3],_fg [4])};
func (_dbb Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_dbb .X +t *b .X ,Y :(1-t )*_dbb .Y +t *b .Y };};func (_fc *Matrix )Shear (x ,y float64 ){_fc .Concat (ShearMatrix (x ,y ))};func (_be Matrix )Scale (xScale ,yScale float64 )Matrix {return _be .Mult (ScaleMatrix (xScale ,yScale ))};
func (_ag Matrix )Translate (tx ,ty float64 )Matrix {return _ag .Mult (TranslationMatrix (tx ,ty ))};func RotationMatrix (angle float64 )Matrix {_cg :=_eg .Cos (angle );_g :=_eg .Sin (angle );return NewMatrix (_cg ,_g ,-_g ,_cg ,0,0);};func (_ed *Matrix )Clone ()Matrix {return NewMatrix (_ed [0],_ed [1],_ed [3],_ed [4],_ed [6],_ed [7])};
func (_bc Matrix )String ()string {_ba ,_cga ,_bag ,_dc ,_dd ,_f :=_bc [0],_bc [1],_bc [3],_bc [4],_bc [6],_bc [7];return _d .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ba ,_cga ,_bag ,_dc ,_dd ,_f );
};func (_df Point )Distance (b Point )float64 {return _eg .Hypot (_df .X -b .X ,_df .Y -b .Y )};const _ee =1.0e-6;func (_cad Matrix )ScalingFactorX ()float64 {return _eg .Hypot (_cad [0],_cad [1])};func (_gd Matrix )Mult (b Matrix )Matrix {_gd .Concat (b );
return _gd };func (_gge Point )String ()string {return _d .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gge .X ,_gge .Y );};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_bda Point )Displace (delta Point )Point {return Point {_bda .X +delta .X ,_bda .Y +delta .Y }};
type Point struct{X float64 ;Y float64 ;};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_edc *Matrix )clampRange (){for _bd ,_ddg :=range _edc {if _ddg > _da {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ddg ,_da );
_edc [_bd ]=_da ;}else if _ddg < -_da {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ddg ,-_da );_edc [_bd ]=-_da ;};};};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_ebb *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ebb [0],_ebb [1]=a ,b ;_ebb [3],_ebb [4]=c ,d ;_ebb [6],_ebb [7]=tx ,ty ;_ebb .clampRange ();};func (_dea *Point )transformByMatrix (_bcd Matrix ){_dea .X ,_dea .Y =_bcd .Transform (_dea .X ,_dea .Y )};
func (_gg Matrix )Unrealistic ()bool {_fgd ,_bf ,_ggf ,_cba :=_eg .Abs (_gg [0]),_eg .Abs (_gg [1]),_eg .Abs (_gg [3]),_eg .Abs (_gg [4]);_af :=_fgd > _fda &&_cba > _fda ;_afb :=_bf > _fda &&_ggf > _fda ;return !(_af ||_afb );};func (_fd Matrix )Inverse ()(Matrix ,bool ){_ef ,_dca :=_fd [0],_fd [1];
_aca ,_ccg :=_fd [3],_fd [4];_ccge ,_abf :=_fd [6],_fd [7];_cbe :=_ef *_ccg -_dca *_aca ;if _eg .Abs (_cbe )< _ee {return Matrix {},false ;};_gc ,_de :=_ccg /_cbe ,-_dca /_cbe ;_ad ,_bb :=-_aca /_cbe ,_ef /_cbe ;_fdf :=-(_gc *_ccge +_ad *_abf );_fe :=-(_de *_ccge +_bb *_abf );
return NewMatrix (_gc ,_de ,_ad ,_bb ,_fdf ,_fe ),true ;};const _da =1e9;func (_db Matrix )Rotate (theta float64 )Matrix {return _db .Mult (RotationMatrix (theta ))};func (_abg Point )Rotate (theta float64 )Point {_ffc :=_eg .Hypot (_abg .X ,_abg .Y );
_ebf :=_eg .Atan2 (_abg .Y ,_abg .X );_deb ,_ggc :=_eg .Sincos (_ebf +theta /180.0*_eg .Pi );return Point {_ffc *_ggc ,_ffc *_deb };};type Matrix [9]float64 ;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_gga *Point )Set (x ,y float64 ){_gga .X ,_gga .Y =x ,y };
func (_dg *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_dg .transformByMatrix (_bg );};const _fce =1e-10;func (_ac Matrix )Translation ()(float64 ,float64 ){return _ac [6],_ac [7]};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_b :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_b .clampRange ();return _b ;};func (_c Matrix )Identity ()bool {return _c [0]==1&&_c [1]==0&&_c [2]==0&&_c [3]==0&&_c [4]==1&&_c [5]==0&&_c [6]==0&&_c [7]==0&&_c [8]==1;};const _fda =1e-6;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
