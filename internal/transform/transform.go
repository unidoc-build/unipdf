//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_fa "fmt";_faf "github.com/unidoc/unipdf/v3/common";_fd "math";);func (_fafc Point )Displace (delta Point )Point {return Point {_fafc .X +delta .X ,_fafc .Y +delta .Y }};func (_fg Matrix )Unrealistic ()bool {_db ,_gaf ,_fgf ,_fc :=_fd .Abs (_fg [0]),_fd .Abs (_fg [1]),_fd .Abs (_fg [3]),_fd .Abs (_fg [4]);_dgf :=_db > _bfb &&_fc > _bfb ;_eaf :=_gaf > _bfb &&_fgf > _bfb ;return !(_dgf ||_eaf );};func (_ce Matrix )Inverse ()(Matrix ,bool ){_ed ,_dga :=_ce [0],_ce [1];_bg ,_eac :=_ce [3],_ce [4];_ecf ,_fb :=_ce [6],_ce [7];_gde :=_ed *_eac -_dga *_bg ;if _fd .Abs (_gde )< _da {return Matrix {},false ;};_bf ,_gc :=_eac /_gde ,-_dga /_gde ;_fbf ,_cd :=-_bg /_gde ,_ed /_gde ;_bca :=-(_bf *_ecf +_fbf *_fb );_fbg :=-(_gc *_ecf +_cd *_fb );return NewMatrix (_bf ,_gc ,_fbf ,_cd ,_bca ,_fbg ),true ;};func (_be Matrix )ScalingFactorX ()float64 {return _fd .Hypot (_be [0],_be [1])};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_gf Matrix )Transform (x ,y float64 )(float64 ,float64 ){_geg :=x *_gf [0]+y *_gf [3]+_gf [6];_ece :=x *_gf [1]+y *_gf [4]+_gf [7];return _geg ,_ece ;};func (_fdaf *Matrix )Clone ()Matrix {return NewMatrix (_fdaf [0],_fdaf [1],_fdaf [3],_fdaf [4],_fdaf [6],_fdaf [7]);};const _ebf =1e9;func (_gdc Matrix )Translation ()(float64 ,float64 ){return _gdc [6],_gdc [7]};func (_cf Matrix )Mult (b Matrix )Matrix {_cf .Concat (b );return _cf };func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_de Matrix )Identity ()bool {return _de [0]==1&&_de [1]==0&&_de [2]==0&&_de [3]==0&&_de [4]==1&&_de [5]==0&&_de [6]==0&&_de [7]==0&&_de [8]==1;};const _da =1.0e-6;func (_gd Matrix )String ()string {_c ,_ge ,_dcg ,_gee ,_eb ,_ga :=_gd [0],_gd [1],_gd [3],_gd [4],_gd [6],_gd [7];return _fa .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_c ,_ge ,_dcg ,_gee ,_eb ,_ga );};func (_fdd *Matrix )clampRange (){for _ca ,_dgg :=range _fdd {if _dgg > _ebf {_faf .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dgg ,_ebf );_fdd [_ca ]=_ebf ;}else if _dgg < -_ebf {_faf .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dgg ,-_ebf );_fdd [_ca ]=-_ebf ;};};};const _bfb =1e-6;func (_df *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ccg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_df .transformByMatrix (_ccg );};func (_bcg *Point )Set (x ,y float64 ){_bcg .X ,_bcg .Y =x ,y };func (_a Matrix )Scale (xScale ,yScale float64 )Matrix {return _a .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_bb Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_bb .X +t *b .X ,Y :(1-t )*_bb .Y +t *b .Y };};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_gb *Matrix )Concat (b Matrix ){*_gb =Matrix {b [0]*_gb [0]+b [1]*_gb [3],b [0]*_gb [1]+b [1]*_gb [4],0,b [3]*_gb [0]+b [4]*_gb [3],b [3]*_gb [1]+b [4]*_gb [4],0,b [6]*_gb [0]+b [7]*_gb [3]+_gb [6],b [6]*_gb [1]+b [7]*_gb [4]+_gb [7],1};_gb .clampRange ();};func (_cc Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_cc [0],_cc [1],_cc [3],_cc [4],_cc [6]+tx ,_cc [7]+ty );};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_b :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_b .clampRange ();return _b ;};const _eaa =1e-10;func (_bgg Point )String ()string {return _fa .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_bgg .X ,_bgg .Y );};func (_d Matrix )Round (precision float64 )Matrix {for _g :=range _d {_d [_g ]=_fd .Round (_d [_g ]/precision )*precision ;};return _d ;};func (_ae Point )Rotate (theta float64 )Point {_fgfa :=_fd .Hypot (_ae .X ,_ae .Y );_ac :=_fd .Atan2 (_ae .Y ,_ae .X );_fae ,_fe :=_fd .Sincos (_ac +theta /180.0*_fd .Pi );return Point {_fgfa *_fe ,_fgfa *_fae };};func (_ea *Matrix )Shear (x ,y float64 ){_ea .Concat (ShearMatrix (x ,y ))};func (_ef Matrix )Rotate (theta float64 )Matrix {_bc ,_fda :=_fd .Sincos (theta /180.0*_fd .Pi );return _ef .Mult (NewMatrix (_fda ,-_bc ,_bc ,_fda ,0,0));};func (_ec *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ec [0],_ec [1]=a ,b ;_ec [3],_ec [4]=c ,d ;_ec [6],_ec [7]=tx ,ty ;_ec .clampRange ();};func (_gab Matrix )Singular ()bool {return _fd .Abs (_gab [0]*_gab [4]-_gab [1]*_gab [3])< _eaa };type Matrix [9]float64 ;func (_ebg Matrix )ScalingFactorY ()float64 {return _fd .Hypot (_ebg [3],_ebg [4])};func (_bedg Point )Distance (b Point )float64 {return _fd .Hypot (_bedg .X -b .X ,_bedg .Y -b .Y )};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_dg Matrix )Angle ()float64 {_bed :=_fd .Atan2 (-_dg [1],_dg [0]);if _bed < 0.0{_bed +=2*_fd .Pi ;};return _bed /_fd .Pi *180.0;};func (_aeb *Point )transformByMatrix (_ebb Matrix ){_aeb .X ,_aeb .Y =_ebb .Transform (_aeb .X ,_aeb .Y )};func RotationMatrix (angle float64 )Matrix {_e :=_fd .Cos (angle );_dc :=_fd .Sin (angle );return NewMatrix (_e ,_dc ,-_dc ,_e ,0,0);};type Point struct{X float64 ;Y float64 ;};