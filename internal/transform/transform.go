//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_db "github.com/unidoc/unipdf/v3/common";_fg "math";);func (_dfe Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_dfe .X ,_dfe .Y );};func (_de Matrix )Singular ()bool {return _fg .Abs (_de [0]*_de [4]-_de [1]*_de [3])< _cea };const _cc =1e9;func (_be Matrix )Scale (xScale ,yScale float64 )Matrix {return _be .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_aa Matrix )Angle ()float64 {_fgd :=_fg .Atan2 (-_aa [1],_aa [0]);if _fgd < 0.0{_fgd +=2*_fg .Pi ;};return _fgd /_fg .Pi *180.0;};type Point struct{X float64 ;Y float64 ;};const _cea =1e-10;func (_gef Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gef .X +t *b .X ,Y :(1-t )*_gef .Y +t *b .Y };};func (_ac *Matrix )Clone ()Matrix {return NewMatrix (_ac [0],_ac [1],_ac [3],_ac [4],_ac [6],_ac [7])};type Matrix [9]float64 ;const _bff =1.0e-6;func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_c :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_c .clampRange ();return _c ;};func (_ge Matrix )ScalingFactorX ()float64 {return _fg .Hypot (_ge [0],_ge [1])};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_gb *Point )Set (x ,y float64 ){_gb .X ,_gb .Y =x ,y };func (_abd *Matrix )Shear (x ,y float64 ){_abd .Concat (ShearMatrix (x ,y ))};func (_fc Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_fc [0],_fc [1],_fc [3],_fc [4],_fc [6]+tx ,_fc [7]+ty );};func (_fe Matrix )Rotate (theta float64 )Matrix {_gc ,_fa :=_fg .Sincos (theta /180.0*_fg .Pi );return _fe .Mult (NewMatrix (_fa ,-_gc ,_gc ,_fa ,0,0));};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_fb *Matrix )clampRange (){for _gad ,_agg :=range _fb {if _agg > _cc {_db .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_agg ,_cc );_fb [_gad ]=_cc ;}else if _agg < -_cc {_db .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_agg ,-_cc );_fb [_gad ]=-_cc ;};};};func (_deb Matrix )ScalingFactorY ()float64 {return _fg .Hypot (_deb [3],_deb [4])};func (_ebb Matrix )Inverse ()(Matrix ,bool ){_af ,_ba :=_ebb [0],_ebb [1];_bd ,_ff :=_ebb [3],_ebb [4];_dbf ,_aad :=_ebb [6],_ebb [7];_gg :=_af *_ff -_ba *_bd ;if _fg .Abs (_gg )< _bff {return Matrix {},false ;};_cd ,_bb :=_ff /_gg ,-_ba /_gg ;_baf ,_df :=-_bd /_gg ,_af /_gg ;_cg :=-(_cd *_dbf +_baf *_aad );_dba :=-(_bb *_dbf +_df *_aad );return NewMatrix (_cd ,_bb ,_baf ,_df ,_cg ,_dba ),true ;};func RotationMatrix (angle float64 )Matrix {_g :=_fg .Cos (angle );_b :=_fg .Sin (angle );return NewMatrix (_g ,_b ,-_b ,_g ,0,0);};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_dbg Matrix )String ()string {_ga ,_ec ,_fgf ,_ab ,_bf ,_ca :=_dbg [0],_dbg [1],_dbg [3],_dbg [4],_dbg [6],_dbg [7];return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ga ,_ec ,_fgf ,_ab ,_bf ,_ca );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ccd Point )Rotate (theta float64 )Point {_ged :=_fg .Hypot (_ccd .X ,_ccd .Y );_fd :=_fg .Atan2 (_ccd .Y ,_ccd .X );_cce ,_fce :=_fg .Sincos (_fd +theta /180.0*_fg .Pi );return Point {_ged *_fce ,_ged *_cce };};func (_cgf Point )Displace (delta Point )Point {return Point {_cgf .X +delta .X ,_cgf .Y +delta .Y }};func (_ccdb *Point )transformByMatrix (_gec Matrix ){_ccdb .X ,_ccdb .Y =_gec .Transform (_ccdb .X ,_ccdb .Y );};func (_bfg Matrix )Mult (b Matrix )Matrix {_bfg .Concat (b );return _bfg };func (_ag Matrix )Identity ()bool {return _ag [0]==1&&_ag [1]==0&&_ag [2]==0&&_ag [3]==0&&_ag [4]==1&&_ag [5]==0&&_ag [6]==0&&_ag [7]==0&&_ag [8]==1;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_cdc Matrix )Unrealistic ()bool {_dfc ,_gac ,_egc ,_dbd :=_fg .Abs (_cdc [0]),_fg .Abs (_cdc [1]),_fg .Abs (_cdc [3]),_fg .Abs (_cdc [4]);_bg :=_dfc > _fcg &&_dbd > _fcg ;_ggg :=_gac > _fcg &&_egc > _fcg ;return !(_bg ||_ggg );};func (_bfb *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_bfb [0],_bfb [1]=a ,b ;_bfb [3],_bfb [4]=c ,d ;_bfb [6],_bfb [7]=tx ,ty ;_bfb .clampRange ();};func (_gf Point )Distance (b Point )float64 {return _fg .Hypot (_gf .X -b .X ,_gf .Y -b .Y )};const _fcg =1e-6;func (_ce Matrix )Transform (x ,y float64 )(float64 ,float64 ){_eb :=x *_ce [0]+y *_ce [3]+_ce [6];_da :=x *_ce [1]+y *_ce [4]+_ce [7];return _eb ,_da ;};func (_eg Matrix )Translation ()(float64 ,float64 ){return _eg [6],_eg [7]};func (_bfe *Matrix )Concat (b Matrix ){*_bfe =Matrix {b [0]*_bfe [0]+b [1]*_bfe [3],b [0]*_bfe [1]+b [1]*_bfe [4],0,b [3]*_bfe [0]+b [4]*_bfe [3],b [3]*_bfe [1]+b [4]*_bfe [4],0,b [6]*_bfe [0]+b [7]*_bfe [3]+_bfe [6],b [6]*_bfe [1]+b [7]*_bfe [4]+_bfe [7],1};_bfe .clampRange ();};func (_ggc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fbd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ggc .transformByMatrix (_fbd );};func (_a Matrix )Round (precision float64 )Matrix {for _e :=range _a {_a [_e ]=_fg .Round (_a [_e ]/precision )*precision ;};return _a ;};