//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_b "fmt";_g "github.com/unidoc/unipdf/v3/common";_d "math";);const _cfg =1.0e-6;func (_da Matrix )String ()string {_eg ,_gb ,_cf ,_a ,_ee ,_ca :=_da [0],_da [1],_da [3],_da [4],_da [6],_da [7];return _b .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_eg ,_gb ,_cf ,_a ,_ee ,_ca );};func (_ce *Matrix )clampRange (){for _ea ,_dcg :=range _ce {if _dcg > _bg {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dcg ,_bg );_ce [_ea ]=_bg ;}else if _dcg < -_bg {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dcg ,-_bg );_ce [_ea ]=-_bg ;};};};func (_fe Matrix )Identity ()bool {return _fe [0]==1&&_fe [1]==0&&_fe [2]==0&&_fe [3]==0&&_fe [4]==1&&_fe [5]==0&&_fe [6]==0&&_fe [7]==0&&_fe [8]==1;};func (_ga Matrix )Translation ()(float64 ,float64 ){return _ga [6],_ga [7]};func (_cfa Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_cfa [0],_cfa [1],_cfa [3],_cfa [4],_cfa [6]+tx ,_cfa [7]+ty );};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};const _bg =1e9;func (_fd Matrix )Inverse ()(Matrix ,bool ){_gab ,_adc :=_fd [0],_fd [1];_dde ,_dgf :=_fd [3],_fd [4];_fb ,_aa :=_fd [6],_fd [7];_bca :=_gab *_dgf -_adc *_dde ;if _d .Abs (_bca )< _cfg {return Matrix {},false ;};_cc ,_ab :=_dgf /_bca ,-_adc /_bca ;_ba ,_fc :=-_dde /_bca ,_gab /_bca ;_bb :=-(_cc *_fb +_ba *_aa );_aeg :=-(_ab *_fb +_fc *_aa );return NewMatrix (_cc ,_ab ,_ba ,_fc ,_bb ,_aeg ),true ;};func (_fgg Point )Distance (b Point )float64 {return _d .Hypot (_fgg .X -b .X ,_fgg .Y -b .Y )};func (_gf *Matrix )Shear (x ,y float64 ){_gf .Concat (ShearMatrix (x ,y ))};func (_fa Matrix )Mult (b Matrix )Matrix {_fa .Concat (b );return _fa };func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ff Matrix )Scale (xScale ,yScale float64 )Matrix {return _ff .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_bfc :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_bfc .clampRange ();return _bfc ;};func (_cg *Matrix )Concat (b Matrix ){*_cg =Matrix {b [0]*_cg [0]+b [1]*_cg [3],b [0]*_cg [1]+b [1]*_cg [4],0,b [3]*_cg [0]+b [4]*_cg [3],b [3]*_cg [1]+b [4]*_cg [4],0,b [6]*_cg [0]+b [7]*_cg [3]+_cg [6],b [6]*_cg [1]+b [7]*_cg [4]+_cg [7],1};_cg .clampRange ();};type Point struct{X float64 ;Y float64 ;};func (_ec Matrix )Singular ()bool {return _d .Abs (_ec [0]*_ec [4]-_ec [1]*_ec [3])< _cb };func (_eca Point )Displace (delta Point )Point {return Point {_eca .X +delta .X ,_eca .Y +delta .Y }};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_e Matrix )Round (precision float64 )Matrix {for _bf :=range _e {_e [_bf ]=_d .Round (_e [_bf ]/precision )*precision ;};return _e ;};func (_gd *Point )Set (x ,y float64 ){_gd .X ,_gd .Y =x ,y };func (_cce *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ag :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cce .transformByMatrix (_ag );};func (_cd Matrix )ScalingFactorX ()float64 {return _d .Hypot (_cd [0],_cd [1])};func (_dd *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_dd [0],_dd [1]=a ,b ;_dd [3],_dd [4]=c ,d ;_dd [6],_dd [7]=tx ,ty ;_dd .clampRange ();};func (_adb Matrix )Unrealistic ()bool {_bd ,_ccf ,_fcg ,_dbe :=_d .Abs (_adb [0]),_d .Abs (_adb [1]),_d .Abs (_adb [3]),_d .Abs (_adb [4]);_ddd :=_bd > _bcf &&_dbe > _bcf ;_cfae :=_ccf > _bcf &&_fcg > _bcf ;return !(_ddd ||_cfae );};type Matrix [9]float64 ;func (_db *Matrix )Clone ()Matrix {return NewMatrix (_db [0],_db [1],_db [3],_db [4],_db [6],_db [7])};func (_bfb Matrix )Rotate (theta float64 )Matrix {_bc ,_eea :=_d .Sincos (theta /180.0*_d .Pi );return _bfb .Mult (NewMatrix (_eea ,-_bc ,_bc ,_eea ,0,0));};func (_egd Matrix )Angle ()float64 {_ef :=_d .Atan2 (-_egd [1],_egd [0]);if _ef < 0.0{_ef +=2*_d .Pi ;};return _ef /_d .Pi *180.0;};func RotationMatrix (angle float64 )Matrix {_c :=_d .Cos (angle );_dc :=_d .Sin (angle );return NewMatrix (_c ,_dc ,-_dc ,_c ,0,0);};func (_gdc Point )String ()string {return _b .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gdc .X ,_gdc .Y );};const _bcf =1e-6;func (_ad Matrix )Transform (x ,y float64 )(float64 ,float64 ){_eeag :=x *_ad [0]+y *_ad [3]+_ad [6];_ae :=x *_ad [1]+y *_ad [4]+_ad [7];return _eeag ,_ae ;};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};const _cb =1e-10;func (_fdd Point )Rotate (theta float64 )Point {_ed :=_d .Hypot (_fdd .X ,_fdd .Y );_fg :=_d .Atan2 (_fdd .Y ,_fdd .X );_dba ,_gfe :=_d .Sincos (_fg +theta /180.0*_d .Pi );return Point {_ed *_gfe ,_ed *_dba };};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_bfe *Point )transformByMatrix (_ffc Matrix ){_bfe .X ,_bfe .Y =_ffc .Transform (_bfe .X ,_bfe .Y )};func (_dg Matrix )ScalingFactorY ()float64 {return _d .Hypot (_dg [3],_dg [4])};func (_edd Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_edd .X +t *b .X ,Y :(1-t )*_edd .Y +t *b .Y };};