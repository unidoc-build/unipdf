//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_e "github.com/unidoc/unipdf/v3/common";_d "math";);func (_da Matrix )Rotate (theta float64 )Matrix {return _da .Mult (RotationMatrix (theta ))};func (_ea *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ea [0],_ea [1]=a ,b ;
_ea [3],_ea [4]=c ,d ;_ea [6],_ea [7]=tx ,ty ;_ea .clampRange ();};func (_cb Matrix )Singular ()bool {return _d .Abs (_cb [0]*_cb [4]-_cb [1]*_cb [3])< _dc };func (_cdf *Point )transformByMatrix (_ba Matrix ){_cdf .X ,_cdf .Y =_ba .Transform (_cdf .X ,_cdf .Y )};
func (_ga Matrix )Round (precision float64 )Matrix {for _b :=range _ga {_ga [_b ]=_d .Round (_ga [_b ]/precision )*precision ;};return _ga ;};func (_dd *Point )Set (x ,y float64 ){_dd .X ,_dd .Y =x ,y };func (_de Point )Rotate (theta float64 )Point {_cd :=_d .Hypot (_de .X ,_de .Y );
_dba :=_d .Atan2 (_de .Y ,_de .X );_daf ,_dfc :=_d .Sincos (_dba +theta /180.0*_d .Pi );return Point {_cd *_dfc ,_cd *_daf };};func (_ce Matrix )Scale (xScale ,yScale float64 )Matrix {return _ce .Mult (ScaleMatrix (xScale ,yScale ))};const _fcf =1.0e-6;
func (_eb *Matrix )clampRange (){for _ebd ,_ffa :=range _eb {if _ffa > _fbg {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ffa ,_fbg );_eb [_ebd ]=_fbg ;}else if _ffa < -_fbg {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ffa ,-_fbg );
_eb [_ebd ]=-_fbg ;};};};func (_fd Matrix )Translate (tx ,ty float64 )Matrix {return _fd .Mult (TranslationMatrix (tx ,ty ))};const _dc =1e-10;func (_ad *Matrix )Clone ()Matrix {return NewMatrix (_ad [0],_ad [1],_ad [3],_ad [4],_ad [6],_ad [7])};func (_db Matrix )String ()string {_ffe ,_egb ,_a ,_ge ,_gd ,_c :=_db [0],_db [1],_db [3],_db [4],_db [6],_db [7];
return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ffe ,_egb ,_a ,_ge ,_gd ,_c );};
func (_cbgc Point )Displace (delta Point )Point {return Point {_cbgc .X +delta .X ,_cbgc .Y +delta .Y }};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_eag Matrix )ScalingFactorY ()float64 {return _d .Hypot (_eag [3],_eag [4])};
func (_fff Matrix )Inverse ()(Matrix ,bool ){_eff ,_daa :=_fff [0],_fff [1];_cf ,_cff :=_fff [3],_fff [4];_gad ,_bdd :=_fff [6],_fff [7];_cbb :=_eff *_cff -_daa *_cf ;if _d .Abs (_cbb )< _fcf {return Matrix {},false ;};_cbg ,_cc :=_cff /_cbb ,-_daa /_cbb ;
_fa ,_ged :=-_cf /_cbb ,_eff /_cbb ;_fb :=-(_cbg *_gad +_fa *_bdd );_fg :=-(_cc *_gad +_ged *_bdd );return NewMatrix (_cbg ,_cc ,_fa ,_ged ,_fb ,_fg ),true ;};func (_fc Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ade :=x *_fc [0]+y *_fc [3]+_fc [6];
_eab :=x *_fc [1]+y *_fc [4]+_fc [7];return _ade ,_eab ;};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_bd :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_bd .clampRange ();return _bd ;};func (_ag *Matrix )Shear (x ,y float64 ){_ag .Concat (ShearMatrix (x ,y ))};
func (_gf Point )Distance (b Point )float64 {return _d .Hypot (_gf .X -b .X ,_gf .Y -b .Y )};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_eae *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_cg :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_eae .transformByMatrix (_cg );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ae Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ae .X +t *b .X ,Y :(1-t )*_ae .Y +t *b .Y };
};func (_fcc Matrix )Unrealistic ()bool {_dg ,_ec ,_ca ,_ac :=_d .Abs (_fcc [0]),_d .Abs (_fcc [1]),_d .Abs (_fcc [3]),_d .Abs (_fcc [4]);_bb :=_dg > _gb &&_ac > _gb ;_dac :=_ec > _gb &&_ca > _gb ;return !(_bb ||_dac );};type Matrix [9]float64 ;func (_ff Matrix )Identity ()bool {return _ff [0]==1&&_ff [1]==0&&_ff [2]==0&&_ff [3]==0&&_ff [4]==1&&_ff [5]==0&&_ff [6]==0&&_ff [7]==0&&_ff [8]==1;
};func (_aga Matrix )ScalingFactorX ()float64 {return _d .Hypot (_aga [0],_aga [1])};func (_aa *Matrix )Concat (b Matrix ){*_aa =Matrix {b [0]*_aa [0]+b [1]*_aa [3],b [0]*_aa [1]+b [1]*_aa [4],0,b [3]*_aa [0]+b [4]*_aa [3],b [3]*_aa [1]+b [4]*_aa [4],0,b [6]*_aa [0]+b [7]*_aa [3]+_aa [6],b [6]*_aa [1]+b [7]*_aa [4]+_aa [7],1};
_aa .clampRange ();};func (_bg Matrix )Angle ()float64 {_gc :=_d .Atan2 (-_bg [1],_bg [0]);if _gc < 0.0{_gc +=2*_d .Pi ;};return _gc /_d .Pi *180.0;};func (_bgd Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_bgd .X ,_bgd .Y );
};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_eac Matrix )Mult (b Matrix )Matrix {_eac .Concat (b );return _eac };func (_df Matrix )Translation ()(float64 ,float64 ){return _df [6],_df [7]};const _fbg =1e9;type Point struct{X float64 ;
Y float64 ;};const _gb =1e-6;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func RotationMatrix (angle float64 )Matrix {_ef :=_d .Cos (angle );_eg :=_d .Sin (angle );return NewMatrix (_ef ,_eg ,-_eg ,_ef ,0,0);
};