//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_c "encoding/binary";_ae "errors";_f "github.com/unidoc/unipdf/v3/common";_aa "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_eaf *SubstreamReader )ReadByte ()(byte ,error ){if _eaf ._beg ==0{return _eaf .readBufferByte ();};return _eaf .readUnalignedByte ();};func (_fbc *SubstreamReader )ReadBool ()(bool ,error ){return _fbc .readBool ()};func (_cd *BufferedWriter )expandIfNeeded (_gb int ){if !_cd .tryGrowByReslice (_gb ){_cd .grow (_gb );};};type BinaryWriter interface{BitWriter ;_a .Writer ;_a .ByteWriter ;Data ()[]byte ;};func (_ff *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ff ._age =-1;var _gaa int64 ;switch whence {case _a .SeekStart :_gaa =offset ;case _a .SeekCurrent :_gaa =_ff ._cg +offset ;case _a .SeekEnd :_gaa =int64 (len (_ff ._dgfc ))+offset ;default:return 0,_ae .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _gaa < 0{return 0,_ae .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ff ._cg =_gaa ;_ff ._cfg =0;return _gaa ,nil ;};type BitWriter interface{WriteBit (_fb int )error ;WriteBits (_bdg uint64 ,_aeb int )(_daa int ,_ag error );FinishByte ();SkipBits (_gf int )error ;};func (_cca *BufferedWriter )byteCapacity ()int {_af :=len (_cca ._cb )-_cca ._ee ;if _cca ._dc !=0{_af --;};return _af ;};func (_fef *SubstreamReader )BitPosition ()int {return int (_fef ._beg )};func (_daf *Reader )read (_cdb []byte )(int ,error ){if _daf ._cg >=int64 (len (_daf ._dgfc )){return 0,_a .EOF ;};_daf ._age =-1;_cdd :=copy (_cdb ,_daf ._dgfc [_daf ._cg :]);_daf ._cg +=int64 (_cdd );return _cdd ,nil ;};func (_ffg *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _a .SeekStart :_ffg ._dbcf =uint64 (offset );case _a .SeekCurrent :_ffg ._dbcf +=uint64 (offset );case _a .SeekEnd :_ffg ._dbcf =_ffg ._bed +uint64 (offset );default:return 0,_ae .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_ffg ._beg =0;return int64 (_ffg ._dbcf ),nil ;};func (_ead *Reader )ReadBool ()(bool ,error ){return _ead .readBool ()};func (_dag *BufferedWriter )Write (d []byte )(int ,error ){_dag .expandIfNeeded (len (d ));if _dag ._dc ==0{return _dag .writeFullBytes (d ),nil ;};return _dag .writeShiftedBytes (d ),nil ;};func (_fa *Reader )ReadByte ()(byte ,error ){if _fa ._cfg ==0{return _fa .readBufferByte ();};return _fa .readUnalignedByte ();};func (_be *BufferedWriter )ResetBitIndex (){_be ._dc =0};func (_dgg *Reader )readBufferByte ()(byte ,error ){if _dgg ._cg >=int64 (len (_dgg ._dgfc )){return 0,_a .EOF ;};_dgg ._age =-1;_def :=_dgg ._dgfc [_dgg ._cg ];_dgg ._cg ++;_dgg ._adfb =int (_def );return _def ,nil ;};func (_bdf *Reader )StreamPosition ()int64 {return _bdf ._cg };func (_ccb *Reader )ReadUint32 ()(uint32 ,error ){_fae :=make ([]byte ,4);_ ,_ba :=_ccb .Read (_fae );if _ba !=nil {return 0,_ba ;};return _c .BigEndian .Uint32 (_fae ),nil ;};func (_dcef *SubstreamReader )Align ()(_deg byte ){_deg =_dcef ._beg ;_dcef ._beg =0;return _deg };func (_fg *Reader )BitPosition ()int {return int (_fg ._cfg )};func (_ede *Reader )ConsumeRemainingBits (){if _ede ._cfg !=0{_ ,_aaa :=_ede .ReadBits (_ede ._cfg );if _aaa !=nil {_f .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_aaa );};};};func (_deab *SubstreamReader )Offset ()uint64 {return _deab ._fdef };func (_adf *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _aa .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_adf ._cb )-1< _adf ._ee {_adf .expandIfNeeded (1);};_dea :=_adf ._dc ;if _adf ._dd {_dea =7-_adf ._dc ;};_adf ._cb [_adf ._ee ]|=byte (uint16 (bit <<_dea )&0xff);_adf ._dc ++;if _adf ._dc ==8{_adf ._ee ++;_adf ._dc =0;};return nil ;};func (_bgbb *Reader )Reset (){_bgbb ._cg =_bgbb ._eba ;_bgbb ._cfg =_bgbb ._bcg };func (_dae *BufferedWriter )writeShiftedBytes (_dce []byte )int {for _ ,_gcc :=range _dce {_dae .writeByte (_gcc );};return len (_dce );};func (_dfe *SubstreamReader )Read (b []byte )(_eceb int ,_cff error ){if _dfe ._dbcf >=_dfe ._bed {_f .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_dfe ._dbcf ,_dfe ._bed );return 0,_a .EOF ;};for ;_eceb < len (b );_eceb ++{if b [_eceb ],_cff =_dfe .readUnalignedByte ();_cff !=nil {if _cff ==_a .EOF {return _eceb ,nil ;};return 0,_cff ;};};return _eceb ,nil ;};type StreamReader interface{_a .Reader ;_a .ByteReader ;_a .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bfe byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_fea *Writer )ResetBit (){_fea ._cgf =0};func (_bbb *SubstreamReader )StreamPosition ()int64 {return int64 (_bbb ._dbcf )};func (_cga *Writer )writeByte (_fcfa byte )error {if _cga ._ebde > len (_cga ._fbf )-1{return _a .EOF ;};if _cga ._ebde ==len (_cga ._fbf )-1&&_cga ._cgf !=0{return _a .EOF ;};if _cga ._cgf ==0{_cga ._fbf [_cga ._ebde ]=_fcfa ;_cga ._ebde ++;return nil ;};if _cga ._agd {_cga ._fbf [_cga ._ebde ]|=_fcfa >>_cga ._cgf ;_cga ._ebde ++;_cga ._fbf [_cga ._ebde ]=byte (uint16 (_fcfa )<<(8-_cga ._cgf )&0xff);}else {_cga ._fbf [_cga ._ebde ]|=byte (uint16 (_fcfa )<<_cga ._cgf &0xff);_cga ._ebde ++;_cga ._fbf [_cga ._ebde ]=_fcfa >>(8-_cga ._cgf );};return nil ;};func (_bgb *BufferedWriter )writeByte (_ebc byte ){switch {case _bgb ._dc ==0:_bgb ._cb [_bgb ._ee ]=_ebc ;_bgb ._ee ++;case _bgb ._dd :_bgb ._cb [_bgb ._ee ]|=_ebc >>_bgb ._dc ;_bgb ._ee ++;_bgb ._cb [_bgb ._ee ]=byte (uint16 (_ebc )<<(8-_bgb ._dc )&0xff);default:_bgb ._cb [_bgb ._ee ]|=byte (uint16 (_ebc )<<_bgb ._dc &0xff);_bgb ._ee ++;_bgb ._cb [_bgb ._ee ]=_ebc >>(8-_bgb ._dc );};};func (_da *BufferedWriter )Len ()int {return _da .byteCapacity ()};func (_ebd *SubstreamReader )fillBuffer ()error {if uint64 (_ebd ._aad .StreamPosition ())!=_ebd ._dbcf +_ebd ._fdef {_ ,_aea :=_ebd ._aad .Seek (int64 (_ebd ._dbcf +_ebd ._fdef ),_a .SeekStart );if _aea !=nil {return _aea ;};};_ebd ._ce =_ebd ._dbcf ;_ecdg :=_gac (uint64 (len (_ebd ._ccad )),_ebd ._bed -_ebd ._dbcf );_afa :=make ([]byte ,_ecdg );_gfd ,_gfb :=_ebd ._aad .Read (_afa );if _gfb !=nil {return _gfb ;};for _bega :=uint64 (0);_bega < _ecdg ;_bega ++{_ebd ._ccad [_bega ]=_afa [_bega ];};_ebd ._afb =_ebd ._ce +uint64 (_gfd );return nil ;};func (_ad *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_gd :=int (_ad ._dc )+skip ;if _gd >=0&&_gd < 8{_ad ._dc =uint8 (_gd );return nil ;};_gd =int (_ad ._dc )+_ad ._ee *8+skip ;if _gd < 0{return _aa .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_eb :=_gd /8;_gc :=_gd %8;_ad ._dc =uint8 (_gc );if _eeb :=_eb -_ad ._ee ;_eeb > 0&&len (_ad ._cb )-1< _eb {if _ad ._dc !=0{_eeb ++;};_ad .expandIfNeeded (_eeb );};_ad ._ee =_eb ;return nil ;};type BufferedWriter struct{_cb []byte ;_dc uint8 ;_ee int ;_dd bool ;};func (_bf *BufferedWriter )Data ()[]byte {return _bf ._cb };func (_bef *Writer )Data ()[]byte {return _bef ._fbf };func (_bdbg *Writer )WriteByte (c byte )error {return _bdbg .writeByte (c )};var _ BinaryWriter =&Writer {};func (_efb *Reader )ReadBits (n byte )(_aeg uint64 ,_ga error ){if n < _efb ._cfg {_cbcc :=_efb ._cfg -n ;_aeg =uint64 (_efb ._bc >>_cbcc );_efb ._bc &=1<<_cbcc -1;_efb ._cfg =_cbcc ;return _aeg ,nil ;};if n > _efb ._cfg {if _efb ._cfg > 0{_aeg =uint64 (_efb ._bc );n -=_efb ._cfg ;};for n >=8{_bb ,_ccae :=_efb .readBufferByte ();if _ccae !=nil {return 0,_ccae ;};_aeg =_aeg <<8+uint64 (_bb );n -=8;};if n > 0{if _efb ._bc ,_ga =_efb .readBufferByte ();_ga !=nil {return 0,_ga ;};_dbc :=8-n ;_aeg =_aeg <<n +uint64 (_efb ._bc >>_dbc );_efb ._bc &=1<<_dbc -1;_efb ._cfg =_dbc ;}else {_efb ._cfg =0;};return _aeg ,nil ;};_efb ._cfg =0;return uint64 (_efb ._bc ),nil ;};func (_dg *BufferedWriter )fullOffset ()int {_cfc :=_dg ._ee ;if _dg ._dc !=0{_cfc ++;};return _cfc ;};func (_ed *BufferedWriter )grow (_fce int ){if _ed ._cb ==nil &&_fce < _d {_ed ._cb =make ([]byte ,_fce ,_d );return ;};_fde :=len (_ed ._cb );if _ed ._dc !=0{_fde ++;};_bg :=cap (_ed ._cb );switch {case _fce <=_bg /2-_fde :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ed ._cb ),cap (_ed ._cb ),_fce );_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bg ,_fde );copy (_ed ._cb ,_ed ._cb [_ed .fullOffset ():]);case _bg > _e -_bg -_fce :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gbc :=make ([]byte ,2*_bg +_fce );copy (_gbc ,_ed ._cb );_ed ._cb =_gbc ;};_ed ._cb =_ed ._cb [:_fde +_fce ];};func (_g *BufferedWriter )Reset (){_g ._cb =_g ._cb [:0];_g ._ee =0;_g ._dc =0};func (_dda *BufferedWriter )WriteBits (bits uint64 ,number int )(_eag int ,_bd error ){const _ac ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_aa .Errorf (_ac ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_cf :=number /8;if _cf > 0{_fc :=number -_cf *8;for _fe :=_cf -1;_fe >=0;_fe --{_cc :=byte ((bits >>uint (_fe *8+_fc ))&0xff);if _bd =_dda .WriteByte (_cc );_bd !=nil {return _eag ,_aa .Wrapf (_bd ,_ac ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cf -_fe +1);};};number -=_cf *8;if number ==0{return _cf ,nil ;};};var _fd int ;for _cbc :=0;_cbc < number ;_cbc ++{if _dda ._dd {_fd =int ((bits >>uint (number -1-_cbc ))&0x1);}else {_fd =int (bits &0x1);bits >>=1;};if _bd =_dda .WriteBit (_fd );_bd !=nil {return _eag ,_aa .Wrapf (_bd ,_ac ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cbc );};};return _cf ,nil ;};func (_adg *Reader )readBool ()(_aaaf bool ,_edce error ){if _adg ._cfg ==0{_adg ._bc ,_edce =_adg .readBufferByte ();if _edce !=nil {return false ,_edce ;};_aaaf =(_adg ._bc &0x80)!=0;_adg ._bc ,_adg ._cfg =_adg ._bc &0x7f,7;return _aaaf ,nil ;};_adg ._cfg --;_aaaf =(_adg ._bc &(1<<_adg ._cfg ))!=0;_adg ._bc &=1<<_adg ._cfg -1;return _aaaf ,nil ;};func (_gbfa *Writer )UseMSB ()bool {return _gbfa ._agd };var _ _a .Writer =&BufferedWriter {};func (_ca *BufferedWriter )WriteByte (bt byte )error {if _ca ._ee > len (_ca ._cb )-1||(_ca ._ee ==len (_ca ._cb )-1&&_ca ._dc !=0){_ca .expandIfNeeded (1);};_ca .writeByte (bt );return nil ;};type SubstreamReader struct{_dbcf uint64 ;_aad StreamReader ;_fdef uint64 ;_bed uint64 ;_ccad []byte ;_ce uint64 ;_afb uint64 ;_defg byte ;_beg byte ;_bgbc uint64 ;_bcb byte ;};type Reader struct{_dgfc []byte ;_bc byte ;_cfg byte ;_cg int64 ;_adfb int ;_age int ;_eba int64 ;_bcg byte ;};type Writer struct{_fbf []byte ;_cgf uint8 ;_ebde int ;_agd bool ;};const (_d =64;_e =int (^uint (0)>>1););func (_ea *BufferedWriter )FinishByte (){if _ea ._dc ==0{return ;};_ea ._dc =0;_ea ._ee ++;};func (_dcbf *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _dcbf .writeBit (uint8 (bit ));};return _aa .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func NewWriterMSB (data []byte )*Writer {return &Writer {_fbf :data ,_agd :true }};func (_ebf *SubstreamReader )Length ()uint64 {return _ebf ._bed };func (_dcc *Reader )readUnalignedByte ()(_dgca byte ,_gaag error ){_bbe :=_dcc ._cfg ;_dgca =_dcc ._bc <<(8-_bbe );_dcc ._bc ,_gaag =_dcc .readBufferByte ();if _gaag !=nil {return 0,_gaag ;};_dgca |=_dcc ._bc >>_bbe ;_dcc ._bc &=1<<_bbe -1;return _dgca ,nil ;};func (_ccc *BufferedWriter )writeFullBytes (_ef []byte )int {_add :=copy (_ccc ._cb [_ccc .fullOffset ():],_ef );_ccc ._ee +=_add ;return _add ;};func (_cbf *SubstreamReader )readBool ()(_eda bool ,_gcd error ){if _cbf ._beg ==0{_cbf ._defg ,_gcd =_cbf .readBufferByte ();if _gcd !=nil {return false ,_gcd ;};_eda =(_cbf ._defg &0x80)!=0;_cbf ._defg ,_cbf ._beg =_cbf ._defg &0x7f,7;return _eda ,nil ;};_cbf ._beg --;_eda =(_cbf ._defg &(1<<_cbf ._beg ))!=0;_cbf ._defg &=1<<_cbf ._beg -1;return _eda ,nil ;};func (_df *Reader )Align ()(_dfb byte ){_dfb =_df ._cfg ;_df ._cfg =0;return _dfb };func (_dgd *Writer )writeBit (_abd uint8 )error {if len (_dgd ._fbf )-1< _dgd ._ebde {return _a .EOF ;};_fab :=_dgd ._cgf ;if _dgd ._agd {_fab =7-_dgd ._cgf ;};_dgd ._fbf [_dgd ._ebde ]|=byte (uint16 (_abd <<_fab )&0xff);_dgd ._cgf ++;if _dgd ._cgf ==8{_dgd ._ebde ++;_dgd ._cgf =0;};return nil ;};func (_cda *BufferedWriter )tryGrowByReslice (_dgf int )bool {if _db :=len (_cda ._cb );_dgf <=cap (_cda ._cb )-_db {_cda ._cb =_cda ._cb [:_db +_dgf ];return true ;};return false ;};func (_faee *Writer )Write (p []byte )(int ,error ){if len (p )> _faee .byteCapacity (){return 0,_a .EOF ;};for _ ,_egdc :=range p {if _bba :=_faee .writeByte (_egdc );_bba !=nil {return 0,_bba ;};};return len (p ),nil ;};func NewReader (data []byte )*Reader {return &Reader {_dgfc :data }};func NewWriter (data []byte )*Writer {return &Writer {_fbf :data }};func (_aecg *Reader )Length ()uint64 {return uint64 (len (_aecg ._dgfc ))};func (_bfc *Reader )Mark (){_bfc ._eba =_bfc ._cg ;_bfc ._bcg =_bfc ._cfg };func (_bcgd *SubstreamReader )readUnalignedByte ()(_ggg byte ,_ab error ){_gdf :=_bcgd ._beg ;_ggg =_bcgd ._defg <<(8-_gdf );_bcgd ._defg ,_ab =_bcgd .readBufferByte ();if _ab !=nil {return 0,_ab ;};_ggg |=_bcgd ._defg >>_gdf ;_bcgd ._defg &=1<<_gdf -1;return _ggg ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_ae .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_f .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_aad :r ,_fdef :offset ,_bed :length ,_ccad :make ([]byte ,length )},nil ;};func (_fded *Writer )byteCapacity ()int {_fge :=len (_fded ._fbf )-_fded ._ebde ;if _fded ._cgf !=0{_fge --;};return _fge ;};func (_agf *SubstreamReader )Reset (){_agf ._dbcf =_agf ._bgbc ;_agf ._beg =_agf ._bcb };func (_feb *Writer )SkipBits (skip int )error {const _gdc ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ffc :=int (_feb ._cgf )+skip ;if _ffc >=0&&_ffc < 8{_feb ._cgf =uint8 (_ffc );return nil ;};_ffc =int (_feb ._cgf )+_feb ._ebde *8+skip ;if _ffc < 0{return _aa .Errorf (_gdc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ggd :=_ffc /8;_eea :=_ffc %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_feb ._cgf ,_feb ._ebde ,int (_feb ._cgf )+(_feb ._ebde )*8,len (_feb ._fbf ),cap (_feb ._fbf ));_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ffc ,_eea );_feb ._cgf =uint8 (_eea );if _fdd :=_ggd -_feb ._ebde ;_fdd > 0&&len (_feb ._fbf )-1< _ggd {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_fdd );return _aa .Errorf (_gdc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_feb ._ebde =_ggd ;_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_feb ._cgf ,_feb ._ebde );return nil ;};var (_ _a .Reader =&Reader {};_ _a .ByteReader =&Reader {};_ _a .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_eca *Reader )Read (p []byte )(_bdb int ,_ge error ){if _eca ._cfg ==0{return _eca .read (p );};for ;_bdb < len (p );_bdb ++{if p [_bdb ],_ge =_eca .readUnalignedByte ();_ge !=nil {return 0,_ge ;};};return _bdb ,nil ;};func (_cee *SubstreamReader )ReadBits (n byte )(_gba uint64 ,_bdbe error ){if n < _cee ._beg {_fdb :=_cee ._beg -n ;_gba =uint64 (_cee ._defg >>_fdb );_cee ._defg &=1<<_fdb -1;_cee ._beg =_fdb ;return _gba ,nil ;};if n > _cee ._beg {if _cee ._beg > 0{_gba =uint64 (_cee ._defg );n -=_cee ._beg ;};var _gea byte ;for n >=8{_gea ,_bdbe =_cee .readBufferByte ();if _bdbe !=nil {return 0,_bdbe ;};_gba =_gba <<8+uint64 (_gea );n -=8;};if n > 0{if _cee ._defg ,_bdbe =_cee .readBufferByte ();_bdbe !=nil {return 0,_bdbe ;};_gbf :=8-n ;_gba =_gba <<n +uint64 (_cee ._defg >>_gbf );_cee ._defg &=1<<_gbf -1;_cee ._beg =_gbf ;}else {_cee ._beg =0;};return _gba ,nil ;};_cee ._beg =0;return uint64 (_cee ._defg ),nil ;};func (_gae *SubstreamReader )Mark (){_gae ._bgbc =_gae ._dbcf ;_gae ._bcb =_gae ._beg };var _ BinaryWriter =&BufferedWriter {};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_dd :true }};func (_gec *Writer )WriteBits (bits uint64 ,number int )(_gag int ,_dfeg error ){const _bfa ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_aa .Errorf (_bfa ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_fcbd :=number /8;if _fcbd > 0{_agff :=number -_fcbd *8;for _dccg :=_fcbd -1;_dccg >=0;_dccg --{_fag :=byte ((bits >>uint (_dccg *8+_agff ))&0xff);if _dfeg =_gec .WriteByte (_fag );_dfeg !=nil {return _gag ,_aa .Wrapf (_dfeg ,_bfa ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fcbd -_dccg +1);};};number -=_fcbd *8;if number ==0{return _fcbd ,nil ;};};var _fagg int ;for _ada :=0;_ada < number ;_ada ++{if _gec ._agd {_fagg =int ((bits >>uint (number -1-_ada ))&0x1);}else {_fagg =int (bits &0x1);bits >>=1;};if _dfeg =_gec .WriteBit (_fagg );_dfeg !=nil {return _gag ,_aa .Wrapf (_dfeg ,_bfa ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ada );};};return _fcbd ,nil ;};func (_ecg *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cgb :=make ([]byte ,4);_ ,_fbd :=_ecg .Read (_cgb );if _fbd !=nil {return 0,_fbd ;};return _c .BigEndian .Uint32 (_cgb ),nil ;};var _ _a .ByteWriter =&BufferedWriter {};func (_fbfe *Writer )FinishByte (){if _fbfe ._cgf ==0{return ;};_fbfe ._cgf =0;_fbfe ._ebde ++;};func (_gg *Reader )ReadBit ()(_edc int ,_gca error ){_fcf ,_gca :=_gg .readBool ();if _gca !=nil {return 0,_gca ;};if _fcf {_edc =1;};return _edc ,nil ;};func (_dfee *SubstreamReader )readBufferByte ()(byte ,error ){if _dfee ._dbcf >=_dfee ._bed {return 0,_a .EOF ;};if _dfee ._dbcf >=_dfee ._afb ||_dfee ._dbcf < _dfee ._ce {if _dcb :=_dfee .fillBuffer ();_dcb !=nil {return 0,_dcb ;};};_ebg :=_dfee ._ccad [_dfee ._dbcf -_dfee ._ce ];_dfee ._dbcf ++;return _ebg ,nil ;};func (_fcb *SubstreamReader )ReadBit ()(_bgd int ,_acb error ){_egd ,_acb :=_fcb .readBool ();if _acb !=nil {return 0,_acb ;};if _egd {_bgd =1;};return _bgd ,nil ;};func _gac (_fcec ,_cfe uint64 )uint64 {if _fcec < _cfe {return _fcec ;};return _cfe ;};