//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_g "encoding/binary";_ff "errors";_c "fmt";_e "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);func (_ada *BufferedWriter )writeByte (_gag byte ){switch {case _ada ._gca ==0:_ada ._dc [_ada ._eb ]=_gag ;
_ada ._eb ++;case _ada ._ac :_ada ._dc [_ada ._eb ]|=_gag >>_ada ._gca ;_ada ._eb ++;_ada ._dc [_ada ._eb ]=byte (uint16 (_gag )<<(8-_ada ._gca )&0xff);default:_ada ._dc [_ada ._eb ]|=byte (uint16 (_gag )<<_ada ._gca &0xff);_ada ._eb ++;_ada ._dc [_ada ._eb ]=_gag >>(8-_ada ._gca );
};};func (_ffc *BufferedWriter )grow (_cec int ){if _ffc ._dc ==nil &&_cec < _b {_ffc ._dc =make ([]byte ,_cec ,_b );return ;};_cg :=len (_ffc ._dc );if _ffc ._gca !=0{_cg ++;};_cc :=cap (_ffc ._dc );switch {case _cec <=_cc /2-_cg :_e .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ffc ._dc ),cap (_ffc ._dc ),_cec );
_e .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cc ,_cg );copy (_ffc ._dc ,_ffc ._dc [_ffc .fullOffset ():]);
case _cc > _be -_cc -_cec :_e .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ee :=make ([]byte ,2*_cc +_cec );copy (_ee ,_ffc ._dc );_ffc ._dc =_ee ;};_ffc ._dc =_ffc ._dc [:_cg +_cec ];
};func (_ab *BufferedWriter )Data ()[]byte {return _ab ._dc };func (_gdb *Writer )WriteBits (bits uint64 ,number int )(_gfa int ,_aag error ){const _faf ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_a .Errorf (_faf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_gec :=number /8;if _gec > 0{_gef :=number -_gec *8;for _fed :=_gec -1;_fed >=0;_fed --{_eab :=byte ((bits >>uint (_fed *8+_gef ))&0xff);if _aag =_gdb .WriteByte (_eab );_aag !=nil {return _gfa ,_a .Wrapf (_aag ,_faf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gec -_fed +1);
};};number -=_gec *8;if number ==0{return _gec ,nil ;};};var _ffb int ;for _cbba :=0;_cbba < number ;_cbba ++{if _gdb ._aaed {_ffb =int ((bits >>uint (number -1-_cbba ))&0x1);}else {_ffb =int (bits &0x1);bits >>=1;};if _aag =_gdb .WriteBit (_ffb );_aag !=nil {return _gfa ,_a .Wrapf (_aag ,_faf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cbba );
};};return _gec ,nil ;};func (_fge *Writer )WriteByte (c byte )error {return _fge .writeByte (c )};func (_cd *BufferedWriter )ResetBitIndex (){_cd ._gca =0};func (_aaa *Reader )AbsoluteLength ()uint64 {return uint64 (len (_aaa ._fc ._aad ))};func (_afdd *Writer )UseMSB ()bool {return _afdd ._aaed };
func NewWriterMSB (data []byte )*Writer {return &Writer {_gf :data ,_aaed :true }};func (_ef *Reader )Align ()(_afd byte ){_afd =_ef ._fe ;_ef ._fe =0;return _afd };func (_eecc *Reader )AbsolutePosition ()int64 {return _eecc ._bcgc +int64 (_eecc ._fc ._aedb )};
func (_fcb *Reader )Read (p []byte )(_fbe int ,_adde error ){if _fcb ._fe ==0{return _fcb .read (p );};for ;_fbe < len (p );_fbe ++{if p [_fbe ],_adde =_fcb .readUnalignedByte ();_adde !=nil {return 0,_adde ;};};return _fbe ,nil ;};func (_dbd *Writer )ResetBit (){_dbd ._bee =0};
func (_gg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ec :=int (_gg ._gca )+skip ;if _ec >=0&&_ec < 8{_gg ._gca =uint8 (_ec );return nil ;};_ec =int (_gg ._gca )+_gg ._eb *8+skip ;if _ec < 0{return _a .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dd :=_ec /8;_ag :=_ec %8;_gg ._gca =uint8 (_ag );if _bg :=_dd -_gg ._eb ;_bg > 0&&len (_gg ._dc )-1< _dd {if _gg ._gca !=0{_bg ++;};_gg .expandIfNeeded (_bg );};_gg ._eb =_dd ;return nil ;};func (_gaf *BufferedWriter )Write (d []byte )(int ,error ){_gaf .expandIfNeeded (len (d ));
if _gaf ._gca ==0{return _gaf .writeFullBytes (d ),nil ;};return _gaf .writeShiftedBytes (d ),nil ;};func (_db *Reader )Reset (){_db ._bcgc =_db ._ebf ;_db ._fe =_db ._de ;_db ._ca =_db ._bab ;_db ._gafg =_db ._fcg ;};func (_fd *BufferedWriter )FinishByte (){if _fd ._gca ==0{return ;
};_fd ._gca =0;_fd ._eb ++;};func (_da *Writer )Data ()[]byte {return _da ._gf };func (_ege *Writer )byteCapacity ()int {_eeg :=len (_ege ._gf )-_ege ._acfc ;if _ege ._bee !=0{_eeg --;};return _eeg ;};func (_aeg *Reader )ReadBit ()(_cgd int ,_fcge error ){_bf ,_fcge :=_aeg .readBool ();
if _fcge !=nil {return 0,_fcge ;};if _bf {_cgd =1;};return _cgd ,nil ;};type readerSource struct{_aad []byte ;_aedb int ;_eg int ;};func (_bcgf *Reader )read (_ddc []byte )(int ,error ){if _bcgf ._bcgc >=int64 (_bcgf ._fc ._eg ){return 0,_f .EOF ;};_bcgf ._bca =-1;
_bcc :=copy (_ddc ,_bcgf ._fc ._aad [(int64 (_bcgf ._fc ._aedb )+_bcgf ._bcgc ):(_bcgf ._fc ._aedb +_bcgf ._fc ._eg )]);_bcgf ._bcgc +=int64 (_bcc );return _bcc ,nil ;};func (_eeb *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_ff .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_eeb ._fc ._aedb +offset ;};if length > 0{_gea :=len (_eeb ._fc ._aad );if relative {_gea =_eeb ._fc ._eg ;};if offset +length > _gea {return nil ,_c .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_eeb ._fc ._eg );
};};if length < 0{_gce :=len (_eeb ._fc ._aad );if relative {_gce =_eeb ._fc ._eg ;};length =_gce -offset ;};return &Reader {_fc :readerSource {_aad :_eeb ._fc ._aad ,_eg :length ,_aedb :offset }},nil ;};func (_edc *Reader )ReadBool ()(bool ,error ){return _edc .readBool ()};
func (_acf *Reader )Length ()uint64 {return uint64 (_acf ._fc ._eg )};type StreamReader interface{_f .Reader ;_f .ByteReader ;_f .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_eda byte )(uint64 ,error );
ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};type BinaryWriter interface{BitWriter ;_f .Writer ;_f .ByteWriter ;Data ()[]byte ;};func (_bbc *Reader )RelativePosition ()int64 {return _bbc ._bcgc };func (_aae *BufferedWriter )tryGrowByReslice (_gaff int )bool {if _fb :=len (_aae ._dc );
_gaff <=cap (_aae ._dc )-_fb {_aae ._dc =_aae ._dc [:_fb +_gaff ];return true ;};return false ;};type Reader struct{_fc readerSource ;_ca byte ;_fe byte ;_bcgc int64 ;_gafg int ;_bca int ;_ebf int64 ;_de byte ;_bab byte ;_fcg int ;};type Writer struct{_gf []byte ;
_bee uint8 ;_acfc int ;_aaed bool ;};func (_cdb *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cdb ._bca =-1;_cdb ._fe =0;_cdb ._ca =0;_cdb ._gafg =0;var _beca int64 ;switch whence {case _f .SeekStart :_beca =offset ;case _f .SeekCurrent :_beca =_cdb ._bcgc +offset ;
case _f .SeekEnd :_beca =int64 (_cdb ._fc ._eg )+offset ;default:return 0,_ff .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _beca < 0{return 0,_ff .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cdb ._bcgc =_beca ;
_cdb ._fe =0;return _beca ,nil ;};func (_gcb *BufferedWriter )byteCapacity ()int {_bcd :=len (_gcb ._dc )-_gcb ._eb ;if _gcb ._gca !=0{_bcd --;};return _bcd ;};func (_ad *BufferedWriter )WriteBits (bits uint64 ,number int )(_ba int ,_bag error ){const _gb ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_a .Errorf (_gb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_bc :=number /8;if _bc > 0{_fdg :=number -_bc *8;for _aa :=_bc -1;_aa >=0;_aa --{_add :=byte ((bits >>uint (_aa *8+_fdg ))&0xff);if _bag =_ad .WriteByte (_add );_bag !=nil {return _ba ,_a .Wrapf (_bag ,_gb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bc -_aa +1);
};};number -=_bc *8;if number ==0{return _bc ,nil ;};};var _ggg int ;for _ggf :=0;_ggf < number ;_ggf ++{if _ad ._ac {_ggg =int ((bits >>uint (number -1-_ggf ))&0x1);}else {_ggg =int (bits &0x1);bits >>=1;};if _bag =_ad .WriteBit (_ggg );_bag !=nil {return _ba ,_a .Wrapf (_bag ,_gb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ggf );
};};return _bc ,nil ;};func (_gd *BufferedWriter )writeFullBytes (_gad []byte )int {_af :=copy (_gd ._dc [_gd .fullOffset ():],_gad );_gd ._eb +=_af ;return _af ;};func (_gdc *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _gdc .writeBit (uint8 (bit ));
};return _a .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ac :true }};var _ _f .ByteWriter =&BufferedWriter {};
var (_ _f .Reader =&Reader {};_ _f .ByteReader =&Reader {};_ _f .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_dde *Writer )SkipBits (skip int )error {const _geg ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_bfc :=int (_dde ._bee )+skip ;if _bfc >=0&&_bfc < 8{_dde ._bee =uint8 (_bfc );return nil ;};_bfc =int (_dde ._bee )+_dde ._acfc *8+skip ;if _bfc < 0{return _a .Errorf (_geg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_cea :=_bfc /8;_daa :=_bfc %8;_e .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_e .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dde ._bee ,_dde ._acfc ,int (_dde ._bee )+(_dde ._acfc )*8,len (_dde ._gf ),cap (_dde ._gf ));
_e .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_bfc ,_daa );_dde ._bee =uint8 (_daa );if _cgf :=_cea -_dde ._acfc ;
_cgf > 0&&len (_dde ._gf )-1< _cea {_e .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cgf );return _a .Errorf (_geg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dde ._acfc =_cea ;
_e .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dde ._bee ,_dde ._acfc );return nil ;};func (_bb *Reader )ReadByte ()(byte ,error ){if _bb ._fe ==0{return _bb .readBufferByte ();
};return _bb .readUnalignedByte ();};func (_aaag *Reader )Mark (){_aaag ._ebf =_aaag ._bcgc ;_aaag ._de =_aaag ._fe ;_aaag ._bab =_aaag ._ca ;_aaag ._fcg =_aaag ._gafg ;};func (_edb *Reader )readBufferByte ()(byte ,error ){if _edb ._bcgc >=int64 (_edb ._fc ._eg ){return 0,_f .EOF ;
};_edb ._bca =-1;_cdbe :=_edb ._fc ._aad [int64 (_edb ._fc ._aedb )+_edb ._bcgc ];_edb ._bcgc ++;_edb ._gafg =int (_cdbe );return _cdbe ,nil ;};func (_cb *BufferedWriter )fullOffset ()int {_ea :=_cb ._eb ;if _cb ._gca !=0{_ea ++;};return _ea ;};func (_fad *Reader )readUnalignedByte ()(_afgf byte ,_bea error ){_cfc :=_fad ._fe ;
_afgf =_fad ._ca <<(8-_cfc );_fad ._ca ,_bea =_fad .readBufferByte ();if _bea !=nil {return 0,_bea ;};_afgf |=_fad ._ca >>_cfc ;_fad ._ca &=1<<_cfc -1;return _afgf ,nil ;};type BitWriter interface{WriteBit (_gcd int )error ;WriteBits (_eea uint64 ,_aef int )(_ed int ,_eec error );
FinishByte ();SkipBits (_ebd int )error ;};func (_dfe *Reader )readBool ()(_cac bool ,_fbb error ){if _dfe ._fe ==0{_dfe ._ca ,_fbb =_dfe .readBufferByte ();if _fbb !=nil {return false ,_fbb ;};_cac =(_dfe ._ca &0x80)!=0;_dfe ._ca ,_dfe ._fe =_dfe ._ca &0x7f,7;
return _cac ,nil ;};_dfe ._fe --;_cac =(_dfe ._ca &(1<<_dfe ._fe ))!=0;_dfe ._ca &=1<<_dfe ._fe -1;return _cac ,nil ;};var _ BinaryWriter =&BufferedWriter {};func (_ge *BufferedWriter )Len ()int {return _ge .byteCapacity ()};func (_aede *Writer )writeBit (_fff uint8 )error {if len (_aede ._gf )-1< _aede ._acfc {return _f .EOF ;
};_feb :=_aede ._bee ;if _aede ._aaed {_feb =7-_aede ._bee ;};_aede ._gf [_aede ._acfc ]|=byte (uint16 (_fff <<_feb )&0xff);_aede ._bee ++;if _aede ._bee ==8{_aede ._acfc ++;_aede ._bee =0;};return nil ;};func (_ce *BufferedWriter )Reset (){_ce ._dc =_ce ._dc [:0];
_ce ._eb =0;_ce ._gca =0};func (_acb *BufferedWriter )expandIfNeeded (_dg int ){if !_acb .tryGrowByReslice (_dg ){_acb .grow (_dg );};};var _ BinaryWriter =&Writer {};func NewWriter (data []byte )*Writer {return &Writer {_gf :data }};func (_bda *Writer )Write (p []byte )(int ,error ){if len (p )> _bda .byteCapacity (){return 0,_f .EOF ;
};for _ ,_gcaa :=range p {if _bbg :=_bda .writeByte (_gcaa );_bbg !=nil {return 0,_bbg ;};};return len (p ),nil ;};const (_b =64;_be =int (^uint (0)>>1););func (_df *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _a .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_df ._dc )-1< _df ._eb {_df .expandIfNeeded (1);};_ae :=_df ._gca ;if _df ._ac {_ae =7-_df ._gca ;};_df ._dc [_df ._eb ]|=byte (uint16 (bit <<_ae )&0xff);_df ._gca ++;if _df ._gca ==8{_df ._eb ++;_df ._gca =0;};return nil ;};func (_fa *BufferedWriter )writeShiftedBytes (_bcg []byte )int {for _ ,_aed :=range _bcg {_fa .writeByte (_aed );
};return len (_bcg );};func NewReader (data []byte )*Reader {return &Reader {_fc :readerSource {_aad :data ,_eg :len (data ),_aedb :0}};};type BufferedWriter struct{_dc []byte ;_gca uint8 ;_eb int ;_ac bool ;};func (_fg *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _fg ._fe !=0{return _fg .ReadBits (_fg ._fe );
};return 0,nil ;};func (_fgc *Reader )ReadUint32 ()(uint32 ,error ){_cgdd :=make ([]byte ,4);_ ,_aeb :=_fgc .Read (_cgdd );if _aeb !=nil {return 0,_aeb ;};return _g .BigEndian .Uint32 (_cgdd ),nil ;};func (_geb *BufferedWriter )WriteByte (bt byte )error {if _geb ._eb > len (_geb ._dc )-1||(_geb ._eb ==len (_geb ._dc )-1&&_geb ._gca !=0){_geb .expandIfNeeded (1);
};_geb .writeByte (bt );return nil ;};func (_fbed *Writer )FinishByte (){if _fbed ._bee ==0{return ;};_fbed ._bee =0;_fbed ._acfc ++;};func (_adea *Writer )writeByte (_cfd byte )error {if _adea ._acfc > len (_adea ._gf )-1{return _f .EOF ;};if _adea ._acfc ==len (_adea ._gf )-1&&_adea ._bee !=0{return _f .EOF ;
};if _adea ._bee ==0{_adea ._gf [_adea ._acfc ]=_cfd ;_adea ._acfc ++;return nil ;};if _adea ._aaed {_adea ._gf [_adea ._acfc ]|=_cfd >>_adea ._bee ;_adea ._acfc ++;_adea ._gf [_adea ._acfc ]=byte (uint16 (_cfd )<<(8-_adea ._bee )&0xff);}else {_adea ._gf [_adea ._acfc ]|=byte (uint16 (_cfd )<<_adea ._bee &0xff);
_adea ._acfc ++;_adea ._gf [_adea ._acfc ]=_cfd >>(8-_adea ._bee );};return nil ;};func (_bec *Reader )ReadBits (n byte )(_fcd uint64 ,_age error ){if n < _bec ._fe {_cbb :=_bec ._fe -n ;_fcd =uint64 (_bec ._ca >>_cbb );_bec ._ca &=1<<_cbb -1;_bec ._fe =_cbb ;
return _fcd ,nil ;};if n > _bec ._fe {if _bec ._fe > 0{_fcd =uint64 (_bec ._ca );n -=_bec ._fe ;};for n >=8{_fbf ,_afg :=_bec .readBufferByte ();if _afg !=nil {return 0,_afg ;};_fcd =_fcd <<8+uint64 (_fbf );n -=8;};if n > 0{if _bec ._ca ,_age =_bec .readBufferByte ();
_age !=nil {return 0,_age ;};_bgf :=8-n ;_fcd =_fcd <<n +uint64 (_bec ._ca >>_bgf );_bec ._ca &=1<<_bgf -1;_bec ._fe =_bgf ;}else {_bec ._fe =0;};return _fcd ,nil ;};_bec ._fe =0;return uint64 (_bec ._ca ),nil ;};var _ _f .Writer =&BufferedWriter {};func (_ffe *Reader )BitPosition ()int {return int (_ffe ._fe )};
