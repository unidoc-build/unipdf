//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_b "errors";_a "github.com/unidoc/unipdf/v3/common";_ba "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_fd *Reader )ReadBit ()(_fda int ,_bbf error ){_bgf ,_bbf :=_fd .readBool ();if _bbf !=nil {return 0,_bbf ;};if _bgf {_fda =1;};return _fda ,nil ;};func (_aafd *Reader )Read (p []byte )(_aaff int ,_gcb error ){if _aafd ._baab ==0{return _aafd .read (p );};for ;_aaff < len (p );_aaff ++{if p [_aaff ],_gcb =_aafd .readUnalignedByte ();_gcb !=nil {return 0,_gcb ;};};return _aaff ,nil ;};func (_daf *Writer )Write (p []byte )(int ,error ){if len (p )> _daf .byteCapacity (){return 0,_c .EOF ;};for _ ,_gbd :=range p {if _ded :=_daf .writeByte (_gbd );_ded !=nil {return 0,_ded ;};};return len (p ),nil ;};func (_bf *Reader )ConsumeRemainingBits (){if _bf ._baab !=0{_ ,_bbd :=_bf .ReadBits (_bf ._baab );if _bbd !=nil {_a .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_bbd );};};};func NewWriter (data []byte )*Writer {return &Writer {_badf :data }};func (_cgd *SubstreamReader )ReadBit ()(_gd int ,_agc error ){_dggg ,_agc :=_cgd .readBool ();if _agc !=nil {return 0,_agc ;};if _dggg {_gd =1;};return _gd ,nil ;};func (_fdc *Reader )ReadUint32 ()(uint32 ,error ){_dca :=make ([]byte ,4);_ ,_aef :=_fdc .Read (_dca );if _aef !=nil {return 0,_aef ;};return _f .BigEndian .Uint32 (_dca ),nil ;};func (_bbg *SubstreamReader )ReadBits (n byte )(_dbf uint64 ,_dea error ){if n < _bbg ._eeac {_aeg :=_bbg ._eeac -n ;_dbf =uint64 (_bbg ._aagg >>_aeg );_bbg ._aagg &=1<<_aeg -1;_bbg ._eeac =_aeg ;return _dbf ,nil ;};if n > _bbg ._eeac {if _bbg ._eeac > 0{_dbf =uint64 (_bbg ._aagg );n -=_bbg ._eeac ;};var _eef byte ;for n >=8{_eef ,_dea =_bbg .readBufferByte ();if _dea !=nil {return 0,_dea ;};_dbf =_dbf <<8+uint64 (_eef );n -=8;};if n > 0{if _bbg ._aagg ,_dea =_bbg .readBufferByte ();_dea !=nil {return 0,_dea ;};_gb :=8-n ;_dbf =_dbf <<n +uint64 (_bbg ._aagg >>_gb );_bbg ._aagg &=1<<_gb -1;_bbg ._eeac =_gb ;}else {_bbg ._eeac =0;};return _dbf ,nil ;};_bbg ._eeac =0;return uint64 (_bbg ._aagg ),nil ;};func (_ed *BufferedWriter )WriteByte (bt byte )error {if _ed ._bad > len (_ed ._g )-1||(_ed ._bad ==len (_ed ._g )-1&&_ed ._ae !=0){_ed .expandIfNeeded (1);};_ed .writeByte (bt );return nil ;};type SubstreamReader struct{_gaa uint64 ;_gac StreamReader ;_gcbe uint64 ;_cfg uint64 ;_fcd []byte ;_dbc uint64 ;_dcb uint64 ;_aagg byte ;_eeac byte ;_fa uint64 ;_eba byte ;};type BinaryWriter interface{BitWriter ;_c .Writer ;_c .ByteWriter ;Data ()[]byte ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_badf :data ,_bgc :true }};func (_gfe *Reader )ReadByte ()(byte ,error ){if _gfe ._baab ==0{return _gfe .readBufferByte ();};return _gfe .readUnalignedByte ();};func (_dgc *Writer )WriteBits (bits uint64 ,number int )(_gfef int ,_gef error ){const _ccbe ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_ba .Errorf (_ccbe ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_aba :=number /8;if _aba > 0{_ebb :=number -_aba *8;for _dbg :=_aba -1;_dbg >=0;_dbg --{_ecb :=byte ((bits >>uint (_dbg *8+_ebb ))&0xff);if _gef =_dgc .WriteByte (_ecb );_gef !=nil {return _gfef ,_ba .Wrapf (_gef ,_ccbe ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_aba -_dbg +1);};};number -=_aba *8;if number ==0{return _aba ,nil ;};};var _bcc int ;for _ffdf :=0;_ffdf < number ;_ffdf ++{if _dgc ._bgc {_bcc =int ((bits >>uint (number -1-_ffdf ))&0x1);}else {_bcc =int (bits &0x1);bits >>=1;};if _gef =_dgc .WriteBit (_bcc );_gef !=nil {return _gfef ,_ba .Wrapf (_gef ,_ccbe ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ffdf );};};return _aba ,nil ;};const (_aa =64;_dc =int (^uint (0)>>1););var _ _c .ByteWriter =&BufferedWriter {};func (_efa *Reader )BitPosition ()int {return int (_efa ._baab )};func (_gg *BufferedWriter )ResetBitIndex (){_gg ._ae =0};var _ BinaryWriter =&Writer {};func (_bac *Reader )StreamPosition ()int64 {return _bac ._feb };func (_dag *Reader )readBufferByte ()(byte ,error ){if _dag ._feb >=int64 (len (_dag ._bc )){return 0,_c .EOF ;};_dag ._ee =-1;_defa :=_dag ._bc [_dag ._feb ];_dag ._feb ++;_dag ._fba =int (_defa );return _defa ,nil ;};func (_dg *BufferedWriter )Reset (){_dg ._g =_dg ._g [:0];_dg ._bad =0;_dg ._ae =0};func (_dgd *Writer )writeBit (_bgd uint8 )error {if len (_dgd ._badf )-1< _dgd ._bee {return _c .EOF ;};_ced :=_dgd ._geag ;if _dgd ._bgc {_ced =7-_dgd ._geag ;};_dgd ._badf [_dgd ._bee ]|=byte (uint16 (_bgd <<_ced )&0xff);_dgd ._geag ++;if _dgd ._geag ==8{_dgd ._bee ++;_dgd ._geag =0;};return nil ;};func (_afg *SubstreamReader )Read (b []byte )(_faa int ,_fga error ){if _afg ._gaa >=_afg ._cfg {_a .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_afg ._gaa ,_afg ._cfg );return 0,_c .EOF ;};for ;_faa < len (b );_faa ++{if b [_faa ],_fga =_afg .readUnalignedByte ();_fga !=nil {if _fga ==_c .EOF {return _faa ,nil ;};return 0,_fga ;};};return _faa ,nil ;};func (_dcd *SubstreamReader )readBufferByte ()(byte ,error ){if _dcd ._gaa >=_dcd ._cfg {return 0,_c .EOF ;};if _dcd ._gaa >=_dcd ._dcb ||_dcd ._gaa < _dcd ._dbc {if _gdg :=_dcd .fillBuffer ();_gdg !=nil {return 0,_gdg ;};};_eeb :=_dcd ._fcd [_dcd ._gaa -_dcd ._dbc ];_dcd ._gaa ++;return _eeb ,nil ;};func (_gfed *Writer )writeByte (_cdce byte )error {if _gfed ._bee > len (_gfed ._badf )-1{return _c .EOF ;};if _gfed ._bee ==len (_gfed ._badf )-1&&_gfed ._geag !=0{return _c .EOF ;};if _gfed ._geag ==0{_gfed ._badf [_gfed ._bee ]=_cdce ;_gfed ._bee ++;return nil ;};if _gfed ._bgc {_gfed ._badf [_gfed ._bee ]|=_cdce >>_gfed ._geag ;_gfed ._bee ++;_gfed ._badf [_gfed ._bee ]=byte (uint16 (_cdce )<<(8-_gfed ._geag )&0xff);}else {_gfed ._badf [_gfed ._bee ]|=byte (uint16 (_cdce )<<_gfed ._geag &0xff);_gfed ._bee ++;_gfed ._badf [_gfed ._bee ]=_cdce >>(8-_gfed ._geag );};return nil ;};func (_eg *BufferedWriter )WriteBits (bits uint64 ,number int )(_adc int ,_cce error ){const _ac ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ba .Errorf (_ac ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_ef :=number /8;if _ef > 0{_ag :=number -_ef *8;for _gcc :=_ef -1;_gcc >=0;_gcc --{_cb :=byte ((bits >>uint (_gcc *8+_ag ))&0xff);if _cce =_eg .WriteByte (_cb );_cce !=nil {return _adc ,_ba .Wrapf (_cce ,_ac ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ef -_gcc +1);};};number -=_ef *8;if number ==0{return _ef ,nil ;};};var _ada int ;for _ec :=0;_ec < number ;_ec ++{if _eg ._df {_ada =int ((bits >>uint (number -1-_ec ))&0x1);}else {_ada =int (bits &0x1);bits >>=1;};if _cce =_eg .WriteBit (_ada );_cce !=nil {return _adc ,_ba .Wrapf (_cce ,_ac ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ec );};};return _ef ,nil ;};func (_bga *Reader )Length ()uint64 {return uint64 (len (_bga ._bc ))};func (_gce *Reader )ReadBits (n byte )(_bdb uint64 ,_db error ){if n < _gce ._baab {_ccfc :=_gce ._baab -n ;_bdb =uint64 (_gce ._ccc >>_ccfc );_gce ._ccc &=1<<_ccfc -1;_gce ._baab =_ccfc ;return _bdb ,nil ;};if n > _gce ._baab {if _gce ._baab > 0{_bdb =uint64 (_gce ._ccc );n -=_gce ._baab ;};for n >=8{_dgf ,_aae :=_gce .readBufferByte ();if _aae !=nil {return 0,_aae ;};_bdb =_bdb <<8+uint64 (_dgf );n -=8;};if n > 0{if _gce ._ccc ,_db =_gce .readBufferByte ();_db !=nil {return 0,_db ;};_ab :=8-n ;_bdb =_bdb <<n +uint64 (_gce ._ccc >>_ab );_gce ._ccc &=1<<_ab -1;_gce ._baab =_ab ;}else {_gce ._baab =0;};return _bdb ,nil ;};_gce ._baab =0;return uint64 (_gce ._ccc ),nil ;};func (_eb *BufferedWriter )tryGrowByReslice (_bd int )bool {if _beg :=len (_eb ._g );_bd <=cap (_eb ._g )-_beg {_eb ._g =_eb ._g [:_beg +_bd ];return true ;};return false ;};type BufferedWriter struct{_g []byte ;_ae uint8 ;_bad int ;_df bool ;};var _ _c .Writer =&BufferedWriter {};func (_de *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ba .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_de ._g )-1< _de ._bad {_de .expandIfNeeded (1);};_cf :=_de ._ae ;if _de ._df {_cf =7-_de ._ae ;};_de ._g [_de ._bad ]|=byte (uint16 (bit <<_cf )&0xff);_de ._ae ++;if _de ._ae ==8{_de ._bad ++;_de ._ae =0;};return nil ;};func (_dcba *SubstreamReader )Length ()uint64 {return _dcba ._cfg };func (_geg *Writer )Data ()[]byte {return _geg ._badf };func (_fb *BufferedWriter )expandIfNeeded (_ge int ){if !_fb .tryGrowByReslice (_ge ){_fb .grow (_ge );};};func (_dab *Reader )readBool ()(_gggf bool ,_ecc error ){if _dab ._baab ==0{_dab ._ccc ,_ecc =_dab .readBufferByte ();if _ecc !=nil {return false ,_ecc ;};_gggf =(_dab ._ccc &0x80)!=0;_dab ._ccc ,_dab ._baab =_dab ._ccc &0x7f,7;return _gggf ,nil ;};_dab ._baab --;_gggf =(_dab ._ccc &(1<<_dab ._baab ))!=0;_dab ._ccc &=1<<_dab ._baab -1;return _gggf ,nil ;};func (_ccf *BufferedWriter )writeByte (_da byte ){switch {case _ccf ._ae ==0:_ccf ._g [_ccf ._bad ]=_da ;_ccf ._bad ++;case _ccf ._df :_ccf ._g [_ccf ._bad ]|=_da >>_ccf ._ae ;_ccf ._bad ++;_ccf ._g [_ccf ._bad ]=byte (uint16 (_da )<<(8-_ccf ._ae )&0xff);default:_ccf ._g [_ccf ._bad ]|=byte (uint16 (_da )<<_ccf ._ae &0xff);_ccf ._bad ++;_ccf ._g [_ccf ._bad ]=_da >>(8-_ccf ._ae );};};func (_bdg *SubstreamReader )Offset ()uint64 {return _bdg ._gcbe };type BitWriter interface{WriteBit (_bg int )error ;WriteBits (_gccb uint64 ,_defg int )(_aag int ,_fec error );FinishByte ();SkipBits (_aafg int )error ;};func (_cd *BufferedWriter )Data ()[]byte {return _cd ._g };var (_ _c .Reader =&Reader {};_ _c .ByteReader =&Reader {};_ _c .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_af *BufferedWriter )byteCapacity ()int {_dgb :=len (_af ._g )-_af ._bad ;if _af ._ae !=0{_dgb --;};return _dgb ;};type Reader struct{_bc []byte ;_ccc byte ;_baab byte ;_feb int64 ;_fba int ;_ee int ;_dd int64 ;_ggg byte ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_b .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_a .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_gac :r ,_gcbe :offset ,_cfg :length ,_fcd :make ([]byte ,length )},nil ;};func (_fbf *Reader )readUnalignedByte ()(_dfbf byte ,_bba error ){_ggag :=_fbf ._baab ;_dfbf =_fbf ._ccc <<(8-_ggag );_fbf ._ccc ,_bba =_fbf .readBufferByte ();if _bba !=nil {return 0,_bba ;};_dfbf |=_fbf ._ccc >>_ggag ;_fbf ._ccc &=1<<_ggag -1;return _dfbf ,nil ;};func (_gf *Reader )Mark (){_gf ._dd =_gf ._feb ;_gf ._ggg =_gf ._baab };type StreamReader interface{_c .Reader ;_c .ByteReader ;_c .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_geb *BufferedWriter )grow (_fe int ){if _geb ._g ==nil &&_fe < _aa {_geb ._g =make ([]byte ,_fe ,_aa );return ;};_ega :=len (_geb ._g );if _geb ._ae !=0{_ega ++;};_gee :=cap (_geb ._g );switch {case _fe <=_gee /2-_ega :_a .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_geb ._g ),cap (_geb ._g ),_fe );_a .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_gee ,_ega );copy (_geb ._g ,_geb ._g [_geb .fullOffset ():]);case _gee > _dc -_gee -_fe :_a .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_dee :=make ([]byte ,2*_gee +_fe );copy (_dee ,_geb ._g );_geb ._g =_dee ;};_geb ._g =_geb ._g [:_ega +_fe ];};func (_eec *Writer )SkipBits (skip int )error {const _bcd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ggc :=int (_eec ._geag )+skip ;if _ggc >=0&&_ggc < 8{_eec ._geag =uint8 (_ggc );return nil ;};_ggc =int (_eec ._geag )+_eec ._bee *8+skip ;if _ggc < 0{return _ba .Errorf (_bcd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_adcb :=_ggc /8;_abc :=_ggc %8;_a .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_a .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_eec ._geag ,_eec ._bee ,int (_eec ._geag )+(_eec ._bee )*8,len (_eec ._badf ),cap (_eec ._badf ));_a .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ggc ,_abc );_eec ._geag =uint8 (_abc );if _gfc :=_adcb -_eec ._bee ;_gfc > 0&&len (_eec ._badf )-1< _adcb {_a .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gfc );return _ba .Errorf (_bcd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_eec ._bee =_adcb ;_a .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_eec ._geag ,_eec ._bee );return nil ;};func (_def *BufferedWriter )fullOffset ()int {_ce :=_def ._bad ;if _def ._ae !=0{_ce ++;};return _ce ;};func (_fdd *SubstreamReader )Mark (){_fdd ._fa =_fdd ._gaa ;_fdd ._eba =_fdd ._eeac };func (_acb *Writer )byteCapacity ()int {_aca :=len (_acb ._badf )-_acb ._bee ;if _acb ._geag !=0{_aca --;};return _aca ;};func (_dfe *Writer )ResetBit (){_dfe ._geag =0};func (_cdcb *Reader )ReadBool ()(bool ,error ){return _cdcb .readBool ()};func (_ccbg *Writer )FinishByte (){if _ccbg ._geag ==0{return ;};_ccbg ._geag =0;_ccbg ._bee ++;};func (_afaf *SubstreamReader )ReadUint32 ()(uint32 ,error ){_efd :=make ([]byte ,4);_ ,_bce :=_afaf .Read (_efd );if _bce !=nil {return 0,_bce ;};return _f .BigEndian .Uint32 (_efd ),nil ;};func (_ff *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ff ._ee =-1;var _ddb int64 ;switch whence {case _c .SeekStart :_ddb =offset ;case _c .SeekCurrent :_ddb =_ff ._feb +offset ;case _c .SeekEnd :_ddb =int64 (len (_ff ._bc ))+offset ;default:return 0,_b .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _ddb < 0{return 0,_b .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ff ._feb =_ddb ;_ff ._baab =0;return _ddb ,nil ;};func (_ece *SubstreamReader )BitPosition ()int {return int (_ece ._eeac )};func (_badg *Reader )Reset (){_badg ._feb =_badg ._dd ;_badg ._baab =_badg ._ggg };func (_ffb *SubstreamReader )Reset (){_ffb ._gaa =_ffb ._fa ;_ffb ._eeac =_ffb ._eba };func (_eca *SubstreamReader )StreamPosition ()int64 {return int64 (_eca ._gaa )};func (_ddg *Reader )Align ()(_ede byte ){_ede =_ddg ._baab ;_ddg ._baab =0;return _ede };func (_gc *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_cc :=int (_gc ._ae )+skip ;if _cc >=0&&_cc < 8{_gc ._ae =uint8 (_cc );return nil ;};_cc =int (_gc ._ae )+_gc ._bad *8+skip ;if _cc < 0{return _ba .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_e :=_cc /8;_cdc :=_cc %8;_gc ._ae =uint8 (_cdc );if _be :=_e -_gc ._bad ;_be > 0&&len (_gc ._g )-1< _e {if _gc ._ae !=0{_be ++;};_gc .expandIfNeeded (_be );};_gc ._bad =_e ;return nil ;};func (_cg *SubstreamReader )Align ()(_dgg byte ){_dgg =_cg ._eeac ;_cg ._eeac =0;return _dgg };func (_fc *BufferedWriter )writeFullBytes (_adbc []byte )int {_dfb :=copy (_fc ._g [_fc .fullOffset ():],_adbc );_fc ._bad +=_dfb ;return _dfb ;};func NewReader (data []byte )*Reader {return &Reader {_bc :data }};func (_bgad *SubstreamReader )ReadByte ()(byte ,error ){if _bgad ._eeac ==0{return _bgad .readBufferByte ();};return _bgad .readUnalignedByte ();};func (_cec *Reader )read (_cdf []byte )(int ,error ){if _cec ._feb >=int64 (len (_cec ._bc )){return 0,_c .EOF ;};_cec ._ee =-1;_dde :=copy (_cdf ,_cec ._bc [_cec ._feb :]);_cec ._feb +=int64 (_dde );return _dde ,nil ;};func (_fdf *SubstreamReader )readBool ()(_ffd bool ,_efc error ){if _fdf ._eeac ==0{_fdf ._aagg ,_efc =_fdf .readBufferByte ();if _efc !=nil {return false ,_efc ;};_ffd =(_fdf ._aagg &0x80)!=0;_fdf ._aagg ,_fdf ._eeac =_fdf ._aagg &0x7f,7;return _ffd ,nil ;};_fdf ._eeac --;_ffd =(_fdf ._aagg &(1<<_fdf ._eeac ))!=0;_fdf ._aagg &=1<<_fdf ._eeac -1;return _ffd ,nil ;};type Writer struct{_badf []byte ;_geag uint8 ;_bee int ;_bgc bool ;};func (_ebd *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ebd .writeBit (uint8 (bit ));};return _ba .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_ga *BufferedWriter )Len ()int {return _ga .byteCapacity ()};var _ BinaryWriter =&BufferedWriter {};func (_ddgf *Writer )UseMSB ()bool {return _ddgf ._bgc };func (_geaf *Writer )WriteByte (c byte )error {return _geaf .writeByte (c )};func _cbb (_fff ,_dcc uint64 )uint64 {if _fff < _dcc {return _fff ;};return _dcc ;};func (_ccb *SubstreamReader )fillBuffer ()error {if uint64 (_ccb ._gac .StreamPosition ())!=_ccb ._gaa +_ccb ._gcbe {_ ,_gae :=_ccb ._gac .Seek (int64 (_ccb ._gaa +_ccb ._gcbe ),_c .SeekStart );if _gae !=nil {return _gae ;};};_ccb ._dbc =_ccb ._gaa ;_bde :=_cbb (uint64 (len (_ccb ._fcd )),_ccb ._cfg -_ccb ._gaa );_eda :=make ([]byte ,_bde );_gea ,_fcc :=_ccb ._gac .Read (_eda );if _fcc !=nil {return _fcc ;};for _egc :=uint64 (0);_egc < _bde ;_egc ++{_ccb ._fcd [_egc ]=_eda [_egc ];};_ccb ._dcb =_ccb ._dbc +uint64 (_gea );return nil ;};func (_aee *SubstreamReader )ReadBool ()(bool ,error ){return _aee .readBool ()};func (_baa *BufferedWriter )writeShiftedBytes (_fbd []byte )int {for _ ,_afa :=range _fbd {_baa .writeByte (_afa );};return len (_fbd );};func (_ad *BufferedWriter )FinishByte (){if _ad ._ae ==0{return ;};_ad ._ae =0;_ad ._bad ++;};func (_gfa *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _c .SeekStart :_gfa ._gaa =uint64 (offset );case _c .SeekCurrent :_gfa ._gaa +=uint64 (offset );case _c .SeekEnd :_gfa ._gaa =_gfa ._cfg +uint64 (offset );default:return 0,_b .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_gfa ._eeac =0;return int64 (_gfa ._gaa ),nil ;};func (_gbb *SubstreamReader )readUnalignedByte ()(_ceg byte ,_fac error ){_dfg :=_gbb ._eeac ;_ceg =_gbb ._aagg <<(8-_dfg );_gbb ._aagg ,_fac =_gbb .readBufferByte ();if _fac !=nil {return 0,_fac ;};_ceg |=_gbb ._aagg >>_dfg ;_gbb ._aagg &=1<<_dfg -1;return _ceg ,nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_df :true }};func (_aaf *BufferedWriter )Write (d []byte )(int ,error ){_aaf .expandIfNeeded (len (d ));if _aaf ._ae ==0{return _aaf .writeFullBytes (d ),nil ;};return _aaf .writeShiftedBytes (d ),nil ;};