//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_d "encoding/binary";_cb "errors";_cg "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_cacb *SubstreamReader )ReadUint32 ()(uint32 ,error ){_bg :=make ([]byte ,4);_ ,_gdb :=_cacb .Read (_bg );
if _gdb !=nil {return 0,_gdb ;};return _d .BigEndian .Uint32 (_bg ),nil ;};func (_a *BufferedWriter )WriteBits (bits uint64 ,number int )(_cag int ,_fed error ){const _dac ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_g .Errorf (_dac ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_cf :=number /8;if _cf > 0{_caa :=number -_cf *8;for _ad :=_cf -1;_ad >=0;_ad --{_ae :=byte ((bits >>uint (_ad *8+_caa ))&0xff);if _fed =_a .WriteByte (_ae );_fed !=nil {return _cag ,_g .Wrapf (_fed ,_dac ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cf -_ad +1);
};};number -=_cf *8;if number ==0{return _cf ,nil ;};};var _eg int ;for _cgb :=0;_cgb < number ;_cgb ++{if _a ._gf {_eg =int ((bits >>uint (number -1-_cgb ))&0x1);}else {_eg =int (bits &0x1);bits >>=1;};if _fed =_a .WriteBit (_eg );_fed !=nil {return _cag ,_g .Wrapf (_fed ,_dac ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cgb );
};};return _cf ,nil ;};func (_cad *Reader )BitPosition ()int {return int (_cad ._ccgb )};func (_bgbf *Writer )SkipBits (skip int )error {const _bad ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;
};_bcd :=int (_bgbf ._bfbfb )+skip ;if _bcd >=0&&_bcd < 8{_bgbf ._bfbfb =uint8 (_bcd );return nil ;};_bcd =int (_bgbf ._bfbfb )+_bgbf ._efbe *8+skip ;if _bcd < 0{return _g .Errorf (_bad ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ebd :=_bcd /8;_gfdd :=_bcd %8;_cg .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_cg .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bgbf ._bfbfb ,_bgbf ._efbe ,int (_bgbf ._bfbfb )+(_bgbf ._efbe )*8,len (_bgbf ._cea ),cap (_bgbf ._cea ));
_cg .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_bcd ,_gfdd );_bgbf ._bfbfb =uint8 (_gfdd );
if _aed :=_ebd -_bgbf ._efbe ;_aed > 0&&len (_bgbf ._cea )-1< _ebd {_cg .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_aed );return _g .Errorf (_bad ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bgbf ._efbe =_ebd ;_cg .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bgbf ._bfbfb ,_bgbf ._efbe );return nil ;
};type Reader struct{_dge []byte ;_dc byte ;_ccgb byte ;_edb int64 ;_cbg int ;_aae int ;_caf int64 ;_edc byte ;};func (_ece *Reader )Align ()(_db byte ){_db =_ece ._ccgb ;_ece ._ccgb =0;return _db };func (_bdg *Writer )FinishByte (){if _bdg ._bfbfb ==0{return ;
};_bdg ._bfbfb =0;_bdg ._efbe ++;};func (_fgf *SubstreamReader )ReadByte ()(byte ,error ){if _fgf ._cdbd ==0{return _fgf .readBufferByte ();};return _fgf .readUnalignedByte ();};func (_fdec *Writer )writeByte (_dfb byte )error {if _fdec ._efbe > len (_fdec ._cea )-1{return _c .EOF ;
};if _fdec ._efbe ==len (_fdec ._cea )-1&&_fdec ._bfbfb !=0{return _c .EOF ;};if _fdec ._bfbfb ==0{_fdec ._cea [_fdec ._efbe ]=_dfb ;_fdec ._efbe ++;return nil ;};if _fdec ._bcb {_fdec ._cea [_fdec ._efbe ]|=_dfb >>_fdec ._bfbfb ;_fdec ._efbe ++;_fdec ._cea [_fdec ._efbe ]=byte (uint16 (_dfb )<<(8-_fdec ._bfbfb )&0xff);
}else {_fdec ._cea [_fdec ._efbe ]|=byte (uint16 (_dfb )<<_fdec ._bfbfb &0xff);_fdec ._efbe ++;_fdec ._cea [_fdec ._efbe ]=_dfb >>(8-_fdec ._bfbfb );};return nil ;};func (_fae *Reader )ReadBool ()(bool ,error ){return _fae .readBool ()};func (_ca *BufferedWriter )Len ()int {return _ca .byteCapacity ()};
func (_ac *Reader )ReadBit ()(_ge int ,_ecc error ){_dbe ,_ecc :=_ac .readBool ();if _ecc !=nil {return 0,_ecc ;};if _dbe {_ge =1;};return _ge ,nil ;};func (_cade *Reader )StreamPosition ()int64 {return _cade ._edb };func (_ddb *Writer )Data ()[]byte {return _ddb ._cea };
func (_bfg *SubstreamReader )Length ()uint64 {return _bfg ._cdb };func (_fge *Reader )readBool ()(_ebc bool ,_ab error ){if _fge ._ccgb ==0{_fge ._dc ,_ab =_fge .readBufferByte ();if _ab !=nil {return false ,_ab ;};_ebc =(_fge ._dc &0x80)!=0;_fge ._dc ,_fge ._ccgb =_fge ._dc &0x7f,7;
return _ebc ,nil ;};_fge ._ccgb --;_ebc =(_fge ._dc &(1<<_fge ._ccgb ))!=0;_fge ._dc &=1<<_fge ._ccgb -1;return _ebc ,nil ;};func (_eae *BufferedWriter )fullOffset ()int {_cc :=_eae ._bd ;if _eae ._da !=0{_cc ++;};return _cc ;};func (_cae *Reader )Length ()uint64 {return uint64 (len (_cae ._dge ))};
func (_bfd *BufferedWriter )WriteByte (bt byte )error {if _bfd ._bd > len (_bfd ._df )-1||(_bfd ._bd ==len (_bfd ._df )-1&&_bfd ._da !=0){_bfd .expandIfNeeded (1);};_bfd .writeByte (bt );return nil ;};func (_af *BufferedWriter )writeFullBytes (_gbb []byte )int {_ccg :=copy (_af ._df [_af .fullOffset ():],_gbb );
_af ._bd +=_ccg ;return _ccg ;};func (_gfd *SubstreamReader )Align ()(_dgd byte ){_dgd =_gfd ._cdbd ;_gfd ._cdbd =0;return _dgd };func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_gf :true }};func (_efe *SubstreamReader )readBufferByte ()(byte ,error ){if _efe ._bcc >=_efe ._cdb {return 0,_c .EOF ;
};if _efe ._bcc >=_efe ._gbfg ||_efe ._bcc < _efe ._dbg {if _bdcb :=_efe .fillBuffer ();_bdcb !=nil {return 0,_bdcb ;};};_dda :=_efe ._ede [_efe ._bcc -_efe ._dbg ];_efe ._bcc ++;return _dda ,nil ;};func (_ggb *SubstreamReader )ReadBool ()(bool ,error ){return _ggb .readBool ()};
type StreamReader interface{_c .Reader ;_c .ByteReader ;_c .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_de byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();
StreamPosition ()int64 ;};func (_egd *BufferedWriter )byteCapacity ()int {_fab :=len (_egd ._df )-_egd ._bd ;if _egd ._da !=0{_fab --;};return _fab ;};func (_gbgb *SubstreamReader )Reset (){_gbgb ._bcc =_gbgb ._agc ;_gbgb ._cdbd =_gbgb ._gbg };func (_ef *BufferedWriter )FinishByte (){if _ef ._da ==0{return ;
};_ef ._da =0;_ef ._bd ++;};type BitWriter interface{WriteBit (_aa int )error ;WriteBits (_eb uint64 ,_daa int )(_fga int ,_cgf error );FinishByte ();SkipBits (_ga int )error ;};type BufferedWriter struct{_df []byte ;_da uint8 ;_bd int ;_gf bool ;};func NewReader (data []byte )*Reader {return &Reader {_dge :data }};
func (_bae *Reader )read (_afg []byte )(int ,error ){if _bae ._edb >=int64 (len (_bae ._dge )){return 0,_c .EOF ;};_bae ._aae =-1;_gde :=copy (_afg ,_bae ._dge [_bae ._edb :]);_bae ._edb +=int64 (_gde );return _gde ,nil ;};func (_fc *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_cac :=int (_fc ._da )+skip ;if _cac >=0&&_cac < 8{_fc ._da =uint8 (_cac );return nil ;};_cac =int (_fc ._da )+_fc ._bd *8+skip ;if _cac < 0{return _g .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bf :=_cac /8;_be :=_cac %8;_fc ._da =uint8 (_be );if _ea :=_bf -_fc ._bd ;_ea > 0&&len (_fc ._df )-1< _bf {if _fc ._da !=0{_ea ++;};_fc .expandIfNeeded (_ea );};_fc ._bd =_bf ;return nil ;};func (_gba *Reader )Mark (){_gba ._caf =_gba ._edb ;_gba ._edc =_gba ._ccgb };
var _ BinaryWriter =&BufferedWriter {};func (_dbf *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _dbf .writeBit (uint8 (bit ));};return _g .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_dgea *SubstreamReader )ReadBit ()(_fee int ,_gc error ){_gaa ,_gc :=_dgea .readBool ();if _gc !=nil {return 0,_gc ;};if _gaa {_fee =1;};return _fee ,nil ;};type Writer struct{_cea []byte ;_bfbfb uint8 ;_efbe int ;_bcb bool ;};func (_ddbf *Writer )ResetBit (){_ddbf ._bfbfb =0};
func (_fd *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _g .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_fd ._df )-1< _fd ._bd {_fd .expandIfNeeded (1);};_bff :=_fd ._da ;if _fd ._gf {_bff =7-_fd ._da ;};_fd ._df [_fd ._bd ]|=byte (uint16 (bit <<_bff )&0xff);_fd ._da ++;if _fd ._da ==8{_fd ._bd ++;_fd ._da =0;};return nil ;};func (_dde *SubstreamReader )Read (b []byte )(_fac int ,_cefa error ){if _dde ._bcc >=_dde ._cdb {_cg .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_dde ._bcc ,_dde ._cdb );
return 0,_c .EOF ;};for ;_fac < len (b );_fac ++{if b [_fac ],_cefa =_dde .readUnalignedByte ();_cefa !=nil {if _cefa ==_c .EOF {return _fac ,nil ;};return 0,_cefa ;};};return _fac ,nil ;};func (_ddd *SubstreamReader )Offset ()uint64 {return _ddd ._dabc };
func (_dae *Reader )ReadBits (n byte )(_dcb uint64 ,_bca error ){if n < _dae ._ccgb {_fgd :=_dae ._ccgb -n ;_dcb =uint64 (_dae ._dc >>_fgd );_dae ._dc &=1<<_fgd -1;_dae ._ccgb =_fgd ;return _dcb ,nil ;};if n > _dae ._ccgb {if _dae ._ccgb > 0{_dcb =uint64 (_dae ._dc );
n -=_dae ._ccgb ;};for n >=8{_bdc ,_dga :=_dae .readBufferByte ();if _dga !=nil {return 0,_dga ;};_dcb =_dcb <<8+uint64 (_bdc );n -=8;};if n > 0{if _dae ._dc ,_bca =_dae .readBufferByte ();_bca !=nil {return 0,_bca ;};_gg :=8-n ;_dcb =_dcb <<n +uint64 (_dae ._dc >>_gg );
_dae ._dc &=1<<_gg -1;_dae ._ccgb =_gg ;}else {_dae ._ccgb =0;};return _dcb ,nil ;};_dae ._ccgb =0;return uint64 (_dae ._dc ),nil ;};func (_bfb *SubstreamReader )ReadBits (n byte )(_acc uint64 ,_cee error ){if n < _bfb ._cdbd {_cbf :=_bfb ._cdbd -n ;_acc =uint64 (_bfb ._aba >>_cbf );
_bfb ._aba &=1<<_cbf -1;_bfb ._cdbd =_cbf ;return _acc ,nil ;};if n > _bfb ._cdbd {if _bfb ._cdbd > 0{_acc =uint64 (_bfb ._aba );n -=_bfb ._cdbd ;};var _ecd byte ;for n >=8{_ecd ,_cee =_bfb .readBufferByte ();if _cee !=nil {return 0,_cee ;};_acc =_acc <<8+uint64 (_ecd );
n -=8;};if n > 0{if _bfb ._aba ,_cee =_bfb .readBufferByte ();_cee !=nil {return 0,_cee ;};_fgaa :=8-n ;_acc =_acc <<n +uint64 (_bfb ._aba >>_fgaa );_bfb ._aba &=1<<_fgaa -1;_bfb ._cdbd =_fgaa ;}else {_bfb ._cdbd =0;};return _acc ,nil ;};_bfb ._cdbd =0;
return uint64 (_bfb ._aba ),nil ;};func (_beec *Writer )writeBit (_aef uint8 )error {if len (_beec ._cea )-1< _beec ._efbe {return _c .EOF ;};_bffb :=_beec ._bfbfb ;if _beec ._bcb {_bffb =7-_beec ._bfbfb ;};_beec ._cea [_beec ._efbe ]|=byte (uint16 (_aef <<_bffb )&0xff);
_beec ._bfbfb ++;if _beec ._bfbfb ==8{_beec ._efbe ++;_beec ._bfbfb =0;};return nil ;};type SubstreamReader struct{_bcc uint64 ;_dffc StreamReader ;_dabc uint64 ;_cdb uint64 ;_ede []byte ;_dbg uint64 ;_gbfg uint64 ;_aba byte ;_cdbd byte ;_agc uint64 ;_gbg byte ;
};func (_fgc *SubstreamReader )StreamPosition ()int64 {return int64 (_fgc ._bcc )};type BinaryWriter interface{BitWriter ;_c .Writer ;_c .ByteWriter ;Data ()[]byte ;};func (_fcc *BufferedWriter )writeShiftedBytes (_eff []byte )int {for _ ,_ccb :=range _eff {_fcc .writeByte (_ccb );
};return len (_eff );};func (_fad *SubstreamReader )fillBuffer ()error {if uint64 (_fad ._dffc .StreamPosition ())!=_fad ._bcc +_fad ._dabc {_ ,_afgd :=_fad ._dffc .Seek (int64 (_fad ._bcc +_fad ._dabc ),_c .SeekStart );if _afgd !=nil {return _afgd ;};
};_fad ._dbg =_fad ._bcc ;_afga :=_egde (uint64 (len (_fad ._ede )),_fad ._cdb -_fad ._bcc );_cafg :=make ([]byte ,_afga );_efb ,_eaed :=_fad ._dffc .Read (_cafg );if _eaed !=nil {return _eaed ;};for _bgb :=uint64 (0);_bgb < _afga ;_bgb ++{_fad ._ede [_bgb ]=_cafg [_bgb ];
};_fad ._gbfg =_fad ._dbg +uint64 (_efb );return nil ;};func (_ccbe *SubstreamReader )BitPosition ()int {return int (_ccbe ._cdbd )};func (_dab *Reader )ReadUint32 ()(uint32 ,error ){_eac :=make ([]byte ,4);_ ,_dged :=_dab .Read (_eac );if _dged !=nil {return 0,_dged ;
};return _d .BigEndian .Uint32 (_eac ),nil ;};func (_fe *BufferedWriter )ResetBitIndex (){_fe ._da =0};func NewWriter (data []byte )*Writer {return &Writer {_cea :data }};func (_acg *Writer )WriteBits (bits uint64 ,number int )(_aad int ,_gec error ){const _fde ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_g .Errorf (_fde ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_fadg :=number /8;if _fadg > 0{_bab :=number -_fadg *8;for _baec :=_fadg -1;_baec >=0;_baec --{_gcf :=byte ((bits >>uint (_baec *8+_bab ))&0xff);if _gec =_acg .WriteByte (_gcf );_gec !=nil {return _aad ,_g .Wrapf (_gec ,_fde ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fadg -_baec +1);
};};number -=_fadg *8;if number ==0{return _fadg ,nil ;};};var _cfb int ;for _fec :=0;_fec < number ;_fec ++{if _acg ._bcb {_cfb =int ((bits >>uint (number -1-_fec ))&0x1);}else {_cfb =int (bits &0x1);bits >>=1;};if _gec =_acg .WriteBit (_cfb );_gec !=nil {return _aad ,_g .Wrapf (_gec ,_fde ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fec );
};};return _fadg ,nil ;};func (_fedg *SubstreamReader )readUnalignedByte ()(_fdfe byte ,_dfe error ){_agfd :=_fedg ._cdbd ;_fdfe =_fedg ._aba <<(8-_agfd );_fedg ._aba ,_dfe =_fedg .readBufferByte ();if _dfe !=nil {return 0,_dfe ;};_fdfe |=_fedg ._aba >>_agfd ;
_fedg ._aba &=1<<_agfd -1;return _fdfe ,nil ;};func (_gb *BufferedWriter )Write (d []byte )(int ,error ){_gb .expandIfNeeded (len (d ));if _gb ._da ==0{return _gb .writeFullBytes (d ),nil ;};return _gb .writeShiftedBytes (d ),nil ;};func (_eec *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_eec ._aae =-1;
var _dbea int64 ;switch whence {case _c .SeekStart :_dbea =offset ;case _c .SeekCurrent :_dbea =_eec ._edb +offset ;case _c .SeekEnd :_dbea =int64 (len (_eec ._dge ))+offset ;default:return 0,_cb .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _dbea < 0{return 0,_cb .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_eec ._edb =_dbea ;
_eec ._ccgb =0;return _dbea ,nil ;};func (_aaea *Reader )Reset (){_aaea ._edb =_aaea ._caf ;_aaea ._ccgb =_aaea ._edc };func (_gede *SubstreamReader )Mark (){_gede ._agc =_gede ._bcc ;_gede ._gbg =_gede ._cdbd };func NewWriterMSB (data []byte )*Writer {return &Writer {_cea :data ,_bcb :true }};
func (_cgc *BufferedWriter )writeByte (_dgb byte ){switch {case _cgc ._da ==0:_cgc ._df [_cgc ._bd ]=_dgb ;_cgc ._bd ++;case _cgc ._gf :_cgc ._df [_cgc ._bd ]|=_dgb >>_cgc ._da ;_cgc ._bd ++;_cgc ._df [_cgc ._bd ]=byte (uint16 (_dgb )<<(8-_cgc ._da )&0xff);
default:_cgc ._df [_cgc ._bd ]|=byte (uint16 (_dgb )<<_cgc ._da &0xff);_cgc ._bd ++;_cgc ._df [_cgc ._bd ]=_dgb >>(8-_cgc ._da );};};func (_ee *BufferedWriter )Reset (){_ee ._df =_ee ._df [:0];_ee ._bd =0;_ee ._da =0};func (_ag *BufferedWriter )tryGrowByReslice (_ec int )bool {if _fdf :=len (_ag ._df );
_ec <=cap (_ag ._df )-_fdf {_ag ._df =_ag ._df [:_fdf +_ec ];return true ;};return false ;};func (_fcb *Reader )Read (p []byte )(_gbff int ,_fda error ){if _fcb ._ccgb ==0{return _fcb .read (p );};for ;_gbff < len (p );_gbff ++{if p [_gbff ],_fda =_fcb .readUnalignedByte ();
_fda !=nil {return 0,_fda ;};};return _gbff ,nil ;};func _egde (_baea ,_ebce uint64 )uint64 {if _baea < _ebce {return _baea ;};return _ebce ;};var _ _c .Writer =&BufferedWriter {};func (_bda *Reader )readUnalignedByte ()(_dff byte ,_dcg error ){_cef :=_bda ._ccgb ;
_dff =_bda ._dc <<(8-_cef );_bda ._dc ,_dcg =_bda .readBufferByte ();if _dcg !=nil {return 0,_dcg ;};_dff |=_bda ._dc >>_cef ;_bda ._dc &=1<<_cef -1;return _dff ,nil ;};func (_e *BufferedWriter )Data ()[]byte {return _e ._df };var (_ _c .Reader =&Reader {};
_ _c .ByteReader =&Reader {};_ _c .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_gd *BufferedWriter )grow (_daf int ){if _gd ._df ==nil &&_daf < _fa {_gd ._df =make ([]byte ,_daf ,_fa );return ;};_ed :=len (_gd ._df );if _gd ._da !=0{_ed ++;};
_cfe :=cap (_gd ._df );switch {case _daf <=_cfe /2-_ed :_cg .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_gd ._df ),cap (_gd ._df ),_daf );
_cg .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cfe ,_ed );copy (_gd ._df ,_gd ._df [_gd .fullOffset ():]);
case _cfe > _b -_cfe -_daf :_cg .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cd :=make ([]byte ,2*_cfe +_daf );copy (_cd ,_gd ._df );_gd ._df =_cd ;};_gd ._df =_gd ._df [:_ed +_daf ];
};func (_gafc *Writer )WriteByte (c byte )error {return _gafc .writeByte (c )};func (_bfbf *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _c .SeekStart :_bfbf ._bcc =uint64 (offset );case _c .SeekCurrent :_bfbf ._bcc +=uint64 (offset );
case _c .SeekEnd :_bfbf ._bcc =_bfbf ._cdb +uint64 (offset );default:return 0,_cb .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_bfbf ._cdbd =0;return int64 (_bfbf ._bcc ),nil ;};func (_cbgc *Writer )Write (p []byte )(int ,error ){if len (p )> _cbgc .byteCapacity (){return 0,_c .EOF ;};for _ ,_aaf :=range p {if _egf :=_cbgc .writeByte (_aaf );_egf !=nil {return 0,_egf ;};};return len (p ),nil ;
};func (_feb *Reader )ConsumeRemainingBits (){if _feb ._ccgb !=0{_ ,_gaff :=_feb .ReadBits (_feb ._ccgb );if _gaff !=nil {_cg .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_gaff );
};};};const (_fa =64;_b =int (^uint (0)>>1););func (_ade *Reader )readBufferByte ()(byte ,error ){if _ade ._edb >=int64 (len (_ade ._dge )){return 0,_c .EOF ;};_ade ._aae =-1;_ged :=_ade ._dge [_ade ._edb ];_ade ._edb ++;_ade ._cbg =int (_ged );return _ged ,nil ;
};var _ BinaryWriter =&Writer {};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_cb .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};
_cg .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_dffc :r ,_dabc :offset ,_cdb :length ,_ede :make ([]byte ,length )},nil ;};func (_ce *Reader )ReadByte ()(byte ,error ){if _ce ._ccgb ==0{return _ce .readBufferByte ();};return _ce .readUnalignedByte ();};func (_bgf *SubstreamReader )readBool ()(_ebca bool ,_adg error ){if _bgf ._cdbd ==0{_bgf ._aba ,_adg =_bgf .readBufferByte ();
if _adg !=nil {return false ,_adg ;};_ebca =(_bgf ._aba &0x80)!=0;_bgf ._aba ,_bgf ._cdbd =_bgf ._aba &0x7f,7;return _ebca ,nil ;};_bgf ._cdbd --;_ebca =(_bgf ._aba &(1<<_bgf ._cdbd ))!=0;_bgf ._aba &=1<<_bgf ._cdbd -1;return _ebca ,nil ;};func (_fg *BufferedWriter )expandIfNeeded (_dd int ){if !_fg .tryGrowByReslice (_dd ){_fg .grow (_dd );
};};func (_gecf *Writer )byteCapacity ()int {_bce :=len (_gecf ._cea )-_gecf ._efbe ;if _gecf ._bfbfb !=0{_bce --;};return _bce ;};var _ _c .ByteWriter =&BufferedWriter {};func (_bfba *Writer )UseMSB ()bool {return _bfba ._bcb };