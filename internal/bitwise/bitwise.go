//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_d "encoding/binary";_ee "errors";_db "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_bd *BufferedWriter )Len ()int {return _bd .byteCapacity ()};func (_gbf *BufferedWriter )byteCapacity ()int {_afc :=len (_gbf ._ge )-_gbf ._ged ;
if _gbf ._cf !=0{_afc --;};return _afc ;};func (_egg *Reader )Mark (){_egg ._ead =_egg ._fd ;_egg ._fab =_egg ._gda ;_egg ._gea =_egg ._fb ;_egg ._fbf =_egg ._afa ;};func (_eff *Writer )SkipBits (skip int )error {const _fabg ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_afcd :=int (_eff ._cdb )+skip ;if _afcd >=0&&_afcd < 8{_eff ._cdb =uint8 (_afcd );return nil ;};_afcd =int (_eff ._cdb )+_eff ._edf *8+skip ;if _afcd < 0{return _b .Errorf (_fabg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dbeb :=_afcd /8;_bdc :=_afcd %8;_db .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_db .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_eff ._cdb ,_eff ._edf ,int (_eff ._cdb )+(_eff ._edf )*8,len (_eff ._dgf ),cap (_eff ._dgf ));
_db .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_afcd ,_bdc );_eff ._cdb =uint8 (_bdc );if _cbe :=_dbeb -_eff ._edf ;
_cbe > 0&&len (_eff ._dgf )-1< _dbeb {_db .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cbe );return _b .Errorf (_fabg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_eff ._edf =_dbeb ;_db .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_eff ._cdb ,_eff ._edf );return nil ;};func (_gad *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _gad ._gda !=0{return _gad .ReadBits (_gad ._gda );
};return 0,nil ;};func (_gge *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _e .SeekStart :_gge ._be =uint64 (offset );case _e .SeekCurrent :_gge ._be +=uint64 (offset );case _e .SeekEnd :_gge ._be =_gge ._cfd +uint64 (offset );
default:return 0,_ee .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_gge ._aba =0;return int64 (_gge ._be ),nil ;};var _ _e .Writer =&BufferedWriter {};func NewWriter (data []byte )*Writer {return &Writer {_dgf :data }};type BufferedWriter struct{_ge []byte ;_cf uint8 ;_ged int ;_gf bool ;};func _bbf (_cdc ,_bfac uint64 )uint64 {if _cdc < _bfac {return _cdc ;
};return _bfac ;};func (_fdg *SubstreamReader )ReadBit ()(_bfg int ,_eeg error ){_gaa ,_eeg :=_fdg .readBool ();if _eeg !=nil {return 0,_eeg ;};if _gaa {_bfg =1;};return _bfg ,nil ;};func (_ccfd *Writer )byteCapacity ()int {_efd :=len (_ccfd ._dgf )-_ccfd ._edf ;
if _ccfd ._cdb !=0{_efd --;};return _efd ;};func (_gc *BufferedWriter )writeFullBytes (_dc []byte )int {_gga :=copy (_gc ._ge [_gc .fullOffset ():],_dc );_gc ._ged +=_gga ;return _gga ;};func (_ae *BufferedWriter )fullOffset ()int {_ffe :=_ae ._ged ;if _ae ._cf !=0{_ffe ++;
};return _ffe ;};func (_bc *BufferedWriter )Write (d []byte )(int ,error ){_bc .expandIfNeeded (len (d ));if _bc ._cf ==0{return _bc .writeFullBytes (d ),nil ;};return _bc .writeShiftedBytes (d ),nil ;};func (_ccd *Reader )ReadBool ()(bool ,error ){return _ccd .readBool ()};
func (_cde *Writer )UseMSB ()bool {return _cde ._abgf };func (_ac *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_geb :=int (_ac ._cf )+skip ;if _geb >=0&&_geb < 8{_ac ._cf =uint8 (_geb );return nil ;};_geb =int (_ac ._cf )+_ac ._ged *8+skip ;
if _geb < 0{return _b .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cg :=_geb /8;_eab :=_geb %8;_ac ._cf =uint8 (_eab );
if _f :=_cg -_ac ._ged ;_f > 0&&len (_ac ._ge )-1< _cg {if _ac ._cf !=0{_f ++;};_ac .expandIfNeeded (_f );};_ac ._ged =_cg ;return nil ;};func (_df *BufferedWriter )Data ()[]byte {return _df ._ge };type SubstreamReader struct{_be uint64 ;_gcc StreamReader ;
_gccc uint64 ;_cfd uint64 ;_acbb []byte ;_cec uint64 ;_dcb uint64 ;_gbc byte ;_aba byte ;_bcf uint64 ;_eace byte ;};func (_ccf *SubstreamReader )ReadBits (n byte )(_gadf uint64 ,_adaa error ){if n < _ccf ._aba {_gag :=_ccf ._aba -n ;_gadf =uint64 (_ccf ._gbc >>_gag );
_ccf ._gbc &=1<<_gag -1;_ccf ._aba =_gag ;return _gadf ,nil ;};if n > _ccf ._aba {if _ccf ._aba > 0{_gadf =uint64 (_ccf ._gbc );n -=_ccf ._aba ;};var _cfg byte ;for n >=8{_cfg ,_adaa =_ccf .readBufferByte ();if _adaa !=nil {return 0,_adaa ;};_gadf =_gadf <<8+uint64 (_cfg );
n -=8;};if n > 0{if _ccf ._gbc ,_adaa =_ccf .readBufferByte ();_adaa !=nil {return 0,_adaa ;};_cbcf :=8-n ;_gadf =_gadf <<n +uint64 (_ccf ._gbc >>_cbcf );_ccf ._gbc &=1<<_cbcf -1;_ccf ._aba =_cbcf ;}else {_ccf ._aba =0;};return _gadf ,nil ;};_ccf ._aba =0;
return uint64 (_ccf ._gbc ),nil ;};func (_ec *SubstreamReader )Reset (){_ec ._be =_ec ._bcf ;_ec ._aba =_ec ._eace };func NewReader (data []byte )*Reader {return &Reader {_fg :data }};func (_bbd *Reader )Align ()(_ffb byte ){_ffb =_bbd ._gda ;_bbd ._gda =0;
return _ffb };func (_feg *SubstreamReader )Read (b []byte )(_bcg int ,_dfc error ){if _feg ._be >=_feg ._cfd {_db .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_feg ._be ,_feg ._cfd );
return 0,_e .EOF ;};for ;_bcg < len (b );_bcg ++{if b [_bcg ],_dfc =_feg .readUnalignedByte ();_dfc !=nil {if _dfc ==_e .EOF {return _bcg ,nil ;};return 0,_dfc ;};};return _bcg ,nil ;};func (_baf *Writer )writeByte (_ggb byte )error {if _baf ._edf > len (_baf ._dgf )-1{return _e .EOF ;
};if _baf ._edf ==len (_baf ._dgf )-1&&_baf ._cdb !=0{return _e .EOF ;};if _baf ._cdb ==0{_baf ._dgf [_baf ._edf ]=_ggb ;_baf ._edf ++;return nil ;};if _baf ._abgf {_baf ._dgf [_baf ._edf ]|=_ggb >>_baf ._cdb ;_baf ._edf ++;_baf ._dgf [_baf ._edf ]=byte (uint16 (_ggb )<<(8-_baf ._cdb )&0xff);
}else {_baf ._dgf [_baf ._edf ]|=byte (uint16 (_ggb )<<_baf ._cdb &0xff);_baf ._edf ++;_baf ._dgf [_baf ._edf ]=_ggb >>(8-_baf ._cdb );};return nil ;};func (_ade *Reader )Read (p []byte )(_fbb int ,_ggg error ){if _ade ._gda ==0{return _ade .read (p );
};for ;_fbb < len (p );_fbb ++{if p [_fbb ],_ggg =_ade .readUnalignedByte ();_ggg !=nil {return 0,_ggg ;};};return _fbb ,nil ;};func (_aee *BufferedWriter )grow (_ace int ){if _aee ._ge ==nil &&_ace < _c {_aee ._ge =make ([]byte ,_ace ,_c );return ;};_bdg :=len (_aee ._ge );
if _aee ._cf !=0{_bdg ++;};_ad :=cap (_aee ._ge );switch {case _ace <=_ad /2-_bdg :_db .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_aee ._ge ),cap (_aee ._ge ),_ace );
_db .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ad ,_bdg );copy (_aee ._ge ,_aee ._ge [_aee .fullOffset ():]);
case _ad > _g -_ad -_ace :_db .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cda :=make ([]byte ,2*_ad +_ace );copy (_cda ,_aee ._ge );_aee ._ge =_cda ;};_aee ._ge =_aee ._ge [:_bdg +_ace ];
};func (_gdea *Writer )Data ()[]byte {return _gdea ._dgf };type Reader struct{_fg []byte ;_fb byte ;_gda byte ;_fd int64 ;_afa int ;_dbe int ;_ead int64 ;_fab byte ;_gea byte ;_fbf int ;};func (_dca *BufferedWriter )tryGrowByReslice (_fac int )bool {if _gef :=len (_dca ._ge );
_fac <=cap (_dca ._ge )-_gef {_dca ._ge =_dca ._ge [:_gef +_fac ];return true ;};return false ;};func (_abg *Reader )read (_eef []byte )(int ,error ){if _abg ._fd >=int64 (len (_abg ._fg )){return 0,_e .EOF ;};_abg ._dbe =-1;_eb :=copy (_eef ,_abg ._fg [_abg ._fd :]);
_abg ._fd +=int64 (_eb );return _eb ,nil ;};var _ BinaryWriter =&BufferedWriter {};func (_cbd *Reader )readBool ()(_cgc bool ,_ag error ){if _cbd ._gda ==0{_cbd ._fb ,_ag =_cbd .readBufferByte ();if _ag !=nil {return false ,_ag ;};_cgc =(_cbd ._fb &0x80)!=0;
_cbd ._fb ,_cbd ._gda =_cbd ._fb &0x7f,7;return _cgc ,nil ;};_cbd ._gda --;_cgc =(_cbd ._fb &(1<<_cbd ._gda ))!=0;_cbd ._fb &=1<<_cbd ._gda -1;return _cgc ,nil ;};func (_abgc *SubstreamReader )Length ()uint64 {return _abgc ._cfd };func (_gdbe *SubstreamReader )BitPosition ()int {return int (_gdbe ._aba )};
func (_ea *BufferedWriter )ResetBitIndex (){_ea ._cf =0};func (_ba *SubstreamReader )ReadBool ()(bool ,error ){return _ba .readBool ()};func (_fdb *Reader )ReadByte ()(byte ,error ){if _fdb ._gda ==0{return _fdb .readBufferByte ();};return _fdb .readUnalignedByte ();
};func (_ebf *Writer )ResetBit (){_ebf ._cdb =0};type BitWriter interface{WriteBit (_afd int )error ;WriteBits (_ca uint64 ,_cc int )(_eed int ,_ed error );FinishByte ();SkipBits (_ffd int )error ;};func (_gfc *Reader )ReadBit ()(_gdd int ,_afca error ){_gdb ,_afca :=_gfc .readBool ();
if _afca !=nil {return 0,_afca ;};if _gdb {_gdd =1;};return _gdd ,nil ;};func (_aa *Reader )readUnalignedByte ()(_cdd byte ,_eaa error ){_dfb :=_aa ._gda ;_cdd =_aa ._fb <<(8-_dfb );_aa ._fb ,_eaa =_aa .readBufferByte ();if _eaa !=nil {return 0,_eaa ;};
_cdd |=_aa ._fb >>_dfb ;_aa ._fb &=1<<_dfb -1;return _cdd ,nil ;};func (_ff *BufferedWriter )WriteBits (bits uint64 ,number int )(_egb int ,_dg error ){const _cff ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_b .Errorf (_cff ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_bfb :=number /8;if _bfb > 0{_gb :=number -_bfb *8;for _bcc :=_bfb -1;_bcc >=0;_bcc --{_bde :=byte ((bits >>uint (_bcc *8+_gb ))&0xff);if _dg =_ff .WriteByte (_bde );_dg !=nil {return _egb ,_b .Wrapf (_dg ,_cff ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bfb -_bcc +1);
};};number -=_bfb *8;if number ==0{return _bfb ,nil ;};};var _af int ;for _bb :=0;_bb < number ;_bb ++{if _ff ._gf {_af =int ((bits >>uint (number -1-_bb ))&0x1);}else {_af =int (bits &0x1);bits >>=1;};if _dg =_ff .WriteBit (_af );_dg !=nil {return _egb ,_b .Wrapf (_dg ,_cff ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bb );
};};return _bfb ,nil ;};func (_ffg *SubstreamReader )ReadByte ()(byte ,error ){if _ffg ._aba ==0{return _ffg .readBufferByte ();};return _ffg .readUnalignedByte ();};func (_aag *Writer )FinishByte (){if _aag ._cdb ==0{return ;};_aag ._cdb =0;_aag ._edf ++;
};func (_cae *Reader )ReadBits (n byte )(_gdc uint64 ,_eda error ){if n < _cae ._gda {_cfb :=_cae ._gda -n ;_gdc =uint64 (_cae ._fb >>_cfb );_cae ._fb &=1<<_cfb -1;_cae ._gda =_cfb ;return _gdc ,nil ;};if n > _cae ._gda {if _cae ._gda > 0{_gdc =uint64 (_cae ._fb );
n -=_cae ._gda ;};for n >=8{_gde ,_gae :=_cae .readBufferByte ();if _gae !=nil {return 0,_gae ;};_gdc =_gdc <<8+uint64 (_gde );n -=8;};if n > 0{if _cae ._fb ,_eda =_cae .readBufferByte ();_eda !=nil {return 0,_eda ;};_ggd :=8-n ;_gdc =_gdc <<n +uint64 (_cae ._fb >>_ggd );
_cae ._fb &=1<<_ggd -1;_cae ._gda =_ggd ;}else {_cae ._gda =0;};return _gdc ,nil ;};_cae ._gda =0;return uint64 (_cae ._fb ),nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_ee .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_db .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_gcc :r ,_gccc :offset ,_cfd :length ,_acbb :make ([]byte ,length )},nil ;};type BinaryWriter interface{BitWriter ;_e .Writer ;_e .ByteWriter ;Data ()[]byte ;};func (_bed *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bed .writeBit (uint8 (bit ));
};return _b .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_beg *SubstreamReader )Align ()(_ddg byte ){_ddg =_beg ._aba ;_beg ._aba =0;
return _ddg };func (_bf *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _b .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_bf ._ge )-1< _bf ._ged {_bf .expandIfNeeded (1);};_eac :=_bf ._cf ;if _bf ._gf {_eac =7-_bf ._cf ;};_bf ._ge [_bf ._ged ]|=byte (uint16 (bit <<_eac )&0xff);_bf ._cf ++;if _bf ._cf ==8{_bf ._ged ++;_bf ._cf =0;};return nil ;};func (_ccfg *SubstreamReader )fillBuffer ()error {if uint64 (_ccfg ._gcc .StreamPosition ())!=_ccfg ._be +_ccfg ._gccc {_ ,_gdae :=_ccfg ._gcc .Seek (int64 (_ccfg ._be +_ccfg ._gccc ),_e .SeekStart );
if _gdae !=nil {return _gdae ;};};_ccfg ._cec =_ccfg ._be ;_bab :=_bbf (uint64 (len (_ccfg ._acbb )),_ccfg ._cfd -_ccfg ._be );_afaf :=make ([]byte ,_bab );_fba ,_bag :=_ccfg ._gcc .Read (_afaf );if _bag !=nil {return _bag ;};for _ege :=uint64 (0);_ege < _bab ;
_ege ++{_ccfg ._acbb [_ege ]=_afaf [_ege ];};_ccfg ._dcb =_ccfg ._cec +uint64 (_fba );return nil ;};func (_bdd *Reader )ReadUint32 ()(uint32 ,error ){_fc :=make ([]byte ,4);_ ,_acb :=_bdd .Read (_fc );if _acb !=nil {return 0,_acb ;};return _d .BigEndian .Uint32 (_fc ),nil ;
};func (_fa *BufferedWriter )expandIfNeeded (_cbc int ){if !_fa .tryGrowByReslice (_cbc ){_fa .grow (_cbc );};};func (_ef *SubstreamReader )Mark (){_ef ._bcf =_ef ._be ;_ef ._eace =_ef ._aba };const (_c =64;_g =int (^uint (0)>>1););func (_dd *Reader )Length ()uint64 {return uint64 (len (_dd ._fg ))};
func (_gddb *SubstreamReader )readBufferByte ()(byte ,error ){if _gddb ._be >=_gddb ._cfd {return 0,_e .EOF ;};if _gddb ._be >=_gddb ._dcb ||_gddb ._be < _gddb ._cec {if _ddc :=_gddb .fillBuffer ();_ddc !=nil {return 0,_ddc ;};};_bfa :=_gddb ._acbb [_gddb ._be -_gddb ._cec ];
_gddb ._be ++;return _bfa ,nil ;};func (_aab *SubstreamReader )readUnalignedByte ()(_bgb byte ,_bccf error ){_bfgb :=_aab ._aba ;_bgb =_aab ._gbc <<(8-_bfgb );_aab ._gbc ,_bccf =_aab .readBufferByte ();if _bccf !=nil {return 0,_bccf ;};_bgb |=_aab ._gbc >>_bfgb ;
_aab ._gbc &=1<<_bfgb -1;return _bgb ,nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_gf :true }};func (_eg *BufferedWriter )Reset (){_eg ._ge =_eg ._ge [:0];_eg ._ged =0;_eg ._cf =0};func (_cdae *Writer )Write (p []byte )(int ,error ){if len (p )> _cdae .byteCapacity (){return 0,_e .EOF ;
};for _ ,_aae :=range p {if _abc :=_cdae .writeByte (_aae );_abc !=nil {return 0,_abc ;};};return len (p ),nil ;};func (_dbcd *Writer )WriteBits (bits uint64 ,number int )(_ggc int ,_egfe error ){const _ecc ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_b .Errorf (_ecc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cba :=number /8;if _cba > 0{_fbfd :=number -_cba *8;for _ebc :=_cba -1;_ebc >=0;_ebc --{_cef :=byte ((bits >>uint (_ebc *8+_fbfd ))&0xff);if _egfe =_dbcd .WriteByte (_cef );_egfe !=nil {return _ggc ,_b .Wrapf (_egfe ,_ecc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cba -_ebc +1);
};};number -=_cba *8;if number ==0{return _cba ,nil ;};};var _cee int ;for _cdag :=0;_cdag < number ;_cdag ++{if _dbcd ._abgf {_cee =int ((bits >>uint (number -1-_cdag ))&0x1);}else {_cee =int (bits &0x1);bits >>=1;};if _egfe =_dbcd .WriteBit (_cee );_egfe !=nil {return _ggc ,_b .Wrapf (_egfe ,_ecc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cdag );
};};return _cba ,nil ;};func (_dbf *Reader )StreamPosition ()int64 {return _dbf ._fd };func (_gbg *Writer )writeBit (_bda uint8 )error {if len (_gbg ._dgf )-1< _gbg ._edf {return _e .EOF ;};_dcbg :=_gbg ._cdb ;if _gbg ._abgf {_dcbg =7-_gbg ._cdb ;};_gbg ._dgf [_gbg ._edf ]|=byte (uint16 (_bda <<_dcbg )&0xff);
_gbg ._cdb ++;if _gbg ._cdb ==8{_gbg ._edf ++;_gbg ._cdb =0;};return nil ;};type Writer struct{_dgf []byte ;_cdb uint8 ;_edf int ;_abgf bool ;};func (_fbbc *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fbbc ._dbe =-1;var _bg int64 ;switch whence {case _e .SeekStart :_bg =offset ;
case _e .SeekCurrent :_bg =_fbbc ._fd +offset ;case _e .SeekEnd :_bg =int64 (len (_fbbc ._fg ))+offset ;default:return 0,_ee .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _bg < 0{return 0,_ee .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_fbbc ._fd =_bg ;
_fbbc ._gda =0;return _bg ,nil ;};func (_dfd *SubstreamReader )StreamPosition ()int64 {return int64 (_dfd ._be )};func (_aff *Reader )Reset (){_aff ._fd =_aff ._ead ;_aff ._gda =_aff ._fab ;_aff ._fb =_aff ._gea ;_aff ._afa =_aff ._fbf ;};var _ _e .ByteWriter =&BufferedWriter {};
func (_afcb *Reader )BitPosition ()int {return int (_afcb ._gda )};func NewWriterMSB (data []byte )*Writer {return &Writer {_dgf :data ,_abgf :true }};func (_ebg *SubstreamReader )ReadUint32 ()(uint32 ,error ){_ccg :=make ([]byte ,4);_ ,_gcd :=_ebg .Read (_ccg );
if _gcd !=nil {return 0,_gcd ;};return _d .BigEndian .Uint32 (_ccg ),nil ;};type StreamReader interface{_e .Reader ;_e .ByteReader ;_e .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fec byte )(uint64 ,error );
ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_dcg *Writer )WriteByte (c byte )error {return _dcg .writeByte (c )};func (_gggd *SubstreamReader )Offset ()uint64 {return _gggd ._gccc };func (_bgg *Reader )readBufferByte ()(byte ,error ){if _bgg ._fd >=int64 (len (_bgg ._fg )){return 0,_e .EOF ;
};_bgg ._dbe =-1;_aca :=_bgg ._fg [_bgg ._fd ];_bgg ._fd ++;_bgg ._afa =int (_aca );return _aca ,nil ;};func (_bfd *SubstreamReader )readBool ()(_gab bool ,_eee error ){if _bfd ._aba ==0{_bfd ._gbc ,_eee =_bfd .readBufferByte ();if _eee !=nil {return false ,_eee ;
};_gab =(_bfd ._gbc &0x80)!=0;_bfd ._gbc ,_bfd ._aba =_bfd ._gbc &0x7f,7;return _gab ,nil ;};_bfd ._aba --;_gab =(_bfd ._gbc &(1<<_bfd ._aba ))!=0;_bfd ._gbc &=1<<_bfd ._aba -1;return _gab ,nil ;};func (_fe *BufferedWriter )writeShiftedBytes (_de []byte )int {for _ ,_ada :=range _de {_fe .writeByte (_ada );
};return len (_de );};func (_ab *BufferedWriter )writeByte (_gg byte ){switch {case _ab ._cf ==0:_ab ._ge [_ab ._ged ]=_gg ;_ab ._ged ++;case _ab ._gf :_ab ._ge [_ab ._ged ]|=_gg >>_ab ._cf ;_ab ._ged ++;_ab ._ge [_ab ._ged ]=byte (uint16 (_gg )<<(8-_ab ._cf )&0xff);
default:_ab ._ge [_ab ._ged ]|=byte (uint16 (_gg )<<_ab ._cf &0xff);_ab ._ged ++;_ab ._ge [_ab ._ged ]=_gg >>(8-_ab ._cf );};};var (_ _e .Reader =&Reader {};_ _e .ByteReader =&Reader {};_ _e .Seeker =&Reader {};_ StreamReader =&Reader {};);var _ BinaryWriter =&Writer {};
func (_gff *BufferedWriter )FinishByte (){if _gff ._cf ==0{return ;};_gff ._cf =0;_gff ._ged ++;};func (_ga *BufferedWriter )WriteByte (bt byte )error {if _ga ._ged > len (_ga ._ge )-1||(_ga ._ged ==len (_ga ._ge )-1&&_ga ._cf !=0){_ga .expandIfNeeded (1);
};_ga .writeByte (bt );return nil ;};