//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_a "encoding/binary";_e "errors";_c "github.com/unidoc/unipdf/v3/common";_ed "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_df "io";);func (_cfc *SubstreamReader )ReadByte ()(byte ,error ){if _cfc ._gca ==0{return _cfc .readBufferByte ();
};return _cfc .readUnalignedByte ();};func (_fec *SubstreamReader )ReadUint32 ()(uint32 ,error ){_eaa :=make ([]byte ,4);_ ,_deeg :=_fec .Read (_eaa );if _deeg !=nil {return 0,_deeg ;};return _a .BigEndian .Uint32 (_eaa ),nil ;};func (_eed *Reader )readBool ()(_ebe bool ,_acf error ){if _eed ._de ==0{_eed ._aec ,_acf =_eed .readBufferByte ();
if _acf !=nil {return false ,_acf ;};_ebe =(_eed ._aec &0x80)!=0;_eed ._aec ,_eed ._de =_eed ._aec &0x7f,7;return _ebe ,nil ;};_eed ._de --;_ebe =(_eed ._aec &(1<<_eed ._de ))!=0;_eed ._aec &=1<<_eed ._de -1;return _ebe ,nil ;};type BufferedWriter struct{_eg []byte ;
_da uint8 ;_bf int ;_ef bool ;};func (_bdc *Writer )WriteBits (bits uint64 ,number int )(_bac int ,_cafd error ){const _fee ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_ed .Errorf (_fee ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_ega :=number /8;if _ega > 0{_gdf :=number -_ega *8;for _eefb :=_ega -1;_eefb >=0;_eefb --{_dgag :=byte ((bits >>uint (_eefb *8+_gdf ))&0xff);if _cafd =_bdc .WriteByte (_dgag );_cafd !=nil {return _bac ,_ed .Wrapf (_cafd ,_fee ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ega -_eefb +1);
};};number -=_ega *8;if number ==0{return _ega ,nil ;};};var _gbea int ;for _fcba :=0;_fcba < number ;_fcba ++{if _bdc ._eec {_gbea =int ((bits >>uint (number -1-_fcba ))&0x1);}else {_gbea =int (bits &0x1);bits >>=1;};if _cafd =_bdc .WriteBit (_gbea );
_cafd !=nil {return _bac ,_ed .Wrapf (_cafd ,_fee ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fcba );};};return _ega ,nil ;};func (_affc *Writer )Data ()[]byte {return _affc ._bdf };type Writer struct{_bdf []byte ;_fag uint8 ;_dbb int ;_eec bool ;};func (_ga *BufferedWriter )WriteByte (bt byte )error {if _ga ._bf > len (_ga ._eg )-1||(_ga ._bf ==len (_ga ._eg )-1&&_ga ._da !=0){_ga .expandIfNeeded (1);
};_ga .writeByte (bt );return nil ;};func (_cgg *Reader )Reset (){_cgg ._gd =_cgg ._gcb ;_cgg ._de =_cgg ._bd ;_cgg ._aec =_cgg ._ff ;_cgg ._ccd =_cgg ._dfe ;};func (_fcb *Writer )ResetBit (){_fcb ._fag =0};type Reader struct{_faf []byte ;_aec byte ;_de byte ;
_gd int64 ;_ccd int ;_bbg int ;_gcb int64 ;_bd byte ;_ff byte ;_dfe int ;};type BinaryWriter interface{BitWriter ;_df .Writer ;_df .ByteWriter ;Data ()[]byte ;};const (_ca =64;_b =int (^uint (0)>>1););func (_fda *BufferedWriter )fullOffset ()int {_dfg :=_fda ._bf ;
if _fda ._da !=0{_dfg ++;};return _dfg ;};type StreamReader interface{_df .Reader ;_df .ByteReader ;_df .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_efg byte )(uint64 ,error );ReadBool ()(bool ,error );
ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_ba *Reader )ReadByte ()(byte ,error ){if _ba ._de ==0{return _ba .readBufferByte ();};return _ba .readUnalignedByte ();};func (_fdf *Reader )read (_baa []byte )(int ,error ){if _fdf ._gd >=int64 (len (_fdf ._faf )){return 0,_df .EOF ;
};_fdf ._bbg =-1;_ffe :=copy (_baa ,_fdf ._faf [_fdf ._gd :]);_fdf ._gd +=int64 (_ffe );return _ffe ,nil ;};func (_ee *Reader )ReadBits (n byte )(_gef uint64 ,_gefe error ){if n < _ee ._de {_gbb :=_ee ._de -n ;_gef =uint64 (_ee ._aec >>_gbb );_ee ._aec &=1<<_gbb -1;
_ee ._de =_gbb ;return _gef ,nil ;};if n > _ee ._de {if _ee ._de > 0{_gef =uint64 (_ee ._aec );n -=_ee ._de ;};for n >=8{_fgg ,_dee :=_ee .readBufferByte ();if _dee !=nil {return 0,_dee ;};_gef =_gef <<8+uint64 (_fgg );n -=8;};if n > 0{if _ee ._aec ,_gefe =_ee .readBufferByte ();
_gefe !=nil {return 0,_gefe ;};_ebaaa :=8-n ;_gef =_gef <<n +uint64 (_ee ._aec >>_ebaaa );_ee ._aec &=1<<_ebaaa -1;_ee ._de =_ebaaa ;}else {_ee ._de =0;};return _gef ,nil ;};_ee ._de =0;return uint64 (_ee ._aec ),nil ;};func NewReader (data []byte )*Reader {return &Reader {_faf :data }};
func (_fggg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _fggg .writeBit (uint8 (bit ));};return _ed .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};type SubstreamReader struct{_ggb uint64 ;_bfd StreamReader ;_abd uint64 ;_dgf uint64 ;_fbe []byte ;_gf uint64 ;_fgf uint64 ;_bef byte ;_gca byte ;_deb uint64 ;_cfg byte ;};func (_cag *BufferedWriter )FinishByte (){if _cag ._da ==0{return ;};_cag ._da =0;
_cag ._bf ++;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ef :true }};func (_cbdf *Writer )UseMSB ()bool {return _cbdf ._eec };func (_bfb *BufferedWriter )Data ()[]byte {return _bfb ._eg };func (_egc *BufferedWriter )ResetBitIndex (){_egc ._da =0};
func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_e .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_c .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_bfd :r ,_abd :offset ,_dgf :length ,_fbe :make ([]byte ,length )},nil ;};func (_bg *SubstreamReader )Length ()uint64 {return _bg ._dgf };func (_bfdb *SubstreamReader )StreamPosition ()int64 {return int64 (_bfdb ._ggb )};func (_ec *BufferedWriter )tryGrowByReslice (_cge int )bool {if _cfa :=len (_ec ._eg );
_cge <=cap (_ec ._eg )-_cfa {_ec ._eg =_ec ._eg [:_cfa +_cge ];return true ;};return false ;};func (_gac *Writer )FinishByte (){if _gac ._fag ==0{return ;};_gac ._fag =0;_gac ._dbb ++;};func (_fg *BufferedWriter )WriteBits (bits uint64 ,number int )(_efb int ,_fd error ){const _gg ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_ed .Errorf (_gg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_edg :=number /8;if _edg > 0{_egf :=number -_edg *8;for _ad :=_edg -1;_ad >=0;_ad --{_eggf :=byte ((bits >>uint (_ad *8+_egf ))&0xff);if _fd =_fg .WriteByte (_eggf );_fd !=nil {return _efb ,_ed .Wrapf (_fd ,_gg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_edg -_ad +1);
};};number -=_edg *8;if number ==0{return _edg ,nil ;};};var _dga int ;for _gc :=0;_gc < number ;_gc ++{if _fg ._ef {_dga =int ((bits >>uint (number -1-_gc ))&0x1);}else {_dga =int (bits &0x1);bits >>=1;};if _fd =_fg .WriteBit (_dga );_fd !=nil {return _efb ,_ed .Wrapf (_fd ,_gg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gc );
};};return _edg ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_bdf :data ,_eec :true }};func (_cbb *SubstreamReader )Mark (){_cbb ._deb =_cbb ._ggb ;_cbb ._cfg =_cbb ._gca };func (_cagb *BufferedWriter )Reset (){_cagb ._eg =_cagb ._eg [:0];
_cagb ._bf =0;_cagb ._da =0};func (_fbf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fbf ._bbg =-1;var _efa int64 ;switch whence {case _df .SeekStart :_efa =offset ;case _df .SeekCurrent :_efa =_fbf ._gd +offset ;case _df .SeekEnd :_efa =int64 (len (_fbf ._faf ))+offset ;
default:return 0,_e .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _efa < 0{return 0,_e .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_fbf ._gd =_efa ;_fbf ._de =0;return _efa ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_bdf :data }};func (_dca *Writer )writeByte (_gea byte )error {if _dca ._dbb > len (_dca ._bdf )-1{return _df .EOF ;};if _dca ._dbb ==len (_dca ._bdf )-1&&_dca ._fag !=0{return _df .EOF ;
};if _dca ._fag ==0{_dca ._bdf [_dca ._dbb ]=_gea ;_dca ._dbb ++;return nil ;};if _dca ._eec {_dca ._bdf [_dca ._dbb ]|=_gea >>_dca ._fag ;_dca ._dbb ++;_dca ._bdf [_dca ._dbb ]=byte (uint16 (_gea )<<(8-_dca ._fag )&0xff);}else {_dca ._bdf [_dca ._dbb ]|=byte (uint16 (_gea )<<_dca ._fag &0xff);
_dca ._dbb ++;_dca ._bdf [_dca ._dbb ]=_gea >>(8-_dca ._fag );};return nil ;};func (_fef *Reader )ReadBool ()(bool ,error ){return _fef .readBool ()};func (_ggc *Reader )ReadUint32 ()(uint32 ,error ){_fge :=make ([]byte ,4);_ ,_adf :=_ggc .Read (_fge );
if _adf !=nil {return 0,_adf ;};return _a .BigEndian .Uint32 (_fge ),nil ;};func (_fe *BufferedWriter )Write (d []byte )(int ,error ){_fe .expandIfNeeded (len (d ));if _fe ._da ==0{return _fe .writeFullBytes (d ),nil ;};return _fe .writeShiftedBytes (d ),nil ;
};func (_acg *Reader )StreamPosition ()int64 {return _acg ._gd };func (_cef *Reader )Align ()(_ebaa byte ){_ebaa =_cef ._de ;_cef ._de =0;return _ebaa };var _ BinaryWriter =&BufferedWriter {};func (_dgef *SubstreamReader )Reset (){_dgef ._ggb =_dgef ._deb ;
_dgef ._gca =_dgef ._cfg };var (_ _df .Reader =&Reader {};_ _df .ByteReader =&Reader {};_ _df .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ge *Reader )BitPosition ()int {return int (_ge ._de )};func (_cb *Reader )ReadBit ()(_bbgf int ,_fc error ){_ggg ,_fc :=_cb .readBool ();
if _fc !=nil {return 0,_fc ;};if _ggg {_bbgf =1;};return _bbgf ,nil ;};func (_dge *BufferedWriter )writeShiftedBytes (_ab []byte )int {for _ ,_fa :=range _ab {_dge .writeByte (_fa );};return len (_ab );};func (_cac *SubstreamReader )readUnalignedByte ()(_cded byte ,_fgga error ){_eggff :=_cac ._gca ;
_cded =_cac ._bef <<(8-_eggff );_cac ._bef ,_fgga =_cac .readBufferByte ();if _fgga !=nil {return 0,_fgga ;};_cded |=_cac ._bef >>_eggff ;_cac ._bef &=1<<_eggff -1;return _cded ,nil ;};func (_aecc *Writer )Write (p []byte )(int ,error ){if len (p )> _aecc .byteCapacity (){return 0,_df .EOF ;
};for _ ,_eecc :=range p {if _eeb :=_aecc .writeByte (_eecc );_eeb !=nil {return 0,_eeb ;};};return len (p ),nil ;};func (_fggc *Reader )readBufferByte ()(byte ,error ){if _fggc ._gd >=int64 (len (_fggc ._faf )){return 0,_df .EOF ;};_fggc ._bbg =-1;_cba :=_fggc ._faf [_fggc ._gd ];
_fggc ._gd ++;_fggc ._ccd =int (_cba );return _cba ,nil ;};func (_dgc *SubstreamReader )readBool ()(_adaa bool ,_eef error ){if _dgc ._gca ==0{_dgc ._bef ,_eef =_dgc .readBufferByte ();if _eef !=nil {return false ,_eef ;};_adaa =(_dgc ._bef &0x80)!=0;_dgc ._bef ,_dgc ._gca =_dgc ._bef &0x7f,7;
return _adaa ,nil ;};_dgc ._gca --;_adaa =(_dgc ._bef &(1<<_dgc ._gca ))!=0;_dgc ._bef &=1<<_dgc ._gca -1;return _adaa ,nil ;};func (_cgb *SubstreamReader )Read (b []byte )(_aae int ,_geg error ){if _cgb ._ggb >=_cgb ._dgf {_c .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_cgb ._ggb ,_cgb ._dgf );
return 0,_df .EOF ;};for ;_aae < len (b );_aae ++{if b [_aae ],_geg =_cgb .readUnalignedByte ();_geg !=nil {if _geg ==_df .EOF {return _aae ,nil ;};return 0,_geg ;};};return _aae ,nil ;};func (_fad *SubstreamReader )ReadBit ()(_fdb int ,_bag error ){_cce ,_bag :=_fad .readBool ();
if _bag !=nil {return 0,_bag ;};if _cce {_fdb =1;};return _fdb ,nil ;};var _ _df .ByteWriter =&BufferedWriter {};func (_cea *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _cea ._de !=0{return _cea .ReadBits (_cea ._de );};return 0,nil ;};type BitWriter interface{WriteBit (_eb int )error ;
WriteBits (_gab uint64 ,_eac int )(_beb int ,_fae error );FinishByte ();SkipBits (_eba int )error ;};func (_aa *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ed .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_aa ._eg )-1< _aa ._bf {_aa .expandIfNeeded (1);};_ae :=_aa ._da ;if _aa ._ef {_ae =7-_aa ._da ;};_aa ._eg [_aa ._bf ]|=byte (uint16 (bit <<_ae )&0xff);_aa ._da ++;if _aa ._da ==8{_aa ._bf ++;_aa ._da =0;};return nil ;};func (_aca *BufferedWriter )grow (_efd int ){if _aca ._eg ==nil &&_efd < _ca {_aca ._eg =make ([]byte ,_efd ,_ca );
return ;};_gbe :=len (_aca ._eg );if _aca ._da !=0{_gbe ++;};_cc :=cap (_aca ._eg );switch {case _efd <=_cc /2-_gbe :_c .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_aca ._eg ),cap (_aca ._eg ),_efd );
_c .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cc ,_gbe );copy (_aca ._eg ,_aca ._eg [_aca .fullOffset ():]);
case _cc > _b -_cc -_efd :_c .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_caa :=make ([]byte ,2*_cc +_efd );copy (_caa ,_aca ._eg );_aca ._eg =_caa ;};_aca ._eg =_aca ._eg [:_gbe +_efd ];
};func (_aff *BufferedWriter )writeFullBytes (_dd []byte )int {_ea :=copy (_aff ._eg [_aff .fullOffset ():],_dd );_aff ._bf +=_ea ;return _ea ;};func (_ecc *Reader )Mark (){_ecc ._gcb =_ecc ._gd ;_ecc ._bd =_ecc ._de ;_ecc ._ff =_ecc ._aec ;_ecc ._dfe =_ecc ._ccd ;
};func (_fcg *Reader )readUnalignedByte ()(_aeb byte ,_dea error ){_cbd :=_fcg ._de ;_aeb =_fcg ._aec <<(8-_cbd );_fcg ._aec ,_dea =_fcg .readBufferByte ();if _dea !=nil {return 0,_dea ;};_aeb |=_fcg ._aec >>_cbd ;_fcg ._aec &=1<<_cbd -1;return _aeb ,nil ;
};func (_bfdf *SubstreamReader )ReadBits (n byte )(_dda uint64 ,_bed error ){if n < _bfdf ._gca {_fff :=_bfdf ._gca -n ;_dda =uint64 (_bfdf ._bef >>_fff );_bfdf ._bef &=1<<_fff -1;_bfdf ._gca =_fff ;return _dda ,nil ;};if n > _bfdf ._gca {if _bfdf ._gca > 0{_dda =uint64 (_bfdf ._bef );
n -=_bfdf ._gca ;};var _fdd byte ;for n >=8{_fdd ,_bed =_bfdf .readBufferByte ();if _bed !=nil {return 0,_bed ;};_dda =_dda <<8+uint64 (_fdd );n -=8;};if n > 0{if _bfdf ._bef ,_bed =_bfdf .readBufferByte ();_bed !=nil {return 0,_bed ;};_adaf :=8-n ;_dda =_dda <<n +uint64 (_bfdf ._bef >>_adaf );
_bfdf ._bef &=1<<_adaf -1;_bfdf ._gca =_adaf ;}else {_bfdf ._gca =0;};return _dda ,nil ;};_bfdf ._gca =0;return uint64 (_bfdf ._bef ),nil ;};var _ BinaryWriter =&Writer {};var _ _df .Writer =&BufferedWriter {};func (_fbc *SubstreamReader )readBufferByte ()(byte ,error ){if _fbc ._ggb >=_fbc ._dgf {return 0,_df .EOF ;
};if _fbc ._ggb >=_fbc ._fgf ||_fbc ._ggb < _fbc ._gf {if _bc :=_fbc .fillBuffer ();_bc !=nil {return 0,_bc ;};};_cbag :=_fbc ._fbe [_fbc ._ggb -_fbc ._gf ];_fbc ._ggb ++;return _cbag ,nil ;};func (_debe *Writer )WriteByte (c byte )error {return _debe .writeByte (c )};
func (_ffc *Reader )Read (p []byte )(_fb int ,_fdg error ){if _ffc ._de ==0{return _ffc .read (p );};for ;_fb < len (p );_fb ++{if p [_fb ],_fdg =_ffc .readUnalignedByte ();_fdg !=nil {return 0,_fdg ;};};return _fb ,nil ;};func (_efbb *Reader )Length ()uint64 {return uint64 (len (_efbb ._faf ))};
func (_ggf *Writer )byteCapacity ()int {_cae :=len (_ggf ._bdf )-_ggf ._dbb ;if _ggf ._fag !=0{_cae --;};return _cae ;};func (_db *SubstreamReader )ReadBool ()(bool ,error ){return _db .readBool ()};func (_bb *BufferedWriter )Len ()int {return _bb .byteCapacity ()};
func (_be *BufferedWriter )byteCapacity ()int {_gcd :=len (_be ._eg )-_be ._bf ;if _be ._da !=0{_gcd --;};return _gcd ;};func (_cg *BufferedWriter )expandIfNeeded (_cfd int ){if !_cg .tryGrowByReslice (_cfd ){_cg .grow (_cfd );};};func (_bde *SubstreamReader )Offset ()uint64 {return _bde ._abd };
func (_ced *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _df .SeekStart :_ced ._ggb =uint64 (offset );case _df .SeekCurrent :_ced ._ggb +=uint64 (offset );case _df .SeekEnd :_ced ._ggb =_ced ._dgf +uint64 (offset );
default:return 0,_e .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_ced ._gca =0;return int64 (_ced ._ggb ),nil ;};func (_acgc *SubstreamReader )Align ()(_cde byte ){_cde =_acgc ._gca ;_acgc ._gca =0;return _cde };func (_gbeb *SubstreamReader )BitPosition ()int {return int (_gbeb ._gca )};func (_ecfg *Writer )writeBit (_feg uint8 )error {if len (_ecfg ._bdf )-1< _ecfg ._dbb {return _df .EOF ;
};_edd :=_ecfg ._fag ;if _ecfg ._eec {_edd =7-_ecfg ._fag ;};_ecfg ._bdf [_ecfg ._dbb ]|=byte (uint16 (_feg <<_edd )&0xff);_ecfg ._fag ++;if _ecfg ._fag ==8{_ecfg ._dbb ++;_ecfg ._fag =0;};return nil ;};func (_dfb *Writer )SkipBits (skip int )error {const _abc ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_fffc :=int (_dfb ._fag )+skip ;if _fffc >=0&&_fffc < 8{_dfb ._fag =uint8 (_fffc );return nil ;};_fffc =int (_dfb ._fag )+_dfb ._dbb *8+skip ;if _fffc < 0{return _ed .Errorf (_abc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_cfgb :=_fffc /8;_aac :=_fffc %8;_c .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_c .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dfb ._fag ,_dfb ._dbb ,int (_dfb ._fag )+(_dfb ._dbb )*8,len (_dfb ._bdf ),cap (_dfb ._bdf ));
_c .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_fffc ,_aac );_dfb ._fag =uint8 (_aac );if _cec :=_cfgb -_dfb ._dbb ;
_cec > 0&&len (_dfb ._bdf )-1< _cfgb {_c .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cec );return _ed .Errorf (_abc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dfb ._dbb =_cfgb ;
_c .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dfb ._fag ,_dfb ._dbb );return nil ;};func _ecf (_acc ,_caf uint64 )uint64 {if _acc < _caf {return _acc ;
};return _caf ;};func (_dg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_f :=int (_dg ._da )+skip ;if _f >=0&&_f < 8{_dg ._da =uint8 (_f );return nil ;};_f =int (_dg ._da )+_dg ._bf *8+skip ;if _f < 0{return _ed .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ce :=_f /8;_cf :=_f %8;_dg ._da =uint8 (_cf );if _egg :=_ce -_dg ._bf ;_egg > 0&&len (_dg ._eg )-1< _ce {if _dg ._da !=0{_egg ++;};_dg .expandIfNeeded (_egg );};_dg ._bf =_ce ;return nil ;};func (_dc *BufferedWriter )writeByte (_af byte ){switch {case _dc ._da ==0:_dc ._eg [_dc ._bf ]=_af ;
_dc ._bf ++;case _dc ._ef :_dc ._eg [_dc ._bf ]|=_af >>_dc ._da ;_dc ._bf ++;_dc ._eg [_dc ._bf ]=byte (uint16 (_af )<<(8-_dc ._da )&0xff);default:_dc ._eg [_dc ._bf ]|=byte (uint16 (_af )<<_dc ._da &0xff);_dc ._bf ++;_dc ._eg [_dc ._bf ]=_af >>(8-_dc ._da );
};};func (_eff *SubstreamReader )fillBuffer ()error {if uint64 (_eff ._bfd .StreamPosition ())!=_eff ._ggb +_eff ._abd {_ ,_dde :=_eff ._bfd .Seek (int64 (_eff ._ggb +_eff ._abd ),_df .SeekStart );if _dde !=nil {return _dde ;};};_eff ._gf =_eff ._ggb ;
_cga :=_ecf (uint64 (len (_eff ._fbe )),_eff ._dgf -_eff ._ggb );_cgga :=make ([]byte ,_cga );_fbb ,_fea :=_eff ._bfd .Read (_cgga );if _fea !=nil {return _fea ;};for _ag :=uint64 (0);_ag < _cga ;_ag ++{_eff ._fbe [_ag ]=_cgga [_ag ];};_eff ._fgf =_eff ._gf +uint64 (_fbb );
return nil ;};