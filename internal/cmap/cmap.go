//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package cmap ;import (_a "bufio";_gba "bytes";_ce "encoding/hex";_f "errors";_g "fmt";_b "github.com/unidoc/unipdf/v3/common";_fb "github.com/unidoc/unipdf/v3/core";_ab "github.com/unidoc/unipdf/v3/internal/cmap/bcmaps";_gg "io";_cd "sort";_gb "strconv";
_d "strings";_cb "unicode/utf16";);func NewCIDSystemInfo (obj _fb .PdfObject )(_bg CIDSystemInfo ,_gbe error ){_deg ,_fd :=_fb .GetDict (obj );if !_fd {return CIDSystemInfo {},_fb .ErrTypeError ;};_ae ,_fd :=_fb .GetStringVal (_deg .Get ("\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079"));
if !_fd {return CIDSystemInfo {},_fb .ErrTypeError ;};_da ,_fd :=_fb .GetStringVal (_deg .Get ("\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067"));if !_fd {return CIDSystemInfo {},_fb .ErrTypeError ;};_ge ,_fd :=_fb .GetIntVal (_deg .Get ("\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074"));
if !_fd {return CIDSystemInfo {},_fb .ErrTypeError ;};return CIDSystemInfo {Registry :_ae ,Ordering :_da ,Supplement :_ge },nil ;};func (_ggga *cMapParser )parseObject ()(cmapObject ,error ){_ggga .skipSpaces ();for {_fec ,_dcbg :=_ggga ._gbee .Peek (2);
if _dcbg !=nil {return nil ,_dcbg ;};if _fec [0]=='%'{_ggga .parseComment ();_ggga .skipSpaces ();continue ;}else if _fec [0]=='/'{_eeaa ,_cdcb :=_ggga .parseName ();return _eeaa ,_cdcb ;}else if _fec [0]=='('{_bbeb ,_fcg :=_ggga .parseString ();return _bbeb ,_fcg ;
}else if _fec [0]=='['{_egb ,_feca :=_ggga .parseArray ();return _egb ,_feca ;}else if (_fec [0]=='<')&&(_fec [1]=='<'){_dcd ,_bfcf :=_ggga .parseDict ();return _dcd ,_bfcf ;}else if _fec [0]=='<'{_ffcc ,_egae :=_ggga .parseHexString ();return _ffcc ,_egae ;
}else if _fb .IsDecimalDigit (_fec [0])||(_fec [0]=='-'&&_fb .IsDecimalDigit (_fec [1])){_fgd ,_ddeb :=_ggga .parseNumber ();if _ddeb !=nil {return nil ,_ddeb ;};return _fgd ,nil ;}else {_aga ,_geba :=_ggga .parseOperand ();if _geba !=nil {return nil ,_geba ;
};return _aga ,nil ;};};};func (cmap *CMap )inCodespace (_dgg CharCode ,_edgg int )bool {for _ ,_ead :=range cmap ._cbe {if _ead .Low <=_dgg &&_dgg <=_ead .High &&_edgg ==_ead .NumBytes {return true ;};};return false ;};type cmapOperand struct{Operand string ;
};func (_eeb *cMapParser )parseName ()(cmapName ,error ){_abed :="";_bbcc :=false ;for {_bdfe ,_egf :=_eeb ._gbee .Peek (1);if _egf ==_gg .EOF {break ;};if _egf !=nil {return cmapName {_abed },_egf ;};if !_bbcc {if _bdfe [0]=='/'{_bbcc =true ;_eeb ._gbee .ReadByte ();
}else {_b .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u004e\u0061\u006d\u0065\u0020\u0073\u0074a\u0072t\u0069n\u0067 \u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0028\u0025\u0020\u0078\u0029",_bdfe ,_bdfe );return cmapName {_abed },_g .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_bdfe [0]);
};}else {if _fb .IsWhiteSpace (_bdfe [0]){break ;}else if (_bdfe [0]=='/')||(_bdfe [0]=='[')||(_bdfe [0]=='(')||(_bdfe [0]==']')||(_bdfe [0]=='<')||(_bdfe [0]=='>'){break ;}else if _bdfe [0]=='#'{_aeadg ,_cfgff :=_eeb ._gbee .Peek (3);if _cfgff !=nil {return cmapName {_abed },_cfgff ;
};_eeb ._gbee .Discard (3);_ecc ,_cfgff :=_ce .DecodeString (string (_aeadg [1:3]));if _cfgff !=nil {return cmapName {_abed },_cfgff ;};_abed +=string (_ecc );}else {_adb ,_ :=_eeb ._gbee .ReadByte ();_abed +=string (_adb );};};};return cmapName {_abed },nil ;
};func (_cbgb *cMapParser )parseNumber ()(cmapObject ,error ){_eba ,_ddfd :=_fb .ParseNumber (_cbgb ._gbee );if _ddfd !=nil {return nil ,_ddfd ;};switch _aba :=_eba .(type ){case *_fb .PdfObjectFloat :return cmapFloat {float64 (*_aba )},nil ;case *_fb .PdfObjectInteger :return cmapInt {int64 (*_aba )},nil ;
};return nil ,_g .Errorf ("\u0075n\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0054",_eba );};func (_fcge *cMapParser )parseDict ()(cmapDict ,error ){_b .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");
_gfd :=_ddcb ();_gda ,_ :=_fcge ._gbee .ReadByte ();if _gda !='<'{return _gfd ,ErrBadCMapDict ;};_gda ,_ =_fcge ._gbee .ReadByte ();if _gda !='<'{return _gfd ,ErrBadCMapDict ;};for {_fcge .skipSpaces ();_def ,_fbgf :=_fcge ._gbee .Peek (2);if _fbgf !=nil {return _gfd ,_fbgf ;
};if (_def [0]=='>')&&(_def [1]=='>'){_fcge ._gbee .ReadByte ();_fcge ._gbee .ReadByte ();break ;};_cebc ,_fbgf :=_fcge .parseName ();_b .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_cebc .Name );if _fbgf !=nil {_b .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0061\u006d\u0065\u002e\u0020\u0065\u0072r=\u0025\u0076",_fbgf );
return _gfd ,_fbgf ;};_fcge .skipSpaces ();_ddfb ,_fbgf :=_fcge .parseObject ();if _fbgf !=nil {return _gfd ,_fbgf ;};_gfd .Dict [_cebc .Name ]=_ddfb ;_fcge .skipSpaces ();_def ,_fbgf =_fcge ._gbee .Peek (3);if _fbgf !=nil {return _gfd ,_fbgf ;};if string (_def )=="\u0064\u0065\u0066"{_fcge ._gbee .Discard (3);
};};return _gfd ,nil ;};func (_ggdb *cMapParser )parseHexString ()(cmapHexString ,error ){_ggdb ._gbee .ReadByte ();_ggf :=[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");
_gdb :=_gba .Buffer {};for {_ggdb .skipSpaces ();_agd ,_bcaa :=_ggdb ._gbee .Peek (1);if _bcaa !=nil {return cmapHexString {},_bcaa ;};if _agd [0]=='>'{_ggdb ._gbee .ReadByte ();break ;};_cbc ,_ :=_ggdb ._gbee .ReadByte ();if _gba .IndexByte (_ggf ,_cbc )>=0{_gdb .WriteByte (_cbc );
};};if _gdb .Len ()%2==1{_b .Log .Debug ("\u0070\u0061rs\u0065\u0048\u0065x\u0053\u0074\u0072\u0069ng:\u0020ap\u0070\u0065\u006e\u0064\u0069\u006e\u0067 '\u0030\u0027\u0020\u0074\u006f\u0020\u0025#\u0071",_gdb .String ());_gdb .WriteByte ('0');};_eeca :=_gdb .Len ()/2;
_dffg ,_ :=_ce .DecodeString (_gdb .String ());return cmapHexString {_ecb :_eeca ,_gcb :_dffg },nil ;};func (cmap *CMap )computeInverseMappings (){for _acd ,_eec :=range cmap ._ca {if _ddb ,_gd :=cmap ._gf [_eec ];!_gd ||(_gd &&_ddb > _acd ){cmap ._gf [_eec ]=_acd ;
};};for _fe ,_gac :=range cmap ._df {if _eg ,_ggd :=cmap ._bf [_gac ];!_ggd ||(_ggd &&_eg > _fe ){cmap ._bf [_gac ]=_fe ;};};_cd .Slice (cmap ._cbe ,func (_beg ,_fbd int )bool {return cmap ._cbe [_beg ].Low < cmap ._cbe [_fbd ].Low });};type fbRange struct{_ga CharCode ;
_de CharCode ;_dc string ;};func (cmap *CMap )parseBfrange ()error {for {var _edge CharCode ;_cfec ,_gcg :=cmap .parseObject ();if _gcg !=nil {if _gcg ==_gg .EOF {break ;};return _gcg ;};switch _bged :=_cfec .(type ){case cmapOperand :if _bged .Operand ==_cfgf {return nil ;
};return _f .New ("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065d\u0020\u006fp\u0065\u0072\u0061\u006e\u0064");case cmapHexString :_edge =_fbgbf (_bged );default:return _f .New ("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065");
};var _bed CharCode ;_cfec ,_gcg =cmap .parseObject ();if _gcg !=nil {if _gcg ==_gg .EOF {break ;};return _gcg ;};switch _cedb :=_cfec .(type ){case cmapOperand :_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0049\u006e\u0063\u006f\u006d\u0070\u006c\u0065\u0074\u0065\u0020\u0062\u0066r\u0061\u006e\u0067\u0065\u0020\u0074\u0072i\u0070\u006c\u0065\u0074");
return ErrBadCMap ;case cmapHexString :_bed =_fbgbf (_cedb );if _bed > 0xffff{_bed =0xffff;};default:_b .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0055\u006e\u0065\u0078\u0070e\u0063t\u0065d\u0020\u0074\u0079\u0070\u0065\u0020\u0025T",_cfec );return ErrBadCMap ;
};_cfec ,_gcg =cmap .parseObject ();if _gcg !=nil {if _gcg ==_gg .EOF {break ;};return _gcg ;};switch _ggg :=_cfec .(type ){case cmapArray :if len (_ggg .Array )!=int (_bed -_edge )+1{_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u006f\u0066\u0020\u0069\u0074\u0065\u006d\u0073\u0020\u0069\u006e\u0020a\u0072\u0072\u0061\u0079");
return ErrBadCMap ;};for _cgfg :=_edge ;_cgfg <=_bed ;_cgfg ++{_ffcbc :=_ggg .Array [_cgfg -_edge ];_ggce ,_bfe :=_ffcbc .(cmapHexString );if !_bfe {return _f .New ("\u006e\u006f\u006e-h\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0020\u0061\u0072\u0072\u0061\u0079");
};_aacg :=_egbc (_ggce );cmap ._df [_cgfg ]=string (_aacg );};case cmapHexString :_cfc :=_egbc (_ggg );_bede :=len (_cfc );for _abg :=_edge ;_abg <=_bed ;_abg ++{cmap ._df [_abg ]=string (_cfc );if _bede > 0{_cfc [_bede -1]++;}else {_b .Log .Debug ("\u004e\u006f\u0020c\u006d\u0061\u0070\u0020\u0074\u0061\u0072\u0067\u0065\u0074\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0066\u006f\u0072\u0020\u0025\u0023\u0076",_abg );
};if _abg ==1<<32-1{break ;};};default:_b .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0055\u006e\u0065\u0078\u0070e\u0063t\u0065d\u0020\u0074\u0079\u0070\u0065\u0020\u0025T",_cfec );return ErrBadCMap ;};};return nil ;};func (cmap *CMap )Stream ()(*_fb .PdfObjectStream ,error ){if cmap ._af !=nil {return cmap ._af ,nil ;
};_fea ,_afc :=_fb .MakeStream (cmap .Bytes (),_fb .NewFlateEncoder ());if _afc !=nil {return nil ,_afc ;};cmap ._af =_fea ;return cmap ._af ,nil ;};func (_afa *cMapParser )parseOperand ()(cmapOperand ,error ){_efc :=cmapOperand {};_fgb :=_gba .Buffer {};
for {_bgc ,_fbgb :=_afa ._gbee .Peek (1);if _fbgb !=nil {if _fbgb ==_gg .EOF {break ;};return _efc ,_fbgb ;};if _fb .IsDelimiter (_bgc [0]){break ;};if _fb .IsWhiteSpace (_bgc [0]){break ;};_ace ,_ :=_afa ._gbee .ReadByte ();_fgb .WriteByte (_ace );};if _fgb .Len ()==0{return _efc ,_g .Errorf ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0070\u0065\u0072\u0061\u006e\u0064\u0020\u0028\u0065\u006d\u0070\u0074\u0079\u0029");
};_efc .Operand =_fgb .String ();return _efc ,nil ;};const (_dfdd ="\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f";_fef ="\u0062e\u0067\u0069\u006e\u0063\u006d\u0061p";_abc ="\u0065n\u0064\u0063\u006d\u0061\u0070";_agb ="\u0062\u0065\u0067\u0069nc\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0072\u0061\u006e\u0067\u0065";
_gggg ="\u0065\u006e\u0064\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065r\u0061\u006e\u0067\u0065";_cgfc ="b\u0065\u0067\u0069\u006e\u0062\u0066\u0063\u0068\u0061\u0072";_gbeg ="\u0065n\u0064\u0062\u0066\u0063\u0068\u0061r";_bgfg ="\u0062\u0065\u0067i\u006e\u0062\u0066\u0072\u0061\u006e\u0067\u0065";
_cfgf ="\u0065\u006e\u0064\u0062\u0066\u0072\u0061\u006e\u0067\u0065";_eea ="\u0062\u0065\u0067\u0069\u006e\u0063\u0069\u0064\u0072\u0061\u006e\u0067\u0065";_caa ="e\u006e\u0064\u0063\u0069\u0064\u0072\u0061\u006e\u0067\u0065";_bab ="\u0075s\u0065\u0063\u006d\u0061\u0070";
_fdf ="\u0057\u004d\u006fd\u0065";_dbgf ="\u0043\u004d\u0061\u0070\u004e\u0061\u006d\u0065";_bdd ="\u0043\u004d\u0061\u0070\u0054\u0079\u0070\u0065";_cdc ="C\u004d\u0061\u0070\u0056\u0065\u0072\u0073\u0069\u006f\u006e";);func _bbc (_geb string )(*CMap ,error ){_dce ,_dd :=_ab .Asset (_geb );
if _dd !=nil {return nil ,_dd ;};return LoadCmapFromDataCID (_dce );};func (cmap *CMap )parseVersion ()error {_fgc :="";_dde :=false ;for _ebcc :=0;_ebcc < 3&&!_dde ;_ebcc ++{_ega ,_caba :=cmap .parseObject ();if _caba !=nil {return _caba ;};switch _edgf :=_ega .(type ){case cmapOperand :switch _edgf .Operand {case "\u0064\u0065\u0066":_dde =true ;
default:_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0070\u0061\u0072\u0073\u0065\u0056e\u0072\u0073\u0069\u006f\u006e\u003a \u0073\u0074\u0061\u0074\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u002e\u0020o\u003d\u0025\u0023\u0076",_ega );
return ErrBadCMap ;};case cmapInt :_fgc =_g .Sprintf ("\u0025\u0064",_edgf ._afed );case cmapFloat :_fgc =_g .Sprintf ("\u0025\u0066",_edgf ._dcef );case cmapString :_fgc =_edgf .String ;default:_b .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020p\u0061\u0072\u0073\u0065Ver\u0073io\u006e\u003a\u0020\u0042\u0061\u0064\u0020ty\u0070\u0065\u002e\u0020\u006f\u003d\u0025#\u0076",_ega );
};};cmap ._ed =_fgc ;return nil ;};func (cmap *CMap )parseWMode ()error {var _ffbb int ;_gfb :=false ;for _abe :=0;_abe < 3&&!_gfb ;_abe ++{_daf ,_bdf :=cmap .parseObject ();if _bdf !=nil {return _bdf ;};switch _ebc :=_daf .(type ){case cmapOperand :switch _ebc .Operand {case "\u0064\u0065\u0066":_gfb =true ;
default:_b .Log .Error ("\u0070\u0061\u0072\u0073\u0065\u0057\u004d\u006f\u0064\u0065:\u0020\u0073\u0074\u0061\u0074\u0065\u0020e\u0072\u0072\u006f\u0072\u002e\u0020\u006f\u003d\u0025\u0023\u0076",_daf );return ErrBadCMap ;};case cmapInt :_ffbb =int (_ebc ._afed );
};};cmap ._dfc =integer {_dgeg :true ,_cadg :_ffbb };return nil ;};func (cmap *CMap )matchCode (_bfc []byte )(_abb CharCode ,_dab int ,_gca bool ){for _ece :=0;_ece < _e ;_ece ++{if _ece < len (_bfc ){_abb =_abb <<8|CharCode (_bfc [_ece ]);_dab ++;};_gca =cmap .inCodespace (_abb ,_ece +1);
if _gca {return _abb ,_dab ,true ;};};_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0063o\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0020m\u0061t\u0063\u0068\u0065\u0073\u0020\u0062\u0079\u0074\u0065\u0073\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d=\u0025\u0023\u0071\u0020\u0063\u006d\u0061\u0070\u003d\u0025\u0073",_bfc ,string (_bfc ),cmap );
return 0,0,false ;};func (_gbfg *cMapParser )parseComment ()(string ,error ){var _dca _gba .Buffer ;_ ,_efee :=_gbfg .skipSpaces ();if _efee !=nil {return _dca .String (),_efee ;};_add :=true ;for {_afd ,_gegc :=_gbfg ._gbee .Peek (1);if _gegc !=nil {_b .Log .Debug ("p\u0061r\u0073\u0065\u0043\u006f\u006d\u006d\u0065\u006et\u003a\u0020\u0065\u0072r=\u0025\u0076",_gegc );
return _dca .String (),_gegc ;};if _add &&_afd [0]!='%'{return _dca .String (),ErrBadCMapComment ;};_add =false ;if (_afd [0]!='\r')&&(_afd [0]!='\n'){_cbg ,_ :=_gbfg ._gbee .ReadByte ();_dca .WriteByte (_cbg );}else {break ;};};return _dca .String (),nil ;
};type Codespace struct{NumBytes int ;Low CharCode ;High CharCode ;};func _cdeg (_agf string )string {_fge :=[]rune (_agf );_ggcdc :=make ([]string ,len (_fge ));for _faa ,_dge :=range _fge {_ggcdc [_faa ]=_g .Sprintf ("\u0025\u0030\u0034\u0078",_dge );
};return _g .Sprintf ("\u003c\u0025\u0073\u003e",_d .Join (_ggcdc ,""));};func LoadPredefinedCMap (name string )(*CMap ,error ){cmap ,_cc :=_bbc (name );if _cc !=nil {return nil ,_cc ;};if cmap ._cf ==""{cmap .computeInverseMappings ();return cmap ,nil ;
};_cef ,_cc :=_bbc (cmap ._cf );if _cc !=nil {return nil ,_cc ;};for _cbd ,_ffb :=range _cef ._ca {if _ ,_fba :=cmap ._ca [_cbd ];!_fba {cmap ._ca [_cbd ]=_ffb ;};};cmap ._cbe =append (cmap ._cbe ,_cef ._cbe ...);cmap .computeInverseMappings ();return cmap ,nil ;
};func (_fbde *cMapParser )parseArray ()(cmapArray ,error ){_gab :=cmapArray {};_gab .Array =[]cmapObject {};_fbde ._gbee .ReadByte ();for {_fbde .skipSpaces ();_cdgb ,_bbd :=_fbde ._gbee .Peek (1);if _bbd !=nil {return _gab ,_bbd ;};if _cdgb [0]==']'{_fbde ._gbee .ReadByte ();
break ;};_cca ,_bbd :=_fbde .parseObject ();if _bbd !=nil {return _gab ,_bbd ;};_gab .Array =append (_gab .Array ,_cca );};return _gab ,nil ;};type cmapInt struct{_afed int64 };func _cfgd (_egd ,_ffa int )int {if _egd < _ffa {return _egd ;};return _ffa ;
};func LoadCmapFromDataCID (data []byte )(*CMap ,error ){return LoadCmapFromData (data ,false )};func (cmap *CMap )Bytes ()[]byte {_b .Log .Trace ("\u0063\u006d\u0061\u0070.B\u0079\u0074\u0065\u0073\u003a\u0020\u0063\u006d\u0061\u0070\u003d\u0025\u0073",cmap .String ());
if len (cmap ._ba )> 0{return cmap ._ba ;};cmap ._ba =[]byte (_d .Join ([]string {_edd ,cmap .toBfData (),_fgg },"\u000a"));return cmap ._ba ;};type cmapFloat struct{_dcef float64 };type cMapParser struct{_gbee *_a .Reader };func (cmap *CMap )String ()string {_fae :=cmap ._ea ;
_edb :=[]string {_g .Sprintf ("\u006e\u0062\u0069\u0074\u0073\u003a\u0025\u0064",cmap ._gc ),_g .Sprintf ("\u0074y\u0070\u0065\u003a\u0025\u0064",cmap ._geg )};if cmap ._ed !=""{_edb =append (_edb ,_g .Sprintf ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u003a\u0025\u0073",cmap ._ed ));
};if cmap ._cf !=""{_edb =append (_edb ,_g .Sprintf ("u\u0073\u0065\u0063\u006d\u0061\u0070\u003a\u0025\u0023\u0071",cmap ._cf ));};_edb =append (_edb ,_g .Sprintf ("\u0073\u0079\u0073\u0074\u0065\u006d\u0049\u006e\u0066\u006f\u003a\u0025\u0073",_fae .String ()));
if len (cmap ._cbe )> 0{_edb =append (_edb ,_g .Sprintf ("\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0073\u003a\u0025\u0064",len (cmap ._cbe )));};if len (cmap ._df )> 0{_edb =append (_edb ,_g .Sprintf ("\u0063\u006fd\u0065\u0054\u006fU\u006e\u0069\u0063\u006f\u0064\u0065\u003a\u0025\u0064",len (cmap ._df )));
};return _g .Sprintf ("\u0043\u004d\u0041P\u007b\u0025\u0023\u0071\u0020\u0025\u0073\u007d",cmap ._gbab ,_d .Join (_edb ,"\u0020"));};func _acc (_dda []byte )*cMapParser {_gbf :=cMapParser {};_ede :=_gba .NewBuffer (_dda );_gbf ._gbee =_a .NewReader (_ede );
return &_gbf ;};func (cmap *CMap )parseCIDRange ()error {for {_adcb ,_dafg :=cmap .parseObject ();if _dafg !=nil {if _dafg ==_gg .EOF {break ;};return _dafg ;};_ccd ,_edff :=_adcb .(cmapHexString );if !_edff {if _agcc ,_efbc :=_adcb .(cmapOperand );_efbc {if _agcc .Operand ==_caa {return nil ;
};return _f .New ("\u0063\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0072\u0076\u0061\u006c\u0020s\u0074\u0061\u0072\u0074\u0020\u006du\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0068\u0065\u0078\u0020\u0073t\u0072\u0069\u006e\u0067");};};_ffg :=_fbgbf (_ccd );
_adcb ,_dafg =cmap .parseObject ();if _dafg !=nil {if _dafg ==_gg .EOF {break ;};return _dafg ;};_bfg ,_edff :=_adcb .(cmapHexString );if !_edff {return _f .New ("\u0063\u0069d\u0020\u0069\u006e\u0074e\u0072\u0076a\u006c\u0020\u0065\u006e\u0064\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0068\u0065\u0078\u0020\u0073t\u0072\u0069\u006e\u0067");
};if len (_ccd ._gcb )!=len (_bfg ._gcb ){return _f .New ("\u0075\u006e\u0065\u0071\u0075\u0061\u006c\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0062\u0079\u0074\u0065\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065");};_aac :=_fbgbf (_bfg );
if _ffg > _aac {_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0049\u0044\u0020\u0072\u0061\u006e\u0067\u0065\u002e\u0020\u0073t\u0061\u0072\u0074\u003d\u0030\u0078\u0025\u0030\u0032\u0078\u0020\u0065\u006e\u0064=\u0030x\u0025\u0030\u0032\u0078",_ffg ,_aac );
return ErrBadCMap ;};_adcb ,_dafg =cmap .parseObject ();if _dafg !=nil {if _dafg ==_gg .EOF {break ;};return _dafg ;};_cgaf ,_edff :=_adcb .(cmapInt );if !_edff {return _f .New ("\u0063\u0069\u0064\u0020\u0073t\u0061\u0072\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0064\u0065\u0063\u0069\u006d\u0061\u006c\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
};if _cgaf ._afed < 0{return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0063\u0069\u0064\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0076\u0061\u006c\u0075\u0065");};_cfd :=_cgaf ._afed ;for _cfe :=_ffg ;_cfe <=_aac ;_cfe ++{cmap ._ca [_cfe ]=CharCode (_cfd );
_cfd ++;};_b .Log .Trace ("C\u0049\u0044\u0020\u0072\u0061\u006eg\u0065\u003a\u0020\u003c\u0030\u0078\u0025\u0058\u003e \u003c\u0030\u0078%\u0058>\u0020\u0025\u0064",_ffg ,_aac ,_cgaf ._afed );};return nil ;};func (cmap *CMap )parseBfchar ()error {for {_gdec ,_fac :=cmap .parseObject ();
if _fac !=nil {if _fac ==_gg .EOF {break ;};return _fac ;};var _ffeb CharCode ;switch _cgf :=_gdec .(type ){case cmapOperand :if _cgf .Operand ==_gbeg {return nil ;};return _f .New ("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065d\u0020\u006fp\u0065\u0072\u0061\u006e\u0064");
case cmapHexString :_ffeb =_fbgbf (_cgf );default:return _f .New ("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065");};_gdec ,_fac =cmap .parseObject ();if _fac !=nil {if _fac ==_gg .EOF {break ;};return _fac ;};var _ddc []rune ;
switch _gbec :=_gdec .(type ){case cmapOperand :if _gbec .Operand ==_gbeg {return nil ;};_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020o\u0070\u0065\u0072\u0061\u006e\u0064\u002e\u0020\u0025\u0023\u0076",_gbec );
return ErrBadCMap ;case cmapHexString :_ddc =_egbc (_gbec );case cmapName :_b .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0061\u006de\u002e \u0025\u0023\u0076",_gbec );_ddc =[]rune {MissingCodeRune };
default:_b .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u0074\u0079\u0070e\u002e \u0025\u0023\u0076",_gdec );return ErrBadCMap ;};cmap ._df [_ffeb ]=string (_ddc );};return nil ;};const (_e =4;
MissingCodeRune ='\ufffd';MissingCodeString =string (MissingCodeRune ););type cmapString struct{String string ;};func (cmap *CMap )parseSystemInfo ()error {_eef :=false ;_aef :=false ;_cce :="";_gfc :=false ;_ged :=CIDSystemInfo {};for _fbb :=0;_fbb < 50&&!_gfc ;
_fbb ++{_fcf ,_gbb :=cmap .parseObject ();if _gbb !=nil {return _gbb ;};switch _ebg :=_fcf .(type ){case cmapDict :_bac :=_ebg .Dict ;_bbfc ,_edf :=_bac ["\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079"];if !_edf {_b .Log .Debug ("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f");
return ErrBadCMap ;};_bcc ,_edf :=_bbfc .(cmapString );if !_edf {_b .Log .Debug ("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f");return ErrBadCMap ;};_ged .Registry =_bcc .String ;
_bbfc ,_edf =_bac ["\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067"];if !_edf {_b .Log .Debug ("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f");return ErrBadCMap ;};_bcc ,_edf =_bbfc .(cmapString );
if !_edf {_b .Log .Debug ("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f");return ErrBadCMap ;};_ged .Ordering =_bcc .String ;_dcb ,_edf :=_bac ["\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074"];
if !_edf {_b .Log .Debug ("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f");return ErrBadCMap ;};_bfcb ,_edf :=_dcb .(cmapInt );if !_edf {_b .Log .Debug ("\u0045\u0052\u0052\u004fR:\u0020\u0042\u0061\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006ef\u006f");
return ErrBadCMap ;};_ged .Supplement =int (_bfcb ._afed );_gfc =true ;case cmapOperand :switch _ebg .Operand {case "\u0062\u0065\u0067i\u006e":_eef =true ;case "\u0065\u006e\u0064":_gfc =true ;case "\u0064\u0065\u0066":_aef =false ;};case cmapName :if _eef {_cce =_ebg .Name ;
_aef =true ;};case cmapString :if _aef {switch _cce {case "\u0052\u0065\u0067\u0069\u0073\u0074\u0072\u0079":_ged .Registry =_ebg .String ;case "\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067":_ged .Ordering =_ebg .String ;};};case cmapInt :if _aef {switch _cce {case "\u0053\u0075\u0070\u0070\u006c\u0065\u006d\u0065\u006e\u0074":_ged .Supplement =int (_ebg ._afed );
};};};};if !_gfc {_b .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0053\u0079\u0073\u0074\u0065\u006d\u0020\u0049\u006e\u0066\u006f\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u006c\u0079");
return ErrBadCMap ;};cmap ._ea =_ged ;return nil ;};func _fbgbf (_bcd cmapHexString )CharCode {_cdga :=CharCode (0);for _ ,_cgfe :=range _bcd ._gcb {_cdga <<=8;_cdga |=CharCode (_cgfe );};return _cdga ;};func IsPredefinedCMap (name string )bool {return _ab .AssetExists (name )};
func (cmap *CMap )BytesToCharcodes (data []byte )([]CharCode ,bool ){var _ddf []CharCode ;if cmap ._gc ==8{for _ ,_fbda :=range data {_ddf =append (_ddf ,CharCode (_fbda ));};return _ddf ,true ;};for _db :=0;_db < len (data );{_gag ,_gdg ,_gaf :=cmap .matchCode (data [_db :]);
if !_gaf {_b .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0063\u006f\u0064\u0065\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0061\u0074\u0020\u0069\u003d\u0025\u0064\u0020\u0062\u0079\u0074\u0065\u0073\u003d\u005b\u0025\u0020\u0030\u0032\u0078\u005d\u003d\u0025\u0023\u0071",_db ,data ,string (data ));
return _ddf ,false ;};_ddf =append (_ddf ,_gag );_db +=_gdg ;};return _ddf ,true ;};func (cmap *CMap )toBfData ()string {if len (cmap ._df )==0{return "";};_aec :=make ([]CharCode ,0,len (cmap ._df ));for _acac :=range cmap ._df {_aec =append (_aec ,_acac );
};_cd .Slice (_aec ,func (_feb ,_bbg int )bool {return _aec [_feb ]< _aec [_bbg ]});var _dfde []charRange ;_gfe :=charRange {_aec [0],_aec [0]};_cad :=cmap ._df [_aec [0]];for _ ,_ced :=range _aec [1:]{_cbec :=cmap ._df [_ced ];if _ced ==_gfe ._ff +1&&_aff (_cbec )==_aff (_cad )+1{_gfe ._ff =_ced ;
}else {_dfde =append (_dfde ,_gfe );_gfe ._ef ,_gfe ._ff =_ced ,_ced ;};_cad =_cbec ;};_dfde =append (_dfde ,_gfe );var _bd []CharCode ;var _fad []fbRange ;for _ ,_cgg :=range _dfde {if _cgg ._ef ==_cgg ._ff {_bd =append (_bd ,_cgg ._ef );}else {_fad =append (_fad ,fbRange {_ga :_cgg ._ef ,_de :_cgg ._ff ,_dc :cmap ._df [_cgg ._ef ]});
};};_b .Log .Trace ("\u0063\u0068ar\u0052\u0061\u006eg\u0065\u0073\u003d\u0025d f\u0062Ch\u0061\u0072\u0073\u003d\u0025\u0064\u0020fb\u0052\u0061\u006e\u0067\u0065\u0073\u003d%\u0064",len (_dfde ),len (_bd ),len (_fad ));var _gec []string ;if len (_bd )> 0{_gdf :=(len (_bd )+_fab -1)/_fab ;
for _adc :=0;_adc < _gdf ;_adc ++{_bca :=_cfgd (len (_bd )-_adc *_fab ,_fab );_gec =append (_gec ,_g .Sprintf ("\u0025\u0064\u0020\u0062\u0065\u0067\u0069\u006e\u0062f\u0063\u0068\u0061\u0072",_bca ));for _gge :=0;_gge < _bca ;_gge ++{_fg :=_bd [_adc *_fab +_gge ];
_gaa :=cmap ._df [_fg ];_gec =append (_gec ,_g .Sprintf ("\u003c%\u0030\u0034\u0078\u003e\u0020\u0025s",_fg ,_cdeg (_gaa )));};_gec =append (_gec ,"\u0065n\u0064\u0062\u0066\u0063\u0068\u0061r");};};if len (_fad )> 0{_bgg :=(len (_fad )+_fab -1)/_fab ;
for _bcg :=0;_bcg < _bgg ;_bcg ++{_ceg :=_cfgd (len (_fad )-_bcg *_fab ,_fab );_gec =append (_gec ,_g .Sprintf ("\u0025d\u0020b\u0065\u0067\u0069\u006e\u0062\u0066\u0072\u0061\u006e\u0067\u0065",_ceg ));for _dbc :=0;_dbc < _ceg ;_dbc ++{_agg :=_fad [_bcg *_fab +_dbc ];
_gec =append (_gec ,_g .Sprintf ("\u003c%\u00304\u0078\u003e\u003c\u0025\u0030\u0034\u0078\u003e\u0020\u0025\u0073",_agg ._ga ,_agg ._de ,_cdeg (_agg ._dc )));};_gec =append (_gec ,"\u0065\u006e\u0064\u0062\u0066\u0072\u0061\u006e\u0067\u0065");};};return _d .Join (_gec ,"\u000a");
};func (cmap *CMap )CharcodeToCID (code CharCode )(CharCode ,bool ){_caf ,_ggc :=cmap ._ca [code ];return _caf ,_ggc ;};func (_fade *cMapParser )parseString ()(cmapString ,error ){_fade ._gbee .ReadByte ();_fbba :=_gba .Buffer {};_gacb :=1;for {_bfb ,_bbeg :=_fade ._gbee .Peek (1);
if _bbeg !=nil {return cmapString {_fbba .String ()},_bbeg ;};if _bfb [0]=='\\'{_fade ._gbee .ReadByte ();_babd ,_bbfd :=_fade ._gbee .ReadByte ();if _bbfd !=nil {return cmapString {_fbba .String ()},_bbfd ;};if _fb .IsOctalDigit (_babd ){_gbag ,_aaa :=_fade ._gbee .Peek (2);
if _aaa !=nil {return cmapString {_fbba .String ()},_aaa ;};var _bebe []byte ;_bebe =append (_bebe ,_babd );for _ ,_fbcc :=range _gbag {if _fb .IsOctalDigit (_fbcc ){_bebe =append (_bebe ,_fbcc );}else {break ;};};_fade ._gbee .Discard (len (_bebe )-1);
_b .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bebe );_daa ,_aaa :=_gb .ParseUint (string (_bebe ),8,32);if _aaa !=nil {return cmapString {_fbba .String ()},_aaa ;};_fbba .WriteByte (byte (_daa ));
continue ;};switch _babd {case 'n':_fbba .WriteByte ('\n');case 'r':_fbba .WriteByte ('\r');case 't':_fbba .WriteByte ('\t');case 'b':_fbba .WriteByte ('\b');case 'f':_fbba .WriteByte ('\f');case '(':_fbba .WriteByte ('(');case ')':_fbba .WriteByte (')');
case '\\':_fbba .WriteByte ('\\');};continue ;}else if _bfb [0]=='('{_gacb ++;}else if _bfb [0]==')'{_gacb --;if _gacb ==0{_fade ._gbee .ReadByte ();break ;};};_gafe ,_ :=_fade ._gbee .ReadByte ();_fbba .WriteByte (_gafe );};return cmapString {_fbba .String ()},nil ;
};type cmapName struct{Name string ;};func (cmap *CMap )StringToCID (s string )(CharCode ,bool ){_eca ,_ffcb :=cmap ._bf [s ];return _eca ,_ffcb ;};type charRange struct{_ef CharCode ;_ff CharCode ;};func (cmap *CMap )CharcodeBytesToUnicode (data []byte )(string ,int ){_cga ,_dg :=cmap .BytesToCharcodes (data );
if !_dg {_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u0068\u0061\u0072\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065s\u0054\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u002e\u0020\u004e\u006f\u0074\u0020\u0069n\u0020\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0073\u002e\u0020\u0064\u0061\u0074\u0061\u003d\u005b\u0025\u0020\u0030\u0032\u0078]\u0020\u0063\u006d\u0061\u0070=\u0025\u0073",data ,cmap );
return "",0;};_gbc :=make ([]string ,len (_cga ));var _cde []CharCode ;for _fa ,_afe :=range _cga {_eab ,_dfd :=cmap ._df [_afe ];if !_dfd {_cde =append (_cde ,_afe );_eab =MissingCodeString ;};_gbc [_fa ]=_eab ;};_ec :=_d .Join (_gbc ,"");if len (_cde )> 0{_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020C\u0068\u0061\u0072c\u006f\u0064\u0065\u0042y\u0074\u0065\u0073\u0054\u006f\u0055\u006e\u0069\u0063\u006f\u0064\u0065\u002e\u0020\u004e\u006f\u0074\u0020\u0069\u006e\u0020\u006d\u0061\u0070\u002e\u000a"+"\u0009d\u0061t\u0061\u003d\u005b\u0025\u00200\u0032\u0078]\u003d\u0025\u0023\u0071\u000a"+"\u0009\u0063h\u0061\u0072\u0063o\u0064\u0065\u0073\u003d\u0025\u0030\u0032\u0078\u000a"+"\u0009\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u003d\u0025\u0064\u0020%\u0030\u0032\u0078\u000a"+"\u0009\u0075\u006e\u0069\u0063\u006f\u0064\u0065\u003d`\u0025\u0073\u0060\u000a"+"\u0009\u0063\u006d\u0061\u0070\u003d\u0025\u0073",data ,string (data ),_cga ,len (_cde ),_cde ,_ec ,cmap );
};return _ec ,len (_cde );};func (cmap *CMap )parse ()error {var _agfa cmapObject ;for {_bad ,_ceb :=cmap .parseObject ();if _ceb !=nil {if _ceb ==_gg .EOF {break ;};_b .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0043\u004d\u0061\u0070\u003a\u0020\u0025\u0076",_ceb );
return _ceb ;};switch _geaf :=_bad .(type ){case cmapOperand :_gbca :=_geaf ;switch _gbca .Operand {case _agb :_cfb :=cmap .parseCodespaceRange ();if _cfb !=nil {return _cfb ;};case _eea :_bdb :=cmap .parseCIDRange ();if _bdb !=nil {return _bdb ;};case _cgfc :_ebe :=cmap .parseBfchar ();
if _ebe !=nil {return _ebe ;};case _bgfg :_fbc :=cmap .parseBfrange ();if _fbc !=nil {return _fbc ;};case _bab :if _agfa ==nil {_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u0073\u0065\u0063m\u0061\u0070\u0020\u0077\u0069\u0074\u0068\u0020\u006e\u006f \u0061\u0072\u0067");
return ErrBadCMap ;};_bbb ,_aea :=_agfa .(cmapName );if !_aea {_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0075\u0073\u0065\u0063\u006d\u0061\u0070\u0020\u0061\u0072\u0067\u0020\u006eo\u0074\u0020\u0061\u0020\u006e\u0061\u006de\u0020\u0025\u0023\u0076",_agfa );
return ErrBadCMap ;};cmap ._cf =_bbb .Name ;case _dfdd :_edc :=cmap .parseSystemInfo ();if _edc !=nil {return _edc ;};};case cmapName :_dae :=_geaf ;switch _dae .Name {case _dfdd :_bffe :=cmap .parseSystemInfo ();if _bffe !=nil {return _bffe ;};case _dbgf :_gdc :=cmap .parseName ();
if _gdc !=nil {return _gdc ;};case _bdd :_cdg :=cmap .parseType ();if _cdg !=nil {return _cdg ;};case _cdc :_dgb :=cmap .parseVersion ();if _dgb !=nil {return _dgb ;};case _fdf :if _ceb =cmap .parseWMode ();_ceb !=nil {return _ceb ;};};};_agfa =_bad ;};
return nil ;};func _egbc (_bccd cmapHexString )[]rune {if len (_bccd ._gcb )==1{return []rune {rune (_bccd ._gcb [0])};};_fegf :=_bccd ._gcb ;if len (_fegf )%2!=0{_fegf =append (_fegf ,0);_b .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0068\u0065\u0078\u0054\u006f\u0052\u0075\u006e\u0065\u0073\u002e\u0020\u0050\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0073\u0068\u0065\u0078\u003d\u0025#\u0076\u0020\u0074\u006f\u0020\u0025\u002b\u0076",_bccd ,_fegf );
};_fbdg :=len (_fegf )>>1;_fgdb :=make ([]uint16 ,_fbdg );for _ecac :=0;_ecac < _fbdg ;_ecac ++{_fgdb [_ecac ]=uint16 (_fegf [_ecac <<1])<<8+uint16 (_fegf [_ecac <<1+1]);};_ebad :=_cb .Decode (_fgdb );return _ebad ;};func (_cgc *cMapParser )skipSpaces ()(int ,error ){_beb :=0;
for {_dee ,_cfdg :=_cgc ._gbee .Peek (1);if _cfdg !=nil {return 0,_cfdg ;};if _fb .IsWhiteSpace (_dee [0]){_cgc ._gbee .ReadByte ();_beb ++;}else {break ;};};return _beb ,nil ;};func (cmap *CMap )NBits ()int {return cmap ._gc };func (cmap *CMap )parseName ()error {_dgea :="";
_gde :=false ;for _ffe :=0;_ffe < 20&&!_gde ;_ffe ++{_dad ,_dbg :=cmap .parseObject ();if _dbg !=nil {return _dbg ;};switch _cdec :=_dad .(type ){case cmapOperand :switch _cdec .Operand {case "\u0064\u0065\u0066":_gde =true ;default:_b .Log .Debug ("\u0070\u0061\u0072\u0073\u0065\u004e\u0061\u006d\u0065\u003a\u0020\u0053\u0074\u0061\u0074\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u002e\u0020o\u003d\u0025\u0023\u0076\u0020n\u0061\u006de\u003d\u0025\u0023\u0071",_dad ,_dgea );
if _dgea !=""{_dgea =_g .Sprintf ("\u0025\u0073\u0020%\u0073",_dgea ,_cdec .Operand );};_b .Log .Debug ("\u0070\u0061\u0072\u0073\u0065\u004e\u0061\u006d\u0065\u003a \u0052\u0065\u0063\u006f\u0076\u0065\u0072e\u0064\u002e\u0020\u006e\u0061\u006d\u0065\u003d\u0025\u0023\u0071",_dgea );
};case cmapName :_dgea =_cdec .Name ;};};if !_gde {_b .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0070\u0061\u0072\u0073\u0065N\u0061m\u0065:\u0020\u004e\u006f\u0020\u0064\u0065\u0066 ");return ErrBadCMap ;};cmap ._gbab =_dgea ;return nil ;};func (cmap *CMap )CIDSystemInfo ()CIDSystemInfo {return cmap ._ea };
func (cmap *CMap )Type ()int {return cmap ._geg };func (_ac *CIDSystemInfo )String ()string {return _g .Sprintf ("\u0025\u0073\u002d\u0025\u0073\u002d\u0025\u0030\u0033\u0064",_ac .Registry ,_ac .Ordering ,_ac .Supplement );};func (cmap *CMap )WMode ()(int ,bool ){return cmap ._dfc ._cadg ,cmap ._dfc ._dgeg };
type CMap struct{*cMapParser ;_gbab string ;_gc int ;_geg int ;_ed string ;_cf string ;_ea CIDSystemInfo ;_cbe []Codespace ;_ca map[CharCode ]CharCode ;_gf map[CharCode ]CharCode ;_df map[CharCode ]string ;_bf map[string ]CharCode ;_ba []byte ;_af *_fb .PdfObjectStream ;
_dfc integer ;};func _ebbf (_dceb cmapHexString )rune {_ebae :=_egbc (_dceb );if _fga :=len (_ebae );_fga ==0{_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0068\u0065\u0078\u0054o\u0052\u0075\u006e\u0065\u002e\u0020\u0045\u0078p\u0065c\u0074\u0065\u0064\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0072u\u006e\u0065\u0020\u0073\u0068\u0065\u0078\u003d\u0025\u0023\u0076",_dceb );
return MissingCodeRune ;};if len (_ebae )> 1{_b .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0068\u0065\u0078\u0054\u006f\u0052\u0075\u006e\u0065\u002e\u0020\u0045\u0078p\u0065\u0063\u0074\u0065\u0064\u0020\u0065\u0078\u0061\u0063\u0074\u006c\u0079\u0020\u006f\u006e\u0065\u0020\u0072\u0075\u006e\u0065\u0020\u0073\u0068\u0065\u0078\u003d\u0025\u0023v\u0020\u002d\u003e\u0020\u0025#\u0076",_dceb ,_ebae );
};return _ebae [0];};type cmapArray struct{Array []cmapObject ;};type cmapHexString struct{_ecb int ;_gcb []byte ;};type integer struct{_dgeg bool ;_cadg int ;};func LoadCmapFromData (data []byte ,isSimple bool )(*CMap ,error ){_b .Log .Trace ("\u004c\u006fa\u0064\u0043\u006d\u0061\u0070\u0046\u0072\u006f\u006d\u0044\u0061\u0074\u0061\u003a\u0020\u0069\u0073\u0053\u0069\u006d\u0070\u006ce=\u0025\u0074",isSimple );
cmap :=_be (isSimple );cmap .cMapParser =_acc (data );_aegd :=cmap .parse ();if _aegd !=nil {return nil ,_aegd ;};if len (cmap ._cbe )==0{if cmap ._cf !=""{return cmap ,nil ;};_b .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0073\u002e\u0020\u0063\u006d\u0061p=\u0025\u0073",cmap );
};cmap .computeInverseMappings ();return cmap ,nil ;};func _ddcb ()cmapDict {return cmapDict {Dict :map[string ]cmapObject {}}};func (cmap *CMap )parseCodespaceRange ()error {for {_agc ,_dgad :=cmap .parseObject ();if _dgad !=nil {if _dgad ==_gg .EOF {break ;
};return _dgad ;};_fdc ,_aead :=_agc .(cmapHexString );if !_aead {if _cba ,_dbf :=_agc .(cmapOperand );_dbf {if _cba .Operand ==_gggg {return nil ;};return _f .New ("\u0075n\u0065x\u0070\u0065\u0063\u0074\u0065d\u0020\u006fp\u0065\u0072\u0061\u006e\u0064");
};};_agc ,_dgad =cmap .parseObject ();if _dgad !=nil {if _dgad ==_gg .EOF {break ;};return _dgad ;};_aad ,_aead :=_agc .(cmapHexString );if !_aead {return _f .New ("\u006e\u006f\u006e-\u0068\u0065\u0078\u0020\u0068\u0069\u0067\u0068");};if len (_fdc ._gcb )!=len (_aad ._gcb ){return _f .New ("\u0075\u006e\u0065\u0071\u0075\u0061\u006c\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066 \u0062\u0079\u0074\u0065\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065");
};_cff :=_fbgbf (_fdc );_cggc :=_fbgbf (_aad );if _cggc < _cff {_b .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0042\u0061d\u0020\u0063\u006fd\u0065\u0073\u0070\u0061\u0063\u0065\u002e\u0020\u006cow\u003d\u0030\u0078%\u0030\u0032x\u0020\u0068\u0069\u0067\u0068\u003d0\u0078\u00250\u0032\u0078",_cff ,_cggc );
return ErrBadCMap ;};_ccff :=_aad ._ecb ;_feg :=Codespace {NumBytes :_ccff ,Low :_cff ,High :_cggc };cmap ._cbe =append (cmap ._cbe ,_feg );_b .Log .Trace ("\u0043\u006f\u0064e\u0073\u0070\u0061\u0063e\u0020\u006c\u006f\u0077\u003a\u0020\u0030x\u0025\u0058\u002c\u0020\u0068\u0069\u0067\u0068\u003a\u0020\u0030\u0078\u0025\u0058",_cff ,_cggc );
};if len (cmap ._cbe )==0{_b .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004e\u006f\u0020\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065\u0073\u0020\u0069\u006e\u0020\u0063ma\u0070\u002e");return ErrBadCMap ;};return nil ;};func (cmap *CMap )CIDToCharcode (cid CharCode )(CharCode ,bool ){_ggb ,_edg :=cmap ._gf [cid ];
return _ggb ,_edg ;};type CIDSystemInfo struct{Registry string ;Ordering string ;Supplement int ;};type cmapDict struct{Dict map[string ]cmapObject ;};const (_fab =100;_edd ="\u000a\u002f\u0043\u0049\u0044\u0049\u006e\u0069\u0074\u0020\u002f\u0050\u0072\u006fc\u0053\u0065\u0074\u0020\u0066\u0069\u006e\u0064\u0072es\u006fu\u0072c\u0065 \u0062\u0065\u0067\u0069\u006e\u000a\u0031\u0032\u0020\u0064\u0069\u0063\u0074\u0020\u0062\u0065\u0067\u0069n\u000a\u0062\u0065\u0067\u0069\u006e\u0063\u006d\u0061\u0070\n\u002f\u0043\u0049\u0044\u0053\u0079\u0073\u0074\u0065m\u0049\u006e\u0066\u006f\u0020\u003c\u003c\u0020\u002f\u0052\u0065\u0067\u0069\u0073t\u0072\u0079\u0020\u0028\u0041\u0064\u006f\u0062\u0065\u0029\u0020\u002f\u004f\u0072\u0064\u0065\u0072\u0069\u006e\u0067\u0020\u0028\u0055\u0043\u0053)\u0020\u002f\u0053\u0075\u0070p\u006c\u0065\u006d\u0065\u006et\u0020\u0030\u0020\u003e\u003e\u0020\u0064\u0065\u0066\u000a\u002f\u0043\u004d\u0061\u0070\u004e\u0061\u006d\u0065\u0020\u002f\u0041\u0064\u006f\u0062\u0065-\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079\u002d\u0055\u0043\u0053\u0020\u0064\u0065\u0066\u000a\u002fC\u004d\u0061\u0070\u0054\u0079\u0070\u0065\u0020\u0032\u0020\u0064\u0065\u0066\u000a\u0031\u0020\u0062\u0065\u0067\u0069\u006e\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063e\u0072\u0061n\u0067\u0065\n\u003c\u0030\u0030\u0030\u0030\u003e\u0020<\u0046\u0046\u0046\u0046\u003e\u000a\u0065\u006e\u0064\u0063\u006f\u0064\u0065\u0073\u0070\u0061\u0063\u0065r\u0061\u006e\u0067\u0065\u000a";
_fgg ="\u0065\u006e\u0064\u0063\u006d\u0061\u0070\u000a\u0043\u004d\u0061\u0070\u004e\u0061\u006d\u0065\u0020\u0063ur\u0072e\u006e\u0074\u0064\u0069\u0063\u0074\u0020\u002f\u0043\u004d\u0061\u0070 \u0064\u0065\u0066\u0069\u006e\u0065\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u0020\u0070\u006fp\u000a\u0065\u006e\u0064\u000a\u0065\u006e\u0064\u000a";
);func _be (_cg bool )*CMap {_bff :=16;if _cg {_bff =8;};return &CMap {_gc :_bff ,_ca :make (map[CharCode ]CharCode ),_gf :make (map[CharCode ]CharCode ),_df :make (map[CharCode ]string ),_bf :make (map[string ]CharCode )};};var (ErrBadCMap =_f .New ("\u0062\u0061\u0064\u0020\u0063\u006d\u0061\u0070");
ErrBadCMapComment =_f .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");ErrBadCMapDict =_f .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
);func (cmap *CMap )Name ()string {return cmap ._gbab };func NewToUnicodeCMap (codeToRune map[CharCode ]rune )*CMap {_bb :=make (map[CharCode ]string ,len (codeToRune ));for _eaf ,_ee :=range codeToRune {_bb [_eaf ]=string (_ee );};cmap :=&CMap {_gbab :"\u0041d\u006fb\u0065\u002d\u0049\u0064\u0065n\u0074\u0069t\u0079\u002d\u0055\u0043\u0053",_geg :2,_gc :16,_ea :CIDSystemInfo {Registry :"\u0041\u0064\u006fb\u0065",Ordering :"\u0055\u0043\u0053",Supplement :0},_cbe :[]Codespace {{Low :0,High :0xffff}},_df :_bb ,_bf :make (map[string ]CharCode ,len (codeToRune )),_ca :make (map[CharCode ]CharCode ,len (codeToRune )),_gf :make (map[CharCode ]CharCode ,len (codeToRune ))};
cmap .computeInverseMappings ();return cmap ;};func (cmap *CMap )CharcodeToUnicode (code CharCode )(string ,bool ){if _bc ,_gea :=cmap ._df [code ];_gea {return _bc ,true ;};return MissingCodeString ,false ;};type CharCode uint32 ;type cmapObject interface{};
func (cmap *CMap )parseType ()error {_ggcde :=0;_gee :=false ;for _cfg :=0;_cfg < 3&&!_gee ;_cfg ++{_cfa ,_fdee :=cmap .parseObject ();if _fdee !=nil {return _fdee ;};switch _dga :=_cfa .(type ){case cmapOperand :switch _dga .Operand {case "\u0064\u0065\u0066":_gee =true ;
default:_b .Log .Error ("\u0070\u0061r\u0073\u0065\u0054\u0079\u0070\u0065\u003a\u0020\u0073\u0074\u0061\u0074\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u002e\u0020\u006f=%\u0023\u0076",_cfa );return ErrBadCMap ;};case cmapInt :_ggcde =int (_dga ._afed );
};};cmap ._geg =_ggcde ;return nil ;};func _aff (_bbga string )rune {_bge :=[]rune (_bbga );return _bge [len (_bge )-1]};