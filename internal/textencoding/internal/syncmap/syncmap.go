//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _b "sync";type StringRuneMap struct{_afg map[string ]rune ;_fbd _b .RWMutex ;};func (_de *RuneSet )Write (r rune ){_de ._gcd .Lock ();defer _de ._gcd .Unlock ();_de ._bg [r ]=struct{}{}};func (_cc *RuneStringMap )Length ()int {_cc ._dd .RLock ();
defer _cc ._dd .RUnlock ();return len (_cc ._deg );};func (_bee *StringRuneMap )Length ()int {_bee ._fbd .RLock ();defer _bee ._fbd .RUnlock ();return len (_bee ._afg );};type StringsMap struct{_fge map[string ]string ;_ddb _b .RWMutex ;};func (_gfa *StringsMap )Read (g string )(string ,bool ){_gfa ._ddb .RLock ();
defer _gfa ._ddb .RUnlock ();_ggb ,_ggc :=_gfa ._fge [g ];return _ggb ,_ggc ;};func (_fba *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fba ._edg .RLock ();defer _fba ._edg .RUnlock ();_fbg ,_bed :=_fba ._bdd [r ];return _fbg ,_bed ;};type RuneStringMap struct{_deg map[rune ]string ;
_dd _b .RWMutex ;};func (_ecg *StringRuneMap )Range (f func (_abac string ,_abb rune )(_ege bool )){_ecg ._fbd .RLock ();defer _ecg ._fbd .RUnlock ();for _afd ,_bcb :=range _ecg ._afg {if f (_afd ,_bcb ){break ;};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_deg :m }};
func MakeRuneSet (length int )*RuneSet {return &RuneSet {_bg :make (map[rune ]struct{},length )}};func (_ebg *RuneStringMap )Range (f func (_gg rune ,_eeb string )(_fdea bool )){_ebg ._dd .RLock ();defer _ebg ._dd .RUnlock ();for _fda ,_bd :=range _ebg ._deg {if f (_fda ,_bd ){break ;
};};};func (_cab *RuneSet )Range (f func (_ed rune )(_ga bool )){_cab ._gcd .RLock ();defer _cab ._gcd .RUnlock ();for _bad :=range _cab ._bg {if f (_bad ){break ;};};};func (_ac *RuneUint16Map )Range (f func (_fdg rune ,_cb uint16 )(_caf bool )){_ac ._edg .RLock ();
defer _ac ._edg .RUnlock ();for _acd ,_aeb :=range _ac ._bdd {if f (_acd ,_aeb ){break ;};};};func (_dfd *StringsMap )Range (f func (_bcg ,_edga string )(_edf bool )){_dfd ._ddb .RLock ();defer _dfd ._ddb .RUnlock ();for _gfg ,_cf :=range _dfd ._fge {if f (_gfg ,_cf ){break ;
};};};type RuneSet struct{_bg map[rune ]struct{};_gcd _b .RWMutex ;};func (_gbe *RuneSet )Length ()int {_gbe ._gcd .RLock ();defer _gbe ._gcd .RUnlock ();return len (_gbe ._bg )};func (_ba *ByteRuneMap )Read (b byte )(rune ,bool ){_ba ._f .RLock ();defer _ba ._f .RUnlock ();
_d ,_ca :=_ba ._e [b ];return _d ,_ca ;};func (_dc *RuneUint16Map )Write (r rune ,g uint16 ){_dc ._edg .Lock ();defer _dc ._edg .Unlock ();_dc ._bdd [r ]=g ;};func (_ebgd *StringRuneMap )Read (g string )(rune ,bool ){_ebgd ._fbd .RLock ();defer _ebgd ._fbd .RUnlock ();
_egg ,_bge :=_ebgd ._afg [g ];return _egg ,_bge ;};func (_bc *RuneByteMap )Write (r rune ,b byte ){_bc ._ec .Lock ();defer _bc ._ec .Unlock ();_bc ._gf [r ]=b };func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_bdd :make (map[rune ]uint16 ,length )};
};type ByteRuneMap struct{_e map[byte ]rune ;_f _b .RWMutex ;};func (_af *RuneUint16Map )RangeDelete (f func (_bcd rune ,_afb uint16 )(_aac bool ,_ddg bool )){_af ._edg .Lock ();defer _af ._edg .Unlock ();for _ea ,_aad :=range _af ._bdd {_cba ,_aaf :=f (_ea ,_aad );
if _cba {delete (_af ._bdd ,_ea );};if _aaf {break ;};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ff :=map[string ]string {};for _ ,_gd :=range tuples {_ff [_gd .Key ]=_gd .Value ;};return &StringsMap {_fge :_ff };};func (_cd *RuneByteMap )Read (r rune )(byte ,bool ){_cd ._ec .RLock ();
defer _cd ._ec .RUnlock ();_db ,_ae :=_cd ._gf [r ];return _db ,_ae ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_e :m }};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_e :make (map[byte ]rune ,length )}};
func (_eae *StringsMap )Write (g1 ,g2 string ){_eae ._ddb .Lock ();defer _eae ._ddb .Unlock ();_eae ._fge [g1 ]=g2 ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_afg :m }};func (_bfa *StringsMap )Copy ()*StringsMap {_bfa ._ddb .RLock ();
defer _bfa ._ddb .RUnlock ();_eec :=map[string ]string {};for _dddf ,_eca :=range _bfa ._fge {_eec [_dddf ]=_eca ;};return &StringsMap {_fge :_eec };};func (_cac *RuneByteMap )Length ()int {_cac ._ec .RLock ();defer _cac ._ec .RUnlock ();return len (_cac ._gf );
};func (_be *ByteRuneMap )Range (f func (_eb byte ,_fd rune )(_fde bool )){_be ._f .RLock ();defer _be ._f .RUnlock ();for _g ,_gc :=range _be ._e {if f (_g ,_gc ){break ;};};};func (_cec *RuneUint16Map )Delete (r rune ){_cec ._edg .Lock ();defer _cec ._edg .Unlock ();
delete (_cec ._bdd ,r );};func (_dda *RuneUint16Map )Length ()int {_dda ._edg .RLock ();defer _dda ._edg .RUnlock ();return len (_dda ._bdd );};func (_aa *RuneSet )Exists (r rune )bool {_aa ._gcd .RLock ();defer _aa ._gcd .RUnlock ();_ ,_cde :=_aa ._bg [r ];
return _cde ;};type RuneUint16Map struct{_bdd map[rune ]uint16 ;_edg _b .RWMutex ;};func (_df *RuneByteMap )Range (f func (_gb rune ,_fg byte )(_eg bool )){_df ._ec .RLock ();defer _df ._ec .RUnlock ();for _ecd ,_ce :=range _df ._gf {if f (_ecd ,_ce ){break ;
};};};func (_ee *RuneStringMap )Read (r rune )(string ,bool ){_ee ._dd .RLock ();defer _ee ._dd .RUnlock ();_fa ,_aba :=_ee ._deg [r ];return _fa ,_aba ;};func (_ddd *RuneStringMap )Write (r rune ,s string ){_ddd ._dd .Lock ();defer _ddd ._dd .Unlock ();
_ddd ._deg [r ]=s ;};func MakeRuneByteMap (length int )*RuneByteMap {_fb :=make (map[rune ]byte ,length );return &RuneByteMap {_gf :_fb };};type RuneByteMap struct{_gf map[rune ]byte ;_ec _b .RWMutex ;};func (_a *ByteRuneMap )Write (b byte ,r rune ){_a ._f .Lock ();
defer _a ._f .Unlock ();_a ._e [b ]=r };type StringsTuple struct{Key ,Value string ;};func (_bf *ByteRuneMap )Length ()int {_bf ._f .RLock ();defer _bf ._f .RUnlock ();return len (_bf ._e )};func (_bag *StringRuneMap )Write (g string ,r rune ){_bag ._fbd .Lock ();
defer _bag ._fbd .Unlock ();_bag ._afg [g ]=r ;};