//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _bg "sync";func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ef :make (map[rune ]struct{},length )}};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_abe :m }};type RuneSet struct{_ef map[rune ]struct{};
_ebf _bg .RWMutex ;};func (_eg *RuneByteMap )Write (r rune ,b byte ){_eg ._ee .Lock ();defer _eg ._ee .Unlock ();_eg ._gg [r ]=b };func (_fg *RuneUint16Map )RangeDelete (f func (_fdf rune ,_dfa uint16 )(_bea bool ,_fbg bool )){_fg ._cb .Lock ();defer _fg ._cb .Unlock ();
for _gbd ,_bf :=range _fg ._de {_fab ,_dc :=f (_gbd ,_bf );if _fab {delete (_fg ._de ,_gbd );};if _dc {break ;};};};func (_aa *RuneByteMap )Read (r rune )(byte ,bool ){_aa ._ee .RLock ();defer _aa ._ee .RUnlock ();_ge ,_gb :=_aa ._gg [r ];return _ge ,_gb ;
};func (_gea *StringRuneMap )Length ()int {_gea ._afg .RLock ();defer _gea ._afg .RUnlock ();return len (_gea ._abe );};func (_ddb *StringRuneMap )Write (g string ,r rune ){_ddb ._afg .Lock ();defer _ddb ._afg .Unlock ();_ddb ._abe [g ]=r ;};type StringsTuple struct{Key ,Value string ;
};func (_eb *RuneByteMap )Length ()int {_eb ._ee .RLock ();defer _eb ._ee .RUnlock ();return len (_eb ._gg )};func (_eaf *RuneUint16Map )Length ()int {_eaf ._cb .RLock ();defer _eaf ._cb .RUnlock ();return len (_eaf ._de );};func (_bd *RuneSet )Write (r rune ){_bd ._ebf .Lock ();
defer _bd ._ebf .Unlock ();_bd ._ef [r ]=struct{}{}};func (_d *ByteRuneMap )Range (f func (_gd byte ,_ag rune )(_ad bool )){_d ._e .RLock ();defer _d ._e .RUnlock ();for _fa ,_ga :=range _d ._g {if f (_fa ,_ga ){break ;};};};func (_ff *ByteRuneMap )Length ()int {_ff ._e .RLock ();
defer _ff ._e .RUnlock ();return len (_ff ._g )};func (_bbg *RuneUint16Map )Range (f func (_gcd rune ,_afa uint16 )(_efe bool )){_bbg ._cb .RLock ();defer _bbg ._cb .RUnlock ();for _aaa ,_ead :=range _bbg ._de {if f (_aaa ,_ead ){break ;};};};func (_faaf *RuneStringMap )Range (f func (_ab rune ,_ba string )(_baf bool )){_faaf ._cee .RLock ();
defer _faaf ._cee .RUnlock ();for _acc ,_gef :=range _faaf ._df {if f (_acc ,_gef ){break ;};};};func (_fc *RuneSet )Length ()int {_fc ._ebf .RLock ();defer _fc ._ebf .RUnlock ();return len (_fc ._ef )};func (_f *ByteRuneMap )Read (b byte )(rune ,bool ){_f ._e .RLock ();
defer _f ._e .RUnlock ();_a ,_c :=_f ._g [b ];return _a ,_c ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_de :make (map[rune ]uint16 ,length )};};func (_fad *RuneUint16Map )Read (r rune )(uint16 ,bool ){_fad ._cb .RLock ();
defer _fad ._cb .RUnlock ();_be ,_bgg :=_fad ._de [r ];return _be ,_bgg ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_df :m }};func (_ae *RuneSet )Exists (r rune )bool {_ae ._ebf .RLock ();defer _ae ._ebf .RUnlock ();
_ ,_egf :=_ae ._ef [r ];return _egf ;};func (_gf *RuneStringMap )Read (r rune )(string ,bool ){_gf ._cee .RLock ();defer _gf ._cee .RUnlock ();_fb ,_bb :=_gf ._df [r ];return _fb ,_bb ;};type RuneStringMap struct{_df map[rune ]string ;_cee _bg .RWMutex ;
};func (_egg *StringRuneMap )Read (g string )(rune ,bool ){_egg ._afg .RLock ();defer _egg ._afg .RUnlock ();_bac ,_eeb :=_egg ._abe [g ];return _bac ,_eeb ;};type RuneUint16Map struct{_de map[rune ]uint16 ;_cb _bg .RWMutex ;};type StringsMap struct{_fdb map[string ]string ;
_gdc _bg .RWMutex ;};func (_aaf *RuneUint16Map )Write (r rune ,g uint16 ){_aaf ._cb .Lock ();defer _aaf ._cb .Unlock ();_aaf ._de [r ]=g ;};type StringRuneMap struct{_abe map[string ]rune ;_afg _bg .RWMutex ;};func (_af *RuneByteMap )Range (f func (_add rune ,_fd byte )(_gc bool )){_af ._ee .RLock ();
defer _af ._ee .RUnlock ();for _ed ,_eae :=range _af ._gg {if f (_ed ,_eae ){break ;};};};func (_bgd *StringsMap )Range (f func (_ca ,_gfb string )(_abg bool )){_bgd ._gdc .RLock ();defer _bgd ._gdc .RUnlock ();for _gcdg ,_fcc :=range _bgd ._fdb {if f (_gcdg ,_fcc ){break ;
};};};func (_abd *StringsMap )Read (g string )(string ,bool ){_abd ._gdc .RLock ();defer _abd ._gdc .RUnlock ();_efdg ,_abc :=_abd ._fdb [g ];return _efdg ,_abc ;};func (_ceea *RuneStringMap )Write (r rune ,s string ){_ceea ._cee .Lock ();defer _ceea ._cee .Unlock ();
_ceea ._df [r ]=s ;};func (_bfc *StringRuneMap )Range (f func (_aee string ,_efd rune )(_bbe bool )){_bfc ._afg .RLock ();defer _bfc ._afg .RUnlock ();for _agb ,_ggb :=range _bfc ._abe {if f (_agb ,_ggb ){break ;};};};func (_ada *StringsMap )Write (g1 ,g2 string ){_ada ._gdc .Lock ();
defer _ada ._gdc .Unlock ();_ada ._fdb [g1 ]=g2 ;};func (_ac *RuneSet )Range (f func (_dd rune )(_ce bool )){_ac ._ebf .RLock ();defer _ac ._ebf .RUnlock ();for _cc :=range _ac ._ef {if f (_cc ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};
type RuneByteMap struct{_gg map[rune ]byte ;_ee _bg .RWMutex ;};func (_gga *RuneStringMap )Length ()int {_gga ._cee .RLock ();defer _gga ._cee .RUnlock ();return len (_gga ._df );};func NewStringsMap (tuples []StringsTuple )*StringsMap {_fbe :=map[string ]string {};
for _ ,_aff :=range tuples {_fbe [_aff .Key ]=_aff .Value ;};return &StringsMap {_fdb :_fbe };};func (_cd *RuneUint16Map )Delete (r rune ){_cd ._cb .Lock ();defer _cd ._cb .Unlock ();delete (_cd ._de ,r )};func MakeRuneByteMap (length int )*RuneByteMap {_faa :=make (map[rune ]byte ,length );
return &RuneByteMap {_gg :_faa };};func (_ea *ByteRuneMap )Write (b byte ,r rune ){_ea ._e .Lock ();defer _ea ._e .Unlock ();_ea ._g [b ]=r };func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};type ByteRuneMap struct{_g map[byte ]rune ;
_e _bg .RWMutex ;};func (_fbed *StringsMap )Copy ()*StringsMap {_fbed ._gdc .RLock ();defer _fbed ._gdc .RUnlock ();_bge :=map[string ]string {};for _fabg ,_ggag :=range _fbed ._fdb {_bge [_fabg ]=_ggag ;};return &StringsMap {_fdb :_bge };};