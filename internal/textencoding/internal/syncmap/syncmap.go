//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func (_gbg *RuneStringMap )Read (r rune )(string ,bool ){_gbg ._acc .RLock ();defer _gbg ._acc .RUnlock ();_bg ,_cb :=_gbg ._bbb [r ];return _bg ,_cb ;};func (_c *RuneSet )Length ()int {_c ._da .RLock ();defer _c ._da .RUnlock ();
return len (_c ._aba )};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};type StringRuneMap struct{_bf map[string ]rune ;_db _a .RWMutex ;};func (_df *ByteRuneMap )Write (b byte ,r rune ){_df ._f .Lock ();
defer _df ._f .Unlock ();_df ._g [b ]=r };func MakeRuneSet (length int )*RuneSet {return &RuneSet {_aba :make (map[rune ]struct{},length )}};func NewStringsMap (tuples []StringsTuple )*StringsMap {_cdb :=map[string ]string {};for _ ,_gf :=range tuples {_cdb [_gf .Key ]=_gf .Value ;
};return &StringsMap {_be :_cdb };};func (_bc *RuneUint16Map )Read (r rune )(uint16 ,bool ){_bc ._efb .RLock ();defer _bc ._efb .RUnlock ();_bbdd ,_dgf :=_bc ._gcg [r ];return _bbdd ,_dgf ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_gcg :make (map[rune ]uint16 ,length )};
};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_bbb :m }};type StringsMap struct{_be map[string ]string ;_bfg _a .RWMutex ;};type RuneSet struct{_aba map[rune ]struct{};_da _a .RWMutex ;};type RuneUint16Map struct{_gcg map[rune ]uint16 ;
_efb _a .RWMutex ;};func (_ac *RuneSet )Write (r rune ){_ac ._da .Lock ();defer _ac ._da .Unlock ();_ac ._aba [r ]=struct{}{}};func (_aae *StringsMap )Copy ()*StringsMap {_aae ._bfg .RLock ();defer _aae ._bfg .RUnlock ();_aad :=map[string ]string {};for _bea ,_ffd :=range _aae ._be {_aad [_bea ]=_ffd ;
};return &StringsMap {_be :_aad };};type ByteRuneMap struct{_g map[byte ]rune ;_f _a .RWMutex ;};func (_ff *ByteRuneMap )Read (b byte )(rune ,bool ){_ff ._f .RLock ();defer _ff ._f .RUnlock ();_b ,_gc :=_ff ._g [b ];return _b ,_gc ;};func (_dfa *RuneUint16Map )Write (r rune ,g uint16 ){_dfa ._efb .Lock ();
defer _dfa ._efb .Unlock ();_dfa ._gcg [r ]=g ;};type RuneStringMap struct{_bbb map[rune ]string ;_acc _a .RWMutex ;};func (_bga *StringsMap )Read (g string )(string ,bool ){_bga ._bfg .RLock ();defer _bga ._bfg .RUnlock ();_ed ,_baf :=_bga ._be [g ];return _ed ,_baf ;
};type RuneByteMap struct{_gb map[rune ]byte ;_gg _a .RWMutex ;};func (_ffc *RuneStringMap )Write (r rune ,s string ){_ffc ._acc .Lock ();defer _ffc ._acc .Unlock ();_ffc ._bbb [r ]=s ;};func (_dfc *RuneStringMap )Range (f func (_ea rune ,_fbg string )(_adg bool )){_dfc ._acc .RLock ();
defer _dfc ._acc .RUnlock ();for _cf ,_fba :=range _dfc ._bbb {if f (_cf ,_fba ){break ;};};};func MakeRuneByteMap (length int )*RuneByteMap {_eg :=make (map[rune ]byte ,length );return &RuneByteMap {_gb :_eg };};func (_cee *StringRuneMap )Length ()int {_cee ._db .RLock ();
defer _cee ._db .RUnlock ();return len (_cee ._bf );};func (_fgg *StringRuneMap )Read (g string )(rune ,bool ){_fgg ._db .RLock ();defer _fgg ._db .RUnlock ();_fc ,_cbb :=_fgg ._bf [g ];return _fc ,_cbb ;};func (_gbf *StringsMap )Range (f func (_fcf ,_ege string )(_aag bool )){_gbf ._bfg .RLock ();
defer _gbf ._bfg .RUnlock ();for _bcc ,_gfg :=range _gbf ._be {if f (_bcc ,_gfg ){break ;};};};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};func (_de *RuneUint16Map )Range (f func (_ae rune ,_ca uint16 )(_caf bool )){_de ._efb .RLock ();
defer _de ._efb .RUnlock ();for _accf ,_ge :=range _de ._gcg {if f (_accf ,_ge ){break ;};};};func (_fea *StringsMap )Write (g1 ,g2 string ){_fea ._bfg .Lock ();defer _fea ._bfg .Unlock ();_fea ._be [g1 ]=g2 ;};func (_ga *RuneSet )Exists (r rune )bool {_ga ._da .RLock ();
defer _ga ._da .RUnlock ();_ ,_ef :=_ga ._aba [r ];return _ef ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_bf :m }};func (_fac *RuneByteMap )Write (r rune ,b byte ){_fac ._gg .Lock ();defer _fac ._gg .Unlock ();
_fac ._gb [r ]=b ;};func (_gbc *RuneByteMap )Read (r rune )(byte ,bool ){_gbc ._gg .RLock ();defer _gbc ._gg .RUnlock ();_bbf ,_fa :=_gbc ._gb [r ];return _bbf ,_fa ;};func (_aa *RuneByteMap )Range (f func (_ab rune ,_dfb byte )(_dd bool )){_aa ._gg .RLock ();
defer _aa ._gg .RUnlock ();for _ad ,_dg :=range _aa ._gb {if f (_ad ,_dg ){break ;};};};func (_gcd *ByteRuneMap )Range (f func (_dfg byte ,_dc rune )(_fe bool )){_gcd ._f .RLock ();defer _gcd ._f .RUnlock ();for _fd ,_e :=range _gcd ._g {if f (_fd ,_e ){break ;
};};};func (_cd *RuneStringMap )Length ()int {_cd ._acc .RLock ();defer _cd ._acc .RUnlock ();return len (_cd ._bbb );};func (_ccf *StringRuneMap )Range (f func (_dgb string ,_gcc rune )(_cbd bool )){_ccf ._db .RLock ();defer _ccf ._db .RUnlock ();for _dbf ,_geg :=range _ccf ._bf {if f (_dbf ,_geg ){break ;
};};};type StringsTuple struct{Key ,Value string ;};func (_fb *RuneSet )Range (f func (_efg rune )(_ba bool )){_fb ._da .RLock ();defer _fb ._da .RUnlock ();for _bbd :=range _fb ._aba {if f (_bbd ){break ;};};};func (_aaa *RuneByteMap )Length ()int {_aaa ._gg .RLock ();
defer _aaa ._gg .RUnlock ();return len (_aaa ._gb );};func (_acb *RuneUint16Map )Delete (r rune ){_acb ._efb .Lock ();defer _acb ._efb .Unlock ();delete (_acb ._gcg ,r );};func (_adf *RuneUint16Map )RangeDelete (f func (_egc rune ,_aea uint16 )(_bcf bool ,_cc bool )){_adf ._efb .Lock ();
defer _adf ._efb .Unlock ();for _fg ,_gaa :=range _adf ._gcg {_bde ,_ce :=f (_fg ,_gaa );if _bde {delete (_adf ._gcg ,_fg );};if _ce {break ;};};};func (_bb *ByteRuneMap )Length ()int {_bb ._f .RLock ();defer _bb ._f .RUnlock ();return len (_bb ._g )};
func (_gcdb *RuneUint16Map )Length ()int {_gcdb ._efb .RLock ();defer _gcdb ._efb .RUnlock ();return len (_gcdb ._gcg );};func (_bfb *StringRuneMap )Write (g string ,r rune ){_bfb ._db .Lock ();defer _bfb ._db .Unlock ();_bfb ._bf [g ]=r ;};