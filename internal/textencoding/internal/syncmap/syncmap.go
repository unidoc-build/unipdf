//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func (_egfc *RuneSet )Write (r rune ){_egfc ._bdb .Lock ();defer _egfc ._bdb .Unlock ();_egfc ._geb [r ]=struct{}{};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_bcc :m }};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_daa :m }};
func (_cee *StringsMap )Copy ()*StringsMap {_cee ._bcaf .RLock ();defer _cee ._bcaf .RUnlock ();_ebbb :=map[string ]string {};for _afg ,_bbga :=range _cee ._abf {_ebbb [_afg ]=_bbga ;};return &StringsMap {_abf :_ebbb };};func NewStringsMap (tuples []StringsTuple )*StringsMap {_cgb :=map[string ]string {};
for _ ,_gd :=range tuples {_cgb [_gd .Key ]=_gd .Value ;};return &StringsMap {_abf :_cgb };};type StringsMap struct{_abf map[string ]string ;_bcaf _a .RWMutex ;};func (_gg *ByteRuneMap )Length ()int {_gg ._bd .RLock ();defer _gg ._bd .RUnlock ();return len (_gg ._e )};
func (_gbc *RuneUint16Map )Length ()int {_gbc ._dda .RLock ();defer _gbc ._dda .RUnlock ();return len (_gbc ._cc );};func (_de *StringsMap )Range (f func (_ac ,_eae string )(_bg bool )){_de ._bcaf .RLock ();defer _de ._bcaf .RUnlock ();for _fbc ,_aff :=range _de ._abf {if f (_fbc ,_aff ){break ;
};};};func (_ebb *RuneStringMap )Length ()int {_ebb ._ec .RLock ();defer _ebb ._ec .RUnlock ();return len (_ebb ._bcc );};func (_ea *RuneSet )Exists (r rune )bool {_ea ._bdb .RLock ();defer _ea ._bdb .RUnlock ();_ ,_bbg :=_ea ._geb [r ];return _bbg ;};
func (_ag *RuneUint16Map )RangeDelete (f func (_dbg rune ,_df uint16 )(_abc bool ,_bca bool )){_ag ._dda .Lock ();defer _ag ._dda .Unlock ();for _ggc ,_ef :=range _ag ._cc {_gb ,_gae :=f (_ggc ,_ef );if _gb {delete (_ag ._cc ,_ggc );};if _gae {break ;};
};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_geb :make (map[rune ]struct{},length )}};func (_aa *ByteRuneMap )Write (b byte ,r rune ){_aa ._bd .Lock ();defer _aa ._bd .Unlock ();_aa ._e [b ]=r };func (_agc *StringRuneMap )Write (g string ,r rune ){_agc ._fea .Lock ();
defer _agc ._fea .Unlock ();_agc ._daa [g ]=r ;};func (_fd *RuneStringMap )Read (r rune )(string ,bool ){_fd ._ec .RLock ();defer _fd ._ec .RUnlock ();_cad ,_aec :=_fd ._bcc [r ];return _cad ,_aec ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_cc :make (map[rune ]uint16 ,length )};
};func (_ed *RuneStringMap )Write (r rune ,s string ){_ed ._ec .Lock ();defer _ed ._ec .Unlock ();_ed ._bcc [r ]=s ;};func (_feg *StringsMap )Read (g string )(string ,bool ){_feg ._bcaf .RLock ();defer _feg ._bcaf .RUnlock ();_fdc ,_bad :=_feg ._abf [g ];
return _fdc ,_bad ;};func (_add *StringsMap )Write (g1 ,g2 string ){_add ._bcaf .Lock ();defer _add ._bcaf .Unlock ();_add ._abf [g1 ]=g2 ;};func (_bbe *RuneSet )Range (f func (_fb rune )(_dg bool )){_bbe ._bdb .RLock ();defer _bbe ._bdb .RUnlock ();for _gc :=range _bbe ._geb {if f (_gc ){break ;
};};};func (_bae *RuneUint16Map )Delete (r rune ){_bae ._dda .Lock ();defer _bae ._dda .Unlock ();delete (_bae ._cc ,r );};func (_dfe *StringRuneMap )Length ()int {_dfe ._fea .RLock ();defer _dfe ._fea .RUnlock ();return len (_dfe ._daa );};func (_da *RuneByteMap )Range (f func (_ffg rune ,_db byte )(_ggd bool )){_da ._ff .RLock ();
defer _da ._ff .RUnlock ();for _ca ,_dag :=range _da ._ge {if f (_ca ,_dag ){break ;};};};func (_abe *StringRuneMap )Read (g string )(rune ,bool ){_abe ._fea .RLock ();defer _abe ._fea .RUnlock ();_ad ,_dbgd :=_abe ._daa [g ];return _ad ,_dbgd ;};type RuneSet struct{_geb map[rune ]struct{};
_bdb _a .RWMutex ;};type RuneStringMap struct{_bcc map[rune ]string ;_ec _a .RWMutex ;};type RuneUint16Map struct{_cc map[rune ]uint16 ;_dda _a .RWMutex ;};type StringsTuple struct{Key ,Value string ;};func MakeRuneByteMap (length int )*RuneByteMap {_bf :=make (map[rune ]byte ,length );
return &RuneByteMap {_ge :_bf };};func (_ffc *RuneUint16Map )Write (r rune ,g uint16 ){_ffc ._dda .Lock ();defer _ffc ._dda .Unlock ();_ffc ._cc [r ]=g ;};type ByteRuneMap struct{_e map[byte ]rune ;_bd _a .RWMutex ;};type StringRuneMap struct{_daa map[string ]rune ;
_fea _a .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_e :m }};func (_ee *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ee ._dda .RLock ();defer _ee ._dda .RUnlock ();_ga ,_dga :=_ee ._cc [r ];return _ga ,_dga ;};
func (_bc *RuneSet )Length ()int {_bc ._bdb .RLock ();defer _bc ._bdb .RUnlock ();return len (_bc ._geb )};func (_cab *RuneByteMap )Length ()int {_cab ._ff .RLock ();defer _cab ._ff .RUnlock ();return len (_cab ._ge );};func (_aad *StringRuneMap )Range (f func (_cb string ,_agb rune )(_fa bool )){_aad ._fea .RLock ();
defer _aad ._fea .RUnlock ();for _fed ,_fce :=range _aad ._daa {if f (_fed ,_fce ){break ;};};};func (_af *RuneUint16Map )Range (f func (_bfd rune ,_cg uint16 )(_daf bool )){_af ._dda .RLock ();defer _af ._dda .RUnlock ();for _cag ,_ddc :=range _af ._cc {if f (_cag ,_ddc ){break ;
};};};func (_c *RuneByteMap )Read (r rune )(byte ,bool ){_c ._ff .RLock ();defer _c ._ff .RUnlock ();_eb ,_bb :=_c ._ge [r ];return _eb ,_bb ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_e :make (map[byte ]rune ,length )}};func (_g *ByteRuneMap )Range (f func (_ab byte ,_dd rune )(_egf bool )){_g ._bd .RLock ();
defer _g ._bd .RUnlock ();for _fc ,_ae :=range _g ._e {if f (_fc ,_ae ){break ;};};};func (_eg *ByteRuneMap )Read (b byte )(rune ,bool ){_eg ._bd .RLock ();defer _eg ._bd .RUnlock ();_d ,_f :=_eg ._e [b ];return _d ,_f ;};type RuneByteMap struct{_ge map[rune ]byte ;
_ff _a .RWMutex ;};func (_ege *RuneByteMap )Write (r rune ,b byte ){_ege ._ff .Lock ();defer _ege ._ff .Unlock ();_ege ._ge [r ]=b ;};func (_eaf *RuneStringMap )Range (f func (_gf rune ,_ce string )(_ba bool )){_eaf ._ec .RLock ();defer _eaf ._ec .RUnlock ();
for _fe ,_cada :=range _eaf ._bcc {if f (_fe ,_cada ){break ;};};};