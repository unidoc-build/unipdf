//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_dc "errors";_ce "github.com/unidoc/freetype/truetype";_ad "github.com/unidoc/unipdf/v3/core";_a "github.com/unidoc/unipdf/v3/internal/textencoding";_e "github.com/unidoc/unipdf/v3/internal/transform";_dca "github.com/unidoc/unipdf/v3/model";
_cf "golang.org/x/image/font";_c "image";_gc "image/color";_d "strings";);func (_afa *TextState )Reset (){_afa .Tm =_e .IdentityMatrix ();_afa .Tlm =_e .IdentityMatrix ()};type Pattern interface{ColorAt (_eb ,_gf int )_gc .Color ;};type FillRule int ;func NewTextState ()TextState {return TextState {Th :100,Tm :_e .IdentityMatrix (),Tlm :_e .IdentityMatrix ()};
};func NewTextFont (font *_dca .PdfFont ,size float64 )(*TextFont ,error ){_ebd :=font .FontDescriptor ();if _ebd ==nil {return nil ,_dc .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");
};_dcge ,_eeaf :=_ad .GetStream (_ebd .FontFile2 );if !_eeaf {return nil ,_dc .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_eafe ,_bd :=_ad .DecodeStream (_dcge );
if _bd !=nil {return nil ,_bd ;};_cfbb ,_bd :=_ce .Parse (_eafe );if _bd !=nil {return nil ,_bd ;};_be :=font .FontDescriptor ().FontName .String ();_fcf :=len (_be )> 7&&_be [6]=='+';if !_cfbb .HasCmap ()&&(!_d .Contains (font .Encoder ().String (),"\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-")||!_fcf ){return nil ,_dc .New ("\u006e\u006f c\u006d\u0061\u0070 \u0061\u006e\u0064\u0020enc\u006fdi\u006e\u0067\u0020\u0069\u0073\u0020\u006eot\u0020\u0069\u0064\u0065\u006e\u0074\u0069t\u0079");
};return &TextFont {Font :font ,Size :size ,_cb :_cfbb },nil ;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);const (LineJoinRound LineJoin =iota ;LineJoinBevel ;);func (_bbf *TextState )Translate (tx ,ty float64 ){_bbf .Tm =_bbf .Tm .Mult (_e .TranslationMatrix (tx ,ty ));};type LineCap int ;func (_feg *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_feg .Tw =aw ;
_feg .Tc =ac ;_feg .ProcQ (data ,ctx );};func (_ccc *TextFont )GetCharMetrics (code _a .CharCode )(float64 ,float64 ,bool ){if _aca ,_bcg :=_ccc .Font .GetCharMetrics (code );_bcg &&_aca .Wx !=0{return _aca .Wx ,_aca .Wy ,_bcg ;};if _ccc ._acd ==nil {return 0,0,false ;
};_db ,_edb :=_ccc ._acd .GetCharMetrics (code );return _db .Wx ,_db .Wy ,_edb &&_db .Wx !=0;};func (_df *TextFont )WithSize (size float64 ,originalFont *_dca .PdfFont )*TextFont {return &TextFont {Font :_df .Font ,Size :size ,_cb :_df ._cb ,_acd :originalFont };
};func (_egb *TextFont )CharcodeToRunes (charcode _a .CharCode )(_a .CharCode ,[]rune ){_aaf :=[]_a .CharCode {charcode };if _egb ._acd ==nil ||_egb ._acd ==_egb .Font {if _egb .Font .IsSimple ()&&_egb ._cb !=nil {if _cfg :=_egb ._cb .Index (rune (charcode ));
_cfg > 0{return charcode ,[]rune {rune (charcode )};};};if _egb ._cb !=nil &&!_egb ._cb .HasCmap ()&&_d .Contains (_egb .Font .Encoder ().String (),"\u0049d\u0065\u006e\u0074\u0069\u0074\u0079-"){if _egdb :=_egb ._cb .Index (rune (charcode ));_egdb > 0{return charcode ,[]rune {rune (charcode )};
};};return charcode ,_egb .Font .CharcodesToUnicode (_aaf );};_eef :=_egb ._acd .CharcodesToUnicode (_aaf );_cgb ,_ :=_egb .Font .RunesToCharcodeBytes (_eef );_gge :=_egb .Font .BytesToCharcodes (_cgb );_bc :=charcode ;if len (_gge )> 0&&_gge [0]!=0{_bc =_gge [0];
};return _bc ,_eef ;};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);func (_cba *TextState )ProcTj (data []byte ,ctx Context ){_gfc :=_cba .Tf .Size ;_fac :=_cba .Th /100.0;_geg :=_cba .GlobalScale ;_dbf :=_e .NewMatrix (_gfc *_fac ,0,0,_gfc ,0,_cba .Ts );
_gff :=ctx .Matrix ();_ec :=_gff .Clone ().Mult (_cba .Tm .Clone ().Mult (_dbf )).ScalingFactorY ();_ebb :=_cba .Tf .NewFace (_ec );_fbgf :=_cba .Tf .BytesToCharcodes (data );for _ ,_eba :=range _fbgf {_efd ,_edg :=_cba .Tf .CharcodeToRunes (_eba );_egca :=string (_edg );
if _egca =="\u0000"{continue ;};_daa :=_gff .Clone ().Mult (_cba .Tm .Clone ().Mult (_dbf ));_eae :=_daa .ScalingFactorY ();_daa =_daa .Scale (1/_eae ,-1/_eae );if _cba .Tr !=TextRenderingModeInvisible {ctx .SetMatrix (_daa );ctx .DrawString (_egca ,_ebb ,0,0);
ctx .SetMatrix (_gff );};_geb :=0.0;if _egca =="\u0020"{_geb =_cba .Tw ;};_adf ,_ ,_acg :=_cba .Tf .GetCharMetrics (_efd );if _acg {_adf =_adf *0.001*_gfc ;}else {_adf ,_ =ctx .MeasureString (_egca ,_ebb );_adf =_adf /_geg ;};_dda :=(_adf +_cba .Tc +_geb )*_fac ;
_cba .Tm =_cba .Tm .Mult (_e .TranslationMatrix (_dda ,0));};};func (_bac *TextState )ProcQ (data []byte ,ctx Context ){_bac .ProcTStar ();_bac .ProcTj (data ,ctx )};func (_dbc *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_dbc .Tm =_e .NewMatrix (a ,b ,c ,d ,e ,f );
_dbc .Tlm =_dbc .Tm .Clone ();};const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;);type Gradient interface{Pattern ;AddColorStop (_ab float64 ,_aa _gc .Color );};type LineJoin int ;type TextFont struct{Font *_dca .PdfFont ;Size float64 ;_cb *_ce .Font ;
_acd *_dca .PdfFont ;};func (_age *TextState )ProcTd (tx ,ty float64 ){_age .Tlm .Concat (_e .TranslationMatrix (tx ,ty ));_age .Tm =_age .Tlm .Clone ();};func (_ede *TextState )ProcTf (font *TextFont ){_ede .Tf =font };func (_gbg *TextState )ProcTD (tx ,ty float64 ){_gbg .Tl =-ty ;
_gbg .ProcTd (tx ,ty )};func (_de *TextState )ProcTStar (){_de .ProcTd (0,-_de .Tl )};func (_cgc *TextFont )BytesToCharcodes (data []byte )[]_a .CharCode {if _cgc ._acd !=nil {return _cgc ._acd .BytesToCharcodes (data );};return _cgc .Font .BytesToCharcodes (data );
};type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;Tf *TextFont ;Ts float64 ;Tm _e .Matrix ;Tlm _e .Matrix ;Tr TextRenderingMode ;GlobalScale float64 ;};func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_bfb ,_fa :=_dca .NewPdfFontFromTTFFile (filePath );
if _fa !=nil {return nil ,_fa ;};return NewTextFont (_bfb ,size );};func (_aba *TextFont )NewFace (size float64 )_cf .Face {return _ce .NewFace (_aba ._cb ,&_ce .Options {Size :size });};type TextRenderingMode int ;type Context interface{Push ();Pop ();
Matrix ()_e .Matrix ;SetMatrix (_ca _e .Matrix );Translate (_ac ,_ga float64 );Scale (_gb ,_b float64 );Rotate (_ba float64 );MoveTo (_f ,_ag float64 );LineTo (_fe ,_fg float64 );CubicTo (_ee ,_fb ,_ebe ,_cfb ,_cg ,_cc float64 );QuadraticTo (_fgc ,_dd ,_acf ,_ade float64 );
NewSubPath ();ClosePath ();ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_eg float64 );SetLineCap (_cab LineCap );SetLineJoin (_caa LineJoin );SetDash (_dcg ...float64 );SetDashOffset (_bag float64 );Fill ();FillPreserve ();
Stroke ();StrokePreserve ();SetRGBA (_abb ,_ege ,_cd ,_dg float64 );SetFillRGBA (_ddf ,_bf ,_egd ,_ef float64 );SetFillStyle (_bg Pattern );SetFillRule (_ge FillRule );SetStrokeRGBA (_ccg ,_bge ,_gg ,_ea float64 );SetStrokeStyle (_ceb Pattern );FillPattern ()Pattern ;
StrokePattern ()Pattern ;TextState ()*TextState ;DrawString (_abd string ,_cdb _cf .Face ,_bfe ,_cae float64 );MeasureString (_fc string ,_eea _cf .Face )(_gaf ,_eac float64 );DrawRectangle (_eaf ,_bb ,_efa ,_egc float64 );DrawImage (_fbg _c .Image ,_bba ,_fea int );
DrawImageAnchored (_af _c .Image ,_ed ,_aac int ,_abf ,_da float64 );Height ()int ;Width ()int ;};